import "./chunk-KPM4MXSK.js";

// node_modules/@arweave-wallet-kit/othent-strategy/dist/index.es.js
var _globalThis$arbundles;
var _excluded = ["version"];
var _excluded2 = ["version"];
var _excluded3 = ["encryptionAlgorithm"];
var _excluded4 = ["id"];
var _excluded5 = ["appInfo", "gatewayConfig", "persistCookie", "persistLocalStorage", "initialUserDetails", "auth0Cache", "auth0RedirectURI", "auth0ReturnToURI"];
var _excluded6 = ["data", "tags"];
function _objectWithoutProperties(e2, t2) {
  if (null == e2)
    return {};
  var o2, r2, i2 = _objectWithoutPropertiesLoose(e2, t2);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e2);
    for (r2 = 0; r2 < n2.length; r2++)
      o2 = n2[r2], -1 === t2.indexOf(o2) && {}.propertyIsEnumerable.call(e2, o2) && (i2[o2] = e2[o2]);
  }
  return i2;
}
function _objectWithoutPropertiesLoose(r2, e2) {
  if (null == r2)
    return {};
  var t2 = {};
  for (var n2 in r2)
    if ({}.hasOwnProperty.call(r2, n2)) {
      if (-1 !== e2.indexOf(n2))
        continue;
      t2[n2] = r2[n2];
    }
  return t2;
}
function _toArray(r2) {
  return _arrayWithHoles(r2) || _iterableToArray(r2) || _unsupportedIterableToArray(r2) || _nonIterableRest();
}
function _createForOfIteratorHelper(r2, e2) {
  var t2 = "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (!t2) {
    if (Array.isArray(r2) || (t2 = _unsupportedIterableToArray(r2)) || e2 && r2 && "number" == typeof r2.length) {
      t2 && (r2 = t2);
      var _n8 = 0, F2 = function F3() {
      };
      return { s: F2, n: function n2() {
        return _n8 >= r2.length ? { done: true } : { done: false, value: r2[_n8++] };
      }, e: function e3(r3) {
        throw r3;
      }, f: F2 };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o2, a2 = true, u2 = false;
  return { s: function s2() {
    t2 = t2.call(r2);
  }, n: function n2() {
    var r3 = t2.next();
    return a2 = r3.done, r3;
  }, e: function e3(r3) {
    u2 = true, o2 = r3;
  }, f: function f2() {
    try {
      a2 || null == t2.return || t2.return();
    } finally {
      if (u2)
        throw o2;
    }
  } };
}
function ownKeys(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys(Object(t2), true).forEach(function(r3) {
      _defineProperty(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _typeof(o2) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof(o2);
}
function _toConsumableArray(r2) {
  return _arrayWithoutHoles(r2) || _iterableToArray(r2) || _unsupportedIterableToArray(r2) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"])
    return Array.from(r2);
}
function _arrayWithoutHoles(r2) {
  if (Array.isArray(r2))
    return _arrayLikeToArray(r2);
}
function _slicedToArray(r2, e2) {
  return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e2) || _unsupportedIterableToArray(r2, e2) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(r2, a2) {
  if (r2) {
    if ("string" == typeof r2)
      return _arrayLikeToArray(r2, a2);
    var t2 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray(r2, a2) : void 0;
  }
}
function _arrayLikeToArray(r2, a2) {
  (null == a2 || a2 > r2.length) && (a2 = r2.length);
  for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++)
    n2[e2] = r2[e2];
  return n2;
}
function _iterableToArrayLimit(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e2, n2, i2, u2, a2 = [], f2 = true, o2 = false;
    try {
      if (i2 = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f2 = false;
      } else
        for (; !(f2 = (e2 = i2.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f2 = true)
          ;
    } catch (r3) {
      o2 = true, n2 = r3;
    } finally {
      try {
        if (!f2 && null != t2.return && (u2 = t2.return(), Object(u2) !== u2))
          return;
      } finally {
        if (o2)
          throw n2;
      }
    }
    return a2;
  }
}
function _arrayWithHoles(r2) {
  if (Array.isArray(r2))
    return r2;
}
function _regeneratorRuntime() {
  "use strict";
  _regeneratorRuntime = function _regeneratorRuntime2() {
    return e2;
  };
  var t2, e2 = {}, r2 = Object.prototype, n2 = r2.hasOwnProperty, o2 = Object.defineProperty || function(t3, e3, r3) {
    t3[e3] = r3.value;
  }, i2 = "function" == typeof Symbol ? Symbol : {}, a2 = i2.iterator || "@@iterator", c3 = i2.asyncIterator || "@@asyncIterator", u2 = i2.toStringTag || "@@toStringTag";
  function define3(t3, e3, r3) {
    return Object.defineProperty(t3, e3, { value: r3, enumerable: true, configurable: true, writable: true }), t3[e3];
  }
  try {
    define3({}, "");
  } catch (t3) {
    define3 = function define4(t4, e3, r3) {
      return t4[e3] = r3;
    };
  }
  function wrap2(t3, e3, r3, n3) {
    var i3 = e3 && e3.prototype instanceof Generator ? e3 : Generator, a3 = Object.create(i3.prototype), c4 = new Context(n3 || []);
    return o2(a3, "_invoke", { value: makeInvokeMethod(t3, r3, c4) }), a3;
  }
  function tryCatch(t3, e3, r3) {
    try {
      return { type: "normal", arg: t3.call(e3, r3) };
    } catch (t4) {
      return { type: "throw", arg: t4 };
    }
  }
  e2.wrap = wrap2;
  var h2 = "suspendedStart", l2 = "suspendedYield", f2 = "executing", s2 = "completed", y3 = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  var p2 = {};
  define3(p2, a2, function() {
    return this;
  });
  var d2 = Object.getPrototypeOf, v2 = d2 && d2(d2(values([])));
  v2 && v2 !== r2 && n2.call(v2, a2) && (p2 = v2);
  var g2 = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p2);
  function defineIteratorMethods(t3) {
    ["next", "throw", "return"].forEach(function(e3) {
      define3(t3, e3, function(t4) {
        return this._invoke(e3, t4);
      });
    });
  }
  function AsyncIterator(t3, e3) {
    function invoke(r4, o3, i3, a3) {
      var c4 = tryCatch(t3[r4], t3, o3);
      if ("throw" !== c4.type) {
        var u3 = c4.arg, h3 = u3.value;
        return h3 && "object" == _typeof(h3) && n2.call(h3, "__await") ? e3.resolve(h3.__await).then(function(t4) {
          invoke("next", t4, i3, a3);
        }, function(t4) {
          invoke("throw", t4, i3, a3);
        }) : e3.resolve(h3).then(function(t4) {
          u3.value = t4, i3(u3);
        }, function(t4) {
          return invoke("throw", t4, i3, a3);
        });
      }
      a3(c4.arg);
    }
    var r3;
    o2(this, "_invoke", { value: function value(t4, n3) {
      function callInvokeWithMethodAndArg() {
        return new e3(function(e4, r4) {
          invoke(t4, n3, e4, r4);
        });
      }
      return r3 = r3 ? r3.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    } });
  }
  function makeInvokeMethod(e3, r3, n3) {
    var o3 = h2;
    return function(i3, a3) {
      if (o3 === f2)
        throw Error("Generator is already running");
      if (o3 === s2) {
        if ("throw" === i3)
          throw a3;
        return { value: t2, done: true };
      }
      for (n3.method = i3, n3.arg = a3; ; ) {
        var c4 = n3.delegate;
        if (c4) {
          var u3 = maybeInvokeDelegate(c4, n3);
          if (u3) {
            if (u3 === y3)
              continue;
            return u3;
          }
        }
        if ("next" === n3.method)
          n3.sent = n3._sent = n3.arg;
        else if ("throw" === n3.method) {
          if (o3 === h2)
            throw o3 = s2, n3.arg;
          n3.dispatchException(n3.arg);
        } else
          "return" === n3.method && n3.abrupt("return", n3.arg);
        o3 = f2;
        var p3 = tryCatch(e3, r3, n3);
        if ("normal" === p3.type) {
          if (o3 = n3.done ? s2 : l2, p3.arg === y3)
            continue;
          return { value: p3.arg, done: n3.done };
        }
        "throw" === p3.type && (o3 = s2, n3.method = "throw", n3.arg = p3.arg);
      }
    };
  }
  function maybeInvokeDelegate(e3, r3) {
    var n3 = r3.method, o3 = e3.iterator[n3];
    if (o3 === t2)
      return r3.delegate = null, "throw" === n3 && e3.iterator.return && (r3.method = "return", r3.arg = t2, maybeInvokeDelegate(e3, r3), "throw" === r3.method) || "return" !== n3 && (r3.method = "throw", r3.arg = new TypeError("The iterator does not provide a '" + n3 + "' method")), y3;
    var i3 = tryCatch(o3, e3.iterator, r3.arg);
    if ("throw" === i3.type)
      return r3.method = "throw", r3.arg = i3.arg, r3.delegate = null, y3;
    var a3 = i3.arg;
    return a3 ? a3.done ? (r3[e3.resultName] = a3.value, r3.next = e3.nextLoc, "return" !== r3.method && (r3.method = "next", r3.arg = t2), r3.delegate = null, y3) : a3 : (r3.method = "throw", r3.arg = new TypeError("iterator result is not an object"), r3.delegate = null, y3);
  }
  function pushTryEntry(t3) {
    var e3 = { tryLoc: t3[0] };
    1 in t3 && (e3.catchLoc = t3[1]), 2 in t3 && (e3.finallyLoc = t3[2], e3.afterLoc = t3[3]), this.tryEntries.push(e3);
  }
  function resetTryEntry(t3) {
    var e3 = t3.completion || {};
    e3.type = "normal", delete e3.arg, t3.completion = e3;
  }
  function Context(t3) {
    this.tryEntries = [{ tryLoc: "root" }], t3.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(e3) {
    if (e3 || "" === e3) {
      var r3 = e3[a2];
      if (r3)
        return r3.call(e3);
      if ("function" == typeof e3.next)
        return e3;
      if (!isNaN(e3.length)) {
        var o3 = -1, i3 = function next() {
          for (; ++o3 < e3.length; )
            if (n2.call(e3, o3))
              return next.value = e3[o3], next.done = false, next;
          return next.value = t2, next.done = true, next;
        };
        return i3.next = i3;
      }
    }
    throw new TypeError(_typeof(e3) + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o2(g2, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o2(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define3(GeneratorFunctionPrototype, u2, "GeneratorFunction"), e2.isGeneratorFunction = function(t3) {
    var e3 = "function" == typeof t3 && t3.constructor;
    return !!e3 && (e3 === GeneratorFunction || "GeneratorFunction" === (e3.displayName || e3.name));
  }, e2.mark = function(t3) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t3, GeneratorFunctionPrototype) : (t3.__proto__ = GeneratorFunctionPrototype, define3(t3, u2, "GeneratorFunction")), t3.prototype = Object.create(g2), t3;
  }, e2.awrap = function(t3) {
    return { __await: t3 };
  }, defineIteratorMethods(AsyncIterator.prototype), define3(AsyncIterator.prototype, c3, function() {
    return this;
  }), e2.AsyncIterator = AsyncIterator, e2.async = function(t3, r3, n3, o3, i3) {
    void 0 === i3 && (i3 = Promise);
    var a3 = new AsyncIterator(wrap2(t3, r3, n3, o3), i3);
    return e2.isGeneratorFunction(r3) ? a3 : a3.next().then(function(t4) {
      return t4.done ? t4.value : a3.next();
    });
  }, defineIteratorMethods(g2), define3(g2, u2, "Generator"), define3(g2, a2, function() {
    return this;
  }), define3(g2, "toString", function() {
    return "[object Generator]";
  }), e2.keys = function(t3) {
    var e3 = Object(t3), r3 = [];
    for (var n3 in e3)
      r3.push(n3);
    return r3.reverse(), function next() {
      for (; r3.length; ) {
        var t4 = r3.pop();
        if (t4 in e3)
          return next.value = t4, next.done = false, next;
      }
      return next.done = true, next;
    };
  }, e2.values = values, Context.prototype = { constructor: Context, reset: function reset2(e3) {
    if (this.prev = 0, this.next = 0, this.sent = this._sent = t2, this.done = false, this.delegate = null, this.method = "next", this.arg = t2, this.tryEntries.forEach(resetTryEntry), !e3)
      for (var r3 in this)
        "t" === r3.charAt(0) && n2.call(this, r3) && !isNaN(+r3.slice(1)) && (this[r3] = t2);
  }, stop: function stop() {
    this.done = true;
    var t3 = this.tryEntries[0].completion;
    if ("throw" === t3.type)
      throw t3.arg;
    return this.rval;
  }, dispatchException: function dispatchException(e3) {
    if (this.done)
      throw e3;
    var r3 = this;
    function handle(n3, o4) {
      return a3.type = "throw", a3.arg = e3, r3.next = n3, o4 && (r3.method = "next", r3.arg = t2), !!o4;
    }
    for (var o3 = this.tryEntries.length - 1; o3 >= 0; --o3) {
      var i3 = this.tryEntries[o3], a3 = i3.completion;
      if ("root" === i3.tryLoc)
        return handle("end");
      if (i3.tryLoc <= this.prev) {
        var c4 = n2.call(i3, "catchLoc"), u3 = n2.call(i3, "finallyLoc");
        if (c4 && u3) {
          if (this.prev < i3.catchLoc)
            return handle(i3.catchLoc, true);
          if (this.prev < i3.finallyLoc)
            return handle(i3.finallyLoc);
        } else if (c4) {
          if (this.prev < i3.catchLoc)
            return handle(i3.catchLoc, true);
        } else {
          if (!u3)
            throw Error("try statement without catch or finally");
          if (this.prev < i3.finallyLoc)
            return handle(i3.finallyLoc);
        }
      }
    }
  }, abrupt: function abrupt(t3, e3) {
    for (var r3 = this.tryEntries.length - 1; r3 >= 0; --r3) {
      var o3 = this.tryEntries[r3];
      if (o3.tryLoc <= this.prev && n2.call(o3, "finallyLoc") && this.prev < o3.finallyLoc) {
        var i3 = o3;
        break;
      }
    }
    i3 && ("break" === t3 || "continue" === t3) && i3.tryLoc <= e3 && e3 <= i3.finallyLoc && (i3 = null);
    var a3 = i3 ? i3.completion : {};
    return a3.type = t3, a3.arg = e3, i3 ? (this.method = "next", this.next = i3.finallyLoc, y3) : this.complete(a3);
  }, complete: function complete(t3, e3) {
    if ("throw" === t3.type)
      throw t3.arg;
    return "break" === t3.type || "continue" === t3.type ? this.next = t3.arg : "return" === t3.type ? (this.rval = this.arg = t3.arg, this.method = "return", this.next = "end") : "normal" === t3.type && e3 && (this.next = e3), y3;
  }, finish: function finish2(t3) {
    for (var e3 = this.tryEntries.length - 1; e3 >= 0; --e3) {
      var r3 = this.tryEntries[e3];
      if (r3.finallyLoc === t3)
        return this.complete(r3.completion, r3.afterLoc), resetTryEntry(r3), y3;
    }
  }, catch: function _catch(t3) {
    for (var e3 = this.tryEntries.length - 1; e3 >= 0; --e3) {
      var r3 = this.tryEntries[e3];
      if (r3.tryLoc === t3) {
        var n3 = r3.completion;
        if ("throw" === n3.type) {
          var o3 = n3.arg;
          resetTryEntry(r3);
        }
        return o3;
      }
    }
    throw Error("illegal catch attempt");
  }, delegateYield: function delegateYield(e3, r3, n3) {
    return this.delegate = { iterator: values(e3), resultName: r3, nextLoc: n3 }, "next" === this.method && (this.arg = t2), y3;
  } }, e2;
}
function asyncGeneratorStep(n2, t2, e2, r2, o2, a2, c3) {
  try {
    var i2 = n2[a2](c3), u2 = i2.value;
  } catch (n3) {
    return void e2(n3);
  }
  i2.done ? t2(u2) : Promise.resolve(u2).then(r2, o2);
}
function _asyncToGenerator(n2) {
  return function() {
    var t2 = this, e2 = arguments;
    return new Promise(function(r2, o2) {
      var a2 = n2.apply(t2, e2);
      function _next(n3) {
        asyncGeneratorStep(a2, r2, o2, _next, _throw, "next", n3);
      }
      function _throw(n3) {
        asyncGeneratorStep(a2, r2, o2, _next, _throw, "throw", n3);
      }
      _next(void 0);
    });
  };
}
function _defineProperty(e2, r2, t2) {
  return (r2 = _toPropertyKey(r2)) in e2 ? Object.defineProperty(e2, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e2[r2] = t2, e2;
}
function _classCallCheck2(a2, n2) {
  if (!(a2 instanceof n2))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e2, r2) {
  for (var t2 = 0; t2 < r2.length; t2++) {
    var o2 = r2[t2];
    o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, _toPropertyKey(o2.key), o2);
  }
}
function _createClass(e2, r2, t2) {
  return r2 && _defineProperties(e2.prototype, r2), t2 && _defineProperties(e2, t2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
}
function _toPropertyKey(t2) {
  var i2 = _toPrimitive(t2, "string");
  return "symbol" == _typeof(i2) ? i2 : i2 + "";
}
function _toPrimitive(t2, r2) {
  if ("object" != _typeof(t2) || !t2)
    return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2 || "default");
    if ("object" != _typeof(i2))
      return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _callSuper(t2, o2, e2) {
  return o2 = _getPrototypeOf(o2), _possibleConstructorReturn2(t2, _isNativeReflectConstruct() ? Reflect.construct(o2, e2 || [], _getPrototypeOf(t2).constructor) : o2.apply(t2, e2));
}
function _possibleConstructorReturn2(t2, e2) {
  if (e2 && ("object" == _typeof(e2) || "function" == typeof e2))
    return e2;
  if (void 0 !== e2)
    throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t2);
}
function _assertThisInitialized(e2) {
  if (void 0 === e2)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e2;
}
function _inherits2(t2, e2) {
  if ("function" != typeof e2 && null !== e2)
    throw new TypeError("Super expression must either be null or a function");
  t2.prototype = Object.create(e2 && e2.prototype, { constructor: { value: t2, writable: true, configurable: true } }), Object.defineProperty(t2, "prototype", { writable: false }), e2 && _setPrototypeOf(t2, e2);
}
function _wrapNativeSuper(t2) {
  var r2 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
  return _wrapNativeSuper = function _wrapNativeSuper2(t3) {
    if (null === t3 || !_isNativeFunction(t3))
      return t3;
    if ("function" != typeof t3)
      throw new TypeError("Super expression must either be null or a function");
    if (void 0 !== r2) {
      if (r2.has(t3))
        return r2.get(t3);
      r2.set(t3, Wrapper);
    }
    function Wrapper() {
      return _construct(t3, arguments, _getPrototypeOf(this).constructor);
    }
    return Wrapper.prototype = Object.create(t3.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }), _setPrototypeOf(Wrapper, t3);
  }, _wrapNativeSuper(t2);
}
function _construct(t2, e2, r2) {
  if (_isNativeReflectConstruct())
    return Reflect.construct.apply(null, arguments);
  var o2 = [null];
  o2.push.apply(o2, e2);
  var p2 = new (t2.bind.apply(t2, o2))();
  return r2 && _setPrototypeOf(p2, r2.prototype), p2;
}
function _isNativeReflectConstruct() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
function _isNativeFunction(t2) {
  try {
    return -1 !== Function.toString.call(t2).indexOf("[native code]");
  } catch (n2) {
    return "function" == typeof t2;
  }
}
function _setPrototypeOf(t2, e2) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e3) {
    return t3.__proto__ = e3, t3;
  }, _setPrototypeOf(t2, e2);
}
function _getPrototypeOf(t2) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t3) {
    return t3.__proto__ || Object.getPrototypeOf(t3);
  }, _getPrototypeOf(t2);
}
function _wrapAsyncGenerator(e2) {
  return function() {
    return new AsyncGenerator(e2.apply(this, arguments));
  };
}
function AsyncGenerator(e2) {
  var r2, t2;
  function resume(r3, t3) {
    try {
      var n2 = e2[r3](t3), o2 = n2.value, u2 = o2 instanceof _OverloadYield;
      Promise.resolve(u2 ? o2.v : o2).then(function(t4) {
        if (u2) {
          var i2 = "return" === r3 ? "return" : "next";
          if (!o2.k || t4.done)
            return resume(i2, t4);
          t4 = e2[i2](t4).value;
        }
        settle2(n2.done ? "return" : "normal", t4);
      }, function(e3) {
        resume("throw", e3);
      });
    } catch (e3) {
      settle2("throw", e3);
    }
  }
  function settle2(e3, n2) {
    switch (e3) {
      case "return":
        r2.resolve({ value: n2, done: true });
        break;
      case "throw":
        r2.reject(n2);
        break;
      default:
        r2.resolve({ value: n2, done: false });
    }
    (r2 = r2.next) ? resume(r2.key, r2.arg) : t2 = null;
  }
  this._invoke = function(e3, n2) {
    return new Promise(function(o2, u2) {
      var i2 = { key: e3, arg: n2, resolve: o2, reject: u2, next: null };
      t2 ? t2 = t2.next = i2 : (r2 = t2 = i2, resume(e3, n2));
    });
  }, "function" != typeof e2.return && (this.return = void 0);
}
AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function() {
  return this;
}, AsyncGenerator.prototype.next = function(e2) {
  return this._invoke("next", e2);
}, AsyncGenerator.prototype.throw = function(e2) {
  return this._invoke("throw", e2);
}, AsyncGenerator.prototype.return = function(e2) {
  return this._invoke("return", e2);
};
function _awaitAsyncGenerator(e2) {
  return new _OverloadYield(e2, 0);
}
function _asyncGeneratorDelegate(t2) {
  var e2 = {}, n2 = false;
  function pump(e3, r2) {
    return n2 = true, r2 = new Promise(function(n3) {
      n3(t2[e3](r2));
    }), { done: false, value: new _OverloadYield(r2, 1) };
  }
  return e2["undefined" != typeof Symbol && Symbol.iterator || "@@iterator"] = function() {
    return this;
  }, e2.next = function(t3) {
    return n2 ? (n2 = false, t3) : pump("next", t3);
  }, "function" == typeof t2.throw && (e2.throw = function(t3) {
    if (n2)
      throw n2 = false, t3;
    return pump("throw", t3);
  }), "function" == typeof t2.return && (e2.return = function(t3) {
    return n2 ? (n2 = false, t3) : pump("return", t3);
  }), e2;
}
function _OverloadYield(e2, d2) {
  this.v = e2, this.k = d2;
}
function _asyncIterator(r2) {
  var n2, t2, o2, e2 = 2;
  for ("undefined" != typeof Symbol && (t2 = Symbol.asyncIterator, o2 = Symbol.iterator); e2--; ) {
    if (t2 && null != (n2 = r2[t2]))
      return n2.call(r2);
    if (o2 && null != (n2 = r2[o2]))
      return new AsyncFromSyncIterator(n2.call(r2));
    t2 = "@@asyncIterator", o2 = "@@iterator";
  }
  throw new TypeError("Object is not async iterable");
}
function AsyncFromSyncIterator(r2) {
  function AsyncFromSyncIteratorContinuation(r3) {
    if (Object(r3) !== r3)
      return Promise.reject(new TypeError(r3 + " is not an object."));
    var n2 = r3.done;
    return Promise.resolve(r3.value).then(function(r4) {
      return { value: r4, done: n2 };
    });
  }
  return AsyncFromSyncIterator = function AsyncFromSyncIterator2(r3) {
    this.s = r3, this.n = r3.next;
  }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function next() {
    return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));
  }, return: function _return(r3) {
    var n2 = this.s.return;
    return void 0 === n2 ? Promise.resolve({ value: r3, done: true }) : AsyncFromSyncIteratorContinuation(n2.apply(this.s, arguments));
  }, throw: function _throw(r3) {
    var n2 = this.s.return;
    return void 0 === n2 ? Promise.reject(r3) : AsyncFromSyncIteratorContinuation(n2.apply(this.s, arguments));
  } }, new AsyncFromSyncIterator(r2);
}
function e(e2, t2) {
  var i2 = {};
  for (var o2 in e2)
    Object.prototype.hasOwnProperty.call(e2, o2) && t2.indexOf(o2) < 0 && (i2[o2] = e2[o2]);
  if (null != e2 && "function" == typeof Object.getOwnPropertySymbols) {
    var n2 = 0;
    for (o2 = Object.getOwnPropertySymbols(e2); n2 < o2.length; n2++)
      t2.indexOf(o2[n2]) < 0 && Object.prototype.propertyIsEnumerable.call(e2, o2[n2]) && (i2[o2[n2]] = e2[o2[n2]]);
  }
  return i2;
}
var t = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function i$1(e2) {
  return e2 && e2.__esModule && Object.prototype.hasOwnProperty.call(e2, "default") ? e2.default : e2;
}
function o(e2, t2) {
  return e2(t2 = { exports: {} }, t2.exports), t2.exports;
}
var n = o(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true });
  var i2 = function() {
    function e3() {
      var e4 = this;
      this.locked = /* @__PURE__ */ new Map(), this.addToLocked = function(t3, i3) {
        var o2 = e4.locked.get(t3);
        void 0 === o2 ? void 0 === i3 ? e4.locked.set(t3, []) : e4.locked.set(t3, [i3]) : void 0 !== i3 && (o2.unshift(i3), e4.locked.set(t3, o2));
      }, this.isLocked = function(t3) {
        return e4.locked.has(t3);
      }, this.lock = function(t3) {
        return new Promise(function(i3, o2) {
          e4.isLocked(t3) ? e4.addToLocked(t3, i3) : (e4.addToLocked(t3), i3());
        });
      }, this.unlock = function(t3) {
        var i3 = e4.locked.get(t3);
        if (void 0 !== i3 && 0 !== i3.length) {
          var o2 = i3.pop();
          e4.locked.set(t3, i3), void 0 !== o2 && setTimeout(o2, 0);
        } else
          e4.locked.delete(t3);
      };
    }
    return e3.getInstance = function() {
      return void 0 === e3.instance && (e3.instance = new e3()), e3.instance;
    }, e3;
  }();
  t2.default = function() {
    return i2.getInstance();
  };
});
i$1(n);
var a = i$1(o(function(e2, i2) {
  var o2 = t && t.__awaiter || function(e3, t2, i3, o3) {
    return new (i3 || (i3 = Promise))(function(n2, a3) {
      function r3(e4) {
        try {
          c4(o3.next(e4));
        } catch (e5) {
          a3(e5);
        }
      }
      function s3(e4) {
        try {
          c4(o3.throw(e4));
        } catch (e5) {
          a3(e5);
        }
      }
      function c4(e4) {
        e4.done ? n2(e4.value) : new i3(function(t3) {
          t3(e4.value);
        }).then(r3, s3);
      }
      c4((o3 = o3.apply(e3, t2 || [])).next());
    });
  }, a2 = t && t.__generator || function(e3, t2) {
    var i3, o3, n2, a3, r3 = { label: 0, sent: function sent() {
      if (1 & n2[0])
        throw n2[1];
      return n2[1];
    }, trys: [], ops: [] };
    return a3 = { next: s3(0), throw: s3(1), return: s3(2) }, "function" == typeof Symbol && (a3[Symbol.iterator] = function() {
      return this;
    }), a3;
    function s3(a4) {
      return function(s4) {
        return function(a5) {
          if (i3)
            throw new TypeError("Generator is already executing.");
          for (; r3; )
            try {
              if (i3 = 1, o3 && (n2 = 2 & a5[0] ? o3.return : a5[0] ? o3.throw || ((n2 = o3.return) && n2.call(o3), 0) : o3.next) && !(n2 = n2.call(o3, a5[1])).done)
                return n2;
              switch (o3 = 0, n2 && (a5 = [2 & a5[0], n2.value]), a5[0]) {
                case 0:
                case 1:
                  n2 = a5;
                  break;
                case 4:
                  return r3.label++, { value: a5[1], done: false };
                case 5:
                  r3.label++, o3 = a5[1], a5 = [0];
                  continue;
                case 7:
                  a5 = r3.ops.pop(), r3.trys.pop();
                  continue;
                default:
                  if (!(n2 = r3.trys, (n2 = n2.length > 0 && n2[n2.length - 1]) || 6 !== a5[0] && 2 !== a5[0])) {
                    r3 = 0;
                    continue;
                  }
                  if (3 === a5[0] && (!n2 || a5[1] > n2[0] && a5[1] < n2[3])) {
                    r3.label = a5[1];
                    break;
                  }
                  if (6 === a5[0] && r3.label < n2[1]) {
                    r3.label = n2[1], n2 = a5;
                    break;
                  }
                  if (n2 && r3.label < n2[2]) {
                    r3.label = n2[2], r3.ops.push(a5);
                    break;
                  }
                  n2[2] && r3.ops.pop(), r3.trys.pop();
                  continue;
              }
              a5 = t2.call(e3, r3);
            } catch (e4) {
              a5 = [6, e4], o3 = 0;
            } finally {
              i3 = n2 = 0;
            }
          if (5 & a5[0])
            throw a5[1];
          return { value: a5[0] ? a5[1] : void 0, done: true };
        }([a4, s4]);
      };
    }
  }, r2 = t;
  Object.defineProperty(i2, "__esModule", { value: true });
  var s2 = "browser-tabs-lock-key", c3 = { key: function key3(e3) {
    return o2(r2, void 0, void 0, function() {
      return a2(this, function(e4) {
        throw new Error("Unsupported");
      });
    });
  }, getItem: function getItem(e3) {
    return o2(r2, void 0, void 0, function() {
      return a2(this, function(e4) {
        throw new Error("Unsupported");
      });
    });
  }, clear: function clear() {
    return o2(r2, void 0, void 0, function() {
      return a2(this, function(e3) {
        return [2, window.localStorage.clear()];
      });
    });
  }, removeItem: function removeItem(e3) {
    return o2(r2, void 0, void 0, function() {
      return a2(this, function(e4) {
        throw new Error("Unsupported");
      });
    });
  }, setItem: function setItem(e3, t2) {
    return o2(r2, void 0, void 0, function() {
      return a2(this, function(e4) {
        throw new Error("Unsupported");
      });
    });
  }, keySync: function keySync(e3) {
    return window.localStorage.key(e3);
  }, getItemSync: function getItemSync(e3) {
    return window.localStorage.getItem(e3);
  }, clearSync: function clearSync() {
    return window.localStorage.clear();
  }, removeItemSync: function removeItemSync(e3) {
    return window.localStorage.removeItem(e3);
  }, setItemSync: function setItemSync(e3, t2) {
    return window.localStorage.setItem(e3, t2);
  } };
  function d2(e3) {
    return new Promise(function(t2) {
      return setTimeout(t2, e3);
    });
  }
  function u2(e3) {
    for (var t2 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz", i3 = "", o3 = 0; o3 < e3; o3++) {
      i3 += t2[Math.floor(Math.random() * t2.length)];
    }
    return i3;
  }
  var l2 = function() {
    function e3(t2) {
      this.acquiredIatSet = /* @__PURE__ */ new Set(), this.storageHandler = void 0, this.id = Date.now().toString() + u2(15), this.acquireLock = this.acquireLock.bind(this), this.releaseLock = this.releaseLock.bind(this), this.releaseLock__private__ = this.releaseLock__private__.bind(this), this.waitForSomethingToChange = this.waitForSomethingToChange.bind(this), this.refreshLockWhileAcquired = this.refreshLockWhileAcquired.bind(this), this.storageHandler = t2, void 0 === e3.waiters && (e3.waiters = []);
    }
    return e3.prototype.acquireLock = function(t2, i3) {
      return void 0 === i3 && (i3 = 5e3), o2(this, void 0, void 0, function() {
        var o3, n2, r3, l3, h2, p2, m2;
        return a2(this, function(a3) {
          switch (a3.label) {
            case 0:
              o3 = Date.now() + u2(4), n2 = Date.now() + i3, r3 = s2 + "-" + t2, l3 = void 0 === this.storageHandler ? c3 : this.storageHandler, a3.label = 1;
            case 1:
              return Date.now() < n2 ? [4, d2(30)] : [3, 8];
            case 2:
              return a3.sent(), null !== l3.getItemSync(r3) ? [3, 5] : (h2 = this.id + "-" + t2 + "-" + o3, [4, d2(Math.floor(25 * Math.random()))]);
            case 3:
              return a3.sent(), l3.setItemSync(r3, JSON.stringify({ id: this.id, iat: o3, timeoutKey: h2, timeAcquired: Date.now(), timeRefreshed: Date.now() })), [4, d2(30)];
            case 4:
              return a3.sent(), null !== (p2 = l3.getItemSync(r3)) && (m2 = JSON.parse(p2)).id === this.id && m2.iat === o3 ? (this.acquiredIatSet.add(o3), this.refreshLockWhileAcquired(r3, o3), [2, true]) : [3, 7];
            case 5:
              return e3.lockCorrector(void 0 === this.storageHandler ? c3 : this.storageHandler), [4, this.waitForSomethingToChange(n2)];
            case 6:
              a3.sent(), a3.label = 7;
            case 7:
              return o3 = Date.now() + u2(4), [3, 1];
            case 8:
              return [2, false];
          }
        });
      });
    }, e3.prototype.refreshLockWhileAcquired = function(e4, t2) {
      return o2(this, void 0, void 0, function() {
        var i3 = this;
        return a2(this, function(r3) {
          return setTimeout(function() {
            return o2(i3, void 0, void 0, function() {
              var i4, o3, r4;
              return a2(this, function(a3) {
                switch (a3.label) {
                  case 0:
                    return [4, n.default().lock(t2)];
                  case 1:
                    return a3.sent(), this.acquiredIatSet.has(t2) ? (i4 = void 0 === this.storageHandler ? c3 : this.storageHandler, null === (o3 = i4.getItemSync(e4)) ? (n.default().unlock(t2), [2]) : ((r4 = JSON.parse(o3)).timeRefreshed = Date.now(), i4.setItemSync(e4, JSON.stringify(r4)), n.default().unlock(t2), this.refreshLockWhileAcquired(e4, t2), [2])) : (n.default().unlock(t2), [2]);
                }
              });
            });
          }, 1e3), [2];
        });
      });
    }, e3.prototype.waitForSomethingToChange = function(t2) {
      return o2(this, void 0, void 0, function() {
        return a2(this, function(i3) {
          switch (i3.label) {
            case 0:
              return [4, new Promise(function(i4) {
                var o3 = false, n2 = Date.now(), a3 = false;
                function r3() {
                  if (a3 || (window.removeEventListener("storage", r3), e3.removeFromWaiting(r3), clearTimeout(s3), a3 = true), !o3) {
                    o3 = true;
                    var t3 = 50 - (Date.now() - n2);
                    t3 > 0 ? setTimeout(i4, t3) : i4(null);
                  }
                }
                window.addEventListener("storage", r3), e3.addToWaiting(r3);
                var s3 = setTimeout(r3, Math.max(0, t2 - Date.now()));
              })];
            case 1:
              return i3.sent(), [2];
          }
        });
      });
    }, e3.addToWaiting = function(t2) {
      this.removeFromWaiting(t2), void 0 !== e3.waiters && e3.waiters.push(t2);
    }, e3.removeFromWaiting = function(t2) {
      void 0 !== e3.waiters && (e3.waiters = e3.waiters.filter(function(e4) {
        return e4 !== t2;
      }));
    }, e3.notifyWaiters = function() {
      void 0 !== e3.waiters && e3.waiters.slice().forEach(function(e4) {
        return e4();
      });
    }, e3.prototype.releaseLock = function(e4) {
      return o2(this, void 0, void 0, function() {
        return a2(this, function(t2) {
          switch (t2.label) {
            case 0:
              return [4, this.releaseLock__private__(e4)];
            case 1:
              return [2, t2.sent()];
          }
        });
      });
    }, e3.prototype.releaseLock__private__ = function(t2) {
      return o2(this, void 0, void 0, function() {
        var i3, o3, r3, d3;
        return a2(this, function(a3) {
          switch (a3.label) {
            case 0:
              return i3 = void 0 === this.storageHandler ? c3 : this.storageHandler, o3 = s2 + "-" + t2, null === (r3 = i3.getItemSync(o3)) ? [2] : (d3 = JSON.parse(r3)).id !== this.id ? [3, 2] : [4, n.default().lock(d3.iat)];
            case 1:
              a3.sent(), this.acquiredIatSet.delete(d3.iat), i3.removeItemSync(o3), n.default().unlock(d3.iat), e3.notifyWaiters(), a3.label = 2;
            case 2:
              return [2];
          }
        });
      });
    }, e3.lockCorrector = function(t2) {
      for (var i3 = Date.now() - 5e3, o3 = t2, n2 = [], a3 = 0; ; ) {
        var r3 = o3.keySync(a3);
        if (null === r3)
          break;
        n2.push(r3), a3++;
      }
      for (var c4 = false, d3 = 0; d3 < n2.length; d3++) {
        var u3 = n2[d3];
        if (u3.includes(s2)) {
          var l3 = o3.getItemSync(u3);
          if (null !== l3) {
            var h2 = JSON.parse(l3);
            (void 0 === h2.timeRefreshed && h2.timeAcquired < i3 || void 0 !== h2.timeRefreshed && h2.timeRefreshed < i3) && (o3.removeItemSync(u3), c4 = true);
          }
        }
      }
      c4 && e3.notifyWaiters();
    }, e3.waiters = void 0, e3;
  }();
  i2.default = l2;
}));
var r$1 = { timeoutInSeconds: 60 };
var s$3 = { name: "auth0-spa-js", version: "2.1.3" };
var c = function c2() {
  return Date.now();
};
var d = function(_Error) {
  function d2(e2, t2) {
    var _this3;
    _classCallCheck2(this, d2);
    _this3 = _callSuper(this, d2, [t2]), _this3.error = e2, _this3.error_description = t2, Object.setPrototypeOf(_assertThisInitialized(_this3), d2.prototype);
    return _this3;
  }
  _inherits2(d2, _Error);
  return _createClass(d2, null, [{ key: "fromPayload", value: function fromPayload(_ref3) {
    var e2 = _ref3.error, t2 = _ref3.error_description;
    return new d2(e2, t2);
  } }]);
}(_wrapNativeSuper(Error));
var u = function(_d) {
  function u2(e2, t2, i2) {
    var _this4;
    var o2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
    _classCallCheck2(this, u2);
    _this4 = _callSuper(this, u2, [e2, t2]), _this4.state = i2, _this4.appState = o2, Object.setPrototypeOf(_assertThisInitialized(_this4), u2.prototype);
    return _this4;
  }
  _inherits2(u2, _d);
  return _createClass(u2);
}(d);
var l = function(_d2) {
  function l2() {
    var _this5;
    _classCallCheck2(this, l2);
    _this5 = _callSuper(this, l2, ["timeout", "Timeout"]), Object.setPrototypeOf(_assertThisInitialized(_this5), l2.prototype);
    return _this5;
  }
  _inherits2(l2, _d2);
  return _createClass(l2);
}(d);
var h = function(_l2) {
  function h2(e2) {
    var _this6;
    _classCallCheck2(this, h2);
    _this6 = _callSuper(this, h2), _this6.popup = e2, Object.setPrototypeOf(_assertThisInitialized(_this6), h2.prototype);
    return _this6;
  }
  _inherits2(h2, _l2);
  return _createClass(h2);
}(l);
var p = function(_d3) {
  function p2(e2) {
    var _this7;
    _classCallCheck2(this, p2);
    _this7 = _callSuper(this, p2, ["cancelled", "Popup closed"]), _this7.popup = e2, Object.setPrototypeOf(_assertThisInitialized(_this7), p2.prototype);
    return _this7;
  }
  _inherits2(p2, _d3);
  return _createClass(p2);
}(d);
var m = function(_d4) {
  function m2(e2, t2, i2) {
    var _this8;
    _classCallCheck2(this, m2);
    _this8 = _callSuper(this, m2, [e2, t2]), _this8.mfa_token = i2, Object.setPrototypeOf(_assertThisInitialized(_this8), m2.prototype);
    return _this8;
  }
  _inherits2(m2, _d4);
  return _createClass(m2);
}(d);
var f$1 = function(_d5) {
  function f2(e2, t2) {
    var _this9;
    _classCallCheck2(this, f2);
    _this9 = _callSuper(this, f2, ["missing_refresh_token", "Missing Refresh Token (audience: '".concat(g(e2, ["default"]), "', scope: '").concat(g(t2), "')")]), _this9.audience = e2, _this9.scope = t2, Object.setPrototypeOf(_assertThisInitialized(_this9), f2.prototype);
    return _this9;
  }
  _inherits2(f2, _d5);
  return _createClass(f2);
}(d);
function g(e2) {
  var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return e2 && !t2.includes(e2) ? e2 : "";
}
var w$1 = function w$12() {
  return window.crypto;
};
var y = function y2() {
  var e2 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_~.";
  var t2 = "";
  return Array.from(w$1().getRandomValues(new Uint8Array(43))).forEach(function(i2) {
    return t2 += e2[i2 % e2.length];
  }), t2;
};
var k = function k2(e2) {
  return btoa(e2);
};
var v$1 = function v$12(t2) {
  var i2 = t2.clientId, o2 = e(t2, ["clientId"]);
  return new URLSearchParams(function(e2) {
    return Object.keys(e2).filter(function(t3) {
      return void 0 !== e2[t3];
    }).reduce(function(t3, i3) {
      return Object.assign(Object.assign({}, t3), _defineProperty({}, i3, e2[i3]));
    }, {});
  }(Object.assign({ client_id: i2 }, o2))).toString();
};
var b = function b2(e2) {
  return function(e3) {
    return decodeURIComponent(atob(e3).split("").map(function(e4) {
      return "%" + ("00" + e4.charCodeAt(0).toString(16)).slice(-2);
    }).join(""));
  }(e2.replace(/_/g, "/").replace(/-/g, "+"));
};
var _$1 = function() {
  var _ref4 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(e2, t2) {
    var i2;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1)
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return fetch(e2, t2);
          case 2:
            i2 = _context.sent;
            _context.t0 = i2.ok;
            _context.next = 6;
            return i2.json();
          case 6:
            _context.t1 = _context.sent;
            return _context.abrupt("return", { ok: _context.t0, json: _context.t1 });
          case 8:
          case "end":
            return _context.stop();
        }
    }, _callee);
  }));
  return function _$12(_x4, _x5) {
    return _ref4.apply(this, arguments);
  };
}();
var I$3 = function() {
  var _ref5 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(e2, t2, i2) {
    var o2, n2;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1)
        switch (_context2.prev = _context2.next) {
          case 0:
            o2 = new AbortController();
            return _context2.abrupt("return", (t2.signal = o2.signal, Promise.race([_$1(e2, t2), new Promise(function(e3, t3) {
              n2 = setTimeout(function() {
                o2.abort(), t3(new Error("Timeout when executing 'fetch'"));
              }, i2);
            })]).finally(function() {
              clearTimeout(n2);
            })));
          case 2:
          case "end":
            return _context2.stop();
        }
    }, _callee2);
  }));
  return function I$32(_x6, _x7, _x8) {
    return _ref5.apply(this, arguments);
  };
}();
var S$2 = function() {
  var _ref6 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee3(e2, t2, i2, o2, n2, a2, r2) {
    var s2, c3;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1)
        switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.abrupt("return", (s2 = { auth: { audience: t2, scope: i2 }, timeout: n2, fetchUrl: e2, fetchOptions: o2, useFormData: r2 }, c3 = a2, new Promise(function(e3, t3) {
              var i3 = new MessageChannel();
              i3.port1.onmessage = function(o3) {
                o3.data.error ? t3(new Error(o3.data.error)) : e3(o3.data), i3.port1.close();
              }, c3.postMessage(s2, [i3.port2]);
            })));
          case 1:
          case "end":
            return _context3.stop();
        }
    }, _callee3);
  }));
  return function S$22(_x9, _x10, _x11, _x12, _x13, _x14, _x15) {
    return _ref6.apply(this, arguments);
  };
}();
var O = function() {
  var _ref7 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee4(e2, t2, i2, o2, n2, a2) {
    var r2, _args4 = arguments;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1)
        switch (_context4.prev = _context4.next) {
          case 0:
            r2 = _args4.length > 6 && _args4[6] !== void 0 ? _args4[6] : 1e4;
            return _context4.abrupt("return", n2 ? S$2(e2, t2, i2, o2, r2, n2, a2) : I$3(e2, o2, r2));
          case 2:
          case "end":
            return _context4.stop();
        }
    }, _callee4);
  }));
  return function O2(_x16, _x17, _x18, _x19, _x20, _x21) {
    return _ref7.apply(this, arguments);
  };
}();
function T$1(_x22, _x23) {
  return _T$.apply(this, arguments);
}
function _T$() {
  _T$ = _asyncToGenerator(_regeneratorRuntime().mark(function _callee215(t2, i2) {
    var o2, n2, a2, r2, c3, u2, l2, h2;
    return _regeneratorRuntime().wrap(function _callee215$(_context216) {
      while (1)
        switch (_context216.prev = _context216.next) {
          case 0:
            o2 = t2.baseUrl, n2 = t2.timeout, a2 = t2.audience, r2 = t2.scope, c3 = t2.auth0Client, u2 = t2.useFormData, l2 = e(t2, ["baseUrl", "timeout", "audience", "scope", "auth0Client", "useFormData"]);
            h2 = u2 ? v$1(l2) : JSON.stringify(l2);
            _context216.next = 4;
            return function() {
              var _ref97 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee214(t3, i3, o3, n3, a3, r3, s2) {
                var c4, u3, _e9, l3, h3, p2, g2, _c4, w2, _e10;
                return _regeneratorRuntime().wrap(function _callee214$(_context215) {
                  while (1)
                    switch (_context215.prev = _context215.next) {
                      case 0:
                        u3 = null;
                        _e9 = 0;
                      case 2:
                        if (!(_e9 < 3)) {
                          _context215.next = 17;
                          break;
                        }
                        _context215.prev = 3;
                        _context215.next = 6;
                        return O(t3, o3, n3, a3, r3, s2, i3);
                      case 6:
                        c4 = _context215.sent;
                        u3 = null;
                        return _context215.abrupt("break", 17);
                      case 11:
                        _context215.prev = 11;
                        _context215.t0 = _context215["catch"](3);
                        u3 = _context215.t0;
                      case 14:
                        _e9++;
                        _context215.next = 2;
                        break;
                      case 17:
                        if (!u3) {
                          _context215.next = 19;
                          break;
                        }
                        throw u3;
                      case 19:
                        l3 = c4.json, h3 = l3.error, p2 = l3.error_description, g2 = e(l3, ["error", "error_description"]), _c4 = c4, w2 = _c4.ok;
                        if (w2) {
                          _context215.next = 27;
                          break;
                        }
                        _e10 = p2 || "HTTP error. Unable to fetch ".concat(t3);
                        if (!("mfa_required" === h3)) {
                          _context215.next = 24;
                          break;
                        }
                        throw new m(h3, _e10, g2.mfa_token);
                      case 24:
                        if (!("missing_refresh_token" === h3)) {
                          _context215.next = 26;
                          break;
                        }
                        throw new f$1(o3, n3);
                      case 26:
                        throw new d(h3 || "request_error", _e10);
                      case 27:
                        return _context215.abrupt("return", g2);
                      case 28:
                      case "end":
                        return _context215.stop();
                    }
                }, _callee214, null, [[3, 11]]);
              }));
              return function(_x309, _x310, _x311, _x312, _x313, _x314, _x315) {
                return _ref97.apply(this, arguments);
              };
            }()("".concat(o2, "/oauth/token"), n2, a2 || "default", r2, { method: "POST", body: h2, headers: { "Content-Type": u2 ? "application/x-www-form-urlencoded" : "application/json", "Auth0-Client": btoa(JSON.stringify(c3 || s$3)) } }, i2, u2);
          case 4:
            return _context216.abrupt("return", _context216.sent);
          case 5:
          case "end":
            return _context216.stop();
        }
    }, _callee215);
  }));
  return _T$.apply(this, arguments);
}
var j = function j2() {
  for (var _len = arguments.length, e2 = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
    e2[_key2] = arguments[_key2];
  }
  return (t2 = e2.filter(Boolean).join(" ").trim().split(/\s+/), Array.from(new Set(t2))).join(" ");
  var t2;
};
var C$1 = function() {
  function C3(e2) {
    var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "@@auth0spajs@@";
    var i2 = arguments.length > 2 ? arguments[2] : void 0;
    _classCallCheck2(this, C3);
    this.prefix = t2, this.suffix = i2, this.clientId = e2.clientId, this.scope = e2.scope, this.audience = e2.audience;
  }
  return _createClass(C3, [{ key: "toKey", value: function toKey() {
    return [this.prefix, this.clientId, this.audience, this.scope, this.suffix].filter(Boolean).join("::");
  } }], [{ key: "fromKey", value: function fromKey(e2) {
    var _e$split = e2.split("::"), _e$split2 = _slicedToArray(_e$split, 4), t2 = _e$split2[0], i2 = _e$split2[1], o2 = _e$split2[2], n2 = _e$split2[3];
    return new C3({ clientId: i2, scope: n2, audience: o2 }, t2);
  } }, { key: "fromCacheEntry", value: function fromCacheEntry(e2) {
    var t2 = e2.scope, i2 = e2.audience, o2 = e2.client_id;
    return new C3({ scope: t2, audience: i2, clientId: o2 });
  } }]);
}();
var z$1 = function() {
  function z2() {
    _classCallCheck2(this, z2);
  }
  return _createClass(z2, [{ key: "set", value: function set(e2, t2) {
    localStorage.setItem(e2, JSON.stringify(t2));
  } }, { key: "get", value: function get5(e2) {
    var t2 = window.localStorage.getItem(e2);
    if (t2)
      try {
        return JSON.parse(t2);
      } catch (e3) {
        return;
      }
  } }, { key: "remove", value: function remove6(e2) {
    localStorage.removeItem(e2);
  } }, { key: "allKeys", value: function allKeys() {
    return Object.keys(window.localStorage).filter(function(e2) {
      return e2.startsWith("@@auth0spajs@@");
    });
  } }]);
}();
var P$1 = _createClass(function P2() {
  _classCallCheck2(this, P2);
  this.enclosedCache = /* @__PURE__ */ function() {
    var e2 = {};
    return { set: function set(t2, i2) {
      e2[t2] = i2;
    }, get: function get5(t2) {
      var i2 = e2[t2];
      if (i2)
        return i2;
    }, remove: function remove6(t2) {
      delete e2[t2];
    }, allKeys: function allKeys() {
      return Object.keys(e2);
    } };
  }();
});
var x$1 = function() {
  function x2(e2, t2, i2) {
    _classCallCheck2(this, x2);
    this.cache = e2, this.keyManifest = t2, this.nowProvider = i2 || c;
  }
  return _createClass(x2, [{ key: "setIdToken", value: function() {
    var _setIdToken = _asyncToGenerator(_regeneratorRuntime().mark(function _callee5(e2, t2, i2) {
      var o2, n2;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1)
          switch (_context5.prev = _context5.next) {
            case 0:
              n2 = this.getIdTokenCacheKey(e2);
              _context5.next = 3;
              return this.cache.set(n2, { id_token: t2, decodedToken: i2 });
            case 3:
              _context5.next = 5;
              return null === (o2 = this.keyManifest) || void 0 === o2 ? void 0 : o2.add(n2);
            case 5:
            case "end":
              return _context5.stop();
          }
      }, _callee5, this);
    }));
    function setIdToken(_x24, _x25, _x26) {
      return _setIdToken.apply(this, arguments);
    }
    return setIdToken;
  }() }, { key: "getIdToken", value: function() {
    var _getIdToken = _asyncToGenerator(_regeneratorRuntime().mark(function _callee6(e2) {
      var t2, _t2;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1)
          switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return this.cache.get(this.getIdTokenCacheKey(e2.clientId));
            case 2:
              t2 = _context6.sent;
              if (!(!t2 && e2.scope && e2.audience)) {
                _context6.next = 12;
                break;
              }
              _context6.next = 6;
              return this.get(e2);
            case 6:
              _t2 = _context6.sent;
              if (_t2) {
                _context6.next = 9;
                break;
              }
              return _context6.abrupt("return");
            case 9:
              if (!(!_t2.id_token || !_t2.decodedToken)) {
                _context6.next = 11;
                break;
              }
              return _context6.abrupt("return");
            case 11:
              return _context6.abrupt("return", { id_token: _t2.id_token, decodedToken: _t2.decodedToken });
            case 12:
              if (!t2) {
                _context6.next = 14;
                break;
              }
              return _context6.abrupt("return", { id_token: t2.id_token, decodedToken: t2.decodedToken });
            case 14:
            case "end":
              return _context6.stop();
          }
      }, _callee6, this);
    }));
    function getIdToken(_x27) {
      return _getIdToken.apply(this, arguments);
    }
    return getIdToken;
  }() }, { key: "get", value: function() {
    var _get = _asyncToGenerator(_regeneratorRuntime().mark(function _callee7(e2) {
      var t2, i2, o2, _t3, _i, n2, a2, _args7 = arguments;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1)
          switch (_context7.prev = _context7.next) {
            case 0:
              t2 = _args7.length > 1 && _args7[1] !== void 0 ? _args7[1] : 0;
              _context7.next = 3;
              return this.cache.get(e2.toKey());
            case 3:
              o2 = _context7.sent;
              if (o2) {
                _context7.next = 16;
                break;
              }
              _context7.next = 7;
              return this.getCacheKeys();
            case 7:
              _t3 = _context7.sent;
              if (_t3) {
                _context7.next = 10;
                break;
              }
              return _context7.abrupt("return");
            case 10:
              _i = this.matchExistingCacheKey(e2, _t3);
              _context7.t0 = _i;
              if (!_context7.t0) {
                _context7.next = 16;
                break;
              }
              _context7.next = 15;
              return this.cache.get(_i);
            case 15:
              o2 = _context7.sent;
            case 16:
              if (o2) {
                _context7.next = 18;
                break;
              }
              return _context7.abrupt("return");
            case 18:
              _context7.next = 20;
              return this.nowProvider();
            case 20:
              n2 = _context7.sent;
              a2 = Math.floor(n2 / 1e3);
              if (!(o2.expiresAt - t2 < a2)) {
                _context7.next = 38;
                break;
              }
              if (!o2.body.refresh_token) {
                _context7.next = 30;
                break;
              }
              o2.body = { refresh_token: o2.body.refresh_token };
              _context7.next = 27;
              return this.cache.set(e2.toKey(), o2);
            case 27:
              _context7.t2 = o2.body;
              _context7.next = 35;
              break;
            case 30:
              _context7.next = 32;
              return this.cache.remove(e2.toKey());
            case 32:
              _context7.next = 34;
              return null === (i2 = this.keyManifest) || void 0 === i2 ? void 0 : i2.remove(e2.toKey());
            case 34:
              _context7.t2 = void _context7.sent;
            case 35:
              _context7.t1 = _context7.t2;
              _context7.next = 39;
              break;
            case 38:
              _context7.t1 = o2.body;
            case 39:
              return _context7.abrupt("return", _context7.t1);
            case 40:
            case "end":
              return _context7.stop();
          }
      }, _callee7, this);
    }));
    function get5(_x28) {
      return _get.apply(this, arguments);
    }
    return get5;
  }() }, { key: "set", value: function() {
    var _set = _asyncToGenerator(_regeneratorRuntime().mark(function _callee8(e2) {
      var t2, i2, o2;
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1)
          switch (_context8.prev = _context8.next) {
            case 0:
              i2 = new C$1({ clientId: e2.client_id, scope: e2.scope, audience: e2.audience });
              _context8.next = 3;
              return this.wrapCacheEntry(e2);
            case 3:
              o2 = _context8.sent;
              _context8.next = 6;
              return this.cache.set(i2.toKey(), o2);
            case 6:
              _context8.next = 8;
              return null === (t2 = this.keyManifest) || void 0 === t2 ? void 0 : t2.add(i2.toKey());
            case 8:
            case "end":
              return _context8.stop();
          }
      }, _callee8, this);
    }));
    function set(_x29) {
      return _set.apply(this, arguments);
    }
    return set;
  }() }, { key: "clear", value: function() {
    var _clear = _asyncToGenerator(_regeneratorRuntime().mark(function _callee10(e2) {
      var _this10 = this;
      var t2, i2;
      return _regeneratorRuntime().wrap(function _callee10$(_context10) {
        while (1)
          switch (_context10.prev = _context10.next) {
            case 0:
              _context10.next = 2;
              return this.getCacheKeys();
            case 2:
              i2 = _context10.sent;
              _context10.t0 = i2;
              if (!_context10.t0) {
                _context10.next = 9;
                break;
              }
              _context10.next = 7;
              return i2.filter(function(t3) {
                return !e2 || t3.includes(e2);
              }).reduce(function() {
                var _ref8 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee9(e3, t3) {
                  return _regeneratorRuntime().wrap(function _callee9$(_context9) {
                    while (1)
                      switch (_context9.prev = _context9.next) {
                        case 0:
                          _context9.next = 2;
                          return e3;
                        case 2:
                          _context9.next = 4;
                          return _this10.cache.remove(t3);
                        case 4:
                        case "end":
                          return _context9.stop();
                      }
                  }, _callee9);
                }));
                return function(_x31, _x32) {
                  return _ref8.apply(this, arguments);
                };
              }(), Promise.resolve());
            case 7:
              _context10.next = 9;
              return null === (t2 = this.keyManifest) || void 0 === t2 ? void 0 : t2.clear();
            case 9:
            case "end":
              return _context10.stop();
          }
      }, _callee10, this);
    }));
    function clear(_x30) {
      return _clear.apply(this, arguments);
    }
    return clear;
  }() }, { key: "wrapCacheEntry", value: function() {
    var _wrapCacheEntry = _asyncToGenerator(_regeneratorRuntime().mark(function _callee11(e2) {
      var t2;
      return _regeneratorRuntime().wrap(function _callee11$(_context11) {
        while (1)
          switch (_context11.prev = _context11.next) {
            case 0:
              _context11.next = 2;
              return this.nowProvider();
            case 2:
              t2 = _context11.sent;
              return _context11.abrupt("return", { body: e2, expiresAt: Math.floor(t2 / 1e3) + e2.expires_in });
            case 4:
            case "end":
              return _context11.stop();
          }
      }, _callee11, this);
    }));
    function wrapCacheEntry(_x33) {
      return _wrapCacheEntry.apply(this, arguments);
    }
    return wrapCacheEntry;
  }() }, { key: "getCacheKeys", value: function() {
    var _getCacheKeys = _asyncToGenerator(_regeneratorRuntime().mark(function _callee12() {
      var e2;
      return _regeneratorRuntime().wrap(function _callee12$(_context12) {
        while (1)
          switch (_context12.prev = _context12.next) {
            case 0:
              if (!this.keyManifest) {
                _context12.next = 15;
                break;
              }
              _context12.next = 3;
              return this.keyManifest.get();
            case 3:
              _context12.t2 = e2 = _context12.sent;
              _context12.t1 = null === _context12.t2;
              if (_context12.t1) {
                _context12.next = 7;
                break;
              }
              _context12.t1 = void 0 === e2;
            case 7:
              if (!_context12.t1) {
                _context12.next = 11;
                break;
              }
              _context12.t3 = void 0;
              _context12.next = 12;
              break;
            case 11:
              _context12.t3 = e2.keys;
            case 12:
              _context12.t0 = _context12.t3;
              _context12.next = 16;
              break;
            case 15:
              _context12.t0 = this.cache.allKeys ? this.cache.allKeys() : void 0;
            case 16:
              return _context12.abrupt("return", _context12.t0);
            case 17:
            case "end":
              return _context12.stop();
          }
      }, _callee12, this);
    }));
    function getCacheKeys() {
      return _getCacheKeys.apply(this, arguments);
    }
    return getCacheKeys;
  }() }, { key: "getIdTokenCacheKey", value: function getIdTokenCacheKey(e2) {
    return new C$1({ clientId: e2 }, "@@auth0spajs@@", "@@user@@").toKey();
  } }, { key: "matchExistingCacheKey", value: function matchExistingCacheKey(e2, t2) {
    return t2.filter(function(t3) {
      var i2;
      var o2 = C$1.fromKey(t3), n2 = new Set(o2.scope && o2.scope.split(" ")), a2 = (null === (i2 = e2.scope) || void 0 === i2 ? void 0 : i2.split(" ")) || [], r2 = o2.scope && a2.reduce(function(e3, t4) {
        return e3 && n2.has(t4);
      }, true);
      return "@@auth0spajs@@" === o2.prefix && o2.clientId === e2.clientId && o2.audience === e2.audience && r2;
    })[0];
  } }]);
}();
var Z$3 = function() {
  function Z2(e2, t2, i2) {
    _classCallCheck2(this, Z2);
    this.storage = e2, this.clientId = t2, this.cookieDomain = i2, this.storageKey = "a0.spajs.txs.".concat(this.clientId);
  }
  return _createClass(Z2, [{ key: "create", value: function create8(e2) {
    this.storage.save(this.storageKey, e2, { daysUntilExpire: 1, cookieDomain: this.cookieDomain });
  } }, { key: "get", value: function get5() {
    return this.storage.get(this.storageKey);
  } }, { key: "remove", value: function remove6() {
    this.storage.remove(this.storageKey, { cookieDomain: this.cookieDomain });
  } }]);
}();
var K$1 = function K$12(e2) {
  return "number" == typeof e2;
};
var W = ["iss", "aud", "exp", "nbf", "iat", "jti", "azp", "nonce", "auth_time", "at_hash", "c_hash", "acr", "amr", "sub_jwk", "cnf", "sip_from_tag", "sip_date", "sip_callid", "sip_cseq_num", "sip_via_branch", "orig", "dest", "mky", "events", "toe", "txn", "rph", "sid", "vot", "vtm"];
var E$1 = function E$12(e2) {
  if (!e2.id_token)
    throw new Error("ID token is required but missing");
  var t2 = function(e3) {
    var t3 = e3.split("."), _t4 = _slicedToArray(t3, 3), i3 = _t4[0], o3 = _t4[1], n3 = _t4[2];
    if (3 !== t3.length || !i3 || !o3 || !n3)
      throw new Error("ID token could not be decoded");
    var a2 = JSON.parse(b(o3)), r2 = { __raw: e3 }, s2 = {};
    return Object.keys(a2).forEach(function(e4) {
      r2[e4] = a2[e4], W.includes(e4) || (s2[e4] = a2[e4]);
    }), { encoded: { header: i3, payload: o3, signature: n3 }, header: JSON.parse(b(i3)), claims: r2, user: s2 };
  }(e2.id_token);
  if (!t2.claims.iss)
    throw new Error("Issuer (iss) claim must be a string present in the ID token");
  if (t2.claims.iss !== e2.iss)
    throw new Error('Issuer (iss) claim mismatch in the ID token; expected "'.concat(e2.iss, '", found "').concat(t2.claims.iss, '"'));
  if (!t2.user.sub)
    throw new Error("Subject (sub) claim must be a string present in the ID token");
  if ("RS256" !== t2.header.alg)
    throw new Error('Signature algorithm of "'.concat(t2.header.alg, '" is not supported. Expected the ID token to be signed with "RS256".'));
  if (!t2.claims.aud || "string" != typeof t2.claims.aud && !Array.isArray(t2.claims.aud))
    throw new Error("Audience (aud) claim must be a string or array of strings present in the ID token");
  if (Array.isArray(t2.claims.aud)) {
    if (!t2.claims.aud.includes(e2.aud))
      throw new Error('Audience (aud) claim mismatch in the ID token; expected "'.concat(e2.aud, '" but was not one of "').concat(t2.claims.aud.join(", "), '"'));
    if (t2.claims.aud.length > 1) {
      if (!t2.claims.azp)
        throw new Error("Authorized Party (azp) claim must be a string present in the ID token when Audience (aud) claim has multiple values");
      if (t2.claims.azp !== e2.aud)
        throw new Error('Authorized Party (azp) claim mismatch in the ID token; expected "'.concat(e2.aud, '", found "').concat(t2.claims.azp, '"'));
    }
  } else if (t2.claims.aud !== e2.aud)
    throw new Error('Audience (aud) claim mismatch in the ID token; expected "'.concat(e2.aud, '" but found "').concat(t2.claims.aud, '"'));
  if (e2.nonce) {
    if (!t2.claims.nonce)
      throw new Error("Nonce (nonce) claim must be a string present in the ID token");
    if (t2.claims.nonce !== e2.nonce)
      throw new Error('Nonce (nonce) claim mismatch in the ID token; expected "'.concat(e2.nonce, '", found "').concat(t2.claims.nonce, '"'));
  }
  if (e2.max_age && !K$1(t2.claims.auth_time))
    throw new Error("Authentication Time (auth_time) claim must be a number present in the ID token when Max Age (max_age) is specified");
  if (null == t2.claims.exp || !K$1(t2.claims.exp))
    throw new Error("Expiration Time (exp) claim must be a number present in the ID token");
  if (!K$1(t2.claims.iat))
    throw new Error("Issued At (iat) claim must be a number present in the ID token");
  var i2 = e2.leeway || 60, o2 = new Date(e2.now || Date.now()), n2 = /* @__PURE__ */ new Date(0);
  if (n2.setUTCSeconds(t2.claims.exp + i2), o2 > n2)
    throw new Error("Expiration Time (exp) claim error in the ID token; current time (".concat(o2, ") is after expiration time (").concat(n2, ")"));
  if (null != t2.claims.nbf && K$1(t2.claims.nbf)) {
    var _e = /* @__PURE__ */ new Date(0);
    if (_e.setUTCSeconds(t2.claims.nbf - i2), o2 < _e)
      throw new Error("Not Before time (nbf) claim in the ID token indicates that this token can't be used just yet. Current time (".concat(o2, ") is before ").concat(_e));
  }
  if (null != t2.claims.auth_time && K$1(t2.claims.auth_time)) {
    var _n = /* @__PURE__ */ new Date(0);
    if (_n.setUTCSeconds(parseInt(t2.claims.auth_time) + e2.max_age + i2), o2 > _n)
      throw new Error("Authentication Time (auth_time) claim in the ID token indicates that too much time has passed since the last end-user authentication. Current time (".concat(o2, ") is after last auth at ").concat(_n));
  }
  if (e2.organization) {
    var _i2 = e2.organization.trim();
    if (_i2.startsWith("org_")) {
      var _e2 = _i2;
      if (!t2.claims.org_id)
        throw new Error("Organization ID (org_id) claim must be a string present in the ID token");
      if (_e2 !== t2.claims.org_id)
        throw new Error('Organization ID (org_id) claim mismatch in the ID token; expected "'.concat(_e2, '", found "').concat(t2.claims.org_id, '"'));
    } else {
      var _e3 = _i2.toLowerCase();
      if (!t2.claims.org_name)
        throw new Error("Organization Name (org_name) claim must be a string present in the ID token");
      if (_e3 !== t2.claims.org_name)
        throw new Error('Organization Name (org_name) claim mismatch in the ID token; expected "'.concat(_e3, '", found "').concat(t2.claims.org_name, '"'));
    }
  }
  return t2;
};
var R = o(function(e2, i2) {
  var o2 = t && t.__assign || function() {
    return o2 = Object.assign || function(e3) {
      for (var t2, i3 = 1, o3 = arguments.length; i3 < o3; i3++)
        for (var n3 in t2 = arguments[i3])
          Object.prototype.hasOwnProperty.call(t2, n3) && (e3[n3] = t2[n3]);
      return e3;
    }, o2.apply(this, arguments);
  };
  function n2(e3, t2) {
    if (!t2)
      return "";
    var i3 = "; " + e3;
    return true === t2 ? i3 : i3 + "=" + t2;
  }
  function a2(e3, t2, i3) {
    return encodeURIComponent(e3).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/\(/g, "%28").replace(/\)/g, "%29") + "=" + encodeURIComponent(t2).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent) + function(e4) {
      if ("number" == typeof e4.expires) {
        var t3 = /* @__PURE__ */ new Date();
        t3.setMilliseconds(t3.getMilliseconds() + 864e5 * e4.expires), e4.expires = t3;
      }
      return n2("Expires", e4.expires ? e4.expires.toUTCString() : "") + n2("Domain", e4.domain) + n2("Path", e4.path) + n2("Secure", e4.secure) + n2("SameSite", e4.sameSite);
    }(i3);
  }
  function r2(e3) {
    for (var t2 = {}, i3 = e3 ? e3.split("; ") : [], o3 = /(%[\dA-F]{2})+/gi, n3 = 0; n3 < i3.length; n3++) {
      var a3 = i3[n3].split("="), r3 = a3.slice(1).join("=");
      '"' === r3.charAt(0) && (r3 = r3.slice(1, -1));
      try {
        t2[a3[0].replace(o3, decodeURIComponent)] = r3.replace(o3, decodeURIComponent);
      } catch (e4) {
      }
    }
    return t2;
  }
  function s2() {
    return r2(document.cookie);
  }
  function c3(e3, t2, i3) {
    document.cookie = a2(e3, t2, o2({ path: "/" }, i3));
  }
  i2.__esModule = true, i2.encode = a2, i2.parse = r2, i2.getAll = s2, i2.get = function(e3) {
    return s2()[e3];
  }, i2.set = c3, i2.remove = function(e3, t2) {
    c3(e3, "", o2(o2({}, t2), { expires: -1 }));
  };
});
i$1(R), R.encode, R.parse, R.getAll;
var U = R.get;
var L$2 = R.set;
var D$2 = R.remove;
var X$3 = { get: function get(e2) {
  var t2 = U(e2);
  if (void 0 !== t2)
    return JSON.parse(t2);
}, save: function save(e2, t2, i2) {
  var o2 = {};
  "https:" === window.location.protocol && (o2 = { secure: true, sameSite: "none" }), (null == i2 ? void 0 : i2.daysUntilExpire) && (o2.expires = i2.daysUntilExpire), (null == i2 ? void 0 : i2.cookieDomain) && (o2.domain = i2.cookieDomain), L$2(e2, JSON.stringify(t2), o2);
}, remove: function remove(e2, t2) {
  var i2 = {};
  (null == t2 ? void 0 : t2.cookieDomain) && (i2.domain = t2.cookieDomain), D$2(e2, i2);
} };
var N$1 = { get: function get2(e2) {
  var t2 = X$3.get(e2);
  return t2 || X$3.get("_legacy_".concat(e2));
}, save: function save2(e2, t2, i2) {
  var o2 = {};
  "https:" === window.location.protocol && (o2 = { secure: true }), (null == i2 ? void 0 : i2.daysUntilExpire) && (o2.expires = i2.daysUntilExpire), (null == i2 ? void 0 : i2.cookieDomain) && (o2.domain = i2.cookieDomain), L$2("_legacy_".concat(e2), JSON.stringify(t2), o2), X$3.save(e2, t2, i2);
}, remove: function remove2(e2, t2) {
  var i2 = {};
  (null == t2 ? void 0 : t2.cookieDomain) && (i2.domain = t2.cookieDomain), D$2(e2, i2), X$3.remove(e2, t2), X$3.remove("_legacy_".concat(e2), t2);
} };
var J = { get: function get3(e2) {
  if ("undefined" == typeof sessionStorage)
    return;
  var t2 = sessionStorage.getItem(e2);
  return null != t2 ? JSON.parse(t2) : void 0;
}, save: function save3(e2, t2) {
  sessionStorage.setItem(e2, JSON.stringify(t2));
}, remove: function remove3(e2) {
  sessionStorage.removeItem(e2);
} };
function F(e2, t2, i2) {
  var o2 = void 0 === t2 ? null : t2, n2 = function(e3, t3) {
    var i3 = atob(e3);
    if (t3) {
      for (var o3 = new Uint8Array(i3.length), n3 = 0, a3 = i3.length; n3 < a3; ++n3)
        o3[n3] = i3.charCodeAt(n3);
      return String.fromCharCode.apply(null, new Uint16Array(o3.buffer));
    }
    return i3;
  }(e2, void 0 !== i2 && i2), a2 = n2.indexOf("\n", 10) + 1, r2 = n2.substring(a2) + (o2 ? "//# sourceMappingURL=" + o2 : ""), s2 = new Blob([r2], { type: "application/javascript" });
  return URL.createObjectURL(s2);
}
var H;
var Y$2;
var G;
var V;
var M$3 = (H = "Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwohZnVuY3Rpb24oKXsidXNlIHN0cmljdCI7Y2xhc3MgZSBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKHQscil7c3VwZXIociksdGhpcy5lcnJvcj10LHRoaXMuZXJyb3JfZGVzY3JpcHRpb249cixPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcyxlLnByb3RvdHlwZSl9c3RhdGljIGZyb21QYXlsb2FkKHtlcnJvcjp0LGVycm9yX2Rlc2NyaXB0aW9uOnJ9KXtyZXR1cm4gbmV3IGUodCxyKX19Y2xhc3MgdCBleHRlbmRzIGV7Y29uc3RydWN0b3IoZSxzKXtzdXBlcigibWlzc2luZ19yZWZyZXNoX3Rva2VuIixgTWlzc2luZyBSZWZyZXNoIFRva2VuIChhdWRpZW5jZTogJyR7cihlLFsiZGVmYXVsdCJdKX0nLCBzY29wZTogJyR7cihzKX0nKWApLHRoaXMuYXVkaWVuY2U9ZSx0aGlzLnNjb3BlPXMsT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsdC5wcm90b3R5cGUpfX1mdW5jdGlvbiByKGUsdD1bXSl7cmV0dXJuIGUmJiF0LmluY2x1ZGVzKGUpP2U6IiJ9ImZ1bmN0aW9uIj09dHlwZW9mIFN1cHByZXNzZWRFcnJvciYmU3VwcHJlc3NlZEVycm9yO2NvbnN0IHM9ZT0+e3ZhcntjbGllbnRJZDp0fT1lLHI9ZnVuY3Rpb24oZSx0KXt2YXIgcj17fTtmb3IodmFyIHMgaW4gZSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxzKSYmdC5pbmRleE9mKHMpPDAmJihyW3NdPWVbc10pO2lmKG51bGwhPWUmJiJmdW5jdGlvbiI9PXR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgbz0wO2ZvcihzPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7bzxzLmxlbmd0aDtvKyspdC5pbmRleE9mKHNbb10pPDAmJk9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlLHNbb10pJiYocltzW29dXT1lW3Nbb11dKX1yZXR1cm4gcn0oZSxbImNsaWVudElkIl0pO3JldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKChlPT5PYmplY3Qua2V5cyhlKS5maWx0ZXIoKHQ9PnZvaWQgMCE9PWVbdF0pKS5yZWR1Y2UoKCh0LHIpPT5PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse1tyXTplW3JdfSkpLHt9KSkoT2JqZWN0LmFzc2lnbih7Y2xpZW50X2lkOnR9LHIpKSkudG9TdHJpbmcoKX07bGV0IG89e307Y29uc3Qgbj0oZSx0KT0+YCR7ZX18JHt0fWA7YWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsKGFzeW5jKHtkYXRhOnt0aW1lb3V0OmUsYXV0aDpyLGZldGNoVXJsOmksZmV0Y2hPcHRpb25zOmMsdXNlRm9ybURhdGE6YX0scG9ydHM6W3BdfSk9PntsZXQgZjtjb25zdHthdWRpZW5jZTp1LHNjb3BlOmx9PXJ8fHt9O3RyeXtjb25zdCByPWE/KGU9Pntjb25zdCB0PW5ldyBVUkxTZWFyY2hQYXJhbXMoZSkscj17fTtyZXR1cm4gdC5mb3JFYWNoKCgoZSx0KT0+e3JbdF09ZX0pKSxyfSkoYy5ib2R5KTpKU09OLnBhcnNlKGMuYm9keSk7aWYoIXIucmVmcmVzaF90b2tlbiYmInJlZnJlc2hfdG9rZW4iPT09ci5ncmFudF90eXBlKXtjb25zdCBlPSgoZSx0KT0+b1tuKGUsdCldKSh1LGwpO2lmKCFlKXRocm93IG5ldyB0KHUsbCk7Yy5ib2R5PWE/cyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse3JlZnJlc2hfdG9rZW46ZX0pKTpKU09OLnN0cmluZ2lmeShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse3JlZnJlc2hfdG9rZW46ZX0pKX1sZXQgaCxnOyJmdW5jdGlvbiI9PXR5cGVvZiBBYm9ydENvbnRyb2xsZXImJihoPW5ldyBBYm9ydENvbnRyb2xsZXIsYy5zaWduYWw9aC5zaWduYWwpO3RyeXtnPWF3YWl0IFByb21pc2UucmFjZShbKGQ9ZSxuZXcgUHJvbWlzZSgoZT0+c2V0VGltZW91dChlLGQpKSkpLGZldGNoKGksT2JqZWN0LmFzc2lnbih7fSxjKSldKX1jYXRjaChlKXtyZXR1cm4gdm9pZCBwLnBvc3RNZXNzYWdlKHtlcnJvcjplLm1lc3NhZ2V9KX1pZighZylyZXR1cm4gaCYmaC5hYm9ydCgpLHZvaWQgcC5wb3N0TWVzc2FnZSh7ZXJyb3I6IlRpbWVvdXQgd2hlbiBleGVjdXRpbmcgJ2ZldGNoJyJ9KTtmPWF3YWl0IGcuanNvbigpLGYucmVmcmVzaF90b2tlbj8oKChlLHQscik9PntvW24odCxyKV09ZX0pKGYucmVmcmVzaF90b2tlbix1LGwpLGRlbGV0ZSBmLnJlZnJlc2hfdG9rZW4pOigoZSx0KT0+e2RlbGV0ZSBvW24oZSx0KV19KSh1LGwpLHAucG9zdE1lc3NhZ2Uoe29rOmcub2ssanNvbjpmfSl9Y2F0Y2goZSl7cC5wb3N0TWVzc2FnZSh7b2s6ITEsanNvbjp7ZXJyb3I6ZS5lcnJvcixlcnJvcl9kZXNjcmlwdGlvbjplLm1lc3NhZ2V9fSl9dmFyIGR9KSl9KCk7Cgo=", Y$2 = null, G = false, function(e2) {
  return V = V || F(H, Y$2, G), new Worker(V, e2);
});
var A$2 = {};
var B$1 = function() {
  function B2(e2, t2) {
    _classCallCheck2(this, B2);
    this.cache = e2, this.clientId = t2, this.manifestKey = this.createManifestKeyFrom(this.clientId);
  }
  return _createClass(B2, [{ key: "add", value: function() {
    var _add = _asyncToGenerator(_regeneratorRuntime().mark(function _callee13(e2) {
      var t2, i2;
      return _regeneratorRuntime().wrap(function _callee13$(_context13) {
        while (1)
          switch (_context13.prev = _context13.next) {
            case 0:
              _context13.t0 = Set;
              _context13.next = 3;
              return this.cache.get(this.manifestKey);
            case 3:
              _context13.t3 = t2 = _context13.sent;
              _context13.t2 = null === _context13.t3;
              if (_context13.t2) {
                _context13.next = 7;
                break;
              }
              _context13.t2 = void 0 === t2;
            case 7:
              if (!_context13.t2) {
                _context13.next = 11;
                break;
              }
              _context13.t4 = void 0;
              _context13.next = 12;
              break;
            case 11:
              _context13.t4 = t2.keys;
            case 12:
              _context13.t1 = _context13.t4;
              if (_context13.t1) {
                _context13.next = 15;
                break;
              }
              _context13.t1 = [];
            case 15:
              _context13.t5 = _context13.t1;
              i2 = new _context13.t0(_context13.t5);
              i2.add(e2);
              _context13.next = 20;
              return this.cache.set(this.manifestKey, { keys: _toConsumableArray(i2) });
            case 20:
            case "end":
              return _context13.stop();
          }
      }, _callee13, this);
    }));
    function add2(_x34) {
      return _add.apply(this, arguments);
    }
    return add2;
  }() }, { key: "remove", value: function() {
    var _remove = _asyncToGenerator(_regeneratorRuntime().mark(function _callee14(e2) {
      var t2, i2;
      return _regeneratorRuntime().wrap(function _callee14$(_context14) {
        while (1)
          switch (_context14.prev = _context14.next) {
            case 0:
              _context14.next = 2;
              return this.cache.get(this.manifestKey);
            case 2:
              t2 = _context14.sent;
              if (!t2) {
                _context14.next = 16;
                break;
              }
              i2 = new Set(t2.keys);
              i2.delete(e2);
              if (!(i2.size > 0)) {
                _context14.next = 12;
                break;
              }
              _context14.next = 9;
              return this.cache.set(this.manifestKey, { keys: _toConsumableArray(i2) });
            case 9:
              _context14.t0 = _context14.sent;
              _context14.next = 15;
              break;
            case 12:
              _context14.next = 14;
              return this.cache.remove(this.manifestKey);
            case 14:
              _context14.t0 = _context14.sent;
            case 15:
              return _context14.abrupt("return", _context14.t0);
            case 16:
            case "end":
              return _context14.stop();
          }
      }, _callee14, this);
    }));
    function remove6(_x35) {
      return _remove.apply(this, arguments);
    }
    return remove6;
  }() }, { key: "get", value: function get5() {
    return this.cache.get(this.manifestKey);
  } }, { key: "clear", value: function clear() {
    return this.cache.remove(this.manifestKey);
  } }, { key: "createManifestKeyFrom", value: function createManifestKeyFrom(e2) {
    return "@@auth0spajs@@::".concat(e2);
  } }]);
}();
var $$1 = { memory: function memory() {
  return new P$1().enclosedCache;
}, localstorage: function localstorage() {
  return new z$1();
} };
var q = function q2(e2) {
  return $$1[e2];
};
var Q$1 = function Q$12(t2) {
  var i2 = t2.openUrl, o2 = t2.onRedirect, n2 = e(t2, ["openUrl", "onRedirect"]);
  return Object.assign(Object.assign({}, n2), { openUrl: false === i2 || i2 ? i2 : o2 });
};
var ee = new a();
var te = function() {
  function te2(e2) {
    var _this11 = this;
    _classCallCheck2(this, te2);
    var t2, i2;
    if (this.userCache = new P$1().enclosedCache, this.defaultOptions = { authorizationParams: { scope: "openid profile email" }, useRefreshTokensFallback: false, useFormData: true }, this._releaseLockOnPageHide = _asyncToGenerator(_regeneratorRuntime().mark(function _callee15() {
      return _regeneratorRuntime().wrap(function _callee15$(_context15) {
        while (1)
          switch (_context15.prev = _context15.next) {
            case 0:
              _context15.next = 2;
              return ee.releaseLock("auth0.lock.getTokenSilently");
            case 2:
              window.removeEventListener("pagehide", _this11._releaseLockOnPageHide);
            case 3:
            case "end":
              return _context15.stop();
          }
      }, _callee15);
    })), this.options = Object.assign(Object.assign(Object.assign({}, this.defaultOptions), e2), { authorizationParams: Object.assign(Object.assign({}, this.defaultOptions.authorizationParams), e2.authorizationParams) }), "undefined" != typeof window && function() {
      if (!w$1())
        throw new Error("For security reasons, `window.crypto` is required to run `auth0-spa-js`.");
      if (void 0 === w$1().subtle)
        throw new Error("\n      auth0-spa-js must run on a secure origin. See https://github.com/auth0/auth0-spa-js/blob/main/FAQ.md#why-do-i-get-auth0-spa-js-must-run-on-a-secure-origin for more information.\n    ");
    }(), e2.cache && e2.cacheLocation && console.warn("Both `cache` and `cacheLocation` options have been specified in the Auth0Client configuration; ignoring `cacheLocation` and using `cache`."), e2.cache)
      i2 = e2.cache;
    else {
      if (t2 = e2.cacheLocation || "memory", !q(t2))
        throw new Error('Invalid cache location "'.concat(t2, '"'));
      i2 = q(t2)();
    }
    this.httpTimeoutMs = e2.httpTimeoutInSeconds ? 1e3 * e2.httpTimeoutInSeconds : 1e4, this.cookieStorage = false === e2.legacySameSiteCookie ? X$3 : N$1, this.orgHintCookieName = "auth0.".concat(this.options.clientId, ".organization_hint"), this.isAuthenticatedCookieName = function(e3) {
      return "auth0.".concat(e3, ".is.authenticated");
    }(this.options.clientId), this.sessionCheckExpiryDays = e2.sessionCheckExpiryDays || 1;
    var o2 = e2.useCookiesForTransactions ? this.cookieStorage : J;
    var n2;
    this.scope = j("openid", this.options.authorizationParams.scope, this.options.useRefreshTokens ? "offline_access" : ""), this.transactionManager = new Z$3(o2, this.options.clientId, this.options.cookieDomain), this.nowProvider = this.options.nowProvider || c, this.cacheManager = new x$1(i2, i2.allKeys ? void 0 : new B$1(i2, this.options.clientId), this.nowProvider), this.domainUrl = (n2 = this.options.domain, /^https?:\/\//.test(n2) ? n2 : "https://".concat(n2)), this.tokenIssuer = function(e3, t3) {
      return e3 ? e3.startsWith("https://") ? e3 : "https://".concat(e3, "/") : "".concat(t3, "/");
    }(this.options.issuer, this.domainUrl), "undefined" != typeof window && window.Worker && this.options.useRefreshTokens && "memory" === t2 && (this.options.workerUrl ? this.worker = new Worker(this.options.workerUrl) : this.worker = new M$3());
  }
  return _createClass(te2, [{ key: "_url", value: function _url(e2) {
    var t2 = encodeURIComponent(btoa(JSON.stringify(this.options.auth0Client || s$3)));
    return "".concat(this.domainUrl).concat(e2, "&auth0Client=").concat(t2);
  } }, { key: "_authorizeUrl", value: function _authorizeUrl(e2) {
    return this._url("/authorize?".concat(v$1(e2)));
  } }, { key: "_verifyIdToken", value: function() {
    var _verifyIdToken2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee16(e2, t2, i2) {
      var o2, n2;
      return _regeneratorRuntime().wrap(function _callee16$(_context16) {
        while (1)
          switch (_context16.prev = _context16.next) {
            case 0:
              _context16.next = 2;
              return this.nowProvider();
            case 2:
              o2 = _context16.sent;
              return _context16.abrupt("return", E$1({ iss: this.tokenIssuer, aud: this.options.clientId, id_token: e2, nonce: t2, organization: i2, leeway: this.options.leeway, max_age: (n2 = this.options.authorizationParams.max_age, "string" != typeof n2 ? n2 : parseInt(n2, 10) || void 0), now: o2 }));
            case 4:
            case "end":
              return _context16.stop();
          }
      }, _callee16, this);
    }));
    function _verifyIdToken(_x36, _x37, _x38) {
      return _verifyIdToken2.apply(this, arguments);
    }
    return _verifyIdToken;
  }() }, { key: "_processOrgHint", value: function _processOrgHint(e2) {
    e2 ? this.cookieStorage.save(this.orgHintCookieName, e2, { daysUntilExpire: this.sessionCheckExpiryDays, cookieDomain: this.options.cookieDomain }) : this.cookieStorage.remove(this.orgHintCookieName, { cookieDomain: this.options.cookieDomain });
  } }, { key: "_prepareAuthorizeUrl", value: function() {
    var _prepareAuthorizeUrl2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee18(e2, t2, i2) {
      var o2, n2, a2, r2, s2, c3;
      return _regeneratorRuntime().wrap(function _callee18$(_context18) {
        while (1)
          switch (_context18.prev = _context18.next) {
            case 0:
              o2 = k(y());
              n2 = k(y());
              a2 = y();
              _context18.t0 = function(e3) {
                var t3 = new Uint8Array(e3);
                return function(e4) {
                  var t4 = { "+": "-", "/": "_", "=": "" };
                  return e4.replace(/[+/=]/g, function(e5) {
                    return t4[e5];
                  });
                }(window.btoa(String.fromCharCode.apply(String, _toConsumableArray(Array.from(t3)))));
              };
              _context18.next = 6;
              return function() {
                var _ref10 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee17(e3) {
                  var t3;
                  return _regeneratorRuntime().wrap(function _callee17$(_context17) {
                    while (1)
                      switch (_context17.prev = _context17.next) {
                        case 0:
                          t3 = w$1().subtle.digest({ name: "SHA-256" }, new TextEncoder().encode(e3));
                          _context17.next = 3;
                          return t3;
                        case 3:
                          return _context17.abrupt("return", _context17.sent);
                        case 4:
                        case "end":
                          return _context17.stop();
                      }
                  }, _callee17);
                }));
                return function(_x42) {
                  return _ref10.apply(this, arguments);
                };
              }()(a2);
            case 6:
              _context18.t1 = _context18.sent;
              r2 = (0, _context18.t0)(_context18.t1);
              s2 = function(e3, t3, i3, o3, n3, a3, r3, s3) {
                return Object.assign(Object.assign(Object.assign({ client_id: e3.clientId }, e3.authorizationParams), i3), { scope: j(t3, i3.scope), response_type: "code", response_mode: s3 || "query", state: o3, nonce: n3, redirect_uri: r3 || e3.authorizationParams.redirect_uri, code_challenge: a3, code_challenge_method: "S256" });
              }(this.options, this.scope, e2, o2, n2, r2, e2.redirect_uri || this.options.authorizationParams.redirect_uri || i2, null == t2 ? void 0 : t2.response_mode);
              c3 = this._authorizeUrl(s2);
              return _context18.abrupt("return", { nonce: n2, code_verifier: a2, scope: s2.scope, audience: s2.audience || "default", redirect_uri: s2.redirect_uri, state: o2, url: c3 });
            case 11:
            case "end":
              return _context18.stop();
          }
      }, _callee18, this);
    }));
    function _prepareAuthorizeUrl(_x39, _x40, _x41) {
      return _prepareAuthorizeUrl2.apply(this, arguments);
    }
    return _prepareAuthorizeUrl;
  }() }, { key: "loginWithPopup", value: function() {
    var _loginWithPopup = _asyncToGenerator(_regeneratorRuntime().mark(function _callee19(e2, t2) {
      var i2, o2, n2, a2;
      return _regeneratorRuntime().wrap(function _callee19$(_context19) {
        while (1)
          switch (_context19.prev = _context19.next) {
            case 0:
              if (!(e2 = e2 || {}, !(t2 = t2 || {}).popup && (t2.popup = function(e3) {
                var t3 = window.screenX + (window.innerWidth - 400) / 2, i3 = window.screenY + (window.innerHeight - 600) / 2;
                return window.open(e3, "auth0:authorize:popup", "left=".concat(t3, ",top=").concat(i3, ",width=400,height=600,resizable,scrollbars=yes,status=1"));
              }(""), !t2.popup))) {
                _context19.next = 2;
                break;
              }
              throw new Error("Unable to open a popup for loginWithPopup - window.open returned `null`");
            case 2:
              _context19.next = 4;
              return this._prepareAuthorizeUrl(e2.authorizationParams || {}, { response_mode: "web_message" }, window.location.origin);
            case 4:
              o2 = _context19.sent;
              t2.popup.location.href = o2.url;
              _context19.next = 8;
              return function(e3) {
                return new Promise(function(t3, i3) {
                  var _o;
                  var n3 = setInterval(function() {
                    e3.popup && e3.popup.closed && (clearInterval(n3), clearTimeout(a3), window.removeEventListener("message", _o, false), i3(new p(e3.popup)));
                  }, 1e3), a3 = setTimeout(function() {
                    clearInterval(n3), i3(new h(e3.popup)), window.removeEventListener("message", _o, false);
                  }, 1e3 * (e3.timeoutInSeconds || 60));
                  _o = function o3(r2) {
                    if (r2.data && "authorization_response" === r2.data.type) {
                      if (clearTimeout(a3), clearInterval(n3), window.removeEventListener("message", _o, false), e3.popup.close(), r2.data.response.error)
                        return i3(d.fromPayload(r2.data.response));
                      t3(r2.data.response);
                    }
                  }, window.addEventListener("message", _o);
                });
              }(Object.assign(Object.assign({}, t2), { timeoutInSeconds: t2.timeoutInSeconds || this.options.authorizeTimeoutInSeconds || 60 }));
            case 8:
              n2 = _context19.sent;
              if (!(o2.state !== n2.state)) {
                _context19.next = 11;
                break;
              }
              throw new d("state_mismatch", "Invalid state");
            case 11:
              a2 = (null === (i2 = e2.authorizationParams) || void 0 === i2 ? void 0 : i2.organization) || this.options.authorizationParams.organization;
              _context19.next = 14;
              return this._requestToken({ audience: o2.audience, scope: o2.scope, code_verifier: o2.code_verifier, grant_type: "authorization_code", code: n2.code, redirect_uri: o2.redirect_uri }, { nonceIn: o2.nonce, organization: a2 });
            case 14:
            case "end":
              return _context19.stop();
          }
      }, _callee19, this);
    }));
    function loginWithPopup(_x43, _x44) {
      return _loginWithPopup.apply(this, arguments);
    }
    return loginWithPopup;
  }() }, { key: "getUser", value: function() {
    var _getUser = _asyncToGenerator(_regeneratorRuntime().mark(function _callee20() {
      var e2, t2;
      return _regeneratorRuntime().wrap(function _callee20$(_context20) {
        while (1)
          switch (_context20.prev = _context20.next) {
            case 0:
              _context20.next = 2;
              return this._getIdTokenFromCache();
            case 2:
              t2 = _context20.sent;
              return _context20.abrupt("return", null === (e2 = null == t2 ? void 0 : t2.decodedToken) || void 0 === e2 ? void 0 : e2.user);
            case 4:
            case "end":
              return _context20.stop();
          }
      }, _callee20, this);
    }));
    function getUser() {
      return _getUser.apply(this, arguments);
    }
    return getUser;
  }() }, { key: "getIdTokenClaims", value: function() {
    var _getIdTokenClaims = _asyncToGenerator(_regeneratorRuntime().mark(function _callee21() {
      var e2, t2;
      return _regeneratorRuntime().wrap(function _callee21$(_context21) {
        while (1)
          switch (_context21.prev = _context21.next) {
            case 0:
              _context21.next = 2;
              return this._getIdTokenFromCache();
            case 2:
              t2 = _context21.sent;
              return _context21.abrupt("return", null === (e2 = null == t2 ? void 0 : t2.decodedToken) || void 0 === e2 ? void 0 : e2.claims);
            case 4:
            case "end":
              return _context21.stop();
          }
      }, _callee21, this);
    }));
    function getIdTokenClaims() {
      return _getIdTokenClaims.apply(this, arguments);
    }
    return getIdTokenClaims;
  }() }, { key: "loginWithRedirect", value: function() {
    var _loginWithRedirect = _asyncToGenerator(_regeneratorRuntime().mark(function _callee22() {
      var t2, i2, o2, n2, a2, r2, s2, c3, d2, u2, l2, h2, _args22 = arguments;
      return _regeneratorRuntime().wrap(function _callee22$(_context22) {
        while (1)
          switch (_context22.prev = _context22.next) {
            case 0:
              t2 = _args22.length > 0 && _args22[0] !== void 0 ? _args22[0] : {};
              o2 = Q$1(t2);
              n2 = o2.openUrl;
              a2 = o2.fragment;
              r2 = o2.appState;
              s2 = e(o2, ["openUrl", "fragment", "appState"]);
              c3 = (null === (i2 = s2.authorizationParams) || void 0 === i2 ? void 0 : i2.organization) || this.options.authorizationParams.organization;
              _context22.next = 9;
              return this._prepareAuthorizeUrl(s2.authorizationParams || {});
            case 9:
              d2 = _context22.sent;
              u2 = d2.url;
              l2 = e(d2, ["url"]);
              this.transactionManager.create(Object.assign(Object.assign(Object.assign({}, l2), { appState: r2 }), c3 && { organization: c3 }));
              h2 = a2 ? "".concat(u2, "#").concat(a2) : u2;
              if (!n2) {
                _context22.next = 19;
                break;
              }
              _context22.next = 17;
              return n2(h2);
            case 17:
              _context22.next = 20;
              break;
            case 19:
              window.location.assign(h2);
            case 20:
            case "end":
              return _context22.stop();
          }
      }, _callee22, this);
    }));
    function loginWithRedirect() {
      return _loginWithRedirect.apply(this, arguments);
    }
    return loginWithRedirect;
  }() }, { key: "handleRedirectCallback", value: function() {
    var _handleRedirectCallback = _asyncToGenerator(_regeneratorRuntime().mark(function _callee23() {
      var e2, t2, _ref11, i2, o2, n2, a2, r2, s2, c3, l2, _args23 = arguments;
      return _regeneratorRuntime().wrap(function _callee23$(_context23) {
        while (1)
          switch (_context23.prev = _context23.next) {
            case 0:
              e2 = _args23.length > 0 && _args23[0] !== void 0 ? _args23[0] : window.location.href;
              t2 = e2.split("?").slice(1);
              if (!(0 === t2.length)) {
                _context23.next = 4;
                break;
              }
              throw new Error("There are no query params available for parsing.");
            case 4:
              _ref11 = function(e3) {
                e3.indexOf("#") > -1 && (e3 = e3.substring(0, e3.indexOf("#")));
                var t3 = new URLSearchParams(e3);
                return { state: t3.get("state"), code: t3.get("code") || void 0, error: t3.get("error") || void 0, error_description: t3.get("error_description") || void 0 };
              }(t2.join("")), i2 = _ref11.state, o2 = _ref11.code, n2 = _ref11.error, a2 = _ref11.error_description, r2 = this.transactionManager.get();
              if (r2) {
                _context23.next = 7;
                break;
              }
              throw new d("missing_transaction", "Invalid state");
            case 7:
              if (!(this.transactionManager.remove(), n2)) {
                _context23.next = 9;
                break;
              }
              throw new u(n2, a2 || n2, i2, r2.appState);
            case 9:
              if (!(!r2.code_verifier || r2.state && r2.state !== i2)) {
                _context23.next = 11;
                break;
              }
              throw new d("state_mismatch", "Invalid state");
            case 11:
              s2 = r2.organization, c3 = r2.nonce, l2 = r2.redirect_uri;
              _context23.next = 14;
              return this._requestToken(Object.assign({ audience: r2.audience, scope: r2.scope, code_verifier: r2.code_verifier, grant_type: "authorization_code", code: o2 }, l2 ? { redirect_uri: l2 } : {}), { nonceIn: c3, organization: s2 });
            case 14:
              return _context23.abrupt("return", { appState: r2.appState });
            case 15:
            case "end":
              return _context23.stop();
          }
      }, _callee23, this);
    }));
    function handleRedirectCallback() {
      return _handleRedirectCallback.apply(this, arguments);
    }
    return handleRedirectCallback;
  }() }, { key: "checkSession", value: function() {
    var _checkSession = _asyncToGenerator(_regeneratorRuntime().mark(function _callee24(e2) {
      return _regeneratorRuntime().wrap(function _callee24$(_context24) {
        while (1)
          switch (_context24.prev = _context24.next) {
            case 0:
              if (this.cookieStorage.get(this.isAuthenticatedCookieName)) {
                _context24.next = 4;
                break;
              }
              if (this.cookieStorage.get("auth0.is.authenticated")) {
                _context24.next = 3;
                break;
              }
              return _context24.abrupt("return");
            case 3:
              this.cookieStorage.save(this.isAuthenticatedCookieName, true, { daysUntilExpire: this.sessionCheckExpiryDays, cookieDomain: this.options.cookieDomain }), this.cookieStorage.remove("auth0.is.authenticated");
            case 4:
              _context24.prev = 4;
              _context24.next = 7;
              return this.getTokenSilently(e2);
            case 7:
              _context24.next = 11;
              break;
            case 9:
              _context24.prev = 9;
              _context24.t0 = _context24["catch"](4);
            case 11:
            case "end":
              return _context24.stop();
          }
      }, _callee24, this, [[4, 9]]);
    }));
    function checkSession(_x45) {
      return _checkSession.apply(this, arguments);
    }
    return checkSession;
  }() }, { key: "getTokenSilently", value: function() {
    var _getTokenSilently2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee25() {
      var _this12 = this;
      var e2, t2, i2, o2, _args25 = arguments;
      return _regeneratorRuntime().wrap(function _callee25$(_context25) {
        while (1)
          switch (_context25.prev = _context25.next) {
            case 0:
              e2 = _args25.length > 0 && _args25[0] !== void 0 ? _args25[0] : {};
              i2 = Object.assign(Object.assign({ cacheMode: "on" }, e2), { authorizationParams: Object.assign(Object.assign(Object.assign({}, this.options.authorizationParams), e2.authorizationParams), { scope: j(this.scope, null === (t2 = e2.authorizationParams) || void 0 === t2 ? void 0 : t2.scope) }) });
              _context25.next = 4;
              return function(e3, t3) {
                var i3 = A$2[t3];
                return i3 || (i3 = e3().finally(function() {
                  delete A$2[t3], i3 = null;
                }), A$2[t3] = i3), i3;
              }(function() {
                return _this12._getTokenSilently(i2);
              }, "".concat(this.options.clientId, "::").concat(i2.authorizationParams.audience, "::").concat(i2.authorizationParams.scope));
            case 4:
              o2 = _context25.sent;
              return _context25.abrupt("return", e2.detailedResponse ? o2 : null == o2 ? void 0 : o2.access_token);
            case 6:
            case "end":
              return _context25.stop();
          }
      }, _callee25, this);
    }));
    function getTokenSilently() {
      return _getTokenSilently2.apply(this, arguments);
    }
    return getTokenSilently;
  }() }, { key: "_getTokenSilently", value: function() {
    var _getTokenSilently3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee27(t2) {
      var i2, o2, _e4, _e5, _e6, _t5, n2, _a2, _r2;
      return _regeneratorRuntime().wrap(function _callee27$(_context27) {
        while (1)
          switch (_context27.prev = _context27.next) {
            case 0:
              i2 = t2.cacheMode, o2 = e(t2, ["cacheMode"]);
              if (!("off" !== i2)) {
                _context27.next = 7;
                break;
              }
              _context27.next = 4;
              return this._getEntryFromCache({ scope: o2.authorizationParams.scope, audience: o2.authorizationParams.audience || "default", clientId: this.options.clientId });
            case 4:
              _e4 = _context27.sent;
              if (!_e4) {
                _context27.next = 7;
                break;
              }
              return _context27.abrupt("return", _e4);
            case 7:
              if (!("cache-only" !== i2)) {
                _context27.next = 39;
                break;
              }
              _context27.next = 10;
              return function() {
                var _ref12 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee26(e2) {
                  var t3, _i3, _args26 = arguments;
                  return _regeneratorRuntime().wrap(function _callee26$(_context26) {
                    while (1)
                      switch (_context26.prev = _context26.next) {
                        case 0:
                          t3 = _args26.length > 1 && _args26[1] !== void 0 ? _args26[1] : 3;
                          _i3 = 0;
                        case 2:
                          if (!(_i3 < t3)) {
                            _context26.next = 10;
                            break;
                          }
                          _context26.next = 5;
                          return e2();
                        case 5:
                          if (!_context26.sent) {
                            _context26.next = 7;
                            break;
                          }
                          return _context26.abrupt("return", true);
                        case 7:
                          _i3++;
                          _context26.next = 2;
                          break;
                        case 10:
                          return _context26.abrupt("return", false);
                        case 11:
                        case "end":
                          return _context26.stop();
                      }
                  }, _callee26);
                }));
                return function(_x47) {
                  return _ref12.apply(this, arguments);
                };
              }()(function() {
                return ee.acquireLock("auth0.lock.getTokenSilently", 5e3);
              }, 10);
            case 10:
              if (_context27.sent) {
                _context27.next = 12;
                break;
              }
              throw new l();
            case 12:
              _context27.prev = 12;
              if (!(window.addEventListener("pagehide", this._releaseLockOnPageHide), "off" !== i2)) {
                _context27.next = 19;
                break;
              }
              _context27.next = 16;
              return this._getEntryFromCache({ scope: o2.authorizationParams.scope, audience: o2.authorizationParams.audience || "default", clientId: this.options.clientId });
            case 16:
              _e5 = _context27.sent;
              if (!_e5) {
                _context27.next = 19;
                break;
              }
              return _context27.abrupt("return", _e5);
            case 19:
              if (!this.options.useRefreshTokens) {
                _context27.next = 25;
                break;
              }
              _context27.next = 22;
              return this._getTokenUsingRefreshToken(o2);
            case 22:
              _context27.t0 = _context27.sent;
              _context27.next = 28;
              break;
            case 25:
              _context27.next = 27;
              return this._getTokenFromIFrame(o2);
            case 27:
              _context27.t0 = _context27.sent;
            case 28:
              _e6 = _context27.t0;
              _t5 = _e6.id_token;
              n2 = _e6.access_token;
              _a2 = _e6.oauthTokenScope;
              _r2 = _e6.expires_in;
              return _context27.abrupt("return", Object.assign(Object.assign({ id_token: _t5, access_token: n2 }, _a2 ? { scope: _a2 } : null), { expires_in: _r2 }));
            case 34:
              _context27.prev = 34;
              _context27.next = 37;
              return ee.releaseLock("auth0.lock.getTokenSilently");
            case 37:
              window.removeEventListener("pagehide", this._releaseLockOnPageHide);
              return _context27.finish(34);
            case 39:
            case "end":
              return _context27.stop();
          }
      }, _callee27, this, [[12, , 34, 39]]);
    }));
    function _getTokenSilently(_x46) {
      return _getTokenSilently3.apply(this, arguments);
    }
    return _getTokenSilently;
  }() }, { key: "getTokenWithPopup", value: function() {
    var _getTokenWithPopup = _asyncToGenerator(_regeneratorRuntime().mark(function _callee28() {
      var e2, t2, i2, o2, _args28 = arguments;
      return _regeneratorRuntime().wrap(function _callee28$(_context28) {
        while (1)
          switch (_context28.prev = _context28.next) {
            case 0:
              e2 = _args28.length > 0 && _args28[0] !== void 0 ? _args28[0] : {};
              t2 = _args28.length > 1 && _args28[1] !== void 0 ? _args28[1] : {};
              o2 = Object.assign(Object.assign({}, e2), { authorizationParams: Object.assign(Object.assign(Object.assign({}, this.options.authorizationParams), e2.authorizationParams), { scope: j(this.scope, null === (i2 = e2.authorizationParams) || void 0 === i2 ? void 0 : i2.scope) }) });
              t2 = Object.assign(Object.assign({}, r$1), t2);
              _context28.next = 6;
              return this.loginWithPopup(o2, t2);
            case 6:
              _context28.next = 8;
              return this.cacheManager.get(new C$1({ scope: o2.authorizationParams.scope, audience: o2.authorizationParams.audience || "default", clientId: this.options.clientId }));
            case 8:
              return _context28.abrupt("return", _context28.sent.access_token);
            case 9:
            case "end":
              return _context28.stop();
          }
      }, _callee28, this);
    }));
    function getTokenWithPopup() {
      return _getTokenWithPopup.apply(this, arguments);
    }
    return getTokenWithPopup;
  }() }, { key: "isAuthenticated", value: function() {
    var _isAuthenticated = _asyncToGenerator(_regeneratorRuntime().mark(function _callee29() {
      return _regeneratorRuntime().wrap(function _callee29$(_context29) {
        while (1)
          switch (_context29.prev = _context29.next) {
            case 0:
              _context29.next = 2;
              return this.getUser();
            case 2:
              return _context29.abrupt("return", !!_context29.sent);
            case 3:
            case "end":
              return _context29.stop();
          }
      }, _callee29, this);
    }));
    function isAuthenticated() {
      return _isAuthenticated.apply(this, arguments);
    }
    return isAuthenticated;
  }() }, { key: "_buildLogoutUrl", value: function _buildLogoutUrl(t2) {
    null !== t2.clientId ? t2.clientId = t2.clientId || this.options.clientId : delete t2.clientId;
    var i2 = t2.logoutParams || {}, o2 = i2.federated, n2 = e(i2, ["federated"]), a2 = o2 ? "&federated" : "";
    return this._url("/v2/logout?".concat(v$1(Object.assign({ clientId: t2.clientId }, n2)))) + a2;
  } }, { key: "logout", value: function() {
    var _logout = _asyncToGenerator(_regeneratorRuntime().mark(function _callee30() {
      var t2, i2, o2, n2, a2, _args30 = arguments;
      return _regeneratorRuntime().wrap(function _callee30$(_context30) {
        while (1)
          switch (_context30.prev = _context30.next) {
            case 0:
              t2 = _args30.length > 0 && _args30[0] !== void 0 ? _args30[0] : {};
              i2 = Q$1(t2), o2 = i2.openUrl, n2 = e(i2, ["openUrl"]);
              if (!(null === t2.clientId)) {
                _context30.next = 7;
                break;
              }
              _context30.next = 5;
              return this.cacheManager.clear();
            case 5:
              _context30.next = 9;
              break;
            case 7:
              _context30.next = 9;
              return this.cacheManager.clear(t2.clientId || this.options.clientId);
            case 9:
              this.cookieStorage.remove(this.orgHintCookieName, { cookieDomain: this.options.cookieDomain });
              this.cookieStorage.remove(this.isAuthenticatedCookieName, { cookieDomain: this.options.cookieDomain });
              this.userCache.remove("@@user@@");
              a2 = this._buildLogoutUrl(n2);
              if (!o2) {
                _context30.next = 18;
                break;
              }
              _context30.next = 16;
              return o2(a2);
            case 16:
              _context30.next = 19;
              break;
            case 18:
              false !== o2 && window.location.assign(a2);
            case 19:
            case "end":
              return _context30.stop();
          }
      }, _callee30, this);
    }));
    function logout() {
      return _logout.apply(this, arguments);
    }
    return logout;
  }() }, { key: "_getTokenFromIFrame", value: function() {
    var _getTokenFromIFrame2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee31(e2) {
      var t2, i2, _yield$this$_prepareA, o2, n2, a2, r2, s2, c3, u2, _i4, _h2, _p;
      return _regeneratorRuntime().wrap(function _callee31$(_context31) {
        while (1)
          switch (_context31.prev = _context31.next) {
            case 0:
              t2 = Object.assign(Object.assign({}, e2.authorizationParams), { prompt: "none" }), i2 = this.cookieStorage.get(this.orgHintCookieName);
              i2 && !t2.organization && (t2.organization = i2);
              _context31.next = 4;
              return this._prepareAuthorizeUrl(t2, { response_mode: "web_message" }, window.location.origin);
            case 4:
              _yield$this$_prepareA = _context31.sent;
              o2 = _yield$this$_prepareA.url;
              n2 = _yield$this$_prepareA.state;
              a2 = _yield$this$_prepareA.nonce;
              r2 = _yield$this$_prepareA.code_verifier;
              s2 = _yield$this$_prepareA.redirect_uri;
              c3 = _yield$this$_prepareA.scope;
              u2 = _yield$this$_prepareA.audience;
              _context31.prev = 12;
              if (!window.crossOriginIsolated) {
                _context31.next = 15;
                break;
              }
              throw new d("login_required", "The application is running in a Cross-Origin Isolated context, silently retrieving a token without refresh token is not possible.");
            case 15:
              _i4 = e2.timeoutInSeconds || this.options.authorizeTimeoutInSeconds;
              _context31.next = 18;
              return function(e3, t3) {
                var i3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 60;
                return new Promise(function(o3, n3) {
                  var a3 = window.document.createElement("iframe");
                  a3.setAttribute("width", "0"), a3.setAttribute("height", "0"), a3.style.display = "none";
                  var r3 = function r4() {
                    window.document.body.contains(a3) && (window.document.body.removeChild(a3), window.removeEventListener("message", _s, false));
                  };
                  var _s;
                  var c4 = setTimeout(function() {
                    n3(new l()), r3();
                  }, 1e3 * i3);
                  _s = function s3(e4) {
                    if (e4.origin != t3)
                      return;
                    if (!e4.data || "authorization_response" !== e4.data.type)
                      return;
                    var i4 = e4.source;
                    i4 && i4.close(), e4.data.response.error ? n3(d.fromPayload(e4.data.response)) : o3(e4.data.response), clearTimeout(c4), window.removeEventListener("message", _s, false), setTimeout(r3, 2e3);
                  }, window.addEventListener("message", _s, false), window.document.body.appendChild(a3), a3.setAttribute("src", e3);
                });
              }(o2, this.domainUrl, _i4);
            case 18:
              _h2 = _context31.sent;
              if (!(n2 !== _h2.state)) {
                _context31.next = 21;
                break;
              }
              throw new d("state_mismatch", "Invalid state");
            case 21:
              _context31.next = 23;
              return this._requestToken(Object.assign(Object.assign({}, e2.authorizationParams), { code_verifier: r2, code: _h2.code, grant_type: "authorization_code", redirect_uri: s2, timeout: e2.authorizationParams.timeout || this.httpTimeoutMs }), { nonceIn: a2, organization: t2.organization });
            case 23:
              _p = _context31.sent;
              return _context31.abrupt("return", Object.assign(Object.assign({}, _p), { scope: c3, oauthTokenScope: _p.scope, audience: u2 }));
            case 27:
              _context31.prev = 27;
              _context31.t0 = _context31["catch"](12);
              throw "login_required" === _context31.t0.error && this.logout({ openUrl: false }), _context31.t0;
            case 30:
            case "end":
              return _context31.stop();
          }
      }, _callee31, this, [[12, 27]]);
    }));
    function _getTokenFromIFrame(_x48) {
      return _getTokenFromIFrame2.apply(this, arguments);
    }
    return _getTokenFromIFrame;
  }() }, { key: "_getTokenUsingRefreshToken", value: function() {
    var _getTokenUsingRefreshToken2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee32(e2) {
      var t2, i2, o2, n2;
      return _regeneratorRuntime().wrap(function _callee32$(_context32) {
        while (1)
          switch (_context32.prev = _context32.next) {
            case 0:
              _context32.next = 2;
              return this.cacheManager.get(new C$1({ scope: e2.authorizationParams.scope, audience: e2.authorizationParams.audience || "default", clientId: this.options.clientId }));
            case 2:
              t2 = _context32.sent;
              if (t2 && t2.refresh_token || this.worker) {
                _context32.next = 9;
                break;
              }
              if (!this.options.useRefreshTokensFallback) {
                _context32.next = 8;
                break;
              }
              _context32.next = 7;
              return this._getTokenFromIFrame(e2);
            case 7:
              return _context32.abrupt("return", _context32.sent);
            case 8:
              throw new f$1(e2.authorizationParams.audience || "default", e2.authorizationParams.scope);
            case 9:
              i2 = e2.authorizationParams.redirect_uri || this.options.authorizationParams.redirect_uri || window.location.origin, o2 = "number" == typeof e2.timeoutInSeconds ? 1e3 * e2.timeoutInSeconds : null;
              _context32.prev = 10;
              _context32.next = 13;
              return this._requestToken(Object.assign(Object.assign(Object.assign({}, e2.authorizationParams), { grant_type: "refresh_token", refresh_token: t2 && t2.refresh_token, redirect_uri: i2 }), o2 && { timeout: o2 }));
            case 13:
              n2 = _context32.sent;
              return _context32.abrupt("return", Object.assign(Object.assign({}, n2), { scope: e2.authorizationParams.scope, oauthTokenScope: n2.scope, audience: e2.authorizationParams.audience || "default" }));
            case 17:
              _context32.prev = 17;
              _context32.t0 = _context32["catch"](10);
              if (!((_context32.t0.message.indexOf("Missing Refresh Token") > -1 || _context32.t0.message && _context32.t0.message.indexOf("invalid refresh token") > -1) && this.options.useRefreshTokensFallback)) {
                _context32.next = 23;
                break;
              }
              _context32.next = 22;
              return this._getTokenFromIFrame(e2);
            case 22:
              return _context32.abrupt("return", _context32.sent);
            case 23:
              throw _context32.t0;
            case 24:
            case "end":
              return _context32.stop();
          }
      }, _callee32, this, [[10, 17]]);
    }));
    function _getTokenUsingRefreshToken(_x49) {
      return _getTokenUsingRefreshToken2.apply(this, arguments);
    }
    return _getTokenUsingRefreshToken;
  }() }, { key: "_saveEntryInCache", value: function() {
    var _saveEntryInCache2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee33(t2) {
      var i2, o2, n2;
      return _regeneratorRuntime().wrap(function _callee33$(_context33) {
        while (1)
          switch (_context33.prev = _context33.next) {
            case 0:
              i2 = t2.id_token, o2 = t2.decodedToken, n2 = e(t2, ["id_token", "decodedToken"]);
              this.userCache.set("@@user@@", { id_token: i2, decodedToken: o2 });
              _context33.next = 4;
              return this.cacheManager.setIdToken(this.options.clientId, t2.id_token, t2.decodedToken);
            case 4:
              _context33.next = 6;
              return this.cacheManager.set(n2);
            case 6:
            case "end":
              return _context33.stop();
          }
      }, _callee33, this);
    }));
    function _saveEntryInCache(_x50) {
      return _saveEntryInCache2.apply(this, arguments);
    }
    return _saveEntryInCache;
  }() }, { key: "_getIdTokenFromCache", value: function() {
    var _getIdTokenFromCache2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee34() {
      var e2, t2, i2;
      return _regeneratorRuntime().wrap(function _callee34$(_context34) {
        while (1)
          switch (_context34.prev = _context34.next) {
            case 0:
              e2 = this.options.authorizationParams.audience || "default";
              _context34.next = 3;
              return this.cacheManager.getIdToken(new C$1({ clientId: this.options.clientId, audience: e2, scope: this.scope }));
            case 3:
              t2 = _context34.sent;
              i2 = this.userCache.get("@@user@@");
              return _context34.abrupt("return", t2 && t2.id_token === (null == i2 ? void 0 : i2.id_token) ? i2 : (this.userCache.set("@@user@@", t2), t2));
            case 6:
            case "end":
              return _context34.stop();
          }
      }, _callee34, this);
    }));
    function _getIdTokenFromCache() {
      return _getIdTokenFromCache2.apply(this, arguments);
    }
    return _getIdTokenFromCache;
  }() }, { key: "_getEntryFromCache", value: function() {
    var _getEntryFromCache2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee35(_ref13) {
      var e2, t2, i2, o2, _e7, _t6, _i5, n2;
      return _regeneratorRuntime().wrap(function _callee35$(_context35) {
        while (1)
          switch (_context35.prev = _context35.next) {
            case 0:
              e2 = _ref13.scope, t2 = _ref13.audience, i2 = _ref13.clientId;
              _context35.next = 3;
              return this.cacheManager.get(new C$1({ scope: e2, audience: t2, clientId: i2 }), 60);
            case 3:
              o2 = _context35.sent;
              if (!(o2 && o2.access_token)) {
                _context35.next = 12;
                break;
              }
              _e7 = o2.access_token;
              _t6 = o2.oauthTokenScope;
              _i5 = o2.expires_in;
              _context35.next = 10;
              return this._getIdTokenFromCache();
            case 10:
              n2 = _context35.sent;
              return _context35.abrupt("return", n2 && Object.assign(Object.assign({ id_token: n2.id_token, access_token: _e7 }, _t6 ? { scope: _t6 } : null), { expires_in: _i5 }));
            case 12:
            case "end":
              return _context35.stop();
          }
      }, _callee35, this);
    }));
    function _getEntryFromCache(_x51) {
      return _getEntryFromCache2.apply(this, arguments);
    }
    return _getEntryFromCache;
  }() }, { key: "_requestToken", value: function() {
    var _requestToken2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee36(e2, t2) {
      var _ref14, i2, o2, n2, a2;
      return _regeneratorRuntime().wrap(function _callee36$(_context36) {
        while (1)
          switch (_context36.prev = _context36.next) {
            case 0:
              _ref14 = t2 || {};
              i2 = _ref14.nonceIn;
              o2 = _ref14.organization;
              _context36.next = 5;
              return T$1(Object.assign({ baseUrl: this.domainUrl, client_id: this.options.clientId, auth0Client: this.options.auth0Client, useFormData: this.options.useFormData, timeout: this.httpTimeoutMs }, e2), this.worker);
            case 5:
              n2 = _context36.sent;
              _context36.next = 8;
              return this._verifyIdToken(n2.id_token, i2, o2);
            case 8:
              a2 = _context36.sent;
              _context36.next = 11;
              return this._saveEntryInCache(Object.assign(Object.assign(Object.assign(Object.assign({}, n2), { decodedToken: a2, scope: e2.scope, audience: e2.audience || "default" }), n2.scope ? { oauthTokenScope: n2.scope } : null), { client_id: this.options.clientId }));
            case 11:
              this.cookieStorage.save(this.isAuthenticatedCookieName, true, { daysUntilExpire: this.sessionCheckExpiryDays, cookieDomain: this.options.cookieDomain });
              this._processOrgHint(o2 || a2.claims.org_id);
              return _context36.abrupt("return", Object.assign(Object.assign({}, n2), { decodedToken: a2 }));
            case 14:
            case "end":
              return _context36.stop();
          }
      }, _callee36, this);
    }));
    function _requestToken(_x52, _x53) {
      return _requestToken2.apply(this, arguments);
    }
    return _requestToken;
  }() }]);
}();
function oe(_x54) {
  return _oe.apply(this, arguments);
}
function _oe() {
  _oe = _asyncToGenerator(_regeneratorRuntime().mark(function _callee216(e2) {
    var t2;
    return _regeneratorRuntime().wrap(function _callee216$(_context217) {
      while (1)
        switch (_context217.prev = _context217.next) {
          case 0:
            t2 = new te(e2);
            _context217.next = 3;
            return t2.checkSession();
          case 3:
            return _context217.abrupt("return", t2);
          case 4:
          case "end":
            return _context217.stop();
        }
    }, _callee216);
  }));
  return _oe.apply(this, arguments);
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a2 = function a3() {
      if (this instanceof a3) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else
    a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k3) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k3);
    Object.defineProperty(a2, k3, d2.get ? d2 : { enumerable: true, get: function get5() {
      return n2[k3];
    } });
  });
  return a2;
}
var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var defineProperty = Object.defineProperty;
var gOPD = Object.getOwnPropertyDescriptor;
var isArray$4 = function isArray2(arr) {
  if (typeof Array.isArray === "function") {
    return Array.isArray(arr);
  }
  return toStr.call(arr) === "[object Array]";
};
var isPlainObject$6 = function isPlainObject2(obj2) {
  if (!obj2 || toStr.call(obj2) !== "[object Object]") {
    return false;
  }
  var hasOwnConstructor = hasOwn.call(obj2, "constructor");
  var hasIsPrototypeOf = obj2.constructor && obj2.constructor.prototype && hasOwn.call(obj2.constructor.prototype, "isPrototypeOf");
  if (obj2.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
    return false;
  }
  var key3;
  for (key3 in obj2) {
  }
  return typeof key3 === "undefined" || hasOwn.call(obj2, key3);
};
var setProperty = function setProperty2(target, options) {
  if (defineProperty && options.name === "__proto__") {
    defineProperty(target, options.name, { enumerable: true, configurable: true, value: options.newValue, writable: true });
  } else {
    target[options.name] = options.newValue;
  }
};
var getProperty = function getProperty2(obj2, name2) {
  if (name2 === "__proto__") {
    if (!hasOwn.call(obj2, name2)) {
      return void 0;
    } else if (gOPD) {
      return gOPD(obj2, name2).value;
    }
  }
  return obj2[name2];
};
var extend$1 = function extend2() {
  var options, name2, src2, copy, copyIsArray, clone3;
  var target = arguments[0];
  var i2 = 1;
  var length3 = arguments.length;
  var deep = false;
  if (typeof target === "boolean") {
    deep = target;
    target = arguments[1] || {};
    i2 = 2;
  }
  if (target == null || _typeof(target) !== "object" && typeof target !== "function") {
    target = {};
  }
  for (; i2 < length3; ++i2) {
    options = arguments[i2];
    if (options != null) {
      for (name2 in options) {
        src2 = getProperty(target, name2);
        copy = getProperty(options, name2);
        if (target !== copy) {
          if (deep && copy && (isPlainObject$6(copy) || (copyIsArray = isArray$4(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone3 = src2 && isArray$4(src2) ? src2 : [];
            } else {
              clone3 = src2 && isPlainObject$6(src2) ? src2 : {};
            }
            setProperty(target, { name: name2, newValue: extend2(deep, clone3, copy) });
          } else if (typeof copy !== "undefined") {
            setProperty(target, { name: name2, newValue: copy });
          }
        }
      }
    }
  }
  return target;
};
var extend$2 = getDefaultExportFromCjs(extend$1);
function bind(fn, thisArg) {
  return function wrap2() {
    return fn.apply(thisArg, arguments);
  };
}
var toString$4 = Object.prototype.toString;
var getPrototypeOf = Object.getPrototypeOf;
var kindOf$1 = /* @__PURE__ */ function(cache) {
  return function(thing) {
    var str = toString$4.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
  };
}(/* @__PURE__ */ Object.create(null));
var kindOfTest = function kindOfTest2(type) {
  type = type.toLowerCase();
  return function(thing) {
    return kindOf$1(thing) === type;
  };
};
var typeOfTest = function typeOfTest2(type) {
  return function(thing) {
    return _typeof(thing) === type;
  };
};
var isArray$3 = Array.isArray;
var isUndefined = typeOfTest("undefined");
function isBuffer$3(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction$2(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  var result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction$2 = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject$3 = function isObject$32(thing) {
  return thing !== null && _typeof(thing) === "object";
};
var isBoolean = function isBoolean2(thing) {
  return thing === true || thing === false;
};
var isPlainObject$5 = function isPlainObject$52(val) {
  if (kindOf$1(val) !== "object") {
    return false;
  }
  var prototype2 = getPrototypeOf(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
var isDate$1 = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = function isStream2(val) {
  return isObject$3(val) && isFunction$2(val.pipe);
};
var isFormData = function isFormData2(thing) {
  var kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$2(thing.append) && ((kind = kindOf$1(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction$2(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var _map = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
var _map2 = _slicedToArray(_map, 4);
var isReadableStream = _map2[0];
var isRequest = _map2[1];
var isResponse = _map2[2];
var isHeaders = _map2[3];
var trim = function trim2(str) {
  return str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
};
function forEach$1(obj2, fn) {
  var _ref9 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _ref9$allOwnKeys = _ref9.allOwnKeys, allOwnKeys = _ref9$allOwnKeys === void 0 ? false : _ref9$allOwnKeys;
  if (obj2 === null || typeof obj2 === "undefined") {
    return;
  }
  var i2;
  var l2;
  if (_typeof(obj2) !== "object") {
    obj2 = [obj2];
  }
  if (isArray$3(obj2)) {
    for (i2 = 0, l2 = obj2.length; i2 < l2; i2++) {
      fn.call(null, obj2[i2], i2, obj2);
    }
  } else {
    var _keys = allOwnKeys ? Object.getOwnPropertyNames(obj2) : Object.keys(obj2);
    var _len2 = _keys.length;
    var _key3;
    for (i2 = 0; i2 < _len2; i2++) {
      _key3 = _keys[i2];
      fn.call(null, obj2[_key3], _key3, obj2);
    }
  }
}
function findKey(obj2, key3) {
  key3 = key3.toLowerCase();
  var keys2 = Object.keys(obj2);
  var i2 = keys2.length;
  var _key;
  while (i2-- > 0) {
    _key = keys2[i2];
    if (key3 === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = function() {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
}();
var isContextDefined = function isContextDefined2(context) {
  return !isUndefined(context) && context !== _global;
};
function merge() {
  var _ref15 = isContextDefined(this) && this || {}, caseless = _ref15.caseless;
  var result = {};
  var assignValue = function assignValue2(val, key3) {
    var targetKey = caseless && findKey(result, key3) || key3;
    if (isPlainObject$5(result[targetKey]) && isPlainObject$5(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject$5(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray$3(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (var _i6 = 0, _l3 = arguments.length; _i6 < _l3; _i6++) {
    arguments[_i6] && forEach$1(arguments[_i6], assignValue);
  }
  return result;
}
var extend = function extend3(a2, b3, thisArg) {
  var _ref16 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, allOwnKeys = _ref16.allOwnKeys;
  forEach$1(b3, function(val, key3) {
    if (thisArg && isFunction$2(val)) {
      a2[key3] = bind(val, thisArg);
    } else {
      a2[key3] = val;
    }
  }, { allOwnKeys });
  return a2;
};
var stripBOM = function stripBOM2(content) {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits$7 = function inherits$72(constructor, superConstructor, props, descriptors2) {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", { value: superConstructor.prototype });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = function toFlatObject2(sourceObj, destObj, filter2, propFilter) {
  var props;
  var i2;
  var prop;
  var merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i2 = props.length;
    while (i2-- > 0) {
      prop = props[i2];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = function endsWith2(str, searchString, position) {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  var lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray$1 = function toArray$12(thing) {
  if (!thing)
    return null;
  if (isArray$3(thing))
    return thing;
  var i2 = thing.length;
  if (!isNumber(i2))
    return null;
  var arr = new Array(i2);
  while (i2-- > 0) {
    arr[i2] = thing[i2];
  }
  return arr;
};
var isTypedArray$2 = /* @__PURE__ */ function(TypedArray) {
  return function(thing) {
    return TypedArray && thing instanceof TypedArray;
  };
}(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = function forEachEntry2(obj2, fn) {
  var generator = obj2 && obj2[Symbol.iterator];
  var iterator = generator.call(obj2);
  var result;
  while ((result = iterator.next()) && !result.done) {
    var pair = result.value;
    fn.call(obj2, pair[0], pair[1]);
  }
};
var matchAll = function matchAll2(regExp, str) {
  var matches;
  var arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = function toCamelCase2(str) {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m2, p1, p2) {
    return p1.toUpperCase() + p2;
  });
};
var hasOwnProperty$6 = function(_ref17) {
  var hasOwnProperty2 = _ref17.hasOwnProperty;
  return function(obj2, prop) {
    return hasOwnProperty2.call(obj2, prop);
  };
}(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = function reduceDescriptors2(obj2, reducer) {
  var descriptors2 = Object.getOwnPropertyDescriptors(obj2);
  var reducedDescriptors = {};
  forEach$1(descriptors2, function(descriptor, name2) {
    var ret;
    if ((ret = reducer(descriptor, name2, obj2)) !== false) {
      reducedDescriptors[name2] = ret || descriptor;
    }
  });
  Object.defineProperties(obj2, reducedDescriptors);
};
var freezeMethods = function freezeMethods2(obj2) {
  reduceDescriptors(obj2, function(descriptor, name2) {
    if (isFunction$2(obj2) && ["arguments", "caller", "callee"].indexOf(name2) !== -1) {
      return false;
    }
    var value = obj2[name2];
    if (!isFunction$2(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = function() {
        throw Error("Can not rewrite read-only method '" + name2 + "'");
      };
    }
  });
};
var toObjectSet = function toObjectSet2(arrayOrString, delimiter) {
  var obj2 = {};
  var define3 = function define4(arr) {
    arr.forEach(function(value) {
      obj2[value] = true;
    });
  };
  isArray$3(arrayOrString) ? define3(arrayOrString) : define3(String(arrayOrString).split(delimiter));
  return obj2;
};
var noop$1 = function noop$12() {
};
var toFiniteNumber = function toFiniteNumber2(value, defaultValue) {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
var ALPHA = "abcdefghijklmnopqrstuvwxyz";
var DIGIT = "0123456789";
var ALPHABET = { DIGIT, ALPHA, ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT };
var generateString = function generateString2() {
  var size = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 16;
  var alphabet2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ALPHABET.ALPHA_DIGIT;
  var str = "";
  var length3 = alphabet2.length;
  while (size--) {
    str += alphabet2[Math.random() * length3 | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction$2(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
var toJSONObject = function toJSONObject2(obj2) {
  var stack = new Array(10);
  var _visit = function visit(source, i2) {
    if (isObject$3(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i2] = source;
        var target = isArray$3(source) ? [] : {};
        forEach$1(source, function(value, key3) {
          var reducedValue = _visit(value, i2 + 1);
          !isUndefined(reducedValue) && (target[key3] = reducedValue);
        });
        stack[i2] = void 0;
        return target;
      }
    }
    return source;
  };
  return _visit(obj2, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = function isThenable2(thing) {
  return thing && (isObject$3(thing) || isFunction$2(thing)) && isFunction$2(thing.then) && isFunction$2(thing.catch);
};
var _setImmediate = function(setImmediateSupported, postMessageSupported) {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? function(token, callbacks) {
    _global.addEventListener("message", function(_ref18) {
      var source = _ref18.source, data = _ref18.data;
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return function(cb) {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  }("axios@".concat(Math.random()), []) : function(cb) {
    return setTimeout(cb);
  };
}(typeof setImmediate === "function", isFunction$2(_global.postMessage));
var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
var utils$g = {
  isArray: isArray$3,
  isArrayBuffer,
  isBuffer: isBuffer$3,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject: isObject$3,
  isPlainObject: isPlainObject$5,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate: isDate$1,
  isFile,
  isBlob,
  isRegExp,
  isFunction: isFunction$2,
  isStream,
  isURLSearchParams,
  isTypedArray: isTypedArray$2,
  isFileList,
  forEach: forEach$1,
  merge,
  extend,
  trim,
  stripBOM,
  inherits: inherits$7,
  toFlatObject,
  kindOf: kindOf$1,
  kindOfTest,
  endsWith,
  toArray: toArray$1,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty: hasOwnProperty$6,
  hasOwnProp: hasOwnProperty$6,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop$1,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap
};
function AxiosError$1(message, code2, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code2 && (this.code = code2);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
utils$g.inherits(AxiosError$1, Error, { toJSON: function toJSON() {
  return {
    // Standard
    message: this.message,
    name: this.name,
    // Microsoft
    description: this.description,
    number: this.number,
    // Mozilla
    fileName: this.fileName,
    lineNumber: this.lineNumber,
    columnNumber: this.columnNumber,
    stack: this.stack,
    // Axios
    config: utils$g.toJSONObject(this.config),
    code: this.code,
    status: this.status
  };
} });
var prototype$1 = AxiosError$1.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach(function(code2) {
  descriptors[code2] = { value: code2 };
});
Object.defineProperties(AxiosError$1, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError$1.from = function(error3, code2, config, request, response, customProps) {
  var axiosError = Object.create(prototype$1);
  utils$g.toFlatObject(error3, axiosError, function filter2(obj2) {
    return obj2 !== Error.prototype;
  }, function(prop) {
    return prop !== "isAxiosError";
  });
  AxiosError$1.call(axiosError, error3.message, code2, config, request, response);
  axiosError.cause = error3;
  axiosError.name = error3.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var httpAdapter = null;
function isVisitable(thing) {
  return utils$g.isPlainObject(thing) || utils$g.isArray(thing);
}
function removeBrackets(key3) {
  return utils$g.endsWith(key3, "[]") ? key3.slice(0, -2) : key3;
}
function renderKey(path2, key3, dots) {
  if (!path2)
    return key3;
  return path2.concat(key3).map(function each(token, i2) {
    token = removeBrackets(token);
    return !dots && i2 ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils$g.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils$g.toFlatObject(utils$g, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData$1(obj2, formData, options) {
  if (!utils$g.isObject(obj2)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new FormData();
  options = utils$g.toFlatObject(options, { metaTokens: true, dots: false, indexes: false }, false, function defined(option, source) {
    return !utils$g.isUndefined(source[option]);
  });
  var metaTokens = options.metaTokens;
  var visitor = options.visitor || defaultVisitor;
  var dots = options.dots;
  var indexes = options.indexes;
  var _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  var useBlob = _Blob && utils$g.isSpecCompliantForm(formData);
  if (!utils$g.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils$g.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils$g.isBlob(value)) {
      throw new AxiosError$1("Blob is not supported. Use a Buffer instead.");
    }
    if (utils$g.isArrayBuffer(value) || utils$g.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key3, path2) {
    var arr = value;
    if (value && !path2 && _typeof(value) === "object") {
      if (utils$g.endsWith(key3, "{}")) {
        key3 = metaTokens ? key3 : key3.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils$g.isArray(value) && isFlatArray(value) || (utils$g.isFileList(value) || utils$g.endsWith(key3, "[]")) && (arr = utils$g.toArray(value))) {
        key3 = removeBrackets(key3);
        arr.forEach(function each(el, index) {
          !(utils$g.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key3], index, dots) : indexes === null ? key3 : key3 + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path2, key3, dots), convertValue(value));
    return false;
  }
  var stack = [];
  var exposedHelpers = Object.assign(predicates, { defaultVisitor, convertValue, isVisitable });
  function build(value, path2) {
    if (utils$g.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path2.join("."));
    }
    stack.push(value);
    utils$g.forEach(value, function each(el, key3) {
      var result = !(utils$g.isUndefined(el) || el === null) && visitor.call(formData, el, utils$g.isString(key3) ? key3.trim() : key3, path2, exposedHelpers);
      if (result === true) {
        build(el, path2 ? path2.concat(key3) : [key3]);
      }
    });
    stack.pop();
  }
  if (!utils$g.isObject(obj2)) {
    throw new TypeError("data must be an object");
  }
  build(obj2);
  return formData;
}
function encode$6(str) {
  var charMap = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData$1(params, this, options);
}
var prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name2, value) {
  this._pairs.push([name2, value]);
};
prototype.toString = function toString2(encoder) {
  var _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$6);
  } : encode$6;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode$5(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  var _encode = options && options.encode || encode$5;
  if (utils$g.isFunction(options)) {
    options = { serialize: options };
  }
  var serializeFn = options && options.serialize;
  var serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$g.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    var hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}
var InterceptorManager = function() {
  function InterceptorManager2() {
    _classCallCheck2(this, InterceptorManager2);
    this.handlers = [];
  }
  return _createClass(InterceptorManager2, [{
    key: "use",
    value: function use4(fulfilled, rejected, options) {
      this.handlers.push({ fulfilled, rejected, synchronous: options ? options.synchronous : false, runWhen: options ? options.runWhen : null });
      return this.handlers.length - 1;
    }
    /**
    * Remove an interceptor from the stack
    *
    * @param {Number} id The ID that was returned by `use`
    *
    * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
    */
  }, {
    key: "eject",
    value: function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    }
    /**
    * Clear all interceptors from the stack
    *
    * @returns {void}
    */
  }, {
    key: "clear",
    value: function clear() {
      if (this.handlers) {
        this.handlers = [];
      }
    }
    /**
    * Iterate over all the registered interceptors
    *
    * This method is particularly useful for skipping over any
    * interceptors that may have become `null` calling `eject`.
    *
    * @param {Function} fn The function to call for each interceptor
    *
    * @returns {void}
    */
  }, { key: "forEach", value: function forEach2(fn) {
    utils$g.forEach(this.handlers, function forEachHandler(h2) {
      if (h2 !== null) {
        fn(h2);
      }
    });
  } }]);
}();
var InterceptorManager$1 = InterceptorManager;
var transitionalDefaults = { silentJSONParsing: true, forcedJSONParsing: true, clarifyTimeoutError: false };
var URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
var FormData$1 = typeof FormData !== "undefined" ? FormData : null;
var Blob$1 = typeof Blob !== "undefined" ? Blob : null;
var platform$1 = { isBrowser: true, classes: { URLSearchParams: URLSearchParams$1, FormData: FormData$1, Blob: Blob$1 }, protocols: ["http", "https", "file", "blob", "url", "data"] };
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var _navigator = (typeof navigator === "undefined" ? "undefined" : _typeof(navigator)) === "object" && navigator || void 0;
var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
var hasStandardBrowserWebWorkerEnv = function() {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
}();
var origin = hasBrowserEnv && window.location.href || "http://localhost";
var utils$f = Object.freeze(Object.defineProperty({ __proto__: null, hasBrowserEnv, hasStandardBrowserEnv, hasStandardBrowserWebWorkerEnv, navigator: _navigator, origin }, Symbol.toStringTag, { value: "Module" }));
var platform = _objectSpread(_objectSpread({}, utils$f), platform$1);
function toURLEncodedForm(data, options) {
  return toFormData$1(data, new platform.classes.URLSearchParams(), Object.assign({ visitor: function visitor(value, key3, path2, helpers) {
    if (platform.isNode && utils$g.isBuffer(value)) {
      this.append(key3, value.toString("base64"));
      return false;
    }
    return helpers.defaultVisitor.apply(this, arguments);
  } }, options));
}
function parsePropPath(name2) {
  return utils$g.matchAll(/\w+|\[(\w*)]/g, name2).map(function(match) {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  var obj2 = {};
  var keys2 = Object.keys(arr);
  var i2;
  var len2 = keys2.length;
  var key3;
  for (i2 = 0; i2 < len2; i2++) {
    key3 = keys2[i2];
    obj2[key3] = arr[key3];
  }
  return obj2;
}
function formDataToJSON(formData) {
  function buildPath(path2, value, target, index) {
    var name2 = path2[index++];
    if (name2 === "__proto__")
      return true;
    var isNumericKey = Number.isFinite(+name2);
    var isLast = index >= path2.length;
    name2 = !name2 && utils$g.isArray(target) ? target.length : name2;
    if (isLast) {
      if (utils$g.hasOwnProp(target, name2)) {
        target[name2] = [target[name2], value];
      } else {
        target[name2] = value;
      }
      return !isNumericKey;
    }
    if (!target[name2] || !utils$g.isObject(target[name2])) {
      target[name2] = [];
    }
    var result = buildPath(path2, value, target[name2], index);
    if (result && utils$g.isArray(target[name2])) {
      target[name2] = arrayToObject(target[name2]);
    }
    return !isNumericKey;
  }
  if (utils$g.isFormData(formData) && utils$g.isFunction(formData.entries)) {
    var obj2 = {};
    utils$g.forEachEntry(formData, function(name2, value) {
      buildPath(parsePropPath(name2), value, obj2, 0);
    });
    return obj2;
  }
  return null;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils$g.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$g.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data, headers) {
    var contentType = headers.getContentType() || "";
    var hasJSONContentType = contentType.indexOf("application/json") > -1;
    var isObjectPayload = utils$g.isObject(data);
    if (isObjectPayload && utils$g.isHTMLForm(data)) {
      data = new FormData(data);
    }
    var isFormData3 = utils$g.isFormData(data);
    if (isFormData3) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }
    if (utils$g.isArrayBuffer(data) || utils$g.isBuffer(data) || utils$g.isStream(data) || utils$g.isFile(data) || utils$g.isBlob(data) || utils$g.isReadableStream(data)) {
      return data;
    }
    if (utils$g.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$g.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    var isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils$g.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        var _FormData = this.env && this.env.FormData;
        return toFormData$1(isFileList2 ? { "files[]": data } : data, _FormData && new _FormData(), this.formSerializer);
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    var transitional2 = this.transitional || defaults.transitional;
    var forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    var JSONRequested = this.responseType === "json";
    if (utils$g.isResponse(data) || utils$g.isReadableStream(data)) {
      return data;
    }
    if (data && utils$g.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      var silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      var strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw AxiosError$1.from(e2, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e2;
        }
      }
    }
    return data;
  }],
  /**
  * A timeout in milliseconds to abort a request. If set to 0 (default) a
  * timeout is not created.
  */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: { FormData: platform.classes.FormData, Blob: platform.classes.Blob },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: { common: { "Accept": "application/json, text/plain, */*", "Content-Type": void 0 } }
};
utils$g.forEach(["delete", "get", "head", "post", "put", "patch"], function(method) {
  defaults.headers[method] = {};
});
var defaults$1 = defaults;
var ignoreDuplicateOf = utils$g.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]);
var parseHeaders = function parseHeaders2(rawHeaders) {
  var parsed = {};
  var key3;
  var val;
  var i2;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i2 = line.indexOf(":");
    key3 = line.substring(0, i2).trim().toLowerCase();
    val = line.substring(i2 + 1).trim();
    if (!key3 || parsed[key3] && ignoreDuplicateOf[key3]) {
      return;
    }
    if (key3 === "set-cookie") {
      if (parsed[key3]) {
        parsed[key3].push(val);
      } else {
        parsed[key3] = [val];
      }
    } else {
      parsed[key3] = parsed[key3] ? parsed[key3] + ", " + val : val;
    }
  });
  return parsed;
};
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils$g.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  var tokens = /* @__PURE__ */ Object.create(null);
  var tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  var match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
var isValidHeaderName = function isValidHeaderName2(str) {
  return /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
};
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils$g.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils$g.isString(value))
    return;
  if (utils$g.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils$g.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, function(w2, char, str) {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj2, header) {
  var accessorName = utils$g.toCamelCase(" " + header);
  ["get", "set", "has"].forEach(function(methodName) {
    Object.defineProperty(obj2, methodName + accessorName, { value: function value(arg1, arg2, arg3) {
      return this[methodName].call(this, header, arg1, arg2, arg3);
    }, configurable: true });
  });
}
var AxiosHeaders$1 = function() {
  function AxiosHeaders2(headers) {
    _classCallCheck2(this, AxiosHeaders2);
    headers && this.set(headers);
  }
  return _createClass(AxiosHeaders2, [{ key: "set", value: function set(header, valueOrRewrite, rewrite) {
    var self2 = this;
    function setHeader(_value, _header, _rewrite) {
      var lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      var key3 = utils$g.findKey(self2, lHeader);
      if (!key3 || self2[key3] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key3] !== false) {
        self2[key3 || _header] = normalizeValue(_value);
      }
    }
    var setHeaders = function setHeaders2(headers, _rewrite) {
      return utils$g.forEach(headers, function(_value, _header) {
        return setHeader(_value, _header, _rewrite);
      });
    };
    if (utils$g.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils$g.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else if (utils$g.isHeaders(header)) {
      var _iterator2 = _createForOfIteratorHelper(header.entries()), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var _step2$value = _slicedToArray(_step2.value, 2), _key4 = _step2$value[0], value = _step2$value[1];
          setHeader(value, _key4, rewrite);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  } }, { key: "get", value: function get5(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      var _key5 = utils$g.findKey(this, header);
      if (_key5) {
        var value = this[_key5];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils$g.isFunction(parser)) {
          return parser.call(this, value, _key5);
        }
        if (utils$g.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  } }, { key: "has", value: function has(header, matcher2) {
    header = normalizeHeader(header);
    if (header) {
      var _key6 = utils$g.findKey(this, header);
      return !!(_key6 && this[_key6] !== void 0 && (!matcher2 || matchHeaderValue(this, this[_key6], _key6, matcher2)));
    }
    return false;
  } }, { key: "delete", value: function _delete(header, matcher2) {
    var self2 = this;
    var deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        var _key7 = utils$g.findKey(self2, _header);
        if (_key7 && (!matcher2 || matchHeaderValue(self2, self2[_key7], _key7, matcher2))) {
          delete self2[_key7];
          deleted = true;
        }
      }
    }
    if (utils$g.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  } }, { key: "clear", value: function clear(matcher2) {
    var keys2 = Object.keys(this);
    var i2 = keys2.length;
    var deleted = false;
    while (i2--) {
      var _key8 = keys2[i2];
      if (!matcher2 || matchHeaderValue(this, this[_key8], _key8, matcher2, true)) {
        delete this[_key8];
        deleted = true;
      }
    }
    return deleted;
  } }, { key: "normalize", value: function normalize2(format) {
    var self2 = this;
    var headers = {};
    utils$g.forEach(this, function(value, header) {
      var key3 = utils$g.findKey(headers, header);
      if (key3) {
        self2[key3] = normalizeValue(value);
        delete self2[header];
        return;
      }
      var normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  } }, { key: "concat", value: function concat2() {
    var _this$constructor;
    for (var _len3 = arguments.length, targets = new Array(_len3), _key9 = 0; _key9 < _len3; _key9++) {
      targets[_key9] = arguments[_key9];
    }
    return (_this$constructor = this.constructor).concat.apply(_this$constructor, [this].concat(targets));
  } }, { key: "toJSON", value: function toJSON2(asStrings) {
    var obj2 = /* @__PURE__ */ Object.create(null);
    utils$g.forEach(this, function(value, header) {
      value != null && value !== false && (obj2[header] = asStrings && utils$g.isArray(value) ? value.join(", ") : value);
    });
    return obj2;
  } }, { key: Symbol.iterator, value: function value() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  } }, { key: "toString", value: function toString3() {
    return Object.entries(this.toJSON()).map(function(_ref19) {
      var _ref20 = _slicedToArray(_ref19, 2), header = _ref20[0], value = _ref20[1];
      return header + ": " + value;
    }).join("\n");
  } }, { key: Symbol.toStringTag, get: function get5() {
    return "AxiosHeaders";
  } }], [{ key: "from", value: function from3(thing) {
    return thing instanceof this ? thing : new this(thing);
  } }, { key: "concat", value: function concat2(first) {
    var computed = new this(first);
    for (var _len4 = arguments.length, targets = new Array(_len4 > 1 ? _len4 - 1 : 0), _key10 = 1; _key10 < _len4; _key10++) {
      targets[_key10 - 1] = arguments[_key10];
    }
    targets.forEach(function(target) {
      return computed.set(target);
    });
    return computed;
  } }, { key: "accessor", value: function accessor(header) {
    var internals = this[$internals] = this[$internals] = { accessors: {} };
    var accessors = internals.accessors;
    var prototype2 = this.prototype;
    function defineAccessor(_header) {
      var lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils$g.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  } }]);
}();
AxiosHeaders$1.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$g.reduceDescriptors(AxiosHeaders$1.prototype, function(_ref21, key3) {
  var value = _ref21.value;
  var mapped = key3[0].toUpperCase() + key3.slice(1);
  return { get: function get5() {
    return value;
  }, set: function set(headerValue) {
    this[mapped] = headerValue;
  } };
});
utils$g.freezeMethods(AxiosHeaders$1);
var AxiosHeaders$2 = AxiosHeaders$1;
function transformData(fns, response) {
  var config = this || defaults$1;
  var context = response || config;
  var headers = AxiosHeaders$2.from(context.headers);
  var data = context.data;
  utils$g.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}
function isCancel$1(value) {
  return !!(value && value.__CANCEL__);
}
function CanceledError$1(message, config, request) {
  AxiosError$1.call(this, message == null ? "canceled" : message, AxiosError$1.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils$g.inherits(CanceledError$1, AxiosError$1, { __CANCEL__: true });
function settle(resolve, reject, response) {
  var validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError$1("Request failed with status code " + response.status, [AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response));
  }
}
function parseProtocol(url) {
  var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  var bytes = new Array(samplesCount);
  var timestamps = new Array(samplesCount);
  var head = 0;
  var tail = 0;
  var firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push2(chunkLength) {
    var now = Date.now();
    var startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    var i2 = tail;
    var bytesCount = 0;
    while (i2 !== head) {
      bytesCount += bytes[i2++];
      i2 = i2 % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    var passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function throttle(fn, freq) {
  var timestamp = 0;
  var threshold = 1e3 / freq;
  var lastArgs;
  var timer;
  var invoke = function invoke2(args) {
    var now = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Date.now();
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn.apply(null, args);
  };
  var throttled = function throttled2() {
    var now = Date.now();
    var passed = now - timestamp;
    for (var _len5 = arguments.length, args = new Array(_len5), _key11 = 0; _key11 < _len5; _key11++) {
      args[_key11] = arguments[_key11];
    }
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(function() {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  var flush = function flush2() {
    return lastArgs && invoke(lastArgs);
  };
  return [throttled, flush];
}
var progressEventReducer = function progressEventReducer2(listener, isDownloadStream) {
  var freq = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 3;
  var bytesNotified = 0;
  var _speedometer = speedometer(50, 250);
  return throttle(function(e2) {
    var loaded = e2.loaded;
    var total = e2.lengthComputable ? e2.total : void 0;
    var progressBytes = loaded - bytesNotified;
    var rate = _speedometer(progressBytes);
    var inRange = loaded <= total;
    bytesNotified = loaded;
    var data = _defineProperty({ loaded, total, progress: total ? loaded / total : void 0, bytes: progressBytes, rate: rate ? rate : void 0, estimated: rate && total && inRange ? (total - loaded) / rate : void 0, event: e2, lengthComputable: total != null }, isDownloadStream ? "download" : "upload", true);
    listener(data);
  }, freq);
};
var progressEventDecorator = function progressEventDecorator2(total, throttled) {
  var lengthComputable = total != null;
  return [function(loaded) {
    return throttled[0]({ lengthComputable, total, loaded });
  }, throttled[1]];
};
var asyncDecorator = function asyncDecorator2(fn) {
  return function() {
    for (var _len6 = arguments.length, args = new Array(_len6), _key12 = 0; _key12 < _len6; _key12++) {
      args[_key12] = arguments[_key12];
    }
    return utils$g.asap(function() {
      return fn.apply(void 0, args);
    });
  };
};
var isURLSameOrigin = platform.hasStandardBrowserEnv ? /* @__PURE__ */ function(origin2, isMSIE) {
  return function(url) {
    url = new URL(url, platform.origin);
    return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
  };
}(new URL(platform.origin), platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)) : function() {
  return true;
};
var cookies = platform.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  { write: function write(name2, value, expires, path2, domain, secure) {
    var cookie = [name2 + "=" + encodeURIComponent(value)];
    utils$g.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
    utils$g.isString(path2) && cookie.push("path=" + path2);
    utils$g.isString(domain) && cookie.push("domain=" + domain);
    secure === true && cookie.push("secure");
    document.cookie = cookie.join("; ");
  }, read: function read2(name2) {
    var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
    return match ? decodeURIComponent(match[3]) : null;
  }, remove: function remove4(name2) {
    this.write(name2, "", Date.now() - 864e5);
  } }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  { write: function write2() {
  }, read: function read3() {
    return null;
  }, remove: function remove5() {
  } }
);
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
var headersToObject = function headersToObject2(thing) {
  return thing instanceof AxiosHeaders$2 ? _objectSpread({}, thing) : thing;
};
function mergeConfig$1(config1, config2) {
  config2 = config2 || {};
  var config = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils$g.isPlainObject(target) && utils$g.isPlainObject(source)) {
      return utils$g.merge.call({ caseless }, target, source);
    } else if (utils$g.isPlainObject(source)) {
      return utils$g.merge({}, source);
    } else if (utils$g.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a2, b3, prop, caseless) {
    if (!utils$g.isUndefined(b3)) {
      return getMergedValue(a2, b3, prop, caseless);
    } else if (!utils$g.isUndefined(a2)) {
      return getMergedValue(void 0, a2, prop, caseless);
    }
  }
  function valueFromConfig2(a2, b3) {
    if (!utils$g.isUndefined(b3)) {
      return getMergedValue(void 0, b3);
    }
  }
  function defaultToConfig2(a2, b3) {
    if (!utils$g.isUndefined(b3)) {
      return getMergedValue(void 0, b3);
    } else if (!utils$g.isUndefined(a2)) {
      return getMergedValue(void 0, a2);
    }
  }
  function mergeDirectKeys(a2, b3, prop) {
    if (prop in config2) {
      return getMergedValue(a2, b3);
    } else if (prop in config1) {
      return getMergedValue(void 0, a2);
    }
  }
  var mergeMap = { url: valueFromConfig2, method: valueFromConfig2, data: valueFromConfig2, baseURL: defaultToConfig2, transformRequest: defaultToConfig2, transformResponse: defaultToConfig2, paramsSerializer: defaultToConfig2, timeout: defaultToConfig2, timeoutMessage: defaultToConfig2, withCredentials: defaultToConfig2, withXSRFToken: defaultToConfig2, adapter: defaultToConfig2, responseType: defaultToConfig2, xsrfCookieName: defaultToConfig2, xsrfHeaderName: defaultToConfig2, onUploadProgress: defaultToConfig2, onDownloadProgress: defaultToConfig2, decompress: defaultToConfig2, maxContentLength: defaultToConfig2, maxBodyLength: defaultToConfig2, beforeRedirect: defaultToConfig2, transport: defaultToConfig2, httpAgent: defaultToConfig2, httpsAgent: defaultToConfig2, cancelToken: defaultToConfig2, socketPath: defaultToConfig2, responseEncoding: defaultToConfig2, validateStatus: mergeDirectKeys, headers: function headers(a2, b3, prop) {
    return mergeDeepProperties(headersToObject(a2), headersToObject(b3), prop, true);
  } };
  utils$g.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    var merge2 = mergeMap[prop] || mergeDeepProperties;
    var configValue = merge2(config1[prop], config2[prop], prop);
    utils$g.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}
var resolveConfig = function resolveConfig2(config) {
  var newConfig = mergeConfig$1({}, config);
  var data = newConfig.data, withXSRFToken = newConfig.withXSRFToken, xsrfHeaderName = newConfig.xsrfHeaderName, xsrfCookieName = newConfig.xsrfCookieName, headers = newConfig.headers, auth = newConfig.auth;
  newConfig.headers = headers = AxiosHeaders$2.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config.params, config.paramsSerializer);
  if (auth) {
    headers.set("Authorization", "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : "")));
  }
  var contentType;
  if (utils$g.isFormData(data)) {
    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if ((contentType = headers.getContentType()) !== false) {
      var _ref22 = contentType ? contentType.split(";").map(function(token) {
        return token.trim();
      }).filter(Boolean) : [], _ref23 = _toArray(_ref22), type = _ref23[0], tokens = _ref23.slice(1);
      headers.setContentType([type || "multipart/form-data"].concat(_toConsumableArray(tokens)).join("; "));
    }
  }
  if (platform.hasStandardBrowserEnv) {
    withXSRFToken && utils$g.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
      var xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhrAdapter = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var _config = resolveConfig(config);
    var requestData = _config.data;
    var requestHeaders = AxiosHeaders$2.from(_config.headers).normalize();
    var responseType = _config.responseType, onUploadProgress = _config.onUploadProgress, onDownloadProgress = _config.onDownloadProgress;
    var onCanceled;
    var uploadThrottled, downloadThrottled;
    var flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    var request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      var responseHeaders = AxiosHeaders$2.from("getAllResponseHeaders" in request && request.getAllResponseHeaders());
      var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      var response = { data: responseData, status: request.status, statusText: request.statusText, headers: responseHeaders, config, request };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError$1("Request aborted", AxiosError$1.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      var transitional2 = _config.transitional || transitionalDefaults;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError$1(timeoutErrorMessage, transitional2.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED, config, request));
      request = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils$g.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key3) {
        request.setRequestHeader(key3, val);
      });
    }
    if (!utils$g.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      var _progressEventReducer = progressEventReducer(onDownloadProgress, true);
      var _progressEventReducer2 = _slicedToArray(_progressEventReducer, 2);
      downloadThrottled = _progressEventReducer2[0];
      flushDownload = _progressEventReducer2[1];
      request.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request.upload) {
      var _progressEventReducer3 = progressEventReducer(onUploadProgress);
      var _progressEventReducer4 = _slicedToArray(_progressEventReducer3, 2);
      uploadThrottled = _progressEventReducer4[0];
      flushUpload = _progressEventReducer4[1];
      request.upload.addEventListener("progress", uploadThrottled);
      request.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = function onCanceled2(cancel) {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError$1(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    var protocol = parseProtocol(_config.url);
    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError$1("Unsupported protocol " + protocol + ":", AxiosError$1.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};
var composeSignals = function composeSignals2(signals, timeout) {
  var _signals = signals = signals ? signals.filter(Boolean) : [], length3 = _signals.length;
  if (timeout || length3) {
    var controller = new AbortController();
    var aborted;
    var onabort = function onabort2(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        var err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError$1 ? err : new CanceledError$1(err instanceof Error ? err.message : err));
      }
    };
    var timer = timeout && setTimeout(function() {
      timer = null;
      onabort(new AxiosError$1("timeout ".concat(timeout, " of ms exceeded"), AxiosError$1.ETIMEDOUT));
    }, timeout);
    var unsubscribe = function unsubscribe2() {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach(function(signal2) {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach(function(signal2) {
      return signal2.addEventListener("abort", onabort);
    });
    var signal = controller.signal;
    signal.unsubscribe = function() {
      return utils$g.asap(unsubscribe);
    };
    return signal;
  }
};
var composeSignals$1 = composeSignals;
var streamChunk = _regeneratorRuntime().mark(function streamChunk2(chunk, chunkSize) {
  var len2, pos, end2;
  return _regeneratorRuntime().wrap(function streamChunk$(_context37) {
    while (1)
      switch (_context37.prev = _context37.next) {
        case 0:
          len2 = chunk.byteLength;
          if (!(!chunkSize || len2 < chunkSize)) {
            _context37.next = 5;
            break;
          }
          _context37.next = 4;
          return chunk;
        case 4:
          return _context37.abrupt("return");
        case 5:
          pos = 0;
        case 6:
          if (!(pos < len2)) {
            _context37.next = 13;
            break;
          }
          end2 = pos + chunkSize;
          _context37.next = 10;
          return chunk.slice(pos, end2);
        case 10:
          pos = end2;
          _context37.next = 6;
          break;
        case 13:
        case "end":
          return _context37.stop();
      }
  }, streamChunk2);
});
var readBytes = function() {
  var _ref = _wrapAsyncGenerator(_regeneratorRuntime().mark(function _callee37(iterable, chunkSize) {
    var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, chunk;
    return _regeneratorRuntime().wrap(function _callee37$(_context38) {
      while (1)
        switch (_context38.prev = _context38.next) {
          case 0:
            _iteratorAbruptCompletion = false;
            _didIteratorError = false;
            _context38.prev = 2;
            _iterator = _asyncIterator(readStream(iterable));
          case 4:
            _context38.next = 6;
            return _awaitAsyncGenerator(_iterator.next());
          case 6:
            if (!(_iteratorAbruptCompletion = !(_step = _context38.sent).done)) {
              _context38.next = 12;
              break;
            }
            chunk = _step.value;
            return _context38.delegateYield(_asyncGeneratorDelegate(_asyncIterator(streamChunk(chunk, chunkSize)), _awaitAsyncGenerator), "t0", 9);
          case 9:
            _iteratorAbruptCompletion = false;
            _context38.next = 4;
            break;
          case 12:
            _context38.next = 18;
            break;
          case 14:
            _context38.prev = 14;
            _context38.t1 = _context38["catch"](2);
            _didIteratorError = true;
            _iteratorError = _context38.t1;
          case 18:
            _context38.prev = 18;
            _context38.prev = 19;
            if (!(_iteratorAbruptCompletion && _iterator.return != null)) {
              _context38.next = 23;
              break;
            }
            _context38.next = 23;
            return _awaitAsyncGenerator(_iterator.return());
          case 23:
            _context38.prev = 23;
            if (!_didIteratorError) {
              _context38.next = 26;
              break;
            }
            throw _iteratorError;
          case 26:
            return _context38.finish(23);
          case 27:
            return _context38.finish(18);
          case 28:
          case "end":
            return _context38.stop();
        }
    }, _callee37, null, [[2, 14, 18, 28], [19, , 23, 27]]);
  }));
  return function readBytes2(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();
var readStream = function() {
  var _ref2 = _wrapAsyncGenerator(_regeneratorRuntime().mark(function _callee38(stream) {
    var reader2, _yield$_awaitAsyncGen, done, value;
    return _regeneratorRuntime().wrap(function _callee38$(_context39) {
      while (1)
        switch (_context39.prev = _context39.next) {
          case 0:
            if (!stream[Symbol.asyncIterator]) {
              _context39.next = 3;
              break;
            }
            return _context39.delegateYield(_asyncGeneratorDelegate(_asyncIterator(stream), _awaitAsyncGenerator), "t0", 2);
          case 2:
            return _context39.abrupt("return");
          case 3:
            reader2 = stream.getReader();
            _context39.prev = 4;
          case 5:
            _context39.next = 7;
            return _awaitAsyncGenerator(reader2.read());
          case 7:
            _yield$_awaitAsyncGen = _context39.sent;
            done = _yield$_awaitAsyncGen.done;
            value = _yield$_awaitAsyncGen.value;
            if (!done) {
              _context39.next = 12;
              break;
            }
            return _context39.abrupt("break", 16);
          case 12:
            _context39.next = 14;
            return value;
          case 14:
            _context39.next = 5;
            break;
          case 16:
            _context39.prev = 16;
            _context39.next = 19;
            return _awaitAsyncGenerator(reader2.cancel());
          case 19:
            return _context39.finish(16);
          case 20:
          case "end":
            return _context39.stop();
        }
    }, _callee38, null, [[4, , 16, 20]]);
  }));
  return function readStream2(_x3) {
    return _ref2.apply(this, arguments);
  };
}();
var trackStream = function trackStream2(stream, chunkSize, onProgress, onFinish) {
  var iterator = readBytes(stream, chunkSize);
  var bytes = 0;
  var done;
  var _onFinish = function _onFinish2(e2) {
    if (!done) {
      done = true;
      onFinish && onFinish(e2);
    }
  };
  return new ReadableStream({ pull: function pull(controller) {
    return _asyncToGenerator(_regeneratorRuntime().mark(function _callee39() {
      var _yield$iterator$next, _done, value, _len7, loadedBytes;
      return _regeneratorRuntime().wrap(function _callee39$(_context40) {
        while (1)
          switch (_context40.prev = _context40.next) {
            case 0:
              _context40.prev = 0;
              _context40.next = 3;
              return iterator.next();
            case 3:
              _yield$iterator$next = _context40.sent;
              _done = _yield$iterator$next.done;
              value = _yield$iterator$next.value;
              if (!_done) {
                _context40.next = 10;
                break;
              }
              _onFinish();
              controller.close();
              return _context40.abrupt("return");
            case 10:
              _len7 = value.byteLength;
              if (onProgress) {
                loadedBytes = bytes += _len7;
                onProgress(loadedBytes);
              }
              controller.enqueue(new Uint8Array(value));
              _context40.next = 19;
              break;
            case 15:
              _context40.prev = 15;
              _context40.t0 = _context40["catch"](0);
              _onFinish(_context40.t0);
              throw _context40.t0;
            case 19:
            case "end":
              return _context40.stop();
          }
      }, _callee39, null, [[0, 15]]);
    }))();
  }, cancel: function cancel(reason) {
    _onFinish(reason);
    return iterator.return();
  } }, { highWaterMark: 2 });
};
var isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
var isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
var encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ function(encoder) {
  return function(str) {
    return encoder.encode(str);
  };
}(new TextEncoder()) : function() {
  var _ref24 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee40(str) {
    return _regeneratorRuntime().wrap(function _callee40$(_context41) {
      while (1)
        switch (_context41.prev = _context41.next) {
          case 0:
            _context41.t0 = Uint8Array;
            _context41.next = 3;
            return new Response(str).arrayBuffer();
          case 3:
            _context41.t1 = _context41.sent;
            return _context41.abrupt("return", new _context41.t0(_context41.t1));
          case 5:
          case "end":
            return _context41.stop();
        }
    }, _callee40);
  }));
  return function(_x55) {
    return _ref24.apply(this, arguments);
  };
}());
var test = function test2(fn) {
  try {
    for (var _len8 = arguments.length, args = new Array(_len8 > 1 ? _len8 - 1 : 0), _key13 = 1; _key13 < _len8; _key13++) {
      args[_key13 - 1] = arguments[_key13];
    }
    return !!fn.apply(void 0, args);
  } catch (e2) {
    return false;
  }
};
var supportsRequestStream = isReadableStreamSupported && test(function() {
  var duplexAccessed = false;
  var hasContentType = new Request(platform.origin, { body: new ReadableStream(), method: "POST", get duplex() {
    duplexAccessed = true;
    return "half";
  } }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
});
var DEFAULT_CHUNK_SIZE = 64 * 1024;
var supportsResponseStream = isReadableStreamSupported && test(function() {
  return utils$g.isReadableStream(new Response("").body);
});
var resolvers = { stream: supportsResponseStream && function(res) {
  return res.body;
} };
isFetchSupported && function(res) {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(function(type) {
    !resolvers[type] && (resolvers[type] = utils$g.isFunction(res[type]) ? function(res2) {
      return res2[type]();
    } : function(_, config) {
      throw new AxiosError$1("Response type '".concat(type, "' is not supported"), AxiosError$1.ERR_NOT_SUPPORT, config);
    });
  });
}(new Response());
var getBodyLength = function() {
  var _ref25 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee41(body) {
    var _request;
    return _regeneratorRuntime().wrap(function _callee41$(_context42) {
      while (1)
        switch (_context42.prev = _context42.next) {
          case 0:
            if (!(body == null)) {
              _context42.next = 2;
              break;
            }
            return _context42.abrupt("return", 0);
          case 2:
            if (!utils$g.isBlob(body)) {
              _context42.next = 4;
              break;
            }
            return _context42.abrupt("return", body.size);
          case 4:
            if (!utils$g.isSpecCompliantForm(body)) {
              _context42.next = 9;
              break;
            }
            _request = new Request(platform.origin, { method: "POST", body });
            _context42.next = 8;
            return _request.arrayBuffer();
          case 8:
            return _context42.abrupt("return", _context42.sent.byteLength);
          case 9:
            if (!(utils$g.isArrayBufferView(body) || utils$g.isArrayBuffer(body))) {
              _context42.next = 11;
              break;
            }
            return _context42.abrupt("return", body.byteLength);
          case 11:
            if (utils$g.isURLSearchParams(body)) {
              body = body + "";
            }
            if (!utils$g.isString(body)) {
              _context42.next = 16;
              break;
            }
            _context42.next = 15;
            return encodeText(body);
          case 15:
            return _context42.abrupt("return", _context42.sent.byteLength);
          case 16:
          case "end":
            return _context42.stop();
        }
    }, _callee41);
  }));
  return function getBodyLength2(_x56) {
    return _ref25.apply(this, arguments);
  };
}();
var resolveBodyLength = function() {
  var _ref26 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee42(headers, body) {
    var length3;
    return _regeneratorRuntime().wrap(function _callee42$(_context43) {
      while (1)
        switch (_context43.prev = _context43.next) {
          case 0:
            length3 = utils$g.toFiniteNumber(headers.getContentLength());
            return _context43.abrupt("return", length3 == null ? getBodyLength(body) : length3);
          case 2:
          case "end":
            return _context43.stop();
        }
    }, _callee42);
  }));
  return function resolveBodyLength2(_x57, _x58) {
    return _ref26.apply(this, arguments);
  };
}();
var fetchAdapter = isFetchSupported && function() {
  var _ref27 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee43(config) {
    var _resolveConfig, url, method, data, signal, cancelToken, timeout, onDownloadProgress, onUploadProgress, responseType, headers, _resolveConfig$withCr, withCredentials, fetchOptions, composedSignal, request, unsubscribe, requestContentLength, _request, contentTypeHeader, _progressEventDecorat, _progressEventDecorat2, onProgress, flush, isCredentialsSupported, response, isStreamResponse, options, responseContentLength, _ref28, _ref29, _onProgress, _flush, responseData;
    return _regeneratorRuntime().wrap(function _callee43$(_context44) {
      while (1)
        switch (_context44.prev = _context44.next) {
          case 0:
            _resolveConfig = resolveConfig(config), url = _resolveConfig.url, method = _resolveConfig.method, data = _resolveConfig.data, signal = _resolveConfig.signal, cancelToken = _resolveConfig.cancelToken, timeout = _resolveConfig.timeout, onDownloadProgress = _resolveConfig.onDownloadProgress, onUploadProgress = _resolveConfig.onUploadProgress, responseType = _resolveConfig.responseType, headers = _resolveConfig.headers, _resolveConfig$withCr = _resolveConfig.withCredentials, withCredentials = _resolveConfig$withCr === void 0 ? "same-origin" : _resolveConfig$withCr, fetchOptions = _resolveConfig.fetchOptions;
            responseType = responseType ? (responseType + "").toLowerCase() : "text";
            composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
            unsubscribe = composedSignal && composedSignal.unsubscribe && function() {
              composedSignal.unsubscribe();
            };
            _context44.prev = 4;
            _context44.t0 = onUploadProgress && supportsRequestStream && method !== "get" && method !== "head";
            if (!_context44.t0) {
              _context44.next = 11;
              break;
            }
            _context44.next = 9;
            return resolveBodyLength(headers, data);
          case 9:
            _context44.t1 = requestContentLength = _context44.sent;
            _context44.t0 = _context44.t1 !== 0;
          case 11:
            if (!_context44.t0) {
              _context44.next = 15;
              break;
            }
            _request = new Request(url, { method: "POST", body: data, duplex: "half" });
            if (utils$g.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
              headers.setContentType(contentTypeHeader);
            }
            if (_request.body) {
              _progressEventDecorat = progressEventDecorator(requestContentLength, progressEventReducer(asyncDecorator(onUploadProgress))), _progressEventDecorat2 = _slicedToArray(_progressEventDecorat, 2), onProgress = _progressEventDecorat2[0], flush = _progressEventDecorat2[1];
              data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
            }
          case 15:
            if (!utils$g.isString(withCredentials)) {
              withCredentials = withCredentials ? "include" : "omit";
            }
            isCredentialsSupported = "credentials" in Request.prototype;
            request = new Request(url, _objectSpread(_objectSpread({}, fetchOptions), {}, { signal: composedSignal, method: method.toUpperCase(), headers: headers.normalize().toJSON(), body: data, duplex: "half", credentials: isCredentialsSupported ? withCredentials : void 0 }));
            _context44.next = 20;
            return fetch(request);
          case 20:
            response = _context44.sent;
            isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
            if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
              options = {};
              ["status", "statusText", "headers"].forEach(function(prop) {
                options[prop] = response[prop];
              });
              responseContentLength = utils$g.toFiniteNumber(response.headers.get("content-length"));
              _ref28 = onDownloadProgress && progressEventDecorator(responseContentLength, progressEventReducer(asyncDecorator(onDownloadProgress), true)) || [], _ref29 = _slicedToArray(_ref28, 2), _onProgress = _ref29[0], _flush = _ref29[1];
              response = new Response(trackStream(response.body, DEFAULT_CHUNK_SIZE, _onProgress, function() {
                _flush && _flush();
                unsubscribe && unsubscribe();
              }), options);
            }
            responseType = responseType || "text";
            _context44.next = 26;
            return resolvers[utils$g.findKey(resolvers, responseType) || "text"](response, config);
          case 26:
            responseData = _context44.sent;
            !isStreamResponse && unsubscribe && unsubscribe();
            _context44.next = 30;
            return new Promise(function(resolve, reject) {
              settle(resolve, reject, { data: responseData, headers: AxiosHeaders$2.from(response.headers), status: response.status, statusText: response.statusText, config, request });
            });
          case 30:
            return _context44.abrupt("return", _context44.sent);
          case 33:
            _context44.prev = 33;
            _context44.t2 = _context44["catch"](4);
            unsubscribe && unsubscribe();
            if (!(_context44.t2 && _context44.t2.name === "TypeError" && /fetch/i.test(_context44.t2.message))) {
              _context44.next = 38;
              break;
            }
            throw Object.assign(new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config, request), { cause: _context44.t2.cause || _context44.t2 });
          case 38:
            throw AxiosError$1.from(_context44.t2, _context44.t2 && _context44.t2.code, config, request);
          case 39:
          case "end":
            return _context44.stop();
        }
    }, _callee43, null, [[4, 33]]);
  }));
  return function(_x59) {
    return _ref27.apply(this, arguments);
  };
}();
var knownAdapters = { http: httpAdapter, xhr: xhrAdapter, fetch: fetchAdapter };
utils$g.forEach(knownAdapters, function(fn, value) {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e2) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var renderReason = function renderReason2(reason) {
  return "- ".concat(reason);
};
var isResolvedHandle = function isResolvedHandle2(adapter) {
  return utils$g.isFunction(adapter) || adapter === null || adapter === false;
};
var adapters = { getAdapter: function getAdapter2(adapters2) {
  adapters2 = utils$g.isArray(adapters2) ? adapters2 : [adapters2];
  var _adapters = adapters2, length3 = _adapters.length;
  var nameOrAdapter;
  var adapter;
  var rejectedReasons = {};
  for (var _i7 = 0; _i7 < length3; _i7++) {
    nameOrAdapter = adapters2[_i7];
    var id = void 0;
    adapter = nameOrAdapter;
    if (!isResolvedHandle(nameOrAdapter)) {
      adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
      if (adapter === void 0) {
        throw new AxiosError$1("Unknown adapter '".concat(id, "'"));
      }
    }
    if (adapter) {
      break;
    }
    rejectedReasons[id || "#" + _i7] = adapter;
  }
  if (!adapter) {
    var reasons = Object.entries(rejectedReasons).map(function(_ref30) {
      var _ref31 = _slicedToArray(_ref30, 2), id2 = _ref31[0], state = _ref31[1];
      return "adapter ".concat(id2, " ") + (state === false ? "is not supported by the environment" : "is not available in the build");
    });
    var _s2 = length3 ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
    throw new AxiosError$1("There is no suitable adapter to dispatch the request " + _s2, "ERR_NOT_SUPPORT");
  }
  return adapter;
}, adapters: knownAdapters };
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError$1(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders$2.from(config.headers);
  config.data = transformData.call(config, config.transformRequest);
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  var adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(config, config.transformResponse, response);
    response.headers = AxiosHeaders$2.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel$1(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(config, config.transformResponse, reason.response);
        reason.response.headers = AxiosHeaders$2.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
var VERSION$1 = "1.7.9";
var validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i2) {
  validators$1[type] = function validator2(thing) {
    return _typeof(thing) === type || "a" + (i2 < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version2, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION$1 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return function(value, opt, opts) {
    if (validator2 === false) {
      throw new AxiosError$1(formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")), AxiosError$1.ERR_DEPRECATED);
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(formatMessage(opt, " has been deprecated since v" + version2 + " and will be removed in the near future"));
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
validators$1.spelling = function spelling(correctSpelling) {
  return function(value, opt) {
    console.warn("".concat(opt, " is likely a misspelling of ").concat(correctSpelling));
    return true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (_typeof(options) !== "object") {
    throw new AxiosError$1("options must be an object", AxiosError$1.ERR_BAD_OPTION_VALUE);
  }
  var keys2 = Object.keys(options);
  var i2 = keys2.length;
  while (i2-- > 0) {
    var opt = keys2[i2];
    var _validator = schema[opt];
    if (_validator) {
      var value = options[opt];
      var result = value === void 0 || _validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError$1("option " + opt + " must be " + result, AxiosError$1.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError$1("Unknown option " + opt, AxiosError$1.ERR_BAD_OPTION);
    }
  }
}
var validator = { assertOptions, validators: validators$1 };
var validators = validator.validators;
var Axios$1 = function() {
  function Axios2(instanceConfig) {
    _classCallCheck2(this, Axios2);
    this.defaults = instanceConfig;
    this.interceptors = { request: new InterceptorManager$1(), response: new InterceptorManager$1() };
  }
  return _createClass(Axios2, [{ key: "request", value: function() {
    var _request2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee44(configOrUrl, config) {
      var dummy, stack;
      return _regeneratorRuntime().wrap(function _callee44$(_context45) {
        while (1)
          switch (_context45.prev = _context45.next) {
            case 0:
              _context45.prev = 0;
              _context45.next = 3;
              return this._request(configOrUrl, config);
            case 3:
              return _context45.abrupt("return", _context45.sent);
            case 6:
              _context45.prev = 6;
              _context45.t0 = _context45["catch"](0);
              if (_context45.t0 instanceof Error) {
                dummy = {};
                Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
                stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
                try {
                  if (!_context45.t0.stack) {
                    _context45.t0.stack = stack;
                  } else if (stack && !String(_context45.t0.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
                    _context45.t0.stack += "\n" + stack;
                  }
                } catch (e2) {
                }
              }
              throw _context45.t0;
            case 10:
            case "end":
              return _context45.stop();
          }
      }, _callee44, this, [[0, 6]]);
    }));
    function request(_x60, _x61) {
      return _request2.apply(this, arguments);
    }
    return request;
  }() }, { key: "_request", value: function _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig$1(this.defaults, config);
    var _config2 = config, transitional2 = _config2.transitional, paramsSerializer = _config2.paramsSerializer, headers = _config2.headers;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, { silentJSONParsing: validators.transitional(validators.boolean), forcedJSONParsing: validators.transitional(validators.boolean), clarifyTimeoutError: validators.transitional(validators.boolean) }, false);
    }
    if (paramsSerializer != null) {
      if (utils$g.isFunction(paramsSerializer)) {
        config.paramsSerializer = { serialize: paramsSerializer };
      } else {
        validator.assertOptions(paramsSerializer, { encode: validators.function, serialize: validators.function }, true);
      }
    }
    validator.assertOptions(config, { baseUrl: validators.spelling("baseURL"), withXsrfToken: validators.spelling("withXSRFToken") }, true);
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    var contextHeaders = headers && utils$g.merge(headers.common, headers[config.method]);
    headers && utils$g.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function(method) {
      delete headers[method];
    });
    config.headers = AxiosHeaders$2.concat(contextHeaders, headers);
    var requestInterceptorChain = [];
    var synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    var responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    var promise;
    var i2 = 0;
    var len2;
    if (!synchronousRequestInterceptors) {
      var chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len2 = chain.length;
      promise = Promise.resolve(config);
      while (i2 < len2) {
        promise = promise.then(chain[i2++], chain[i2++]);
      }
      return promise;
    }
    len2 = requestInterceptorChain.length;
    var newConfig = config;
    i2 = 0;
    while (i2 < len2) {
      var onFulfilled = requestInterceptorChain[i2++];
      var onRejected = requestInterceptorChain[i2++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error3) {
        onRejected.call(this, error3);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error3) {
      return Promise.reject(error3);
    }
    i2 = 0;
    len2 = responseInterceptorChain.length;
    while (i2 < len2) {
      promise = promise.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
    }
    return promise;
  } }, { key: "getUri", value: function getUri(config) {
    config = mergeConfig$1(this.defaults, config);
    var fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  } }]);
}();
utils$g.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios$1.prototype[method] = function(url, config) {
    return this.request(mergeConfig$1(config || {}, { method, url, data: (config || {}).data }));
  };
});
utils$g.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig$1(config || {}, { method, headers: isForm ? { "Content-Type": "multipart/form-data" } : {}, url, data }));
    };
  }
  Axios$1.prototype[method] = generateHTTPMethod();
  Axios$1.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios$2 = Axios$1;
var CancelToken$1 = function() {
  function CancelToken2(executor) {
    _classCallCheck2(this, CancelToken2);
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    var token = this;
    this.promise.then(function(cancel) {
      if (!token._listeners)
        return;
      var i2 = token._listeners.length;
      while (i2-- > 0) {
        token._listeners[i2](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = function(onfulfilled) {
      var _resolve;
      var promise = new Promise(function(resolve) {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError$1(message, config, request);
      resolvePromise(token.reason);
    });
  }
  return _createClass(CancelToken2, [{
    key: "throwIfRequested",
    value: function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    }
    /**
    * Subscribe to the cancel signal
    */
  }, {
    key: "subscribe",
    value: function subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    }
    /**
    * Unsubscribe from the cancel signal
    */
  }, { key: "unsubscribe", value: function unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    var index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  } }, {
    key: "toAbortSignal",
    value: function toAbortSignal() {
      var _this13 = this;
      var controller = new AbortController();
      var abort = function abort2(err) {
        controller.abort(err);
      };
      this.subscribe(abort);
      controller.signal.unsubscribe = function() {
        return _this13.unsubscribe(abort);
      };
      return controller.signal;
    }
    /**
    * Returns an object that contains a new `CancelToken` and a function that, when called,
    * cancels the `CancelToken`.
    */
  }], [{ key: "source", value: function source() {
    var cancel;
    var token = new CancelToken2(function executor(c3) {
      cancel = c3;
    });
    return { token, cancel };
  } }]);
}();
var CancelToken$2 = CancelToken$1;
function spread$1(callback) {
  return function wrap2(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError$1(payload) {
  return utils$g.isObject(payload) && payload.isAxiosError === true;
}
var HttpStatusCode$1 = { Continue: 100, SwitchingProtocols: 101, Processing: 102, EarlyHints: 103, Ok: 200, Created: 201, Accepted: 202, NonAuthoritativeInformation: 203, NoContent: 204, ResetContent: 205, PartialContent: 206, MultiStatus: 207, AlreadyReported: 208, ImUsed: 226, MultipleChoices: 300, MovedPermanently: 301, Found: 302, SeeOther: 303, NotModified: 304, UseProxy: 305, Unused: 306, TemporaryRedirect: 307, PermanentRedirect: 308, BadRequest: 400, Unauthorized: 401, PaymentRequired: 402, Forbidden: 403, NotFound: 404, MethodNotAllowed: 405, NotAcceptable: 406, ProxyAuthenticationRequired: 407, RequestTimeout: 408, Conflict: 409, Gone: 410, LengthRequired: 411, PreconditionFailed: 412, PayloadTooLarge: 413, UriTooLong: 414, UnsupportedMediaType: 415, RangeNotSatisfiable: 416, ExpectationFailed: 417, ImATeapot: 418, MisdirectedRequest: 421, UnprocessableEntity: 422, Locked: 423, FailedDependency: 424, TooEarly: 425, UpgradeRequired: 426, PreconditionRequired: 428, TooManyRequests: 429, RequestHeaderFieldsTooLarge: 431, UnavailableForLegalReasons: 451, InternalServerError: 500, NotImplemented: 501, BadGateway: 502, ServiceUnavailable: 503, GatewayTimeout: 504, HttpVersionNotSupported: 505, VariantAlsoNegotiates: 506, InsufficientStorage: 507, LoopDetected: 508, NotExtended: 510, NetworkAuthenticationRequired: 511 };
Object.entries(HttpStatusCode$1).forEach(function(_ref32) {
  var _ref33 = _slicedToArray(_ref32, 2), key3 = _ref33[0], value = _ref33[1];
  HttpStatusCode$1[value] = key3;
});
var HttpStatusCode$2 = HttpStatusCode$1;
function createInstance(defaultConfig) {
  var context = new Axios$2(defaultConfig);
  var instance = bind(Axios$2.prototype.request, context);
  utils$g.extend(instance, Axios$2.prototype, context, { allOwnKeys: true });
  utils$g.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create8(instanceConfig) {
    return createInstance(mergeConfig$1(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults$1);
axios.Axios = Axios$2;
axios.CanceledError = CanceledError$1;
axios.CancelToken = CancelToken$2;
axios.isCancel = isCancel$1;
axios.VERSION = VERSION$1;
axios.toFormData = toFormData$1;
axios.AxiosError = AxiosError$1;
axios.Cancel = axios.CanceledError;
axios.all = function all2(promises) {
  return Promise.all(promises);
};
axios.spread = spread$1;
axios.isAxiosError = isAxiosError$1;
axios.mergeConfig = mergeConfig$1;
axios.AxiosHeaders = AxiosHeaders$2;
axios.formToJSON = function(thing) {
  return formDataToJSON(utils$g.isHTMLForm(thing) ? new FormData(thing) : thing);
};
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$2;
axios.default = axios;
var axios3 = axios;
var Axios = axios3.Axios;
var AxiosError = axios3.AxiosError;
var CanceledError = axios3.CanceledError;
var isCancel = axios3.isCancel;
var CancelToken = axios3.CancelToken;
var VERSION = axios3.VERSION;
var all = axios3.all;
var Cancel = axios3.Cancel;
var isAxiosError = axios3.isAxiosError;
var spread = axios3.spread;
var toFormData = axios3.toFormData;
var AxiosHeaders = axios3.AxiosHeaders;
var HttpStatusCode = axios3.HttpStatusCode;
var formToJSON = axios3.formToJSON;
var getAdapter = axios3.getAdapter;
var mergeConfig = axios3.mergeConfig;
var base64Js = {};
base64Js.byteLength = byteLength;
var toByteArray_1 = base64Js.toByteArray = toByteArray;
var fromByteArray_1 = base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (i = 0, len = code$1.length; i < len; ++i) {
  lookup[i] = code$1[i];
  revLookup[code$1.charCodeAt(i)] = i;
}
var i;
var len;
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len2 = b64.length;
  if (len2 % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1)
    validLen = len2;
  var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i2;
  for (i2 = 0; i2 < len2; i2 += 4) {
    tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end2) {
  var tmp;
  var output = [];
  for (var i2 = start; i2 < end2; i2 += 3) {
    tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len2 = uint8.length;
  var extraBytes = len2 % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
    parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len2 - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
  } else if (extraBytes === 2) {
    tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
  }
  return parts.join("");
}
var dist = {};
var arweaveMnemonicKeys = {};
var src$2 = {};
var sha256$8 = {};
var _md = {};
var _assert = {};
Object.defineProperty(_assert, "__esModule", { value: true });
_assert.anumber = anumber;
_assert.abytes = abytes;
_assert.ahash = ahash;
_assert.aexists = aexists;
_assert.aoutput = aoutput;
function anumber(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error("positive integer expected, got " + n2);
}
function isBytes(a2) {
  return a2 instanceof Uint8Array || ArrayBuffer.isView(a2) && a2.constructor.name === "Uint8Array";
}
function abytes(b3) {
  if (!isBytes(b3))
    throw new Error("Uint8Array expected");
  for (var _len9 = arguments.length, lengths2 = new Array(_len9 > 1 ? _len9 - 1 : 0), _key14 = 1; _key14 < _len9; _key14++) {
    lengths2[_key14 - 1] = arguments[_key14];
  }
  if (lengths2.length > 0 && !lengths2.includes(b3.length))
    throw new Error("Uint8Array expected of length " + lengths2 + ", got length=" + b3.length);
}
function ahash(h2) {
  if (typeof h2 !== "function" || typeof h2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  anumber(h2.outputLen);
  anumber(h2.blockLen);
}
function aexists(instance) {
  var checkFinished = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out);
  var min = instance.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}
var utils$e = {};
var crypto$5 = {};
Object.defineProperty(crypto$5, "__esModule", { value: true });
crypto$5.crypto = void 0;
crypto$5.crypto = (typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Hash = exports.nextTick = exports.byteSwapIfBE = exports.isLE = void 0;
  exports.isBytes = isBytes2;
  exports.u8 = u8;
  exports.u32 = u32;
  exports.createView = createView;
  exports.rotr = rotr;
  exports.rotl = rotl;
  exports.byteSwap = byteSwap;
  exports.byteSwap32 = byteSwap32;
  exports.bytesToHex = bytesToHex;
  exports.hexToBytes = hexToBytes;
  exports.asyncLoop = asyncLoop;
  exports.utf8ToBytes = utf8ToBytes;
  exports.toBytes = toBytes;
  exports.concatBytes = concatBytes;
  exports.checkOpts = checkOpts;
  exports.wrapConstructor = wrapConstructor;
  exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
  exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
  exports.randomBytes = randomBytes2;
  var crypto_1 = crypto$5;
  var _assert_js_12 = _assert;
  function isBytes2(a2) {
    return a2 instanceof Uint8Array || ArrayBuffer.isView(a2) && a2.constructor.name === "Uint8Array";
  }
  function u8(arr) {
    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
  }
  function u32(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  }
  function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  }
  function rotr(word, shift) {
    return word << 32 - shift | word >>> shift;
  }
  function rotl(word, shift) {
    return word << shift | word >>> 32 - shift >>> 0;
  }
  exports.isLE = function() {
    return new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  }();
  function byteSwap(word) {
    return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
  }
  exports.byteSwapIfBE = exports.isLE ? function(n2) {
    return n2;
  } : function(n2) {
    return byteSwap(n2);
  };
  function byteSwap32(arr) {
    for (var _i8 = 0; _i8 < arr.length; _i8++) {
      arr[_i8] = byteSwap(arr[_i8]);
    }
  }
  var hexes = Array.from({ length: 256 }, function(_, i2) {
    return i2.toString(16).padStart(2, "0");
  });
  function bytesToHex(bytes) {
    (0, _assert_js_12.abytes)(bytes);
    var hex = "";
    for (var _i9 = 0; _i9 < bytes.length; _i9++) {
      hex += hexes[bytes[_i9]];
    }
    return hex;
  }
  var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
  function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9)
      return ch - asciis._0;
    if (ch >= asciis.A && ch <= asciis.F)
      return ch - (asciis.A - 10);
    if (ch >= asciis.a && ch <= asciis.f)
      return ch - (asciis.a - 10);
    return;
  }
  function hexToBytes(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + _typeof(hex));
    var hl = hex.length;
    var al = hl / 2;
    if (hl % 2)
      throw new Error("hex string expected, got unpadded hex of length " + hl);
    var array = new Uint8Array(al);
    for (var ai = 0, hi = 0; ai < al; ai++, hi += 2) {
      var n1 = asciiToBase16(hex.charCodeAt(hi));
      var n2 = asciiToBase16(hex.charCodeAt(hi + 1));
      if (n1 === void 0 || n2 === void 0) {
        var char = hex[hi] + hex[hi + 1];
        throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
      }
      array[ai] = n1 * 16 + n2;
    }
    return array;
  }
  var nextTick = function() {
    var _ref34 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee45() {
      return _regeneratorRuntime().wrap(function _callee45$(_context46) {
        while (1)
          switch (_context46.prev = _context46.next) {
            case 0:
            case "end":
              return _context46.stop();
          }
      }, _callee45);
    }));
    return function nextTick2() {
      return _ref34.apply(this, arguments);
    };
  }();
  exports.nextTick = nextTick;
  function asyncLoop(_x62, _x63, _x64) {
    return _asyncLoop.apply(this, arguments);
  }
  function _asyncLoop() {
    _asyncLoop = _asyncToGenerator(_regeneratorRuntime().mark(function _callee46(iters, tick, cb) {
      var ts, _i12, diff;
      return _regeneratorRuntime().wrap(function _callee46$(_context47) {
        while (1)
          switch (_context47.prev = _context47.next) {
            case 0:
              ts = Date.now();
              _i12 = 0;
            case 2:
              if (!(_i12 < iters)) {
                _context47.next = 13;
                break;
              }
              cb(_i12);
              diff = Date.now() - ts;
              if (!(diff >= 0 && diff < tick)) {
                _context47.next = 7;
                break;
              }
              return _context47.abrupt("continue", 10);
            case 7:
              _context47.next = 9;
              return (0, exports.nextTick)();
            case 9:
              ts += diff;
            case 10:
              _i12++;
              _context47.next = 2;
              break;
            case 13:
            case "end":
              return _context47.stop();
          }
      }, _callee46);
    }));
    return _asyncLoop.apply(this, arguments);
  }
  function utf8ToBytes(str) {
    if (typeof str !== "string")
      throw new Error("utf8ToBytes expected string, got " + _typeof(str));
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function toBytes(data) {
    if (typeof data === "string")
      data = utf8ToBytes(data);
    (0, _assert_js_12.abytes)(data);
    return data;
  }
  function concatBytes() {
    var sum = 0;
    for (var _i10 = 0; _i10 < arguments.length; _i10++) {
      var _a3 = _i10 < 0 || arguments.length <= _i10 ? void 0 : arguments[_i10];
      (0, _assert_js_12.abytes)(_a3);
      sum += _a3.length;
    }
    var res = new Uint8Array(sum);
    for (var _i11 = 0, pad2 = 0; _i11 < arguments.length; _i11++) {
      var _a4 = _i11 < 0 || arguments.length <= _i11 ? void 0 : arguments[_i11];
      res.set(_a4, pad2);
      pad2 += _a4.length;
    }
    return res;
  }
  var Hash = function() {
    function Hash2() {
      _classCallCheck2(this, Hash2);
    }
    return _createClass(Hash2, [{ key: "clone", value: (
      // Safe version that clones internal state
      function clone3() {
        return this._cloneInto();
      }
    ) }]);
  }();
  exports.Hash = Hash;
  function checkOpts(defaults2, opts) {
    if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    var merged = Object.assign(defaults2, opts);
    return merged;
  }
  function wrapConstructor(hashCons) {
    var hashC = function hashC2(msg) {
      return hashCons().update(toBytes(msg)).digest();
    };
    var tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = function() {
      return hashCons();
    };
    return hashC;
  }
  function wrapConstructorWithOpts(hashCons) {
    var hashC = function hashC2(msg, opts) {
      return hashCons(opts).update(toBytes(msg)).digest();
    };
    var tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = function(opts) {
      return hashCons(opts);
    };
    return hashC;
  }
  function wrapXOFConstructorWithOpts(hashCons) {
    var hashC = function hashC2(msg, opts) {
      return hashCons(opts).update(toBytes(msg)).digest();
    };
    var tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = function(opts) {
      return hashCons(opts);
    };
    return hashC;
  }
  function randomBytes2() {
    var bytesLength = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 32;
    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
      return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === "function") {
      return crypto_1.crypto.randomBytes(bytesLength);
    }
    throw new Error("crypto.getRandomValues must be defined");
  }
})(utils$e);
Object.defineProperty(_md, "__esModule", { value: true });
_md.HashMD = void 0;
_md.setBigUint64 = setBigUint64;
_md.Chi = Chi;
_md.Maj = Maj;
var _assert_js_1$1 = _assert;
var utils_js_1$3 = utils$e;
function setBigUint64(view, byteOffset, value, isLE) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE);
  var _32n2 = BigInt(32);
  var _u32_max = BigInt(4294967295);
  var wh = Number(value >> _32n2 & _u32_max);
  var wl = Number(value & _u32_max);
  var h2 = isLE ? 4 : 0;
  var l2 = isLE ? 0 : 4;
  view.setUint32(byteOffset + h2, wh, isLE);
  view.setUint32(byteOffset + l2, wl, isLE);
}
function Chi(a2, b3, c3) {
  return a2 & b3 ^ ~a2 & c3;
}
function Maj(a2, b3, c3) {
  return a2 & b3 ^ a2 & c3 ^ b3 & c3;
}
var HashMD = function(_utils_js_1$3$Hash) {
  function HashMD2(blockLen, outputLen, padOffset, isLE) {
    var _this14;
    _classCallCheck2(this, HashMD2);
    _this14 = _callSuper(this, HashMD2);
    _this14.blockLen = blockLen;
    _this14.outputLen = outputLen;
    _this14.padOffset = padOffset;
    _this14.isLE = isLE;
    _this14.finished = false;
    _this14.length = 0;
    _this14.pos = 0;
    _this14.destroyed = false;
    _this14.buffer = new Uint8Array(blockLen);
    _this14.view = (0, utils_js_1$3.createView)(_this14.buffer);
    return _this14;
  }
  _inherits2(HashMD2, _utils_js_1$3$Hash);
  return _createClass(HashMD2, [{ key: "update", value: function update5(data) {
    (0, _assert_js_1$1.aexists)(this);
    var view = this.view, buffer2 = this.buffer, blockLen = this.blockLen;
    data = (0, utils_js_1$3.toBytes)(data);
    var len2 = data.length;
    for (var pos = 0; pos < len2; ) {
      var take = Math.min(blockLen - this.pos, len2 - pos);
      if (take === blockLen) {
        var dataView = (0, utils_js_1$3.createView)(data);
        for (; blockLen <= len2 - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer2.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  } }, { key: "digestInto", value: function digestInto(out) {
    (0, _assert_js_1$1.aexists)(this);
    (0, _assert_js_1$1.aoutput)(out, this);
    this.finished = true;
    var buffer2 = this.buffer, view = this.view, blockLen = this.blockLen, isLE = this.isLE;
    var pos = this.pos;
    buffer2[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (var _i13 = pos; _i13 < blockLen; _i13++)
      buffer2[_i13] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
    this.process(view, 0);
    var oview = (0, utils_js_1$3.createView)(out);
    var len2 = this.outputLen;
    if (len2 % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    var outLen = len2 / 4;
    var state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (var _i14 = 0; _i14 < outLen; _i14++)
      oview.setUint32(4 * _i14, state[_i14], isLE);
  } }, { key: "digest", value: function digest11() {
    var buffer2 = this.buffer, outputLen = this.outputLen;
    this.digestInto(buffer2);
    var res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  } }, { key: "_cloneInto", value: function _cloneInto(to) {
    var _to;
    to || (to = new this.constructor());
    (_to = to).set.apply(_to, _toConsumableArray(this.get()));
    var blockLen = this.blockLen, buffer2 = this.buffer, length3 = this.length, finished = this.finished, destroyed = this.destroyed, pos = this.pos;
    to.length = length3;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length3 % blockLen)
      to.buffer.set(buffer2);
    return to;
  } }]);
}(utils_js_1$3.Hash);
_md.HashMD = HashMD;
Object.defineProperty(sha256$8, "__esModule", { value: true });
sha256$8.sha224 = sha256$8.sha256 = sha256$8.SHA256 = void 0;
var _md_js_1$1 = _md;
var utils_js_1$2 = utils$e;
var SHA256_K = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
var SHA256_IV = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var SHA256_W = new Uint32Array(64);
var SHA256$2 = function(_md_js_1$1$HashMD) {
  function SHA2562() {
    var _this15;
    _classCallCheck2(this, SHA2562);
    _this15 = _callSuper(this, SHA2562, [64, 32, 8, false]);
    _this15.A = SHA256_IV[0] | 0;
    _this15.B = SHA256_IV[1] | 0;
    _this15.C = SHA256_IV[2] | 0;
    _this15.D = SHA256_IV[3] | 0;
    _this15.E = SHA256_IV[4] | 0;
    _this15.F = SHA256_IV[5] | 0;
    _this15.G = SHA256_IV[6] | 0;
    _this15.H = SHA256_IV[7] | 0;
    return _this15;
  }
  _inherits2(SHA2562, _md_js_1$1$HashMD);
  return _createClass(SHA2562, [{
    key: "get",
    value: function get5() {
      var A2 = this.A, B2 = this.B, C3 = this.C, D3 = this.D, E2 = this.E, F2 = this.F, G2 = this.G, H2 = this.H;
      return [A2, B2, C3, D3, E2, F2, G2, H2];
    }
    // prettier-ignore
  }, { key: "set", value: function set(A2, B2, C3, D3, E2, F2, G2, H2) {
    this.A = A2 | 0;
    this.B = B2 | 0;
    this.C = C3 | 0;
    this.D = D3 | 0;
    this.E = E2 | 0;
    this.F = F2 | 0;
    this.G = G2 | 0;
    this.H = H2 | 0;
  } }, { key: "process", value: function process2(view, offset) {
    for (var _i15 = 0; _i15 < 16; _i15++, offset += 4)
      SHA256_W[_i15] = view.getUint32(offset, false);
    for (var _i16 = 16; _i16 < 64; _i16++) {
      var W15 = SHA256_W[_i16 - 15];
      var W2 = SHA256_W[_i16 - 2];
      var s0 = (0, utils_js_1$2.rotr)(W15, 7) ^ (0, utils_js_1$2.rotr)(W15, 18) ^ W15 >>> 3;
      var s1 = (0, utils_js_1$2.rotr)(W2, 17) ^ (0, utils_js_1$2.rotr)(W2, 19) ^ W2 >>> 10;
      SHA256_W[_i16] = s1 + SHA256_W[_i16 - 7] + s0 + SHA256_W[_i16 - 16] | 0;
    }
    var A2 = this.A, B2 = this.B, C3 = this.C, D3 = this.D, E2 = this.E, F2 = this.F, G2 = this.G, H2 = this.H;
    for (var _i17 = 0; _i17 < 64; _i17++) {
      var sigma1 = (0, utils_js_1$2.rotr)(E2, 6) ^ (0, utils_js_1$2.rotr)(E2, 11) ^ (0, utils_js_1$2.rotr)(E2, 25);
      var T1 = H2 + sigma1 + (0, _md_js_1$1.Chi)(E2, F2, G2) + SHA256_K[_i17] + SHA256_W[_i17] | 0;
      var sigma0 = (0, utils_js_1$2.rotr)(A2, 2) ^ (0, utils_js_1$2.rotr)(A2, 13) ^ (0, utils_js_1$2.rotr)(A2, 22);
      var T22 = sigma0 + (0, _md_js_1$1.Maj)(A2, B2, C3) | 0;
      H2 = G2;
      G2 = F2;
      F2 = E2;
      E2 = D3 + T1 | 0;
      D3 = C3;
      C3 = B2;
      B2 = A2;
      A2 = T1 + T22 | 0;
    }
    A2 = A2 + this.A | 0;
    B2 = B2 + this.B | 0;
    C3 = C3 + this.C | 0;
    D3 = D3 + this.D | 0;
    E2 = E2 + this.E | 0;
    F2 = F2 + this.F | 0;
    G2 = G2 + this.G | 0;
    H2 = H2 + this.H | 0;
    this.set(A2, B2, C3, D3, E2, F2, G2, H2);
  } }, { key: "roundClean", value: function roundClean() {
    SHA256_W.fill(0);
  } }, { key: "destroy", value: function destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  } }]);
}(_md_js_1$1.HashMD);
sha256$8.SHA256 = SHA256$2;
var SHA224$1 = function(_SHA256$) {
  function SHA2242() {
    var _this16;
    _classCallCheck2(this, SHA2242);
    _this16 = _callSuper(this, SHA2242);
    _this16.A = 3238371032 | 0;
    _this16.B = 914150663 | 0;
    _this16.C = 812702999 | 0;
    _this16.D = 4144912697 | 0;
    _this16.E = 4290775857 | 0;
    _this16.F = 1750603025 | 0;
    _this16.G = 1694076839 | 0;
    _this16.H = 3204075428 | 0;
    _this16.outputLen = 28;
    return _this16;
  }
  _inherits2(SHA2242, _SHA256$);
  return _createClass(SHA2242);
}(SHA256$2);
sha256$8.sha256 = (0, utils_js_1$2.wrapConstructor)(function() {
  return new SHA256$2();
});
sha256$8.sha224 = (0, utils_js_1$2.wrapConstructor)(function() {
  return new SHA224$1();
});
var sha512$7 = {};
var _u64 = {};
Object.defineProperty(_u64, "__esModule", { value: true });
_u64.add5L = _u64.add5H = _u64.add4H = _u64.add4L = _u64.add3H = _u64.add3L = _u64.rotlBL = _u64.rotlBH = _u64.rotlSL = _u64.rotlSH = _u64.rotr32L = _u64.rotr32H = _u64.rotrBL = _u64.rotrBH = _u64.rotrSL = _u64.rotrSH = _u64.shrSL = _u64.shrSH = _u64.toBig = void 0;
_u64.fromBig = fromBig;
_u64.split = split;
_u64.add = add$2;
var U32_MASK64 = BigInt(Math.pow(2, 32) - 1);
var _32n = BigInt(32);
function fromBig(n2) {
  var le = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  if (le)
    return { h: Number(n2 & U32_MASK64), l: Number(n2 >> _32n & U32_MASK64) };
  return { h: Number(n2 >> _32n & U32_MASK64) | 0, l: Number(n2 & U32_MASK64) | 0 };
}
function split(lst) {
  var le = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var Ah = new Uint32Array(lst.length);
  var Al = new Uint32Array(lst.length);
  for (var _i18 = 0; _i18 < lst.length; _i18++) {
    var _fromBig = fromBig(lst[_i18], le), _h3 = _fromBig.h, _l4 = _fromBig.l;
    var _ref35 = [_h3, _l4];
    Ah[_i18] = _ref35[0];
    Al[_i18] = _ref35[1];
  }
  return [Ah, Al];
}
var toBig = function toBig2(h2, l2) {
  return BigInt(h2 >>> 0) << _32n | BigInt(l2 >>> 0);
};
_u64.toBig = toBig;
var shrSH = function shrSH2(h2, _l, s2) {
  return h2 >>> s2;
};
_u64.shrSH = shrSH;
var shrSL = function shrSL2(h2, l2, s2) {
  return h2 << 32 - s2 | l2 >>> s2;
};
_u64.shrSL = shrSL;
var rotrSH = function rotrSH2(h2, l2, s2) {
  return h2 >>> s2 | l2 << 32 - s2;
};
_u64.rotrSH = rotrSH;
var rotrSL = function rotrSL2(h2, l2, s2) {
  return h2 << 32 - s2 | l2 >>> s2;
};
_u64.rotrSL = rotrSL;
var rotrBH = function rotrBH2(h2, l2, s2) {
  return h2 << 64 - s2 | l2 >>> s2 - 32;
};
_u64.rotrBH = rotrBH;
var rotrBL = function rotrBL2(h2, l2, s2) {
  return h2 >>> s2 - 32 | l2 << 64 - s2;
};
_u64.rotrBL = rotrBL;
var rotr32H = function rotr32H2(_h, l2) {
  return l2;
};
_u64.rotr32H = rotr32H;
var rotr32L = function rotr32L2(h2, _l) {
  return h2;
};
_u64.rotr32L = rotr32L;
var rotlSH = function rotlSH2(h2, l2, s2) {
  return h2 << s2 | l2 >>> 32 - s2;
};
_u64.rotlSH = rotlSH;
var rotlSL = function rotlSL2(h2, l2, s2) {
  return l2 << s2 | h2 >>> 32 - s2;
};
_u64.rotlSL = rotlSL;
var rotlBH = function rotlBH2(h2, l2, s2) {
  return l2 << s2 - 32 | h2 >>> 64 - s2;
};
_u64.rotlBH = rotlBH;
var rotlBL = function rotlBL2(h2, l2, s2) {
  return h2 << s2 - 32 | l2 >>> 64 - s2;
};
_u64.rotlBL = rotlBL;
function add$2(Ah, Al, Bh, Bl) {
  var l2 = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l2 / Math.pow(2, 32) | 0) | 0, l: l2 | 0 };
}
var add3L = function add3L2(Al, Bl, Cl) {
  return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
};
_u64.add3L = add3L;
var add3H = function add3H2(low, Ah, Bh, Ch) {
  return Ah + Bh + Ch + (low / Math.pow(2, 32) | 0) | 0;
};
_u64.add3H = add3H;
var add4L = function add4L2(Al, Bl, Cl, Dl) {
  return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
};
_u64.add4L = add4L;
var add4H = function add4H2(low, Ah, Bh, Ch, Dh) {
  return Ah + Bh + Ch + Dh + (low / Math.pow(2, 32) | 0) | 0;
};
_u64.add4H = add4H;
var add5L = function add5L2(Al, Bl, Cl, Dl, El) {
  return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
};
_u64.add5L = add5L;
var add5H = function add5H2(low, Ah, Bh, Ch, Dh, Eh) {
  return Ah + Bh + Ch + Dh + Eh + (low / Math.pow(2, 32) | 0) | 0;
};
_u64.add5H = add5H;
var u64 = { fromBig, split, toBig, shrSH, shrSL, rotrSH, rotrSL, rotrBH, rotrBL, rotr32H, rotr32L, rotlSH, rotlSL, rotlBH, rotlBL, add: add$2, add3L, add3H, add4L, add4H, add5H, add5L };
_u64.default = u64;
Object.defineProperty(sha512$7, "__esModule", { value: true });
sha512$7.sha384 = sha512$7.sha512_256 = sha512$7.sha512_224 = sha512$7.sha512 = sha512$7.SHA384 = sha512$7.SHA512_256 = sha512$7.SHA512_224 = sha512$7.SHA512 = void 0;
var _md_js_1 = _md;
var _u64_js_1 = _u64;
var utils_js_1$1 = utils$e;
var _ref36 = function() {
  return _u64_js_1.default.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map(function(n2) {
    return BigInt(n2);
  }));
}();
var _ref37 = _slicedToArray(_ref36, 2);
var SHA512_Kh = _ref37[0];
var SHA512_Kl = _ref37[1];
var SHA512_W_H = new Uint32Array(80);
var SHA512_W_L = new Uint32Array(80);
var SHA512$2 = function(_md_js_1$HashMD) {
  function SHA5122() {
    var _this17;
    _classCallCheck2(this, SHA5122);
    _this17 = _callSuper(this, SHA5122, [128, 64, 16, false]);
    _this17.Ah = 1779033703 | 0;
    _this17.Al = 4089235720 | 0;
    _this17.Bh = 3144134277 | 0;
    _this17.Bl = 2227873595 | 0;
    _this17.Ch = 1013904242 | 0;
    _this17.Cl = 4271175723 | 0;
    _this17.Dh = 2773480762 | 0;
    _this17.Dl = 1595750129 | 0;
    _this17.Eh = 1359893119 | 0;
    _this17.El = 2917565137 | 0;
    _this17.Fh = 2600822924 | 0;
    _this17.Fl = 725511199 | 0;
    _this17.Gh = 528734635 | 0;
    _this17.Gl = 4215389547 | 0;
    _this17.Hh = 1541459225 | 0;
    _this17.Hl = 327033209 | 0;
    return _this17;
  }
  _inherits2(SHA5122, _md_js_1$HashMD);
  return _createClass(SHA5122, [{
    key: "get",
    value: function get5() {
      var Ah = this.Ah, Al = this.Al, Bh = this.Bh, Bl = this.Bl, Ch = this.Ch, Cl = this.Cl, Dh = this.Dh, Dl = this.Dl, Eh = this.Eh, El = this.El, Fh = this.Fh, Fl = this.Fl, Gh = this.Gh, Gl = this.Gl, Hh = this.Hh, Hl = this.Hl;
      return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
  }, { key: "set", value: function set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  } }, { key: "process", value: function process2(view, offset) {
    for (var _i19 = 0; _i19 < 16; _i19++, offset += 4) {
      SHA512_W_H[_i19] = view.getUint32(offset);
      SHA512_W_L[_i19] = view.getUint32(offset += 4);
    }
    for (var _i20 = 16; _i20 < 80; _i20++) {
      var W15h = SHA512_W_H[_i20 - 15] | 0;
      var W15l = SHA512_W_L[_i20 - 15] | 0;
      var s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
      var s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
      var W2h = SHA512_W_H[_i20 - 2] | 0;
      var W2l = SHA512_W_L[_i20 - 2] | 0;
      var s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
      var s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
      var SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L[_i20 - 7], SHA512_W_L[_i20 - 16]);
      var SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H[_i20 - 7], SHA512_W_H[_i20 - 16]);
      SHA512_W_H[_i20] = SUMh | 0;
      SHA512_W_L[_i20] = SUMl | 0;
    }
    var Ah = this.Ah, Al = this.Al, Bh = this.Bh, Bl = this.Bl, Ch = this.Ch, Cl = this.Cl, Dh = this.Dh, Dl = this.Dl, Eh = this.Eh, El = this.El, Fh = this.Fh, Fl = this.Fl, Gh = this.Gh, Gl = this.Gl, Hh = this.Hh, Hl = this.Hl;
    for (var _i21 = 0; _i21 < 80; _i21++) {
      var sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);
      var sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);
      var CHIh = Eh & Fh ^ ~Eh & Gh;
      var CHIl = El & Fl ^ ~El & Gl;
      var T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[_i21], SHA512_W_L[_i21]);
      var T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[_i21], SHA512_W_H[_i21]);
      var T1l = T1ll | 0;
      var sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);
      var sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);
      var MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      var MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      var _u64_js_1$default$add = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0);
      Eh = _u64_js_1$default$add.h;
      El = _u64_js_1$default$add.l;
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      var All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
      Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    var _u64_js_1$default$add2 = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0);
    Ah = _u64_js_1$default$add2.h;
    Al = _u64_js_1$default$add2.l;
    var _u64_js_1$default$add3 = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0);
    Bh = _u64_js_1$default$add3.h;
    Bl = _u64_js_1$default$add3.l;
    var _u64_js_1$default$add4 = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0);
    Ch = _u64_js_1$default$add4.h;
    Cl = _u64_js_1$default$add4.l;
    var _u64_js_1$default$add5 = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0);
    Dh = _u64_js_1$default$add5.h;
    Dl = _u64_js_1$default$add5.l;
    var _u64_js_1$default$add6 = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0);
    Eh = _u64_js_1$default$add6.h;
    El = _u64_js_1$default$add6.l;
    var _u64_js_1$default$add7 = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0);
    Fh = _u64_js_1$default$add7.h;
    Fl = _u64_js_1$default$add7.l;
    var _u64_js_1$default$add8 = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0);
    Gh = _u64_js_1$default$add8.h;
    Gl = _u64_js_1$default$add8.l;
    var _u64_js_1$default$add9 = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0);
    Hh = _u64_js_1$default$add9.h;
    Hl = _u64_js_1$default$add9.l;
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  } }, { key: "roundClean", value: function roundClean() {
    SHA512_W_H.fill(0);
    SHA512_W_L.fill(0);
  } }, { key: "destroy", value: function destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  } }]);
}(_md_js_1.HashMD);
sha512$7.SHA512 = SHA512$2;
var SHA512_224 = function(_SHA512$) {
  function SHA512_2242() {
    var _this18;
    _classCallCheck2(this, SHA512_2242);
    _this18 = _callSuper(this, SHA512_2242);
    _this18.Ah = 2352822216 | 0;
    _this18.Al = 424955298 | 0;
    _this18.Bh = 1944164710 | 0;
    _this18.Bl = 2312950998 | 0;
    _this18.Ch = 502970286 | 0;
    _this18.Cl = 855612546 | 0;
    _this18.Dh = 1738396948 | 0;
    _this18.Dl = 1479516111 | 0;
    _this18.Eh = 258812777 | 0;
    _this18.El = 2077511080 | 0;
    _this18.Fh = 2011393907 | 0;
    _this18.Fl = 79989058 | 0;
    _this18.Gh = 1067287976 | 0;
    _this18.Gl = 1780299464 | 0;
    _this18.Hh = 286451373 | 0;
    _this18.Hl = 2446758561 | 0;
    _this18.outputLen = 28;
    return _this18;
  }
  _inherits2(SHA512_2242, _SHA512$);
  return _createClass(SHA512_2242);
}(SHA512$2);
sha512$7.SHA512_224 = SHA512_224;
var SHA512_256 = function(_SHA512$2) {
  function SHA512_2562() {
    var _this19;
    _classCallCheck2(this, SHA512_2562);
    _this19 = _callSuper(this, SHA512_2562);
    _this19.Ah = 573645204 | 0;
    _this19.Al = 4230739756 | 0;
    _this19.Bh = 2673172387 | 0;
    _this19.Bl = 3360449730 | 0;
    _this19.Ch = 596883563 | 0;
    _this19.Cl = 1867755857 | 0;
    _this19.Dh = 2520282905 | 0;
    _this19.Dl = 1497426621 | 0;
    _this19.Eh = 2519219938 | 0;
    _this19.El = 2827943907 | 0;
    _this19.Fh = 3193839141 | 0;
    _this19.Fl = 1401305490 | 0;
    _this19.Gh = 721525244 | 0;
    _this19.Gl = 746961066 | 0;
    _this19.Hh = 246885852 | 0;
    _this19.Hl = 2177182882 | 0;
    _this19.outputLen = 32;
    return _this19;
  }
  _inherits2(SHA512_2562, _SHA512$2);
  return _createClass(SHA512_2562);
}(SHA512$2);
sha512$7.SHA512_256 = SHA512_256;
var SHA384$1 = function(_SHA512$3) {
  function SHA3842() {
    var _this20;
    _classCallCheck2(this, SHA3842);
    _this20 = _callSuper(this, SHA3842);
    _this20.Ah = 3418070365 | 0;
    _this20.Al = 3238371032 | 0;
    _this20.Bh = 1654270250 | 0;
    _this20.Bl = 914150663 | 0;
    _this20.Ch = 2438529370 | 0;
    _this20.Cl = 812702999 | 0;
    _this20.Dh = 355462360 | 0;
    _this20.Dl = 4144912697 | 0;
    _this20.Eh = 1731405415 | 0;
    _this20.El = 4290775857 | 0;
    _this20.Fh = 2394180231 | 0;
    _this20.Fl = 1750603025 | 0;
    _this20.Gh = 3675008525 | 0;
    _this20.Gl = 1694076839 | 0;
    _this20.Hh = 1203062813 | 0;
    _this20.Hl = 3204075428 | 0;
    _this20.outputLen = 48;
    return _this20;
  }
  _inherits2(SHA3842, _SHA512$3);
  return _createClass(SHA3842);
}(SHA512$2);
sha512$7.SHA384 = SHA384$1;
sha512$7.sha512 = (0, utils_js_1$1.wrapConstructor)(function() {
  return new SHA512$2();
});
sha512$7.sha512_224 = (0, utils_js_1$1.wrapConstructor)(function() {
  return new SHA512_224();
});
sha512$7.sha512_256 = (0, utils_js_1$1.wrapConstructor)(function() {
  return new SHA512_256();
});
sha512$7.sha384 = (0, utils_js_1$1.wrapConstructor)(function() {
  return new SHA384$1();
});
var pbkdf2$5 = {};
var hmac$4 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hmac = exports.HMAC = void 0;
  var _assert_js_12 = _assert;
  var utils_js_12 = utils$e;
  var HMAC = function(_utils_js_1$Hash) {
    function HMAC2(hash2, _key) {
      var _this21;
      _classCallCheck2(this, HMAC2);
      _this21 = _callSuper(this, HMAC2);
      _this21.finished = false;
      _this21.destroyed = false;
      (0, _assert_js_12.ahash)(hash2);
      var key3 = (0, utils_js_12.toBytes)(_key);
      _this21.iHash = hash2.create();
      if (typeof _this21.iHash.update !== "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      _this21.blockLen = _this21.iHash.blockLen;
      _this21.outputLen = _this21.iHash.outputLen;
      var blockLen = _this21.blockLen;
      var pad2 = new Uint8Array(blockLen);
      pad2.set(key3.length > blockLen ? hash2.create().update(key3).digest() : key3);
      for (var _i22 = 0; _i22 < pad2.length; _i22++)
        pad2[_i22] ^= 54;
      _this21.iHash.update(pad2);
      _this21.oHash = hash2.create();
      for (var _i23 = 0; _i23 < pad2.length; _i23++)
        pad2[_i23] ^= 54 ^ 92;
      _this21.oHash.update(pad2);
      pad2.fill(0);
      return _this21;
    }
    _inherits2(HMAC2, _utils_js_1$Hash);
    return _createClass(HMAC2, [{ key: "update", value: function update5(buf) {
      (0, _assert_js_12.aexists)(this);
      this.iHash.update(buf);
      return this;
    } }, { key: "digestInto", value: function digestInto(out) {
      (0, _assert_js_12.aexists)(this);
      (0, _assert_js_12.abytes)(out, this.outputLen);
      this.finished = true;
      this.iHash.digestInto(out);
      this.oHash.update(out);
      this.oHash.digestInto(out);
      this.destroy();
    } }, { key: "digest", value: function digest11() {
      var out = new Uint8Array(this.oHash.outputLen);
      this.digestInto(out);
      return out;
    } }, { key: "_cloneInto", value: function _cloneInto(to) {
      to || (to = Object.create(Object.getPrototypeOf(this), {}));
      var oHash = this.oHash, iHash = this.iHash, finished = this.finished, destroyed = this.destroyed, blockLen = this.blockLen, outputLen = this.outputLen;
      to = to;
      to.finished = finished;
      to.destroyed = destroyed;
      to.blockLen = blockLen;
      to.outputLen = outputLen;
      to.oHash = oHash._cloneInto(to.oHash);
      to.iHash = iHash._cloneInto(to.iHash);
      return to;
    } }, { key: "destroy", value: function destroy() {
      this.destroyed = true;
      this.oHash.destroy();
      this.iHash.destroy();
    } }]);
  }(utils_js_12.Hash);
  exports.HMAC = HMAC;
  var hmac3 = function hmac4(hash2, key3, message) {
    return new HMAC(hash2, key3).update(message).digest();
  };
  exports.hmac = hmac3;
  exports.hmac.create = function(hash2, key3) {
    return new HMAC(hash2, key3);
  };
})(hmac$4);
Object.defineProperty(pbkdf2$5, "__esModule", { value: true });
pbkdf2$5.pbkdf2 = pbkdf2$4;
pbkdf2$5.pbkdf2Async = pbkdf2Async;
var _assert_js_1 = _assert;
var hmac_js_1 = hmac$4;
var utils_js_1 = utils$e;
function pbkdf2Init(hash2, _password, _salt, _opts) {
  (0, _assert_js_1.ahash)(hash2);
  var opts = (0, utils_js_1.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);
  var c3 = opts.c, dkLen = opts.dkLen, asyncTick = opts.asyncTick;
  (0, _assert_js_1.anumber)(c3);
  (0, _assert_js_1.anumber)(dkLen);
  (0, _assert_js_1.anumber)(asyncTick);
  if (c3 < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  var password = (0, utils_js_1.toBytes)(_password);
  var salt2 = (0, utils_js_1.toBytes)(_salt);
  var DK = new Uint8Array(dkLen);
  var PRF = hmac_js_1.hmac.create(hash2, password);
  var PRFSalt = PRF._cloneInto().update(salt2);
  return { c: c3, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u2) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  u2.fill(0);
  return DK;
}
function pbkdf2$4(hash2, password, salt2, opts) {
  var _pbkdf2Init = pbkdf2Init(hash2, password, salt2, opts), c3 = _pbkdf2Init.c, dkLen = _pbkdf2Init.dkLen, DK = _pbkdf2Init.DK, PRF = _pbkdf2Init.PRF, PRFSalt = _pbkdf2Init.PRFSalt;
  var prfW;
  var arr = new Uint8Array(4);
  var view = (0, utils_js_1.createView)(arr);
  var u2 = new Uint8Array(PRF.outputLen);
  for (var ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    var Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u2);
    Ti.set(u2.subarray(0, Ti.length));
    for (var ui = 1; ui < c3; ui++) {
      PRF._cloneInto(prfW).update(u2).digestInto(u2);
      for (var _i24 = 0; _i24 < Ti.length; _i24++)
        Ti[_i24] ^= u2[_i24];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u2);
}
function pbkdf2Async(_x65, _x66, _x67, _x68) {
  return _pbkdf2Async.apply(this, arguments);
}
function _pbkdf2Async() {
  _pbkdf2Async = _asyncToGenerator(_regeneratorRuntime().mark(function _callee217(hash2, password, salt2, opts) {
    var _pbkdf2Init2, c3, dkLen, asyncTick, DK, PRF, PRFSalt, prfW, arr, view, u2, _loop2, ti, pos;
    return _regeneratorRuntime().wrap(function _callee217$(_context219) {
      while (1)
        switch (_context219.prev = _context219.next) {
          case 0:
            _pbkdf2Init2 = pbkdf2Init(hash2, password, salt2, opts), c3 = _pbkdf2Init2.c, dkLen = _pbkdf2Init2.dkLen, asyncTick = _pbkdf2Init2.asyncTick, DK = _pbkdf2Init2.DK, PRF = _pbkdf2Init2.PRF, PRFSalt = _pbkdf2Init2.PRFSalt;
            arr = new Uint8Array(4);
            view = (0, utils_js_1.createView)(arr);
            u2 = new Uint8Array(PRF.outputLen);
            _loop2 = _regeneratorRuntime().mark(function _loop22() {
              var Ti;
              return _regeneratorRuntime().wrap(function _loop2$(_context218) {
                while (1)
                  switch (_context218.prev = _context218.next) {
                    case 0:
                      Ti = DK.subarray(pos, pos + PRF.outputLen);
                      view.setInt32(0, ti, false);
                      (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u2);
                      Ti.set(u2.subarray(0, Ti.length));
                      _context218.next = 6;
                      return (0, utils_js_1.asyncLoop)(c3 - 1, asyncTick, function() {
                        PRF._cloneInto(prfW).update(u2).digestInto(u2);
                        for (var _i78 = 0; _i78 < Ti.length; _i78++)
                          Ti[_i78] ^= u2[_i78];
                      });
                    case 6:
                    case "end":
                      return _context218.stop();
                  }
              }, _loop22);
            });
            ti = 1, pos = 0;
          case 6:
            if (!(pos < dkLen)) {
              _context219.next = 11;
              break;
            }
            return _context219.delegateYield(_loop2(), "t0", 8);
          case 8:
            ti++, pos += PRF.outputLen;
            _context219.next = 6;
            break;
          case 11:
            return _context219.abrupt("return", pbkdf2Output(PRF, PRFSalt, DK, prfW, u2));
          case 12:
          case "end":
            return _context219.stop();
        }
    }, _callee217);
  }));
  return _pbkdf2Async.apply(this, arguments);
}
var _wordlists = {};
var require$$0$5 = ["abdikace", "abeceda", "adresa", "agrese", "akce", "aktovka", "alej", "alkohol", "amputace", "ananas", "andulka", "anekdota", "anketa", "antika", "anulovat", "archa", "arogance", "asfalt", "asistent", "aspirace", "astma", "astronom", "atlas", "atletika", "atol", "autobus", "azyl", "babka", "bachor", "bacil", "baculka", "badatel", "bageta", "bagr", "bahno", "bakterie", "balada", "baletka", "balkon", "balonek", "balvan", "balza", "bambus", "bankomat", "barbar", "baret", "barman", "baroko", "barva", "baterka", "batoh", "bavlna", "bazalka", "bazilika", "bazuka", "bedna", "beran", "beseda", "bestie", "beton", "bezinka", "bezmoc", "beztak", "bicykl", "bidlo", "biftek", "bikiny", "bilance", "biograf", "biolog", "bitva", "bizon", "blahobyt", "blatouch", "blecha", "bledule", "blesk", "blikat", "blizna", "blokovat", "bloudit", "blud", "bobek", "bobr", "bodlina", "bodnout", "bohatost", "bojkot", "bojovat", "bokorys", "bolest", "borec", "borovice", "bota", "boubel", "bouchat", "bouda", "boule", "bourat", "boxer", "bradavka", "brambora", "branka", "bratr", "brepta", "briketa", "brko", "brloh", "bronz", "broskev", "brunetka", "brusinka", "brzda", "brzy", "bublina", "bubnovat", "buchta", "buditel", "budka", "budova", "bufet", "bujarost", "bukvice", "buldok", "bulva", "bunda", "bunkr", "burza", "butik", "buvol", "buzola", "bydlet", "bylina", "bytovka", "bzukot", "capart", "carevna", "cedr", "cedule", "cejch", "cejn", "cela", "celer", "celkem", "celnice", "cenina", "cennost", "cenovka", "centrum", "cenzor", "cestopis", "cetka", "chalupa", "chapadlo", "charita", "chata", "chechtat", "chemie", "chichot", "chirurg", "chlad", "chleba", "chlubit", "chmel", "chmura", "chobot", "chochol", "chodba", "cholera", "chomout", "chopit", "choroba", "chov", "chrapot", "chrlit", "chrt", "chrup", "chtivost", "chudina", "chutnat", "chvat", "chvilka", "chvost", "chyba", "chystat", "chytit", "cibule", "cigareta", "cihelna", "cihla", "cinkot", "cirkus", "cisterna", "citace", "citrus", "cizinec", "cizost", "clona", "cokoliv", "couvat", "ctitel", "ctnost", "cudnost", "cuketa", "cukr", "cupot", "cvaknout", "cval", "cvik", "cvrkot", "cyklista", "daleko", "dareba", "datel", "datum", "dcera", "debata", "dechovka", "decibel", "deficit", "deflace", "dekl", "dekret", "demokrat", "deprese", "derby", "deska", "detektiv", "dikobraz", "diktovat", "dioda", "diplom", "disk", "displej", "divadlo", "divoch", "dlaha", "dlouho", "dluhopis", "dnes", "dobro", "dobytek", "docent", "dochutit", "dodnes", "dohled", "dohoda", "dohra", "dojem", "dojnice", "doklad", "dokola", "doktor", "dokument", "dolar", "doleva", "dolina", "doma", "dominant", "domluvit", "domov", "donutit", "dopad", "dopis", "doplnit", "doposud", "doprovod", "dopustit", "dorazit", "dorost", "dort", "dosah", "doslov", "dostatek", "dosud", "dosyta", "dotaz", "dotek", "dotknout", "doufat", "doutnat", "dovozce", "dozadu", "doznat", "dozorce", "drahota", "drak", "dramatik", "dravec", "draze", "drdol", "drobnost", "drogerie", "drozd", "drsnost", "drtit", "drzost", "duben", "duchovno", "dudek", "duha", "duhovka", "dusit", "dusno", "dutost", "dvojice", "dvorec", "dynamit", "ekolog", "ekonomie", "elektron", "elipsa", "email", "emise", "emoce", "empatie", "epizoda", "epocha", "epopej", "epos", "esej", "esence", "eskorta", "eskymo", "etiketa", "euforie", "evoluce", "exekuce", "exkurze", "expedice", "exploze", "export", "extrakt", "facka", "fajfka", "fakulta", "fanatik", "fantazie", "farmacie", "favorit", "fazole", "federace", "fejeton", "fenka", "fialka", "figurant", "filozof", "filtr", "finance", "finta", "fixace", "fjord", "flanel", "flirt", "flotila", "fond", "fosfor", "fotbal", "fotka", "foton", "frakce", "freska", "fronta", "fukar", "funkce", "fyzika", "galeje", "garant", "genetika", "geolog", "gilotina", "glazura", "glejt", "golem", "golfista", "gotika", "graf", "gramofon", "granule", "grep", "gril", "grog", "groteska", "guma", "hadice", "hadr", "hala", "halenka", "hanba", "hanopis", "harfa", "harpuna", "havran", "hebkost", "hejkal", "hejno", "hejtman", "hektar", "helma", "hematom", "herec", "herna", "heslo", "hezky", "historik", "hladovka", "hlasivky", "hlava", "hledat", "hlen", "hlodavec", "hloh", "hloupost", "hltat", "hlubina", "hluchota", "hmat", "hmota", "hmyz", "hnis", "hnojivo", "hnout", "hoblina", "hoboj", "hoch", "hodiny", "hodlat", "hodnota", "hodovat", "hojnost", "hokej", "holinka", "holka", "holub", "homole", "honitba", "honorace", "horal", "horda", "horizont", "horko", "horlivec", "hormon", "hornina", "horoskop", "horstvo", "hospoda", "hostina", "hotovost", "houba", "houf", "houpat", "houska", "hovor", "hradba", "hranice", "hravost", "hrazda", "hrbolek", "hrdina", "hrdlo", "hrdost", "hrnek", "hrobka", "hromada", "hrot", "hrouda", "hrozen", "hrstka", "hrubost", "hryzat", "hubenost", "hubnout", "hudba", "hukot", "humr", "husita", "hustota", "hvozd", "hybnost", "hydrant", "hygiena", "hymna", "hysterik", "idylka", "ihned", "ikona", "iluze", "imunita", "infekce", "inflace", "inkaso", "inovace", "inspekce", "internet", "invalida", "investor", "inzerce", "ironie", "jablko", "jachta", "jahoda", "jakmile", "jakost", "jalovec", "jantar", "jarmark", "jaro", "jasan", "jasno", "jatka", "javor", "jazyk", "jedinec", "jedle", "jednatel", "jehlan", "jekot", "jelen", "jelito", "jemnost", "jenom", "jepice", "jeseter", "jevit", "jezdec", "jezero", "jinak", "jindy", "jinoch", "jiskra", "jistota", "jitrnice", "jizva", "jmenovat", "jogurt", "jurta", "kabaret", "kabel", "kabinet", "kachna", "kadet", "kadidlo", "kahan", "kajak", "kajuta", "kakao", "kaktus", "kalamita", "kalhoty", "kalibr", "kalnost", "kamera", "kamkoliv", "kamna", "kanibal", "kanoe", "kantor", "kapalina", "kapela", "kapitola", "kapka", "kaple", "kapota", "kapr", "kapusta", "kapybara", "karamel", "karotka", "karton", "kasa", "katalog", "katedra", "kauce", "kauza", "kavalec", "kazajka", "kazeta", "kazivost", "kdekoliv", "kdesi", "kedluben", "kemp", "keramika", "kino", "klacek", "kladivo", "klam", "klapot", "klasika", "klaun", "klec", "klenba", "klepat", "klesnout", "klid", "klima", "klisna", "klobouk", "klokan", "klopa", "kloub", "klubovna", "klusat", "kluzkost", "kmen", "kmitat", "kmotr", "kniha", "knot", "koalice", "koberec", "kobka", "kobliha", "kobyla", "kocour", "kohout", "kojenec", "kokos", "koktejl", "kolaps", "koleda", "kolize", "kolo", "komando", "kometa", "komik", "komnata", "komora", "kompas", "komunita", "konat", "koncept", "kondice", "konec", "konfese", "kongres", "konina", "konkurs", "kontakt", "konzerva", "kopanec", "kopie", "kopnout", "koprovka", "korbel", "korektor", "kormidlo", "koroptev", "korpus", "koruna", "koryto", "korzet", "kosatec", "kostka", "kotel", "kotleta", "kotoul", "koukat", "koupelna", "kousek", "kouzlo", "kovboj", "koza", "kozoroh", "krabice", "krach", "krajina", "kralovat", "krasopis", "kravata", "kredit", "krejcar", "kresba", "kreveta", "kriket", "kritik", "krize", "krkavec", "krmelec", "krmivo", "krocan", "krok", "kronika", "kropit", "kroupa", "krovka", "krtek", "kruhadlo", "krupice", "krutost", "krvinka", "krychle", "krypta", "krystal", "kryt", "kudlanka", "kufr", "kujnost", "kukla", "kulajda", "kulich", "kulka", "kulomet", "kultura", "kuna", "kupodivu", "kurt", "kurzor", "kutil", "kvalita", "kvasinka", "kvestor", "kynolog", "kyselina", "kytara", "kytice", "kytka", "kytovec", "kyvadlo", "labrador", "lachtan", "ladnost", "laik", "lakomec", "lamela", "lampa", "lanovka", "lasice", "laso", "lastura", "latinka", "lavina", "lebka", "leckdy", "leden", "lednice", "ledovka", "ledvina", "legenda", "legie", "legrace", "lehce", "lehkost", "lehnout", "lektvar", "lenochod", "lentilka", "lepenka", "lepidlo", "letadlo", "letec", "letmo", "letokruh", "levhart", "levitace", "levobok", "libra", "lichotka", "lidojed", "lidskost", "lihovina", "lijavec", "lilek", "limetka", "linie", "linka", "linoleum", "listopad", "litina", "litovat", "lobista", "lodivod", "logika", "logoped", "lokalita", "loket", "lomcovat", "lopata", "lopuch", "lord", "losos", "lotr", "loudal", "louh", "louka", "louskat", "lovec", "lstivost", "lucerna", "lucifer", "lump", "lusk", "lustrace", "lvice", "lyra", "lyrika", "lysina", "madam", "madlo", "magistr", "mahagon", "majetek", "majitel", "majorita", "makak", "makovice", "makrela", "malba", "malina", "malovat", "malvice", "maminka", "mandle", "manko", "marnost", "masakr", "maskot", "masopust", "matice", "matrika", "maturita", "mazanec", "mazivo", "mazlit", "mazurka", "mdloba", "mechanik", "meditace", "medovina", "melasa", "meloun", "mentolka", "metla", "metoda", "metr", "mezera", "migrace", "mihnout", "mihule", "mikina", "mikrofon", "milenec", "milimetr", "milost", "mimika", "mincovna", "minibar", "minomet", "minulost", "miska", "mistr", "mixovat", "mladost", "mlha", "mlhovina", "mlok", "mlsat", "mluvit", "mnich", "mnohem", "mobil", "mocnost", "modelka", "modlitba", "mohyla", "mokro", "molekula", "momentka", "monarcha", "monokl", "monstrum", "montovat", "monzun", "mosaz", "moskyt", "most", "motivace", "motorka", "motyka", "moucha", "moudrost", "mozaika", "mozek", "mozol", "mramor", "mravenec", "mrkev", "mrtvola", "mrzet", "mrzutost", "mstitel", "mudrc", "muflon", "mulat", "mumie", "munice", "muset", "mutace", "muzeum", "muzikant", "myslivec", "mzda", "nabourat", "nachytat", "nadace", "nadbytek", "nadhoz", "nadobro", "nadpis", "nahlas", "nahnat", "nahodile", "nahradit", "naivita", "najednou", "najisto", "najmout", "naklonit", "nakonec", "nakrmit", "nalevo", "namazat", "namluvit", "nanometr", "naoko", "naopak", "naostro", "napadat", "napevno", "naplnit", "napnout", "naposled", "naprosto", "narodit", "naruby", "narychlo", "nasadit", "nasekat", "naslepo", "nastat", "natolik", "navenek", "navrch", "navzdory", "nazvat", "nebe", "nechat", "necky", "nedaleko", "nedbat", "neduh", "negace", "nehet", "nehoda", "nejen", "nejprve", "neklid", "nelibost", "nemilost", "nemoc", "neochota", "neonka", "nepokoj", "nerost", "nerv", "nesmysl", "nesoulad", "netvor", "neuron", "nevina", "nezvykle", "nicota", "nijak", "nikam", "nikdy", "nikl", "nikterak", "nitro", "nocleh", "nohavice", "nominace", "nora", "norek", "nositel", "nosnost", "nouze", "noviny", "novota", "nozdra", "nuda", "nudle", "nuget", "nutit", "nutnost", "nutrie", "nymfa", "obal", "obarvit", "obava", "obdiv", "obec", "obehnat", "obejmout", "obezita", "obhajoba", "obilnice", "objasnit", "objekt", "obklopit", "oblast", "oblek", "obliba", "obloha", "obluda", "obnos", "obohatit", "obojek", "obout", "obrazec", "obrna", "obruba", "obrys", "obsah", "obsluha", "obstarat", "obuv", "obvaz", "obvinit", "obvod", "obvykle", "obyvatel", "obzor", "ocas", "ocel", "ocenit", "ochladit", "ochota", "ochrana", "ocitnout", "odboj", "odbyt", "odchod", "odcizit", "odebrat", "odeslat", "odevzdat", "odezva", "odhadce", "odhodit", "odjet", "odjinud", "odkaz", "odkoupit", "odliv", "odluka", "odmlka", "odolnost", "odpad", "odpis", "odplout", "odpor", "odpustit", "odpykat", "odrazka", "odsoudit", "odstup", "odsun", "odtok", "odtud", "odvaha", "odveta", "odvolat", "odvracet", "odznak", "ofina", "ofsajd", "ohlas", "ohnisko", "ohrada", "ohrozit", "ohryzek", "okap", "okenice", "oklika", "okno", "okouzlit", "okovy", "okrasa", "okres", "okrsek", "okruh", "okupant", "okurka", "okusit", "olejnina", "olizovat", "omak", "omeleta", "omezit", "omladina", "omlouvat", "omluva", "omyl", "onehdy", "opakovat", "opasek", "operace", "opice", "opilost", "opisovat", "opora", "opozice", "opravdu", "oproti", "orbital", "orchestr", "orgie", "orlice", "orloj", "ortel", "osada", "oschnout", "osika", "osivo", "oslava", "oslepit", "oslnit", "oslovit", "osnova", "osoba", "osolit", "ospalec", "osten", "ostraha", "ostuda", "ostych", "osvojit", "oteplit", "otisk", "otop", "otrhat", "otrlost", "otrok", "otruby", "otvor", "ovanout", "ovar", "oves", "ovlivnit", "ovoce", "oxid", "ozdoba", "pachatel", "pacient", "padouch", "pahorek", "pakt", "palanda", "palec", "palivo", "paluba", "pamflet", "pamlsek", "panenka", "panika", "panna", "panovat", "panstvo", "pantofle", "paprika", "parketa", "parodie", "parta", "paruka", "paryba", "paseka", "pasivita", "pastelka", "patent", "patrona", "pavouk", "pazneht", "pazourek", "pecka", "pedagog", "pejsek", "peklo", "peloton", "penalta", "pendrek", "penze", "periskop", "pero", "pestrost", "petarda", "petice", "petrolej", "pevnina", "pexeso", "pianista", "piha", "pijavice", "pikle", "piknik", "pilina", "pilnost", "pilulka", "pinzeta", "pipeta", "pisatel", "pistole", "pitevna", "pivnice", "pivovar", "placenta", "plakat", "plamen", "planeta", "plastika", "platit", "plavidlo", "plaz", "plech", "plemeno", "plenta", "ples", "pletivo", "plevel", "plivat", "plnit", "plno", "plocha", "plodina", "plomba", "plout", "pluk", "plyn", "pobavit", "pobyt", "pochod", "pocit", "poctivec", "podat", "podcenit", "podepsat", "podhled", "podivit", "podklad", "podmanit", "podnik", "podoba", "podpora", "podraz", "podstata", "podvod", "podzim", "poezie", "pohanka", "pohnutka", "pohovor", "pohroma", "pohyb", "pointa", "pojistka", "pojmout", "pokazit", "pokles", "pokoj", "pokrok", "pokuta", "pokyn", "poledne", "polibek", "polknout", "poloha", "polynom", "pomalu", "pominout", "pomlka", "pomoc", "pomsta", "pomyslet", "ponechat", "ponorka", "ponurost", "popadat", "popel", "popisek", "poplach", "poprosit", "popsat", "popud", "poradce", "porce", "porod", "porucha", "poryv", "posadit", "posed", "posila", "poskok", "poslanec", "posoudit", "pospolu", "postava", "posudek", "posyp", "potah", "potkan", "potlesk", "potomek", "potrava", "potupa", "potvora", "poukaz", "pouto", "pouzdro", "povaha", "povidla", "povlak", "povoz", "povrch", "povstat", "povyk", "povzdech", "pozdrav", "pozemek", "poznatek", "pozor", "pozvat", "pracovat", "prahory", "praktika", "prales", "praotec", "praporek", "prase", "pravda", "princip", "prkno", "probudit", "procento", "prodej", "profese", "prohra", "projekt", "prolomit", "promile", "pronikat", "propad", "prorok", "prosba", "proton", "proutek", "provaz", "prskavka", "prsten", "prudkost", "prut", "prvek", "prvohory", "psanec", "psovod", "pstruh", "ptactvo", "puberta", "puch", "pudl", "pukavec", "puklina", "pukrle", "pult", "pumpa", "punc", "pupen", "pusa", "pusinka", "pustina", "putovat", "putyka", "pyramida", "pysk", "pytel", "racek", "rachot", "radiace", "radnice", "radon", "raft", "ragby", "raketa", "rakovina", "rameno", "rampouch", "rande", "rarach", "rarita", "rasovna", "rastr", "ratolest", "razance", "razidlo", "reagovat", "reakce", "recept", "redaktor", "referent", "reflex", "rejnok", "reklama", "rekord", "rekrut", "rektor", "reputace", "revize", "revma", "revolver", "rezerva", "riskovat", "riziko", "robotika", "rodokmen", "rohovka", "rokle", "rokoko", "romaneto", "ropovod", "ropucha", "rorejs", "rosol", "rostlina", "rotmistr", "rotoped", "rotunda", "roubenka", "roucho", "roup", "roura", "rovina", "rovnice", "rozbor", "rozchod", "rozdat", "rozeznat", "rozhodce", "rozinka", "rozjezd", "rozkaz", "rozloha", "rozmar", "rozpad", "rozruch", "rozsah", "roztok", "rozum", "rozvod", "rubrika", "ruchadlo", "rukavice", "rukopis", "ryba", "rybolov", "rychlost", "rydlo", "rypadlo", "rytina", "ryzost", "sadista", "sahat", "sako", "samec", "samizdat", "samota", "sanitka", "sardinka", "sasanka", "satelit", "sazba", "sazenice", "sbor", "schovat", "sebranka", "secese", "sedadlo", "sediment", "sedlo", "sehnat", "sejmout", "sekera", "sekta", "sekunda", "sekvoje", "semeno", "seno", "servis", "sesadit", "seshora", "seskok", "seslat", "sestra", "sesuv", "sesypat", "setba", "setina", "setkat", "setnout", "setrvat", "sever", "seznam", "shoda", "shrnout", "sifon", "silnice", "sirka", "sirotek", "sirup", "situace", "skafandr", "skalisko", "skanzen", "skaut", "skeptik", "skica", "skladba", "sklenice", "sklo", "skluz", "skoba", "skokan", "skoro", "skripta", "skrz", "skupina", "skvost", "skvrna", "slabika", "sladidlo", "slanina", "slast", "slavnost", "sledovat", "slepec", "sleva", "slezina", "slib", "slina", "sliznice", "slon", "sloupek", "slovo", "sluch", "sluha", "slunce", "slupka", "slza", "smaragd", "smetana", "smilstvo", "smlouva", "smog", "smrad", "smrk", "smrtka", "smutek", "smysl", "snad", "snaha", "snob", "sobota", "socha", "sodovka", "sokol", "sopka", "sotva", "souboj", "soucit", "soudce", "souhlas", "soulad", "soumrak", "souprava", "soused", "soutok", "souviset", "spalovna", "spasitel", "spis", "splav", "spodek", "spojenec", "spolu", "sponzor", "spornost", "spousta", "sprcha", "spustit", "sranda", "sraz", "srdce", "srna", "srnec", "srovnat", "srpen", "srst", "srub", "stanice", "starosta", "statika", "stavba", "stehno", "stezka", "stodola", "stolek", "stopa", "storno", "stoupat", "strach", "stres", "strhnout", "strom", "struna", "studna", "stupnice", "stvol", "styk", "subjekt", "subtropy", "suchar", "sudost", "sukno", "sundat", "sunout", "surikata", "surovina", "svah", "svalstvo", "svetr", "svatba", "svazek", "svisle", "svitek", "svoboda", "svodidlo", "svorka", "svrab", "sykavka", "sykot", "synek", "synovec", "sypat", "sypkost", "syrovost", "sysel", "sytost", "tabletka", "tabule", "tahoun", "tajemno", "tajfun", "tajga", "tajit", "tajnost", "taktika", "tamhle", "tampon", "tancovat", "tanec", "tanker", "tapeta", "tavenina", "tazatel", "technika", "tehdy", "tekutina", "telefon", "temnota", "tendence", "tenista", "tenor", "teplota", "tepna", "teprve", "terapie", "termoska", "textil", "ticho", "tiskopis", "titulek", "tkadlec", "tkanina", "tlapka", "tleskat", "tlukot", "tlupa", "tmel", "toaleta", "topinka", "topol", "torzo", "touha", "toulec", "tradice", "traktor", "tramp", "trasa", "traverza", "trefit", "trest", "trezor", "trhavina", "trhlina", "trochu", "trojice", "troska", "trouba", "trpce", "trpitel", "trpkost", "trubec", "truchlit", "truhlice", "trus", "trvat", "tudy", "tuhnout", "tuhost", "tundra", "turista", "turnaj", "tuzemsko", "tvaroh", "tvorba", "tvrdost", "tvrz", "tygr", "tykev", "ubohost", "uboze", "ubrat", "ubrousek", "ubrus", "ubytovna", "ucho", "uctivost", "udivit", "uhradit", "ujednat", "ujistit", "ujmout", "ukazatel", "uklidnit", "uklonit", "ukotvit", "ukrojit", "ulice", "ulita", "ulovit", "umyvadlo", "unavit", "uniforma", "uniknout", "upadnout", "uplatnit", "uplynout", "upoutat", "upravit", "uran", "urazit", "usednout", "usilovat", "usmrtit", "usnadnit", "usnout", "usoudit", "ustlat", "ustrnout", "utahovat", "utkat", "utlumit", "utonout", "utopenec", "utrousit", "uvalit", "uvolnit", "uvozovka", "uzdravit", "uzel", "uzenina", "uzlina", "uznat", "vagon", "valcha", "valoun", "vana", "vandal", "vanilka", "varan", "varhany", "varovat", "vcelku", "vchod", "vdova", "vedro", "vegetace", "vejce", "velbloud", "veletrh", "velitel", "velmoc", "velryba", "venkov", "veranda", "verze", "veselka", "veskrze", "vesnice", "vespodu", "vesta", "veterina", "veverka", "vibrace", "vichr", "videohra", "vidina", "vidle", "vila", "vinice", "viset", "vitalita", "vize", "vizitka", "vjezd", "vklad", "vkus", "vlajka", "vlak", "vlasec", "vlevo", "vlhkost", "vliv", "vlnovka", "vloupat", "vnucovat", "vnuk", "voda", "vodivost", "vodoznak", "vodstvo", "vojensky", "vojna", "vojsko", "volant", "volba", "volit", "volno", "voskovka", "vozidlo", "vozovna", "vpravo", "vrabec", "vracet", "vrah", "vrata", "vrba", "vrcholek", "vrhat", "vrstva", "vrtule", "vsadit", "vstoupit", "vstup", "vtip", "vybavit", "vybrat", "vychovat", "vydat", "vydra", "vyfotit", "vyhledat", "vyhnout", "vyhodit", "vyhradit", "vyhubit", "vyjasnit", "vyjet", "vyjmout", "vyklopit", "vykonat", "vylekat", "vymazat", "vymezit", "vymizet", "vymyslet", "vynechat", "vynikat", "vynutit", "vypadat", "vyplatit", "vypravit", "vypustit", "vyrazit", "vyrovnat", "vyrvat", "vyslovit", "vysoko", "vystavit", "vysunout", "vysypat", "vytasit", "vytesat", "vytratit", "vyvinout", "vyvolat", "vyvrhel", "vyzdobit", "vyznat", "vzadu", "vzbudit", "vzchopit", "vzdor", "vzduch", "vzdychat", "vzestup", "vzhledem", "vzkaz", "vzlykat", "vznik", "vzorek", "vzpoura", "vztah", "vztek", "xylofon", "zabrat", "zabydlet", "zachovat", "zadarmo", "zadusit", "zafoukat", "zahltit", "zahodit", "zahrada", "zahynout", "zajatec", "zajet", "zajistit", "zaklepat", "zakoupit", "zalepit", "zamezit", "zamotat", "zamyslet", "zanechat", "zanikat", "zaplatit", "zapojit", "zapsat", "zarazit", "zastavit", "zasunout", "zatajit", "zatemnit", "zatknout", "zaujmout", "zavalit", "zavelet", "zavinit", "zavolat", "zavrtat", "zazvonit", "zbavit", "zbrusu", "zbudovat", "zbytek", "zdaleka", "zdarma", "zdatnost", "zdivo", "zdobit", "zdroj", "zdvih", "zdymadlo", "zelenina", "zeman", "zemina", "zeptat", "zezadu", "zezdola", "zhatit", "zhltnout", "zhluboka", "zhotovit", "zhruba", "zima", "zimnice", "zjemnit", "zklamat", "zkoumat", "zkratka", "zkumavka", "zlato", "zlehka", "zloba", "zlom", "zlost", "zlozvyk", "zmapovat", "zmar", "zmatek", "zmije", "zmizet", "zmocnit", "zmodrat", "zmrzlina", "zmutovat", "znak", "znalost", "znamenat", "znovu", "zobrazit", "zotavit", "zoubek", "zoufale", "zplodit", "zpomalit", "zprava", "zprostit", "zprudka", "zprvu", "zrada", "zranit", "zrcadlo", "zrnitost", "zrno", "zrovna", "zrychlit", "zrzavost", "zticha", "ztratit", "zubovina", "zubr", "zvednout", "zvenku", "zvesela", "zvon", "zvrat", "zvukovod", "zvyk"];
var require$$1 = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
var require$$2 = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
var require$$3$1 = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
var require$$4$2 = ["abaisser", "abandon", "abdiquer", "abeille", "abolir", "aborder", "aboutir", "aboyer", "abrasif", "abreuver", "abriter", "abroger", "abrupt", "absence", "absolu", "absurde", "abusif", "abyssal", "academie", "acajou", "acarien", "accabler", "accepter", "acclamer", "accolade", "accroche", "accuser", "acerbe", "achat", "acheter", "aciduler", "acier", "acompte", "acquerir", "acronyme", "acteur", "actif", "actuel", "adepte", "adequat", "adhesif", "adjectif", "adjuger", "admettre", "admirer", "adopter", "adorer", "adoucir", "adresse", "adroit", "adulte", "adverbe", "aerer", "aeronef", "affaire", "affecter", "affiche", "affreux", "affubler", "agacer", "agencer", "agile", "agiter", "agrafer", "agreable", "agrume", "aider", "aiguille", "ailier", "aimable", "aisance", "ajouter", "ajuster", "alarmer", "alchimie", "alerte", "algebre", "algue", "aliener", "aliment", "alleger", "alliage", "allouer", "allumer", "alourdir", "alpaga", "altesse", "alveole", "amateur", "ambigu", "ambre", "amenager", "amertume", "amidon", "amiral", "amorcer", "amour", "amovible", "amphibie", "ampleur", "amusant", "analyse", "anaphore", "anarchie", "anatomie", "ancien", "aneantir", "angle", "angoisse", "anguleux", "animal", "annexer", "annonce", "annuel", "anodin", "anomalie", "anonyme", "anormal", "antenne", "antidote", "anxieux", "apaiser", "aperitif", "aplanir", "apologie", "appareil", "appeler", "apporter", "appuyer", "aquarium", "aqueduc", "arbitre", "arbuste", "ardeur", "ardoise", "argent", "arlequin", "armature", "armement", "armoire", "armure", "arpenter", "arracher", "arriver", "arroser", "arsenic", "arteriel", "article", "aspect", "asphalte", "aspirer", "assaut", "asservir", "assiette", "associer", "assurer", "asticot", "astre", "astuce", "atelier", "atome", "atrium", "atroce", "attaque", "attentif", "attirer", "attraper", "aubaine", "auberge", "audace", "audible", "augurer", "aurore", "automne", "autruche", "avaler", "avancer", "avarice", "avenir", "averse", "aveugle", "aviateur", "avide", "avion", "aviser", "avoine", "avouer", "avril", "axial", "axiome", "badge", "bafouer", "bagage", "baguette", "baignade", "balancer", "balcon", "baleine", "balisage", "bambin", "bancaire", "bandage", "banlieue", "banniere", "banquier", "barbier", "baril", "baron", "barque", "barrage", "bassin", "bastion", "bataille", "bateau", "batterie", "baudrier", "bavarder", "belette", "belier", "belote", "benefice", "berceau", "berger", "berline", "bermuda", "besace", "besogne", "betail", "beurre", "biberon", "bicycle", "bidule", "bijou", "bilan", "bilingue", "billard", "binaire", "biologie", "biopsie", "biotype", "biscuit", "bison", "bistouri", "bitume", "bizarre", "blafard", "blague", "blanchir", "blessant", "blinder", "blond", "bloquer", "blouson", "bobard", "bobine", "boire", "boiser", "bolide", "bonbon", "bondir", "bonheur", "bonifier", "bonus", "bordure", "borne", "botte", "boucle", "boueux", "bougie", "boulon", "bouquin", "bourse", "boussole", "boutique", "boxeur", "branche", "brasier", "brave", "brebis", "breche", "breuvage", "bricoler", "brigade", "brillant", "brioche", "brique", "brochure", "broder", "bronzer", "brousse", "broyeur", "brume", "brusque", "brutal", "bruyant", "buffle", "buisson", "bulletin", "bureau", "burin", "bustier", "butiner", "butoir", "buvable", "buvette", "cabanon", "cabine", "cachette", "cadeau", "cadre", "cafeine", "caillou", "caisson", "calculer", "calepin", "calibre", "calmer", "calomnie", "calvaire", "camarade", "camera", "camion", "campagne", "canal", "caneton", "canon", "cantine", "canular", "capable", "caporal", "caprice", "capsule", "capter", "capuche", "carabine", "carbone", "caresser", "caribou", "carnage", "carotte", "carreau", "carton", "cascade", "casier", "casque", "cassure", "causer", "caution", "cavalier", "caverne", "caviar", "cedille", "ceinture", "celeste", "cellule", "cendrier", "censurer", "central", "cercle", "cerebral", "cerise", "cerner", "cerveau", "cesser", "chagrin", "chaise", "chaleur", "chambre", "chance", "chapitre", "charbon", "chasseur", "chaton", "chausson", "chavirer", "chemise", "chenille", "chequier", "chercher", "cheval", "chien", "chiffre", "chignon", "chimere", "chiot", "chlorure", "chocolat", "choisir", "chose", "chouette", "chrome", "chute", "cigare", "cigogne", "cimenter", "cinema", "cintrer", "circuler", "cirer", "cirque", "citerne", "citoyen", "citron", "civil", "clairon", "clameur", "claquer", "classe", "clavier", "client", "cligner", "climat", "clivage", "cloche", "clonage", "cloporte", "cobalt", "cobra", "cocasse", "cocotier", "coder", "codifier", "coffre", "cogner", "cohesion", "coiffer", "coincer", "colere", "colibri", "colline", "colmater", "colonel", "combat", "comedie", "commande", "compact", "concert", "conduire", "confier", "congeler", "connoter", "consonne", "contact", "convexe", "copain", "copie", "corail", "corbeau", "cordage", "corniche", "corpus", "correct", "cortege", "cosmique", "costume", "coton", "coude", "coupure", "courage", "couteau", "couvrir", "coyote", "crabe", "crainte", "cravate", "crayon", "creature", "crediter", "cremeux", "creuser", "crevette", "cribler", "crier", "cristal", "critere", "croire", "croquer", "crotale", "crucial", "cruel", "crypter", "cubique", "cueillir", "cuillere", "cuisine", "cuivre", "culminer", "cultiver", "cumuler", "cupide", "curatif", "curseur", "cyanure", "cycle", "cylindre", "cynique", "daigner", "damier", "danger", "danseur", "dauphin", "debattre", "debiter", "deborder", "debrider", "debutant", "decaler", "decembre", "dechirer", "decider", "declarer", "decorer", "decrire", "decupler", "dedale", "deductif", "deesse", "defensif", "defiler", "defrayer", "degager", "degivrer", "deglutir", "degrafer", "dejeuner", "delice", "deloger", "demander", "demeurer", "demolir", "denicher", "denouer", "dentelle", "denuder", "depart", "depenser", "dephaser", "deplacer", "deposer", "deranger", "derober", "desastre", "descente", "desert", "designer", "desobeir", "dessiner", "destrier", "detacher", "detester", "detourer", "detresse", "devancer", "devenir", "deviner", "devoir", "diable", "dialogue", "diamant", "dicter", "differer", "digerer", "digital", "digne", "diluer", "dimanche", "diminuer", "dioxyde", "directif", "diriger", "discuter", "disposer", "dissiper", "distance", "divertir", "diviser", "docile", "docteur", "dogme", "doigt", "domaine", "domicile", "dompter", "donateur", "donjon", "donner", "dopamine", "dortoir", "dorure", "dosage", "doseur", "dossier", "dotation", "douanier", "double", "douceur", "douter", "doyen", "dragon", "draper", "dresser", "dribbler", "droiture", "duperie", "duplexe", "durable", "durcir", "dynastie", "eblouir", "ecarter", "echarpe", "echelle", "eclairer", "eclipse", "eclore", "ecluse", "ecole", "economie", "ecorce", "ecouter", "ecraser", "ecremer", "ecrivain", "ecrou", "ecume", "ecureuil", "edifier", "eduquer", "effacer", "effectif", "effigie", "effort", "effrayer", "effusion", "egaliser", "egarer", "ejecter", "elaborer", "elargir", "electron", "elegant", "elephant", "eleve", "eligible", "elitisme", "eloge", "elucider", "eluder", "emballer", "embellir", "embryon", "emeraude", "emission", "emmener", "emotion", "emouvoir", "empereur", "employer", "emporter", "emprise", "emulsion", "encadrer", "enchere", "enclave", "encoche", "endiguer", "endosser", "endroit", "enduire", "energie", "enfance", "enfermer", "enfouir", "engager", "engin", "englober", "enigme", "enjamber", "enjeu", "enlever", "ennemi", "ennuyeux", "enrichir", "enrobage", "enseigne", "entasser", "entendre", "entier", "entourer", "entraver", "enumerer", "envahir", "enviable", "envoyer", "enzyme", "eolien", "epaissir", "epargne", "epatant", "epaule", "epicerie", "epidemie", "epier", "epilogue", "epine", "episode", "epitaphe", "epoque", "epreuve", "eprouver", "epuisant", "equerre", "equipe", "eriger", "erosion", "erreur", "eruption", "escalier", "espadon", "espece", "espiegle", "espoir", "esprit", "esquiver", "essayer", "essence", "essieu", "essorer", "estime", "estomac", "estrade", "etagere", "etaler", "etanche", "etatique", "eteindre", "etendoir", "eternel", "ethanol", "ethique", "ethnie", "etirer", "etoffer", "etoile", "etonnant", "etourdir", "etrange", "etroit", "etude", "euphorie", "evaluer", "evasion", "eventail", "evidence", "eviter", "evolutif", "evoquer", "exact", "exagerer", "exaucer", "exceller", "excitant", "exclusif", "excuse", "executer", "exemple", "exercer", "exhaler", "exhorter", "exigence", "exiler", "exister", "exotique", "expedier", "explorer", "exposer", "exprimer", "exquis", "extensif", "extraire", "exulter", "fable", "fabuleux", "facette", "facile", "facture", "faiblir", "falaise", "fameux", "famille", "farceur", "farfelu", "farine", "farouche", "fasciner", "fatal", "fatigue", "faucon", "fautif", "faveur", "favori", "febrile", "feconder", "federer", "felin", "femme", "femur", "fendoir", "feodal", "fermer", "feroce", "ferveur", "festival", "feuille", "feutre", "fevrier", "fiasco", "ficeler", "fictif", "fidele", "figure", "filature", "filetage", "filiere", "filleul", "filmer", "filou", "filtrer", "financer", "finir", "fiole", "firme", "fissure", "fixer", "flairer", "flamme", "flasque", "flatteur", "fleau", "fleche", "fleur", "flexion", "flocon", "flore", "fluctuer", "fluide", "fluvial", "folie", "fonderie", "fongible", "fontaine", "forcer", "forgeron", "formuler", "fortune", "fossile", "foudre", "fougere", "fouiller", "foulure", "fourmi", "fragile", "fraise", "franchir", "frapper", "frayeur", "fregate", "freiner", "frelon", "fremir", "frenesie", "frere", "friable", "friction", "frisson", "frivole", "froid", "fromage", "frontal", "frotter", "fruit", "fugitif", "fuite", "fureur", "furieux", "furtif", "fusion", "futur", "gagner", "galaxie", "galerie", "gambader", "garantir", "gardien", "garnir", "garrigue", "gazelle", "gazon", "geant", "gelatine", "gelule", "gendarme", "general", "genie", "genou", "gentil", "geologie", "geometre", "geranium", "germe", "gestuel", "geyser", "gibier", "gicler", "girafe", "givre", "glace", "glaive", "glisser", "globe", "gloire", "glorieux", "golfeur", "gomme", "gonfler", "gorge", "gorille", "goudron", "gouffre", "goulot", "goupille", "gourmand", "goutte", "graduel", "graffiti", "graine", "grand", "grappin", "gratuit", "gravir", "grenat", "griffure", "griller", "grimper", "grogner", "gronder", "grotte", "groupe", "gruger", "grutier", "gruyere", "guepard", "guerrier", "guide", "guimauve", "guitare", "gustatif", "gymnaste", "gyrostat", "habitude", "hachoir", "halte", "hameau", "hangar", "hanneton", "haricot", "harmonie", "harpon", "hasard", "helium", "hematome", "herbe", "herisson", "hermine", "heron", "hesiter", "heureux", "hiberner", "hibou", "hilarant", "histoire", "hiver", "homard", "hommage", "homogene", "honneur", "honorer", "honteux", "horde", "horizon", "horloge", "hormone", "horrible", "houleux", "housse", "hublot", "huileux", "humain", "humble", "humide", "humour", "hurler", "hydromel", "hygiene", "hymne", "hypnose", "idylle", "ignorer", "iguane", "illicite", "illusion", "image", "imbiber", "imiter", "immense", "immobile", "immuable", "impact", "imperial", "implorer", "imposer", "imprimer", "imputer", "incarner", "incendie", "incident", "incliner", "incolore", "indexer", "indice", "inductif", "inedit", "ineptie", "inexact", "infini", "infliger", "informer", "infusion", "ingerer", "inhaler", "inhiber", "injecter", "injure", "innocent", "inoculer", "inonder", "inscrire", "insecte", "insigne", "insolite", "inspirer", "instinct", "insulter", "intact", "intense", "intime", "intrigue", "intuitif", "inutile", "invasion", "inventer", "inviter", "invoquer", "ironique", "irradier", "irreel", "irriter", "isoler", "ivoire", "ivresse", "jaguar", "jaillir", "jambe", "janvier", "jardin", "jauger", "jaune", "javelot", "jetable", "jeton", "jeudi", "jeunesse", "joindre", "joncher", "jongler", "joueur", "jouissif", "journal", "jovial", "joyau", "joyeux", "jubiler", "jugement", "junior", "jupon", "juriste", "justice", "juteux", "juvenile", "kayak", "kimono", "kiosque", "label", "labial", "labourer", "lacerer", "lactose", "lagune", "laine", "laisser", "laitier", "lambeau", "lamelle", "lampe", "lanceur", "langage", "lanterne", "lapin", "largeur", "larme", "laurier", "lavabo", "lavoir", "lecture", "legal", "leger", "legume", "lessive", "lettre", "levier", "lexique", "lezard", "liasse", "liberer", "libre", "licence", "licorne", "liege", "lievre", "ligature", "ligoter", "ligue", "limer", "limite", "limonade", "limpide", "lineaire", "lingot", "lionceau", "liquide", "lisiere", "lister", "lithium", "litige", "littoral", "livreur", "logique", "lointain", "loisir", "lombric", "loterie", "louer", "lourd", "loutre", "louve", "loyal", "lubie", "lucide", "lucratif", "lueur", "lugubre", "luisant", "lumiere", "lunaire", "lundi", "luron", "lutter", "luxueux", "machine", "magasin", "magenta", "magique", "maigre", "maillon", "maintien", "mairie", "maison", "majorer", "malaxer", "malefice", "malheur", "malice", "mallette", "mammouth", "mandater", "maniable", "manquant", "manteau", "manuel", "marathon", "marbre", "marchand", "mardi", "maritime", "marqueur", "marron", "marteler", "mascotte", "massif", "materiel", "matiere", "matraque", "maudire", "maussade", "mauve", "maximal", "mechant", "meconnu", "medaille", "medecin", "mediter", "meduse", "meilleur", "melange", "melodie", "membre", "memoire", "menacer", "mener", "menhir", "mensonge", "mentor", "mercredi", "merite", "merle", "messager", "mesure", "metal", "meteore", "methode", "metier", "meuble", "miauler", "microbe", "miette", "mignon", "migrer", "milieu", "million", "mimique", "mince", "mineral", "minimal", "minorer", "minute", "miracle", "miroiter", "missile", "mixte", "mobile", "moderne", "moelleux", "mondial", "moniteur", "monnaie", "monotone", "monstre", "montagne", "monument", "moqueur", "morceau", "morsure", "mortier", "moteur", "motif", "mouche", "moufle", "moulin", "mousson", "mouton", "mouvant", "multiple", "munition", "muraille", "murene", "murmure", "muscle", "museum", "musicien", "mutation", "muter", "mutuel", "myriade", "myrtille", "mystere", "mythique", "nageur", "nappe", "narquois", "narrer", "natation", "nation", "nature", "naufrage", "nautique", "navire", "nebuleux", "nectar", "nefaste", "negation", "negliger", "negocier", "neige", "nerveux", "nettoyer", "neurone", "neutron", "neveu", "niche", "nickel", "nitrate", "niveau", "noble", "nocif", "nocturne", "noirceur", "noisette", "nomade", "nombreux", "nommer", "normatif", "notable", "notifier", "notoire", "nourrir", "nouveau", "novateur", "novembre", "novice", "nuage", "nuancer", "nuire", "nuisible", "numero", "nuptial", "nuque", "nutritif", "obeir", "objectif", "obliger", "obscur", "observer", "obstacle", "obtenir", "obturer", "occasion", "occuper", "ocean", "octobre", "octroyer", "octupler", "oculaire", "odeur", "odorant", "offenser", "officier", "offrir", "ogive", "oiseau", "oisillon", "olfactif", "olivier", "ombrage", "omettre", "onctueux", "onduler", "onereux", "onirique", "opale", "opaque", "operer", "opinion", "opportun", "opprimer", "opter", "optique", "orageux", "orange", "orbite", "ordonner", "oreille", "organe", "orgueil", "orifice", "ornement", "orque", "ortie", "osciller", "osmose", "ossature", "otarie", "ouragan", "ourson", "outil", "outrager", "ouvrage", "ovation", "oxyde", "oxygene", "ozone", "paisible", "palace", "palmares", "palourde", "palper", "panache", "panda", "pangolin", "paniquer", "panneau", "panorama", "pantalon", "papaye", "papier", "papoter", "papyrus", "paradoxe", "parcelle", "paresse", "parfumer", "parler", "parole", "parrain", "parsemer", "partager", "parure", "parvenir", "passion", "pasteque", "paternel", "patience", "patron", "pavillon", "pavoiser", "payer", "paysage", "peigne", "peintre", "pelage", "pelican", "pelle", "pelouse", "peluche", "pendule", "penetrer", "penible", "pensif", "penurie", "pepite", "peplum", "perdrix", "perforer", "periode", "permuter", "perplexe", "persil", "perte", "peser", "petale", "petit", "petrir", "peuple", "pharaon", "phobie", "phoque", "photon", "phrase", "physique", "piano", "pictural", "piece", "pierre", "pieuvre", "pilote", "pinceau", "pipette", "piquer", "pirogue", "piscine", "piston", "pivoter", "pixel", "pizza", "placard", "plafond", "plaisir", "planer", "plaque", "plastron", "plateau", "pleurer", "plexus", "pliage", "plomb", "plonger", "pluie", "plumage", "pochette", "poesie", "poete", "pointe", "poirier", "poisson", "poivre", "polaire", "policier", "pollen", "polygone", "pommade", "pompier", "ponctuel", "ponderer", "poney", "portique", "position", "posseder", "posture", "potager", "poteau", "potion", "pouce", "poulain", "poumon", "pourpre", "poussin", "pouvoir", "prairie", "pratique", "precieux", "predire", "prefixe", "prelude", "prenom", "presence", "pretexte", "prevoir", "primitif", "prince", "prison", "priver", "probleme", "proceder", "prodige", "profond", "progres", "proie", "projeter", "prologue", "promener", "propre", "prospere", "proteger", "prouesse", "proverbe", "prudence", "pruneau", "psychose", "public", "puceron", "puiser", "pulpe", "pulsar", "punaise", "punitif", "pupitre", "purifier", "puzzle", "pyramide", "quasar", "querelle", "question", "quietude", "quitter", "quotient", "racine", "raconter", "radieux", "ragondin", "raideur", "raisin", "ralentir", "rallonge", "ramasser", "rapide", "rasage", "ratisser", "ravager", "ravin", "rayonner", "reactif", "reagir", "realiser", "reanimer", "recevoir", "reciter", "reclamer", "recolter", "recruter", "reculer", "recycler", "rediger", "redouter", "refaire", "reflexe", "reformer", "refrain", "refuge", "regalien", "region", "reglage", "regulier", "reiterer", "rejeter", "rejouer", "relatif", "relever", "relief", "remarque", "remede", "remise", "remonter", "remplir", "remuer", "renard", "renfort", "renifler", "renoncer", "rentrer", "renvoi", "replier", "reporter", "reprise", "reptile", "requin", "reserve", "resineux", "resoudre", "respect", "rester", "resultat", "retablir", "retenir", "reticule", "retomber", "retracer", "reunion", "reussir", "revanche", "revivre", "revolte", "revulsif", "richesse", "rideau", "rieur", "rigide", "rigoler", "rincer", "riposter", "risible", "risque", "rituel", "rival", "riviere", "rocheux", "romance", "rompre", "ronce", "rondin", "roseau", "rosier", "rotatif", "rotor", "rotule", "rouge", "rouille", "rouleau", "routine", "royaume", "ruban", "rubis", "ruche", "ruelle", "rugueux", "ruiner", "ruisseau", "ruser", "rustique", "rythme", "sabler", "saboter", "sabre", "sacoche", "safari", "sagesse", "saisir", "salade", "salive", "salon", "saluer", "samedi", "sanction", "sanglier", "sarcasme", "sardine", "saturer", "saugrenu", "saumon", "sauter", "sauvage", "savant", "savonner", "scalpel", "scandale", "scelerat", "scenario", "sceptre", "schema", "science", "scinder", "score", "scrutin", "sculpter", "seance", "secable", "secher", "secouer", "secreter", "sedatif", "seduire", "seigneur", "sejour", "selectif", "semaine", "sembler", "semence", "seminal", "senateur", "sensible", "sentence", "separer", "sequence", "serein", "sergent", "serieux", "serrure", "serum", "service", "sesame", "sevir", "sevrage", "sextuple", "sideral", "siecle", "sieger", "siffler", "sigle", "signal", "silence", "silicium", "simple", "sincere", "sinistre", "siphon", "sirop", "sismique", "situer", "skier", "social", "socle", "sodium", "soigneux", "soldat", "soleil", "solitude", "soluble", "sombre", "sommeil", "somnoler", "sonde", "songeur", "sonnette", "sonore", "sorcier", "sortir", "sosie", "sottise", "soucieux", "soudure", "souffle", "soulever", "soupape", "source", "soutirer", "souvenir", "spacieux", "spatial", "special", "sphere", "spiral", "stable", "station", "sternum", "stimulus", "stipuler", "strict", "studieux", "stupeur", "styliste", "sublime", "substrat", "subtil", "subvenir", "succes", "sucre", "suffixe", "suggerer", "suiveur", "sulfate", "superbe", "supplier", "surface", "suricate", "surmener", "surprise", "sursaut", "survie", "suspect", "syllabe", "symbole", "symetrie", "synapse", "syntaxe", "systeme", "tabac", "tablier", "tactile", "tailler", "talent", "talisman", "talonner", "tambour", "tamiser", "tangible", "tapis", "taquiner", "tarder", "tarif", "tartine", "tasse", "tatami", "tatouage", "taupe", "taureau", "taxer", "temoin", "temporel", "tenaille", "tendre", "teneur", "tenir", "tension", "terminer", "terne", "terrible", "tetine", "texte", "theme", "theorie", "therapie", "thorax", "tibia", "tiede", "timide", "tirelire", "tiroir", "tissu", "titane", "titre", "tituber", "toboggan", "tolerant", "tomate", "tonique", "tonneau", "toponyme", "torche", "tordre", "tornade", "torpille", "torrent", "torse", "tortue", "totem", "toucher", "tournage", "tousser", "toxine", "traction", "trafic", "tragique", "trahir", "train", "trancher", "travail", "trefle", "tremper", "tresor", "treuil", "triage", "tribunal", "tricoter", "trilogie", "triomphe", "tripler", "triturer", "trivial", "trombone", "tronc", "tropical", "troupeau", "tuile", "tulipe", "tumulte", "tunnel", "turbine", "tuteur", "tutoyer", "tuyau", "tympan", "typhon", "typique", "tyran", "ubuesque", "ultime", "ultrason", "unanime", "unifier", "union", "unique", "unitaire", "univers", "uranium", "urbain", "urticant", "usage", "usine", "usuel", "usure", "utile", "utopie", "vacarme", "vaccin", "vagabond", "vague", "vaillant", "vaincre", "vaisseau", "valable", "valise", "vallon", "valve", "vampire", "vanille", "vapeur", "varier", "vaseux", "vassal", "vaste", "vecteur", "vedette", "vegetal", "vehicule", "veinard", "veloce", "vendredi", "venerer", "venger", "venimeux", "ventouse", "verdure", "verin", "vernir", "verrou", "verser", "vertu", "veston", "veteran", "vetuste", "vexant", "vexer", "viaduc", "viande", "victoire", "vidange", "video", "vignette", "vigueur", "vilain", "village", "vinaigre", "violon", "vipere", "virement", "virtuose", "virus", "visage", "viseur", "vision", "visqueux", "visuel", "vital", "vitesse", "viticole", "vitrine", "vivace", "vivipare", "vocation", "voguer", "voile", "voisin", "voiture", "volaille", "volcan", "voltiger", "volume", "vorace", "vortex", "voter", "vouloir", "voyage", "voyelle", "wagon", "xenon", "yacht", "zebre", "zenith", "zeste", "zoologie"];
var require$$5$2 = ["abaco", "abbaglio", "abbinato", "abete", "abisso", "abolire", "abrasivo", "abrogato", "accadere", "accenno", "accusato", "acetone", "achille", "acido", "acqua", "acre", "acrilico", "acrobata", "acuto", "adagio", "addebito", "addome", "adeguato", "aderire", "adipe", "adottare", "adulare", "affabile", "affetto", "affisso", "affranto", "aforisma", "afoso", "africano", "agave", "agente", "agevole", "aggancio", "agire", "agitare", "agonismo", "agricolo", "agrumeto", "aguzzo", "alabarda", "alato", "albatro", "alberato", "albo", "albume", "alce", "alcolico", "alettone", "alfa", "algebra", "aliante", "alibi", "alimento", "allagato", "allegro", "allievo", "allodola", "allusivo", "almeno", "alogeno", "alpaca", "alpestre", "altalena", "alterno", "alticcio", "altrove", "alunno", "alveolo", "alzare", "amalgama", "amanita", "amarena", "ambito", "ambrato", "ameba", "america", "ametista", "amico", "ammasso", "ammenda", "ammirare", "ammonito", "amore", "ampio", "ampliare", "amuleto", "anacardo", "anagrafe", "analista", "anarchia", "anatra", "anca", "ancella", "ancora", "andare", "andrea", "anello", "angelo", "angolare", "angusto", "anima", "annegare", "annidato", "anno", "annuncio", "anonimo", "anticipo", "anzi", "apatico", "apertura", "apode", "apparire", "appetito", "appoggio", "approdo", "appunto", "aprile", "arabica", "arachide", "aragosta", "araldica", "arancio", "aratura", "arazzo", "arbitro", "archivio", "ardito", "arenile", "argento", "argine", "arguto", "aria", "armonia", "arnese", "arredato", "arringa", "arrosto", "arsenico", "arso", "artefice", "arzillo", "asciutto", "ascolto", "asepsi", "asettico", "asfalto", "asino", "asola", "aspirato", "aspro", "assaggio", "asse", "assoluto", "assurdo", "asta", "astenuto", "astice", "astratto", "atavico", "ateismo", "atomico", "atono", "attesa", "attivare", "attorno", "attrito", "attuale", "ausilio", "austria", "autista", "autonomo", "autunno", "avanzato", "avere", "avvenire", "avviso", "avvolgere", "azione", "azoto", "azzimo", "azzurro", "babele", "baccano", "bacino", "baco", "badessa", "badilata", "bagnato", "baita", "balcone", "baldo", "balena", "ballata", "balzano", "bambino", "bandire", "baraonda", "barbaro", "barca", "baritono", "barlume", "barocco", "basilico", "basso", "batosta", "battuto", "baule", "bava", "bavosa", "becco", "beffa", "belgio", "belva", "benda", "benevole", "benigno", "benzina", "bere", "berlina", "beta", "bibita", "bici", "bidone", "bifido", "biga", "bilancia", "bimbo", "binocolo", "biologo", "bipede", "bipolare", "birbante", "birra", "biscotto", "bisesto", "bisnonno", "bisonte", "bisturi", "bizzarro", "blando", "blatta", "bollito", "bonifico", "bordo", "bosco", "botanico", "bottino", "bozzolo", "braccio", "bradipo", "brama", "branca", "bravura", "bretella", "brevetto", "brezza", "briglia", "brillante", "brindare", "broccolo", "brodo", "bronzina", "brullo", "bruno", "bubbone", "buca", "budino", "buffone", "buio", "bulbo", "buono", "burlone", "burrasca", "bussola", "busta", "cadetto", "caduco", "calamaro", "calcolo", "calesse", "calibro", "calmo", "caloria", "cambusa", "camerata", "camicia", "cammino", "camola", "campale", "canapa", "candela", "cane", "canino", "canotto", "cantina", "capace", "capello", "capitolo", "capogiro", "cappero", "capra", "capsula", "carapace", "carcassa", "cardo", "carisma", "carovana", "carretto", "cartolina", "casaccio", "cascata", "caserma", "caso", "cassone", "castello", "casuale", "catasta", "catena", "catrame", "cauto", "cavillo", "cedibile", "cedrata", "cefalo", "celebre", "cellulare", "cena", "cenone", "centesimo", "ceramica", "cercare", "certo", "cerume", "cervello", "cesoia", "cespo", "ceto", "chela", "chiaro", "chicca", "chiedere", "chimera", "china", "chirurgo", "chitarra", "ciao", "ciclismo", "cifrare", "cigno", "cilindro", "ciottolo", "circa", "cirrosi", "citrico", "cittadino", "ciuffo", "civetta", "civile", "classico", "clinica", "cloro", "cocco", "codardo", "codice", "coerente", "cognome", "collare", "colmato", "colore", "colposo", "coltivato", "colza", "coma", "cometa", "commando", "comodo", "computer", "comune", "conciso", "condurre", "conferma", "congelare", "coniuge", "connesso", "conoscere", "consumo", "continuo", "convegno", "coperto", "copione", "coppia", "copricapo", "corazza", "cordata", "coricato", "cornice", "corolla", "corpo", "corredo", "corsia", "cortese", "cosmico", "costante", "cottura", "covato", "cratere", "cravatta", "creato", "credere", "cremoso", "crescita", "creta", "criceto", "crinale", "crisi", "critico", "croce", "cronaca", "crostata", "cruciale", "crusca", "cucire", "cuculo", "cugino", "cullato", "cupola", "curatore", "cursore", "curvo", "cuscino", "custode", "dado", "daino", "dalmata", "damerino", "daniela", "dannoso", "danzare", "datato", "davanti", "davvero", "debutto", "decennio", "deciso", "declino", "decollo", "decreto", "dedicato", "definito", "deforme", "degno", "delegare", "delfino", "delirio", "delta", "demenza", "denotato", "dentro", "deposito", "derapata", "derivare", "deroga", "descritto", "deserto", "desiderio", "desumere", "detersivo", "devoto", "diametro", "dicembre", "diedro", "difeso", "diffuso", "digerire", "digitale", "diluvio", "dinamico", "dinnanzi", "dipinto", "diploma", "dipolo", "diradare", "dire", "dirotto", "dirupo", "disagio", "discreto", "disfare", "disgelo", "disposto", "distanza", "disumano", "dito", "divano", "divelto", "dividere", "divorato", "doblone", "docente", "doganale", "dogma", "dolce", "domato", "domenica", "dominare", "dondolo", "dono", "dormire", "dote", "dottore", "dovuto", "dozzina", "drago", "druido", "dubbio", "dubitare", "ducale", "duna", "duomo", "duplice", "duraturo", "ebano", "eccesso", "ecco", "eclissi", "economia", "edera", "edicola", "edile", "editoria", "educare", "egemonia", "egli", "egoismo", "egregio", "elaborato", "elargire", "elegante", "elencato", "eletto", "elevare", "elfico", "elica", "elmo", "elsa", "eluso", "emanato", "emblema", "emesso", "emiro", "emotivo", "emozione", "empirico", "emulo", "endemico", "enduro", "energia", "enfasi", "enoteca", "entrare", "enzima", "epatite", "epilogo", "episodio", "epocale", "eppure", "equatore", "erario", "erba", "erboso", "erede", "eremita", "erigere", "ermetico", "eroe", "erosivo", "errante", "esagono", "esame", "esanime", "esaudire", "esca", "esempio", "esercito", "esibito", "esigente", "esistere", "esito", "esofago", "esortato", "esoso", "espanso", "espresso", "essenza", "esso", "esteso", "estimare", "estonia", "estroso", "esultare", "etilico", "etnico", "etrusco", "etto", "euclideo", "europa", "evaso", "evidenza", "evitato", "evoluto", "evviva", "fabbrica", "faccenda", "fachiro", "falco", "famiglia", "fanale", "fanfara", "fango", "fantasma", "fare", "farfalla", "farinoso", "farmaco", "fascia", "fastoso", "fasullo", "faticare", "fato", "favoloso", "febbre", "fecola", "fede", "fegato", "felpa", "feltro", "femmina", "fendere", "fenomeno", "fermento", "ferro", "fertile", "fessura", "festivo", "fetta", "feudo", "fiaba", "fiducia", "fifa", "figurato", "filo", "finanza", "finestra", "finire", "fiore", "fiscale", "fisico", "fiume", "flacone", "flamenco", "flebo", "flemma", "florido", "fluente", "fluoro", "fobico", "focaccia", "focoso", "foderato", "foglio", "folata", "folclore", "folgore", "fondente", "fonetico", "fonia", "fontana", "forbito", "forchetta", "foresta", "formica", "fornaio", "foro", "fortezza", "forzare", "fosfato", "fosso", "fracasso", "frana", "frassino", "fratello", "freccetta", "frenata", "fresco", "frigo", "frollino", "fronde", "frugale", "frutta", "fucilata", "fucsia", "fuggente", "fulmine", "fulvo", "fumante", "fumetto", "fumoso", "fune", "funzione", "fuoco", "furbo", "furgone", "furore", "fuso", "futile", "gabbiano", "gaffe", "galateo", "gallina", "galoppo", "gambero", "gamma", "garanzia", "garbo", "garofano", "garzone", "gasdotto", "gasolio", "gastrico", "gatto", "gaudio", "gazebo", "gazzella", "geco", "gelatina", "gelso", "gemello", "gemmato", "gene", "genitore", "gennaio", "genotipo", "gergo", "ghepardo", "ghiaccio", "ghisa", "giallo", "gilda", "ginepro", "giocare", "gioiello", "giorno", "giove", "girato", "girone", "gittata", "giudizio", "giurato", "giusto", "globulo", "glutine", "gnomo", "gobba", "golf", "gomito", "gommone", "gonfio", "gonna", "governo", "gracile", "grado", "grafico", "grammo", "grande", "grattare", "gravoso", "grazia", "greca", "gregge", "grifone", "grigio", "grinza", "grotta", "gruppo", "guadagno", "guaio", "guanto", "guardare", "gufo", "guidare", "ibernato", "icona", "identico", "idillio", "idolo", "idra", "idrico", "idrogeno", "igiene", "ignaro", "ignorato", "ilare", "illeso", "illogico", "illudere", "imballo", "imbevuto", "imbocco", "imbuto", "immane", "immerso", "immolato", "impacco", "impeto", "impiego", "importo", "impronta", "inalare", "inarcare", "inattivo", "incanto", "incendio", "inchino", "incisivo", "incluso", "incontro", "incrocio", "incubo", "indagine", "india", "indole", "inedito", "infatti", "infilare", "inflitto", "ingaggio", "ingegno", "inglese", "ingordo", "ingrosso", "innesco", "inodore", "inoltrare", "inondato", "insano", "insetto", "insieme", "insonnia", "insulina", "intasato", "intero", "intonaco", "intuito", "inumidire", "invalido", "invece", "invito", "iperbole", "ipnotico", "ipotesi", "ippica", "iride", "irlanda", "ironico", "irrigato", "irrorare", "isolato", "isotopo", "isterico", "istituto", "istrice", "italia", "iterare", "labbro", "labirinto", "lacca", "lacerato", "lacrima", "lacuna", "laddove", "lago", "lampo", "lancetta", "lanterna", "lardoso", "larga", "laringe", "lastra", "latenza", "latino", "lattuga", "lavagna", "lavoro", "legale", "leggero", "lembo", "lentezza", "lenza", "leone", "lepre", "lesivo", "lessato", "lesto", "letterale", "leva", "levigato", "libero", "lido", "lievito", "lilla", "limatura", "limitare", "limpido", "lineare", "lingua", "liquido", "lira", "lirica", "lisca", "lite", "litigio", "livrea", "locanda", "lode", "logica", "lombare", "londra", "longevo", "loquace", "lorenzo", "loto", "lotteria", "luce", "lucidato", "lumaca", "luminoso", "lungo", "lupo", "luppolo", "lusinga", "lusso", "lutto", "macabro", "macchina", "macero", "macinato", "madama", "magico", "maglia", "magnete", "magro", "maiolica", "malafede", "malgrado", "malinteso", "malsano", "malto", "malumore", "mana", "mancia", "mandorla", "mangiare", "manifesto", "mannaro", "manovra", "mansarda", "mantide", "manubrio", "mappa", "maratona", "marcire", "maretta", "marmo", "marsupio", "maschera", "massaia", "mastino", "materasso", "matricola", "mattone", "maturo", "mazurca", "meandro", "meccanico", "mecenate", "medesimo", "meditare", "mega", "melassa", "melis", "melodia", "meninge", "meno", "mensola", "mercurio", "merenda", "merlo", "meschino", "mese", "messere", "mestolo", "metallo", "metodo", "mettere", "miagolare", "mica", "micelio", "michele", "microbo", "midollo", "miele", "migliore", "milano", "milite", "mimosa", "minerale", "mini", "minore", "mirino", "mirtillo", "miscela", "missiva", "misto", "misurare", "mitezza", "mitigare", "mitra", "mittente", "mnemonico", "modello", "modifica", "modulo", "mogano", "mogio", "mole", "molosso", "monastero", "monco", "mondina", "monetario", "monile", "monotono", "monsone", "montato", "monviso", "mora", "mordere", "morsicato", "mostro", "motivato", "motosega", "motto", "movenza", "movimento", "mozzo", "mucca", "mucosa", "muffa", "mughetto", "mugnaio", "mulatto", "mulinello", "multiplo", "mummia", "munto", "muovere", "murale", "musa", "muscolo", "musica", "mutevole", "muto", "nababbo", "nafta", "nanometro", "narciso", "narice", "narrato", "nascere", "nastrare", "naturale", "nautica", "naviglio", "nebulosa", "necrosi", "negativo", "negozio", "nemmeno", "neofita", "neretto", "nervo", "nessuno", "nettuno", "neutrale", "neve", "nevrotico", "nicchia", "ninfa", "nitido", "nobile", "nocivo", "nodo", "nome", "nomina", "nordico", "normale", "norvegese", "nostrano", "notare", "notizia", "notturno", "novella", "nucleo", "nulla", "numero", "nuovo", "nutrire", "nuvola", "nuziale", "oasi", "obbedire", "obbligo", "obelisco", "oblio", "obolo", "obsoleto", "occasione", "occhio", "occidente", "occorrere", "occultare", "ocra", "oculato", "odierno", "odorare", "offerta", "offrire", "offuscato", "oggetto", "oggi", "ognuno", "olandese", "olfatto", "oliato", "oliva", "ologramma", "oltre", "omaggio", "ombelico", "ombra", "omega", "omissione", "ondoso", "onere", "onice", "onnivoro", "onorevole", "onta", "operato", "opinione", "opposto", "oracolo", "orafo", "ordine", "orecchino", "orefice", "orfano", "organico", "origine", "orizzonte", "orma", "ormeggio", "ornativo", "orologio", "orrendo", "orribile", "ortensia", "ortica", "orzata", "orzo", "osare", "oscurare", "osmosi", "ospedale", "ospite", "ossa", "ossidare", "ostacolo", "oste", "otite", "otre", "ottagono", "ottimo", "ottobre", "ovale", "ovest", "ovino", "oviparo", "ovocito", "ovunque", "ovviare", "ozio", "pacchetto", "pace", "pacifico", "padella", "padrone", "paese", "paga", "pagina", "palazzina", "palesare", "pallido", "palo", "palude", "pandoro", "pannello", "paolo", "paonazzo", "paprica", "parabola", "parcella", "parere", "pargolo", "pari", "parlato", "parola", "partire", "parvenza", "parziale", "passivo", "pasticca", "patacca", "patologia", "pattume", "pavone", "peccato", "pedalare", "pedonale", "peggio", "peloso", "penare", "pendice", "penisola", "pennuto", "penombra", "pensare", "pentola", "pepe", "pepita", "perbene", "percorso", "perdonato", "perforare", "pergamena", "periodo", "permesso", "perno", "perplesso", "persuaso", "pertugio", "pervaso", "pesatore", "pesista", "peso", "pestifero", "petalo", "pettine", "petulante", "pezzo", "piacere", "pianta", "piattino", "piccino", "picozza", "piega", "pietra", "piffero", "pigiama", "pigolio", "pigro", "pila", "pilifero", "pillola", "pilota", "pimpante", "pineta", "pinna", "pinolo", "pioggia", "piombo", "piramide", "piretico", "pirite", "pirolisi", "pitone", "pizzico", "placebo", "planare", "plasma", "platano", "plenario", "pochezza", "poderoso", "podismo", "poesia", "poggiare", "polenta", "poligono", "pollice", "polmonite", "polpetta", "polso", "poltrona", "polvere", "pomice", "pomodoro", "ponte", "popoloso", "porfido", "poroso", "porpora", "porre", "portata", "posa", "positivo", "possesso", "postulato", "potassio", "potere", "pranzo", "prassi", "pratica", "precluso", "predica", "prefisso", "pregiato", "prelievo", "premere", "prenotare", "preparato", "presenza", "pretesto", "prevalso", "prima", "principe", "privato", "problema", "procura", "produrre", "profumo", "progetto", "prolunga", "promessa", "pronome", "proposta", "proroga", "proteso", "prova", "prudente", "prugna", "prurito", "psiche", "pubblico", "pudica", "pugilato", "pugno", "pulce", "pulito", "pulsante", "puntare", "pupazzo", "pupilla", "puro", "quadro", "qualcosa", "quasi", "querela", "quota", "raccolto", "raddoppio", "radicale", "radunato", "raffica", "ragazzo", "ragione", "ragno", "ramarro", "ramingo", "ramo", "randagio", "rantolare", "rapato", "rapina", "rappreso", "rasatura", "raschiato", "rasente", "rassegna", "rastrello", "rata", "ravveduto", "reale", "recepire", "recinto", "recluta", "recondito", "recupero", "reddito", "redimere", "regalato", "registro", "regola", "regresso", "relazione", "remare", "remoto", "renna", "replica", "reprimere", "reputare", "resa", "residente", "responso", "restauro", "rete", "retina", "retorica", "rettifica", "revocato", "riassunto", "ribadire", "ribelle", "ribrezzo", "ricarica", "ricco", "ricevere", "riciclato", "ricordo", "ricreduto", "ridicolo", "ridurre", "rifasare", "riflesso", "riforma", "rifugio", "rigare", "rigettato", "righello", "rilassato", "rilevato", "rimanere", "rimbalzo", "rimedio", "rimorchio", "rinascita", "rincaro", "rinforzo", "rinnovo", "rinomato", "rinsavito", "rintocco", "rinuncia", "rinvenire", "riparato", "ripetuto", "ripieno", "riportare", "ripresa", "ripulire", "risata", "rischio", "riserva", "risibile", "riso", "rispetto", "ristoro", "risultato", "risvolto", "ritardo", "ritegno", "ritmico", "ritrovo", "riunione", "riva", "riverso", "rivincita", "rivolto", "rizoma", "roba", "robotico", "robusto", "roccia", "roco", "rodaggio", "rodere", "roditore", "rogito", "rollio", "romantico", "rompere", "ronzio", "rosolare", "rospo", "rotante", "rotondo", "rotula", "rovescio", "rubizzo", "rubrica", "ruga", "rullino", "rumine", "rumoroso", "ruolo", "rupe", "russare", "rustico", "sabato", "sabbiare", "sabotato", "sagoma", "salasso", "saldatura", "salgemma", "salivare", "salmone", "salone", "saltare", "saluto", "salvo", "sapere", "sapido", "saporito", "saraceno", "sarcasmo", "sarto", "sassoso", "satellite", "satira", "satollo", "saturno", "savana", "savio", "saziato", "sbadiglio", "sbalzo", "sbancato", "sbarra", "sbattere", "sbavare", "sbendare", "sbirciare", "sbloccato", "sbocciato", "sbrinare", "sbruffone", "sbuffare", "scabroso", "scadenza", "scala", "scambiare", "scandalo", "scapola", "scarso", "scatenare", "scavato", "scelto", "scenico", "scettro", "scheda", "schiena", "sciarpa", "scienza", "scindere", "scippo", "sciroppo", "scivolo", "sclerare", "scodella", "scolpito", "scomparto", "sconforto", "scoprire", "scorta", "scossone", "scozzese", "scriba", "scrollare", "scrutinio", "scuderia", "scultore", "scuola", "scuro", "scusare", "sdebitare", "sdoganare", "seccatura", "secondo", "sedano", "seggiola", "segnalato", "segregato", "seguito", "selciato", "selettivo", "sella", "selvaggio", "semaforo", "sembrare", "seme", "seminato", "sempre", "senso", "sentire", "sepolto", "sequenza", "serata", "serbato", "sereno", "serio", "serpente", "serraglio", "servire", "sestina", "setola", "settimana", "sfacelo", "sfaldare", "sfamato", "sfarzoso", "sfaticato", "sfera", "sfida", "sfilato", "sfinge", "sfocato", "sfoderare", "sfogo", "sfoltire", "sforzato", "sfratto", "sfruttato", "sfuggito", "sfumare", "sfuso", "sgabello", "sgarbato", "sgonfiare", "sgorbio", "sgrassato", "sguardo", "sibilo", "siccome", "sierra", "sigla", "signore", "silenzio", "sillaba", "simbolo", "simpatico", "simulato", "sinfonia", "singolo", "sinistro", "sino", "sintesi", "sinusoide", "sipario", "sisma", "sistole", "situato", "slitta", "slogatura", "sloveno", "smarrito", "smemorato", "smentito", "smeraldo", "smilzo", "smontare", "smottato", "smussato", "snellire", "snervato", "snodo", "sobbalzo", "sobrio", "soccorso", "sociale", "sodale", "soffitto", "sogno", "soldato", "solenne", "solido", "sollazzo", "solo", "solubile", "solvente", "somatico", "somma", "sonda", "sonetto", "sonnifero", "sopire", "soppeso", "sopra", "sorgere", "sorpasso", "sorriso", "sorso", "sorteggio", "sorvolato", "sospiro", "sosta", "sottile", "spada", "spalla", "spargere", "spatola", "spavento", "spazzola", "specie", "spedire", "spegnere", "spelatura", "speranza", "spessore", "spettrale", "spezzato", "spia", "spigoloso", "spillato", "spinoso", "spirale", "splendido", "sportivo", "sposo", "spranga", "sprecare", "spronato", "spruzzo", "spuntino", "squillo", "sradicare", "srotolato", "stabile", "stacco", "staffa", "stagnare", "stampato", "stantio", "starnuto", "stasera", "statuto", "stelo", "steppa", "sterzo", "stiletto", "stima", "stirpe", "stivale", "stizzoso", "stonato", "storico", "strappo", "stregato", "stridulo", "strozzare", "strutto", "stuccare", "stufo", "stupendo", "subentro", "succoso", "sudore", "suggerito", "sugo", "sultano", "suonare", "superbo", "supporto", "surgelato", "surrogato", "sussurro", "sutura", "svagare", "svedese", "sveglio", "svelare", "svenuto", "svezia", "sviluppo", "svista", "svizzera", "svolta", "svuotare", "tabacco", "tabulato", "tacciare", "taciturno", "tale", "talismano", "tampone", "tannino", "tara", "tardivo", "targato", "tariffa", "tarpare", "tartaruga", "tasto", "tattico", "taverna", "tavolata", "tazza", "teca", "tecnico", "telefono", "temerario", "tempo", "temuto", "tendone", "tenero", "tensione", "tentacolo", "teorema", "terme", "terrazzo", "terzetto", "tesi", "tesserato", "testato", "tetro", "tettoia", "tifare", "tigella", "timbro", "tinto", "tipico", "tipografo", "tiraggio", "tiro", "titanio", "titolo", "titubante", "tizio", "tizzone", "toccare", "tollerare", "tolto", "tombola", "tomo", "tonfo", "tonsilla", "topazio", "topologia", "toppa", "torba", "tornare", "torrone", "tortora", "toscano", "tossire", "tostatura", "totano", "trabocco", "trachea", "trafila", "tragedia", "tralcio", "tramonto", "transito", "trapano", "trarre", "trasloco", "trattato", "trave", "treccia", "tremolio", "trespolo", "tributo", "tricheco", "trifoglio", "trillo", "trincea", "trio", "tristezza", "triturato", "trivella", "tromba", "trono", "troppo", "trottola", "trovare", "truccato", "tubatura", "tuffato", "tulipano", "tumulto", "tunisia", "turbare", "turchino", "tuta", "tutela", "ubicato", "uccello", "uccisore", "udire", "uditivo", "uffa", "ufficio", "uguale", "ulisse", "ultimato", "umano", "umile", "umorismo", "uncinetto", "ungere", "ungherese", "unicorno", "unificato", "unisono", "unitario", "unte", "uovo", "upupa", "uragano", "urgenza", "urlo", "usanza", "usato", "uscito", "usignolo", "usuraio", "utensile", "utilizzo", "utopia", "vacante", "vaccinato", "vagabondo", "vagliato", "valanga", "valgo", "valico", "valletta", "valoroso", "valutare", "valvola", "vampata", "vangare", "vanitoso", "vano", "vantaggio", "vanvera", "vapore", "varano", "varcato", "variante", "vasca", "vedetta", "vedova", "veduto", "vegetale", "veicolo", "velcro", "velina", "velluto", "veloce", "venato", "vendemmia", "vento", "verace", "verbale", "vergogna", "verifica", "vero", "verruca", "verticale", "vescica", "vessillo", "vestale", "veterano", "vetrina", "vetusto", "viandante", "vibrante", "vicenda", "vichingo", "vicinanza", "vidimare", "vigilia", "vigneto", "vigore", "vile", "villano", "vimini", "vincitore", "viola", "vipera", "virgola", "virologo", "virulento", "viscoso", "visione", "vispo", "vissuto", "visura", "vita", "vitello", "vittima", "vivanda", "vivido", "viziare", "voce", "voga", "volatile", "volere", "volpe", "voragine", "vulcano", "zampogna", "zanna", "zappato", "zattera", "zavorra", "zefiro", "zelante", "zelo", "zenzero", "zerbino", "zibetto", "zinco", "zircone", "zitto", "zolla", "zotico", "zucchero", "zufolo", "zulu", "zuppa"];
var require$$6$1 = ["abaco", "abdomen", "abeja", "abierto", "abogado", "abono", "aborto", "abrazo", "abrir", "abuelo", "abuso", "acabar", "academia", "acceso", "accion", "aceite", "acelga", "acento", "aceptar", "acido", "aclarar", "acne", "acoger", "acoso", "activo", "acto", "actriz", "actuar", "acudir", "acuerdo", "acusar", "adicto", "admitir", "adoptar", "adorno", "aduana", "adulto", "aereo", "afectar", "aficion", "afinar", "afirmar", "agil", "agitar", "agonia", "agosto", "agotar", "agregar", "agrio", "agua", "agudo", "aguila", "aguja", "ahogo", "ahorro", "aire", "aislar", "ajedrez", "ajeno", "ajuste", "alacran", "alambre", "alarma", "alba", "album", "alcalde", "aldea", "alegre", "alejar", "alerta", "aleta", "alfiler", "alga", "algodon", "aliado", "aliento", "alivio", "alma", "almeja", "almibar", "altar", "alteza", "altivo", "alto", "altura", "alumno", "alzar", "amable", "amante", "amapola", "amargo", "amasar", "ambar", "ambito", "ameno", "amigo", "amistad", "amor", "amparo", "amplio", "ancho", "anciano", "ancla", "andar", "anden", "anemia", "angulo", "anillo", "animo", "anis", "anotar", "antena", "antiguo", "antojo", "anual", "anular", "anuncio", "anadir", "anejo", "ano", "apagar", "aparato", "apetito", "apio", "aplicar", "apodo", "aporte", "apoyo", "aprender", "aprobar", "apuesta", "apuro", "arado", "arana", "arar", "arbitro", "arbol", "arbusto", "archivo", "arco", "arder", "ardilla", "arduo", "area", "arido", "aries", "armonia", "arnes", "aroma", "arpa", "arpon", "arreglo", "arroz", "arruga", "arte", "artista", "asa", "asado", "asalto", "ascenso", "asegurar", "aseo", "asesor", "asiento", "asilo", "asistir", "asno", "asombro", "aspero", "astilla", "astro", "astuto", "asumir", "asunto", "atajo", "ataque", "atar", "atento", "ateo", "atico", "atleta", "atomo", "atraer", "atroz", "atun", "audaz", "audio", "auge", "aula", "aumento", "ausente", "autor", "aval", "avance", "avaro", "ave", "avellana", "avena", "avestruz", "avion", "aviso", "ayer", "ayuda", "ayuno", "azafran", "azar", "azote", "azucar", "azufre", "azul", "baba", "babor", "bache", "bahia", "baile", "bajar", "balanza", "balcon", "balde", "bambu", "banco", "banda", "bano", "barba", "barco", "barniz", "barro", "bascula", "baston", "basura", "batalla", "bateria", "batir", "batuta", "baul", "bazar", "bebe", "bebida", "bello", "besar", "beso", "bestia", "bicho", "bien", "bingo", "blanco", "bloque", "blusa", "boa", "bobina", "bobo", "boca", "bocina", "boda", "bodega", "boina", "bola", "bolero", "bolsa", "bomba", "bondad", "bonito", "bono", "bonsai", "borde", "borrar", "bosque", "bote", "botin", "boveda", "bozal", "bravo", "brazo", "brecha", "breve", "brillo", "brinco", "brisa", "broca", "broma", "bronce", "brote", "bruja", "brusco", "bruto", "buceo", "bucle", "bueno", "buey", "bufanda", "bufon", "buho", "buitre", "bulto", "burbuja", "burla", "burro", "buscar", "butaca", "buzon", "caballo", "cabeza", "cabina", "cabra", "cacao", "cadaver", "cadena", "caer", "cafe", "caida", "caiman", "caja", "cajon", "cal", "calamar", "calcio", "caldo", "calidad", "calle", "calma", "calor", "calvo", "cama", "cambio", "camello", "camino", "campo", "cancer", "candil", "canela", "canguro", "canica", "canto", "cana", "canon", "caoba", "caos", "capaz", "capitan", "capote", "captar", "capucha", "cara", "carbon", "carcel", "careta", "carga", "carino", "carne", "carpeta", "carro", "carta", "casa", "casco", "casero", "caspa", "castor", "catorce", "catre", "caudal", "causa", "cazo", "cebolla", "ceder", "cedro", "celda", "celebre", "celoso", "celula", "cemento", "ceniza", "centro", "cerca", "cerdo", "cereza", "cero", "cerrar", "certeza", "cesped", "cetro", "chacal", "chaleco", "champu", "chancla", "chapa", "charla", "chico", "chiste", "chivo", "choque", "choza", "chuleta", "chupar", "ciclon", "ciego", "cielo", "cien", "cierto", "cifra", "cigarro", "cima", "cinco", "cine", "cinta", "cipres", "circo", "ciruela", "cisne", "cita", "ciudad", "clamor", "clan", "claro", "clase", "clave", "cliente", "clima", "clinica", "cobre", "coccion", "cochino", "cocina", "coco", "codigo", "codo", "cofre", "coger", "cohete", "cojin", "cojo", "cola", "colcha", "colegio", "colgar", "colina", "collar", "colmo", "columna", "combate", "comer", "comida", "comodo", "compra", "conde", "conejo", "conga", "conocer", "consejo", "contar", "copa", "copia", "corazon", "corbata", "corcho", "cordon", "corona", "correr", "coser", "cosmos", "costa", "craneo", "crater", "crear", "crecer", "creido", "crema", "cria", "crimen", "cripta", "crisis", "cromo", "cronica", "croqueta", "crudo", "cruz", "cuadro", "cuarto", "cuatro", "cubo", "cubrir", "cuchara", "cuello", "cuento", "cuerda", "cuesta", "cueva", "cuidar", "culebra", "culpa", "culto", "cumbre", "cumplir", "cuna", "cuneta", "cuota", "cupon", "cupula", "curar", "curioso", "curso", "curva", "cutis", "dama", "danza", "dar", "dardo", "datil", "deber", "debil", "decada", "decir", "dedo", "defensa", "definir", "dejar", "delfin", "delgado", "delito", "demora", "denso", "dental", "deporte", "derecho", "derrota", "desayuno", "deseo", "desfile", "desnudo", "destino", "desvio", "detalle", "detener", "deuda", "dia", "diablo", "diadema", "diamante", "diana", "diario", "dibujo", "dictar", "diente", "dieta", "diez", "dificil", "digno", "dilema", "diluir", "dinero", "directo", "dirigir", "disco", "diseno", "disfraz", "diva", "divino", "doble", "doce", "dolor", "domingo", "don", "donar", "dorado", "dormir", "dorso", "dos", "dosis", "dragon", "droga", "ducha", "duda", "duelo", "dueno", "dulce", "duo", "duque", "durar", "dureza", "duro", "ebano", "ebrio", "echar", "eco", "ecuador", "edad", "edicion", "edificio", "editor", "educar", "efecto", "eficaz", "eje", "ejemplo", "elefante", "elegir", "elemento", "elevar", "elipse", "elite", "elixir", "elogio", "eludir", "embudo", "emitir", "emocion", "empate", "empeno", "empleo", "empresa", "enano", "encargo", "enchufe", "encia", "enemigo", "enero", "enfado", "enfermo", "engano", "enigma", "enlace", "enorme", "enredo", "ensayo", "ensenar", "entero", "entrar", "envase", "envio", "epoca", "equipo", "erizo", "escala", "escena", "escolar", "escribir", "escudo", "esencia", "esfera", "esfuerzo", "espada", "espejo", "espia", "esposa", "espuma", "esqui", "estar", "este", "estilo", "estufa", "etapa", "eterno", "etica", "etnia", "evadir", "evaluar", "evento", "evitar", "exacto", "examen", "exceso", "excusa", "exento", "exigir", "exilio", "existir", "exito", "experto", "explicar", "exponer", "extremo", "fabrica", "fabula", "fachada", "facil", "factor", "faena", "faja", "falda", "fallo", "falso", "faltar", "fama", "familia", "famoso", "faraon", "farmacia", "farol", "farsa", "fase", "fatiga", "fauna", "favor", "fax", "febrero", "fecha", "feliz", "feo", "feria", "feroz", "fertil", "fervor", "festin", "fiable", "fianza", "fiar", "fibra", "ficcion", "ficha", "fideo", "fiebre", "fiel", "fiera", "fiesta", "figura", "fijar", "fijo", "fila", "filete", "filial", "filtro", "fin", "finca", "fingir", "finito", "firma", "flaco", "flauta", "flecha", "flor", "flota", "fluir", "flujo", "fluor", "fobia", "foca", "fogata", "fogon", "folio", "folleto", "fondo", "forma", "forro", "fortuna", "forzar", "fosa", "foto", "fracaso", "fragil", "franja", "frase", "fraude", "freir", "freno", "fresa", "frio", "frito", "fruta", "fuego", "fuente", "fuerza", "fuga", "fumar", "funcion", "funda", "furgon", "furia", "fusil", "futbol", "futuro", "gacela", "gafas", "gaita", "gajo", "gala", "galeria", "gallo", "gamba", "ganar", "gancho", "ganga", "ganso", "garaje", "garza", "gasolina", "gastar", "gato", "gavilan", "gemelo", "gemir", "gen", "genero", "genio", "gente", "geranio", "gerente", "germen", "gesto", "gigante", "gimnasio", "girar", "giro", "glaciar", "globo", "gloria", "gol", "golfo", "goloso", "golpe", "goma", "gordo", "gorila", "gorra", "gota", "goteo", "gozar", "grada", "grafico", "grano", "grasa", "gratis", "grave", "grieta", "grillo", "gripe", "gris", "grito", "grosor", "grua", "grueso", "grumo", "grupo", "guante", "guapo", "guardia", "guerra", "guia", "guino", "guion", "guiso", "guitarra", "gusano", "gustar", "haber", "habil", "hablar", "hacer", "hacha", "hada", "hallar", "hamaca", "harina", "haz", "hazana", "hebilla", "hebra", "hecho", "helado", "helio", "hembra", "herir", "hermano", "heroe", "hervir", "hielo", "hierro", "higado", "higiene", "hijo", "himno", "historia", "hocico", "hogar", "hoguera", "hoja", "hombre", "hongo", "honor", "honra", "hora", "hormiga", "horno", "hostil", "hoyo", "hueco", "huelga", "huerta", "hueso", "huevo", "huida", "huir", "humano", "humedo", "humilde", "humo", "hundir", "huracan", "hurto", "icono", "ideal", "idioma", "idolo", "iglesia", "iglu", "igual", "ilegal", "ilusion", "imagen", "iman", "imitar", "impar", "imperio", "imponer", "impulso", "incapaz", "indice", "inerte", "infiel", "informe", "ingenio", "inicio", "inmenso", "inmune", "innato", "insecto", "instante", "interes", "intimo", "intuir", "inutil", "invierno", "ira", "iris", "ironia", "isla", "islote", "jabali", "jabon", "jamon", "jarabe", "jardin", "jarra", "jaula", "jazmin", "jefe", "jeringa", "jinete", "jornada", "joroba", "joven", "joya", "juerga", "jueves", "juez", "jugador", "jugo", "juguete", "juicio", "junco", "jungla", "junio", "juntar", "jupiter", "jurar", "justo", "juvenil", "juzgar", "kilo", "koala", "labio", "lacio", "lacra", "lado", "ladron", "lagarto", "lagrima", "laguna", "laico", "lamer", "lamina", "lampara", "lana", "lancha", "langosta", "lanza", "lapiz", "largo", "larva", "lastima", "lata", "latex", "latir", "laurel", "lavar", "lazo", "leal", "leccion", "leche", "lector", "leer", "legion", "legumbre", "lejano", "lengua", "lento", "lena", "leon", "leopardo", "lesion", "letal", "letra", "leve", "leyenda", "libertad", "libro", "licor", "lider", "lidiar", "lienzo", "liga", "ligero", "lima", "limite", "limon", "limpio", "lince", "lindo", "linea", "lingote", "lino", "linterna", "liquido", "liso", "lista", "litera", "litio", "litro", "llaga", "llama", "llanto", "llave", "llegar", "llenar", "llevar", "llorar", "llover", "lluvia", "lobo", "locion", "loco", "locura", "logica", "logro", "lombriz", "lomo", "lonja", "lote", "lucha", "lucir", "lugar", "lujo", "luna", "lunes", "lupa", "lustro", "luto", "luz", "maceta", "macho", "madera", "madre", "maduro", "maestro", "mafia", "magia", "mago", "maiz", "maldad", "maleta", "malla", "malo", "mama", "mambo", "mamut", "manco", "mando", "manejar", "manga", "maniqui", "manjar", "mano", "manso", "manta", "manana", "mapa", "maquina", "mar", "marco", "marea", "marfil", "margen", "marido", "marmol", "marron", "martes", "marzo", "masa", "mascara", "masivo", "matar", "materia", "matiz", "matriz", "maximo", "mayor", "mazorca", "mecha", "medalla", "medio", "medula", "mejilla", "mejor", "melena", "melon", "memoria", "menor", "mensaje", "mente", "menu", "mercado", "merengue", "merito", "mes", "meson", "meta", "meter", "metodo", "metro", "mezcla", "miedo", "miel", "miembro", "miga", "mil", "milagro", "militar", "millon", "mimo", "mina", "minero", "minimo", "minuto", "miope", "mirar", "misa", "miseria", "misil", "mismo", "mitad", "mito", "mochila", "mocion", "moda", "modelo", "moho", "mojar", "molde", "moler", "molino", "momento", "momia", "monarca", "moneda", "monja", "monto", "mono", "morada", "morder", "moreno", "morir", "morro", "morsa", "mortal", "mosca", "mostrar", "motivo", "mover", "movil", "mozo", "mucho", "mudar", "mueble", "muela", "muerte", "muestra", "mugre", "mujer", "mula", "muleta", "multa", "mundo", "muneca", "mural", "muro", "musculo", "museo", "musgo", "musica", "muslo", "nacar", "nacion", "nadar", "naipe", "naranja", "nariz", "narrar", "nasal", "natal", "nativo", "natural", "nausea", "naval", "nave", "navidad", "necio", "nectar", "negar", "negocio", "negro", "neon", "nervio", "neto", "neutro", "nevar", "nevera", "nicho", "nido", "niebla", "nieto", "ninez", "nino", "nitido", "nivel", "nobleza", "noche", "nomina", "noria", "norma", "norte", "nota", "noticia", "novato", "novela", "novio", "nube", "nuca", "nucleo", "nudillo", "nudo", "nuera", "nueve", "nuez", "nulo", "numero", "nutria", "oasis", "obeso", "obispo", "objeto", "obra", "obrero", "observar", "obtener", "obvio", "oca", "ocaso", "oceano", "ochenta", "ocho", "ocio", "ocre", "octavo", "octubre", "oculto", "ocupar", "ocurrir", "odiar", "odio", "odisea", "oeste", "ofensa", "oferta", "oficio", "ofrecer", "ogro", "oido", "oir", "ojo", "ola", "oleada", "olfato", "olivo", "olla", "olmo", "olor", "olvido", "ombligo", "onda", "onza", "opaco", "opcion", "opera", "opinar", "oponer", "optar", "optica", "opuesto", "oracion", "orador", "oral", "orbita", "orca", "orden", "oreja", "organo", "orgia", "orgullo", "oriente", "origen", "orilla", "oro", "orquesta", "oruga", "osadia", "oscuro", "osezno", "oso", "ostra", "otono", "otro", "oveja", "ovulo", "oxido", "oxigeno", "oyente", "ozono", "pacto", "padre", "paella", "pagina", "pago", "pais", "pajaro", "palabra", "palco", "paleta", "palido", "palma", "paloma", "palpar", "pan", "panal", "panico", "pantera", "panuelo", "papa", "papel", "papilla", "paquete", "parar", "parcela", "pared", "parir", "paro", "parpado", "parque", "parrafo", "parte", "pasar", "paseo", "pasion", "paso", "pasta", "pata", "patio", "patria", "pausa", "pauta", "pavo", "payaso", "peaton", "pecado", "pecera", "pecho", "pedal", "pedir", "pegar", "peine", "pelar", "peldano", "pelea", "peligro", "pellejo", "pelo", "peluca", "pena", "pensar", "penon", "peon", "peor", "pepino", "pequeno", "pera", "percha", "perder", "pereza", "perfil", "perico", "perla", "permiso", "perro", "persona", "pesa", "pesca", "pesimo", "pestana", "petalo", "petroleo", "pez", "pezuna", "picar", "pichon", "pie", "piedra", "pierna", "pieza", "pijama", "pilar", "piloto", "pimienta", "pino", "pintor", "pinza", "pina", "piojo", "pipa", "pirata", "pisar", "piscina", "piso", "pista", "piton", "pizca", "placa", "plan", "plata", "playa", "plaza", "pleito", "pleno", "plomo", "pluma", "plural", "pobre", "poco", "poder", "podio", "poema", "poesia", "poeta", "polen", "policia", "pollo", "polvo", "pomada", "pomelo", "pomo", "pompa", "poner", "porcion", "portal", "posada", "poseer", "posible", "poste", "potencia", "potro", "pozo", "prado", "precoz", "pregunta", "premio", "prensa", "preso", "previo", "primo", "principe", "prision", "privar", "proa", "probar", "proceso", "producto", "proeza", "profesor", "programa", "prole", "promesa", "pronto", "propio", "proximo", "prueba", "publico", "puchero", "pudor", "pueblo", "puerta", "puesto", "pulga", "pulir", "pulmon", "pulpo", "pulso", "puma", "punto", "punal", "puno", "pupa", "pupila", "pure", "quedar", "queja", "quemar", "querer", "queso", "quieto", "quimica", "quince", "quitar", "rabano", "rabia", "rabo", "racion", "radical", "raiz", "rama", "rampa", "rancho", "rango", "rapaz", "rapido", "rapto", "rasgo", "raspa", "rato", "rayo", "raza", "razon", "reaccion", "realidad", "rebano", "rebote", "recaer", "receta", "rechazo", "recoger", "recreo", "recto", "recurso", "red", "redondo", "reducir", "reflejo", "reforma", "refran", "refugio", "regalo", "regir", "regla", "regreso", "rehen", "reino", "reir", "reja", "relato", "relevo", "relieve", "relleno", "reloj", "remar", "remedio", "remo", "rencor", "rendir", "renta", "reparto", "repetir", "reposo", "reptil", "res", "rescate", "resina", "respeto", "resto", "resumen", "retiro", "retorno", "retrato", "reunir", "reves", "revista", "rey", "rezar", "rico", "riego", "rienda", "riesgo", "rifa", "rigido", "rigor", "rincon", "rinon", "rio", "riqueza", "risa", "ritmo", "rito", "rizo", "roble", "roce", "rociar", "rodar", "rodeo", "rodilla", "roer", "rojizo", "rojo", "romero", "romper", "ron", "ronco", "ronda", "ropa", "ropero", "rosa", "rosca", "rostro", "rotar", "rubi", "rubor", "rudo", "rueda", "rugir", "ruido", "ruina", "ruleta", "rulo", "rumbo", "rumor", "ruptura", "ruta", "rutina", "sabado", "saber", "sabio", "sable", "sacar", "sagaz", "sagrado", "sala", "saldo", "salero", "salir", "salmon", "salon", "salsa", "salto", "salud", "salvar", "samba", "sancion", "sandia", "sanear", "sangre", "sanidad", "sano", "santo", "sapo", "saque", "sardina", "sarten", "sastre", "satan", "sauna", "saxofon", "seccion", "seco", "secreto", "secta", "sed", "seguir", "seis", "sello", "selva", "semana", "semilla", "senda", "sensor", "senal", "senor", "separar", "sepia", "sequia", "ser", "serie", "sermon", "servir", "sesenta", "sesion", "seta", "setenta", "severo", "sexo", "sexto", "sidra", "siesta", "siete", "siglo", "signo", "silaba", "silbar", "silencio", "silla", "simbolo", "simio", "sirena", "sistema", "sitio", "situar", "sobre", "socio", "sodio", "sol", "solapa", "soldado", "soledad", "solido", "soltar", "solucion", "sombra", "sondeo", "sonido", "sonoro", "sonrisa", "sopa", "soplar", "soporte", "sordo", "sorpresa", "sorteo", "sosten", "sotano", "suave", "subir", "suceso", "sudor", "suegra", "suelo", "sueno", "suerte", "sufrir", "sujeto", "sultan", "sumar", "superar", "suplir", "suponer", "supremo", "sur", "surco", "sureno", "surgir", "susto", "sutil", "tabaco", "tabique", "tabla", "tabu", "taco", "tacto", "tajo", "talar", "talco", "talento", "talla", "talon", "tamano", "tambor", "tango", "tanque", "tapa", "tapete", "tapia", "tapon", "taquilla", "tarde", "tarea", "tarifa", "tarjeta", "tarot", "tarro", "tarta", "tatuaje", "tauro", "taza", "tazon", "teatro", "techo", "tecla", "tecnica", "tejado", "tejer", "tejido", "tela", "telefono", "tema", "temor", "templo", "tenaz", "tender", "tener", "tenis", "tenso", "teoria", "terapia", "terco", "termino", "ternura", "terror", "tesis", "tesoro", "testigo", "tetera", "texto", "tez", "tibio", "tiburon", "tiempo", "tienda", "tierra", "tieso", "tigre", "tijera", "tilde", "timbre", "timido", "timo", "tinta", "tio", "tipico", "tipo", "tira", "tiron", "titan", "titere", "titulo", "tiza", "toalla", "tobillo", "tocar", "tocino", "todo", "toga", "toldo", "tomar", "tono", "tonto", "topar", "tope", "toque", "torax", "torero", "tormenta", "torneo", "toro", "torpedo", "torre", "torso", "tortuga", "tos", "tosco", "toser", "toxico", "trabajo", "tractor", "traer", "trafico", "trago", "traje", "tramo", "trance", "trato", "trauma", "trazar", "trebol", "tregua", "treinta", "tren", "trepar", "tres", "tribu", "trigo", "tripa", "triste", "triunfo", "trofeo", "trompa", "tronco", "tropa", "trote", "trozo", "truco", "trueno", "trufa", "tuberia", "tubo", "tuerto", "tumba", "tumor", "tunel", "tunica", "turbina", "turismo", "turno", "tutor", "ubicar", "ulcera", "umbral", "unidad", "unir", "universo", "uno", "untar", "una", "urbano", "urbe", "urgente", "urna", "usar", "usuario", "util", "utopia", "uva", "vaca", "vacio", "vacuna", "vagar", "vago", "vaina", "vajilla", "vale", "valido", "valle", "valor", "valvula", "vampiro", "vara", "variar", "varon", "vaso", "vecino", "vector", "vehiculo", "veinte", "vejez", "vela", "velero", "veloz", "vena", "vencer", "venda", "veneno", "vengar", "venir", "venta", "venus", "ver", "verano", "verbo", "verde", "vereda", "verja", "verso", "verter", "via", "viaje", "vibrar", "vicio", "victima", "vida", "video", "vidrio", "viejo", "viernes", "vigor", "vil", "villa", "vinagre", "vino", "vinedo", "violin", "viral", "virgo", "virtud", "visor", "vispera", "vista", "vitamina", "viudo", "vivaz", "vivero", "vivir", "vivo", "volcan", "volumen", "volver", "voraz", "votar", "voto", "voz", "vuelo", "vulgar", "yacer", "yate", "yegua", "yema", "yerno", "yeso", "yodo", "yoga", "yogur", "zafiro", "zanja", "zapato", "zarza", "zona", "zorro", "zumo", "zurdo"];
var require$$7 = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
var require$$8 = ["abacate", "abaixo", "abalar", "abater", "abduzir", "abelha", "aberto", "abismo", "abotoar", "abranger", "abreviar", "abrigar", "abrupto", "absinto", "absoluto", "absurdo", "abutre", "acabado", "acalmar", "acampar", "acanhar", "acaso", "aceitar", "acelerar", "acenar", "acervo", "acessar", "acetona", "achatar", "acidez", "acima", "acionado", "acirrar", "aclamar", "aclive", "acolhida", "acomodar", "acoplar", "acordar", "acumular", "acusador", "adaptar", "adega", "adentro", "adepto", "adequar", "aderente", "adesivo", "adeus", "adiante", "aditivo", "adjetivo", "adjunto", "admirar", "adorar", "adquirir", "adubo", "adverso", "advogado", "aeronave", "afastar", "aferir", "afetivo", "afinador", "afivelar", "aflito", "afluente", "afrontar", "agachar", "agarrar", "agasalho", "agenciar", "agilizar", "agiota", "agitado", "agora", "agradar", "agreste", "agrupar", "aguardar", "agulha", "ajoelhar", "ajudar", "ajustar", "alameda", "alarme", "alastrar", "alavanca", "albergue", "albino", "alcatra", "aldeia", "alecrim", "alegria", "alertar", "alface", "alfinete", "algum", "alheio", "aliar", "alicate", "alienar", "alinhar", "aliviar", "almofada", "alocar", "alpiste", "alterar", "altitude", "alucinar", "alugar", "aluno", "alusivo", "alvo", "amaciar", "amador", "amarelo", "amassar", "ambas", "ambiente", "ameixa", "amenizar", "amido", "amistoso", "amizade", "amolador", "amontoar", "amoroso", "amostra", "amparar", "ampliar", "ampola", "anagrama", "analisar", "anarquia", "anatomia", "andaime", "anel", "anexo", "angular", "animar", "anjo", "anomalia", "anotado", "ansioso", "anterior", "anuidade", "anunciar", "anzol", "apagador", "apalpar", "apanhado", "apego", "apelido", "apertada", "apesar", "apetite", "apito", "aplauso", "aplicada", "apoio", "apontar", "aposta", "aprendiz", "aprovar", "aquecer", "arame", "aranha", "arara", "arcada", "ardente", "areia", "arejar", "arenito", "aresta", "argiloso", "argola", "arma", "arquivo", "arraial", "arrebate", "arriscar", "arroba", "arrumar", "arsenal", "arterial", "artigo", "arvoredo", "asfaltar", "asilado", "aspirar", "assador", "assinar", "assoalho", "assunto", "astral", "atacado", "atadura", "atalho", "atarefar", "atear", "atender", "aterro", "ateu", "atingir", "atirador", "ativo", "atoleiro", "atracar", "atrevido", "atriz", "atual", "atum", "auditor", "aumentar", "aura", "aurora", "autismo", "autoria", "autuar", "avaliar", "avante", "avaria", "avental", "avesso", "aviador", "avisar", "avulso", "axila", "azarar", "azedo", "azeite", "azulejo", "babar", "babosa", "bacalhau", "bacharel", "bacia", "bagagem", "baiano", "bailar", "baioneta", "bairro", "baixista", "bajular", "baleia", "baliza", "balsa", "banal", "bandeira", "banho", "banir", "banquete", "barato", "barbado", "baronesa", "barraca", "barulho", "baseado", "bastante", "batata", "batedor", "batida", "batom", "batucar", "baunilha", "beber", "beijo", "beirada", "beisebol", "beldade", "beleza", "belga", "beliscar", "bendito", "bengala", "benzer", "berimbau", "berlinda", "berro", "besouro", "bexiga", "bezerro", "bico", "bicudo", "bienal", "bifocal", "bifurcar", "bigorna", "bilhete", "bimestre", "bimotor", "biologia", "biombo", "biosfera", "bipolar", "birrento", "biscoito", "bisneto", "bispo", "bissexto", "bitola", "bizarro", "blindado", "bloco", "bloquear", "boato", "bobagem", "bocado", "bocejo", "bochecha", "boicotar", "bolada", "boletim", "bolha", "bolo", "bombeiro", "bonde", "boneco", "bonita", "borbulha", "borda", "boreal", "borracha", "bovino", "boxeador", "branco", "brasa", "braveza", "breu", "briga", "brilho", "brincar", "broa", "brochura", "bronzear", "broto", "bruxo", "bucha", "budismo", "bufar", "bule", "buraco", "busca", "busto", "buzina", "cabana", "cabelo", "cabide", "cabo", "cabrito", "cacau", "cacetada", "cachorro", "cacique", "cadastro", "cadeado", "cafezal", "caiaque", "caipira", "caixote", "cajado", "caju", "calafrio", "calcular", "caldeira", "calibrar", "calmante", "calota", "camada", "cambista", "camisa", "camomila", "campanha", "camuflar", "canavial", "cancelar", "caneta", "canguru", "canhoto", "canivete", "canoa", "cansado", "cantar", "canudo", "capacho", "capela", "capinar", "capotar", "capricho", "captador", "capuz", "caracol", "carbono", "cardeal", "careca", "carimbar", "carneiro", "carpete", "carreira", "cartaz", "carvalho", "casaco", "casca", "casebre", "castelo", "casulo", "catarata", "cativar", "caule", "causador", "cautelar", "cavalo", "caverna", "cebola", "cedilha", "cegonha", "celebrar", "celular", "cenoura", "censo", "centeio", "cercar", "cerrado", "certeiro", "cerveja", "cetim", "cevada", "chacota", "chaleira", "chamado", "chapada", "charme", "chatice", "chave", "chefe", "chegada", "cheiro", "cheque", "chicote", "chifre", "chinelo", "chocalho", "chover", "chumbo", "chutar", "chuva", "cicatriz", "ciclone", "cidade", "cidreira", "ciente", "cigana", "cimento", "cinto", "cinza", "ciranda", "circuito", "cirurgia", "citar", "clareza", "clero", "clicar", "clone", "clube", "coado", "coagir", "cobaia", "cobertor", "cobrar", "cocada", "coelho", "coentro", "coeso", "cogumelo", "coibir", "coifa", "coiote", "colar", "coleira", "colher", "colidir", "colmeia", "colono", "coluna", "comando", "combinar", "comentar", "comitiva", "comover", "complexo", "comum", "concha", "condor", "conectar", "confuso", "congelar", "conhecer", "conjugar", "consumir", "contrato", "convite", "cooperar", "copeiro", "copiador", "copo", "coquetel", "coragem", "cordial", "corneta", "coronha", "corporal", "correio", "cortejo", "coruja", "corvo", "cosseno", "costela", "cotonete", "couro", "couve", "covil", "cozinha", "cratera", "cravo", "creche", "credor", "creme", "crer", "crespo", "criada", "criminal", "crioulo", "crise", "criticar", "crosta", "crua", "cruzeiro", "cubano", "cueca", "cuidado", "cujo", "culatra", "culminar", "culpar", "cultura", "cumprir", "cunhado", "cupido", "curativo", "curral", "cursar", "curto", "cuspir", "custear", "cutelo", "damasco", "datar", "debater", "debitar", "deboche", "debulhar", "decalque", "decimal", "declive", "decote", "decretar", "dedal", "dedicado", "deduzir", "defesa", "defumar", "degelo", "degrau", "degustar", "deitado", "deixar", "delator", "delegado", "delinear", "delonga", "demanda", "demitir", "demolido", "dentista", "depenado", "depilar", "depois", "depressa", "depurar", "deriva", "derramar", "desafio", "desbotar", "descanso", "desenho", "desfiado", "desgaste", "desigual", "deslize", "desmamar", "desova", "despesa", "destaque", "desviar", "detalhar", "detentor", "detonar", "detrito", "deusa", "dever", "devido", "devotado", "dezena", "diagrama", "dialeto", "didata", "difuso", "digitar", "dilatado", "diluente", "diminuir", "dinastia", "dinheiro", "diocese", "direto", "discreta", "disfarce", "disparo", "disquete", "dissipar", "distante", "ditador", "diurno", "diverso", "divisor", "divulgar", "dizer", "dobrador", "dolorido", "domador", "dominado", "donativo", "donzela", "dormente", "dorsal", "dosagem", "dourado", "doutor", "drenagem", "drible", "drogaria", "duelar", "duende", "dueto", "duplo", "duquesa", "durante", "duvidoso", "eclodir", "ecoar", "ecologia", "edificar", "edital", "educado", "efeito", "efetivar", "ejetar", "elaborar", "eleger", "eleitor", "elenco", "elevador", "eliminar", "elogiar", "embargo", "embolado", "embrulho", "embutido", "emenda", "emergir", "emissor", "empatia", "empenho", "empinado", "empolgar", "emprego", "empurrar", "emulador", "encaixe", "encenado", "enchente", "encontro", "endeusar", "endossar", "enfaixar", "enfeite", "enfim", "engajado", "engenho", "englobar", "engomado", "engraxar", "enguia", "enjoar", "enlatar", "enquanto", "enraizar", "enrolado", "enrugar", "ensaio", "enseada", "ensino", "ensopado", "entanto", "enteado", "entidade", "entortar", "entrada", "entulho", "envergar", "enviado", "envolver", "enxame", "enxerto", "enxofre", "enxuto", "epiderme", "equipar", "ereto", "erguido", "errata", "erva", "ervilha", "esbanjar", "esbelto", "escama", "escola", "escrita", "escuta", "esfinge", "esfolar", "esfregar", "esfumado", "esgrima", "esmalte", "espanto", "espelho", "espiga", "esponja", "espreita", "espumar", "esquerda", "estaca", "esteira", "esticar", "estofado", "estrela", "estudo", "esvaziar", "etanol", "etiqueta", "euforia", "europeu", "evacuar", "evaporar", "evasivo", "eventual", "evidente", "evoluir", "exagero", "exalar", "examinar", "exato", "exausto", "excesso", "excitar", "exclamar", "executar", "exemplo", "exibir", "exigente", "exonerar", "expandir", "expelir", "expirar", "explanar", "exposto", "expresso", "expulsar", "externo", "extinto", "extrato", "fabricar", "fabuloso", "faceta", "facial", "fada", "fadiga", "faixa", "falar", "falta", "familiar", "fandango", "fanfarra", "fantoche", "fardado", "farelo", "farinha", "farofa", "farpa", "fartura", "fatia", "fator", "favorita", "faxina", "fazenda", "fechado", "feijoada", "feirante", "felino", "feminino", "fenda", "feno", "fera", "feriado", "ferrugem", "ferver", "festejar", "fetal", "feudal", "fiapo", "fibrose", "ficar", "ficheiro", "figurado", "fileira", "filho", "filme", "filtrar", "firmeza", "fisgada", "fissura", "fita", "fivela", "fixador", "fixo", "flacidez", "flamingo", "flanela", "flechada", "flora", "flutuar", "fluxo", "focal", "focinho", "fofocar", "fogo", "foguete", "foice", "folgado", "folheto", "forjar", "formiga", "forno", "forte", "fosco", "fossa", "fragata", "fralda", "frango", "frasco", "fraterno", "freira", "frente", "fretar", "frieza", "friso", "fritura", "fronha", "frustrar", "fruteira", "fugir", "fulano", "fuligem", "fundar", "fungo", "funil", "furador", "furioso", "futebol", "gabarito", "gabinete", "gado", "gaiato", "gaiola", "gaivota", "galega", "galho", "galinha", "galocha", "ganhar", "garagem", "garfo", "gargalo", "garimpo", "garoupa", "garrafa", "gasoduto", "gasto", "gata", "gatilho", "gaveta", "gazela", "gelado", "geleia", "gelo", "gemada", "gemer", "gemido", "generoso", "gengiva", "genial", "genoma", "genro", "geologia", "gerador", "germinar", "gesso", "gestor", "ginasta", "gincana", "gingado", "girafa", "girino", "glacial", "glicose", "global", "glorioso", "goela", "goiaba", "golfe", "golpear", "gordura", "gorjeta", "gorro", "gostoso", "goteira", "governar", "gracejo", "gradual", "grafite", "gralha", "grampo", "granada", "gratuito", "graveto", "graxa", "grego", "grelhar", "greve", "grilo", "grisalho", "gritaria", "grosso", "grotesco", "grudado", "grunhido", "gruta", "guache", "guarani", "guaxinim", "guerrear", "guiar", "guincho", "guisado", "gula", "guloso", "guru", "habitar", "harmonia", "haste", "haver", "hectare", "herdar", "heresia", "hesitar", "hiato", "hibernar", "hidratar", "hiena", "hino", "hipismo", "hipnose", "hipoteca", "hoje", "holofote", "homem", "honesto", "honrado", "hormonal", "hospedar", "humorado", "iate", "ideia", "idoso", "ignorado", "igreja", "iguana", "ileso", "ilha", "iludido", "iluminar", "ilustrar", "imagem", "imediato", "imenso", "imersivo", "iminente", "imitador", "imortal", "impacto", "impedir", "implante", "impor", "imprensa", "impune", "imunizar", "inalador", "inapto", "inativo", "incenso", "inchar", "incidir", "incluir", "incolor", "indeciso", "indireto", "indutor", "ineficaz", "inerente", "infantil", "infestar", "infinito", "inflamar", "informal", "infrator", "ingerir", "inibido", "inicial", "inimigo", "injetar", "inocente", "inodoro", "inovador", "inox", "inquieto", "inscrito", "inseto", "insistir", "inspetor", "instalar", "insulto", "intacto", "integral", "intimar", "intocado", "intriga", "invasor", "inverno", "invicto", "invocar", "iogurte", "iraniano", "ironizar", "irreal", "irritado", "isca", "isento", "isolado", "isqueiro", "italiano", "janeiro", "jangada", "janta", "jararaca", "jardim", "jarro", "jasmim", "jato", "javali", "jazida", "jejum", "joaninha", "joelhada", "jogador", "joia", "jornal", "jorrar", "jovem", "juba", "judeu", "judoca", "juiz", "julgador", "julho", "jurado", "jurista", "juro", "justa", "labareda", "laboral", "lacre", "lactante", "ladrilho", "lagarta", "lagoa", "laje", "lamber", "lamentar", "laminar", "lampejo", "lanche", "lapidar", "lapso", "laranja", "lareira", "largura", "lasanha", "lastro", "lateral", "latido", "lavanda", "lavoura", "lavrador", "laxante", "lazer", "lealdade", "lebre", "legado", "legendar", "legista", "leigo", "leiloar", "leitura", "lembrete", "leme", "lenhador", "lentilha", "leoa", "lesma", "leste", "letivo", "letreiro", "levar", "leveza", "levitar", "liberal", "libido", "liderar", "ligar", "ligeiro", "limitar", "limoeiro", "limpador", "linda", "linear", "linhagem", "liquidez", "listagem", "lisura", "litoral", "livro", "lixa", "lixeira", "locador", "locutor", "lojista", "lombo", "lona", "longe", "lontra", "lorde", "lotado", "loteria", "loucura", "lousa", "louvar", "luar", "lucidez", "lucro", "luneta", "lustre", "lutador", "luva", "macaco", "macete", "machado", "macio", "madeira", "madrinha", "magnata", "magreza", "maior", "mais", "malandro", "malha", "malote", "maluco", "mamilo", "mamoeiro", "mamute", "manada", "mancha", "mandato", "manequim", "manhoso", "manivela", "manobrar", "mansa", "manter", "manusear", "mapeado", "maquinar", "marcador", "maresia", "marfim", "margem", "marinho", "marmita", "maroto", "marquise", "marreco", "martelo", "marujo", "mascote", "masmorra", "massagem", "mastigar", "matagal", "materno", "matinal", "matutar", "maxilar", "medalha", "medida", "medusa", "megafone", "meiga", "melancia", "melhor", "membro", "memorial", "menino", "menos", "mensagem", "mental", "merecer", "mergulho", "mesada", "mesclar", "mesmo", "mesquita", "mestre", "metade", "meteoro", "metragem", "mexer", "mexicano", "micro", "migalha", "migrar", "milagre", "milenar", "milhar", "mimado", "minerar", "minhoca", "ministro", "minoria", "miolo", "mirante", "mirtilo", "misturar", "mocidade", "moderno", "modular", "moeda", "moer", "moinho", "moita", "moldura", "moleza", "molho", "molinete", "molusco", "montanha", "moqueca", "morango", "morcego", "mordomo", "morena", "mosaico", "mosquete", "mostarda", "motel", "motim", "moto", "motriz", "muda", "muito", "mulata", "mulher", "multar", "mundial", "munido", "muralha", "murcho", "muscular", "museu", "musical", "nacional", "nadador", "naja", "namoro", "narina", "narrado", "nascer", "nativa", "natureza", "navalha", "navegar", "navio", "neblina", "nebuloso", "negativa", "negociar", "negrito", "nervoso", "neta", "neural", "nevasca", "nevoeiro", "ninar", "ninho", "nitidez", "nivelar", "nobreza", "noite", "noiva", "nomear", "nominal", "nordeste", "nortear", "notar", "noticiar", "noturno", "novelo", "novilho", "novo", "nublado", "nudez", "numeral", "nupcial", "nutrir", "nuvem", "obcecado", "obedecer", "objetivo", "obrigado", "obscuro", "obstetra", "obter", "obturar", "ocidente", "ocioso", "ocorrer", "oculista", "ocupado", "ofegante", "ofensiva", "oferenda", "oficina", "ofuscado", "ogiva", "olaria", "oleoso", "olhar", "oliveira", "ombro", "omelete", "omisso", "omitir", "ondulado", "oneroso", "ontem", "opcional", "operador", "oponente", "oportuno", "oposto", "orar", "orbitar", "ordem", "ordinal", "orfanato", "orgasmo", "orgulho", "oriental", "origem", "oriundo", "orla", "ortodoxo", "orvalho", "oscilar", "ossada", "osso", "ostentar", "otimismo", "ousadia", "outono", "outubro", "ouvido", "ovelha", "ovular", "oxidar", "oxigenar", "pacato", "paciente", "pacote", "pactuar", "padaria", "padrinho", "pagar", "pagode", "painel", "pairar", "paisagem", "palavra", "palestra", "palheta", "palito", "palmada", "palpitar", "pancada", "panela", "panfleto", "panqueca", "pantanal", "papagaio", "papelada", "papiro", "parafina", "parcial", "pardal", "parede", "partida", "pasmo", "passado", "pastel", "patamar", "patente", "patinar", "patrono", "paulada", "pausar", "peculiar", "pedalar", "pedestre", "pediatra", "pedra", "pegada", "peitoral", "peixe", "pele", "pelicano", "penca", "pendurar", "peneira", "penhasco", "pensador", "pente", "perceber", "perfeito", "pergunta", "perito", "permitir", "perna", "perplexo", "persiana", "pertence", "peruca", "pescado", "pesquisa", "pessoa", "petiscar", "piada", "picado", "piedade", "pigmento", "pilastra", "pilhado", "pilotar", "pimenta", "pincel", "pinguim", "pinha", "pinote", "pintar", "pioneiro", "pipoca", "piquete", "piranha", "pires", "pirueta", "piscar", "pistola", "pitanga", "pivete", "planta", "plaqueta", "platina", "plebeu", "plumagem", "pluvial", "pneu", "poda", "poeira", "poetisa", "polegada", "policiar", "poluente", "polvilho", "pomar", "pomba", "ponderar", "pontaria", "populoso", "porta", "possuir", "postal", "pote", "poupar", "pouso", "povoar", "praia", "prancha", "prato", "praxe", "prece", "predador", "prefeito", "premiar", "prensar", "preparar", "presilha", "pretexto", "prevenir", "prezar", "primata", "princesa", "prisma", "privado", "processo", "produto", "profeta", "proibido", "projeto", "prometer", "propagar", "prosa", "protetor", "provador", "publicar", "pudim", "pular", "pulmonar", "pulseira", "punhal", "punir", "pupilo", "pureza", "puxador", "quadra", "quantia", "quarto", "quase", "quebrar", "queda", "queijo", "quente", "querido", "quimono", "quina", "quiosque", "rabanada", "rabisco", "rachar", "racionar", "radial", "raiar", "rainha", "raio", "raiva", "rajada", "ralado", "ramal", "ranger", "ranhura", "rapadura", "rapel", "rapidez", "raposa", "raquete", "raridade", "rasante", "rascunho", "rasgar", "raspador", "rasteira", "rasurar", "ratazana", "ratoeira", "realeza", "reanimar", "reaver", "rebaixar", "rebelde", "rebolar", "recado", "recente", "recheio", "recibo", "recordar", "recrutar", "recuar", "rede", "redimir", "redonda", "reduzida", "reenvio", "refinar", "refletir", "refogar", "refresco", "refugiar", "regalia", "regime", "regra", "reinado", "reitor", "rejeitar", "relativo", "remador", "remendo", "remorso", "renovado", "reparo", "repelir", "repleto", "repolho", "represa", "repudiar", "requerer", "resenha", "resfriar", "resgatar", "residir", "resolver", "respeito", "ressaca", "restante", "resumir", "retalho", "reter", "retirar", "retomada", "retratar", "revelar", "revisor", "revolta", "riacho", "rica", "rigidez", "rigoroso", "rimar", "ringue", "risada", "risco", "risonho", "robalo", "rochedo", "rodada", "rodeio", "rodovia", "roedor", "roleta", "romano", "roncar", "rosado", "roseira", "rosto", "rota", "roteiro", "rotina", "rotular", "rouco", "roupa", "roxo", "rubro", "rugido", "rugoso", "ruivo", "rumo", "rupestre", "russo", "sabor", "saciar", "sacola", "sacudir", "sadio", "safira", "saga", "sagrada", "saibro", "salada", "saleiro", "salgado", "saliva", "salpicar", "salsicha", "saltar", "salvador", "sambar", "samurai", "sanar", "sanfona", "sangue", "sanidade", "sapato", "sarda", "sargento", "sarjeta", "saturar", "saudade", "saxofone", "sazonal", "secar", "secular", "seda", "sedento", "sediado", "sedoso", "sedutor", "segmento", "segredo", "segundo", "seiva", "seleto", "selvagem", "semanal", "semente", "senador", "senhor", "sensual", "sentado", "separado", "sereia", "seringa", "serra", "servo", "setembro", "setor", "sigilo", "silhueta", "silicone", "simetria", "simpatia", "simular", "sinal", "sincero", "singular", "sinopse", "sintonia", "sirene", "siri", "situado", "soberano", "sobra", "socorro", "sogro", "soja", "solda", "soletrar", "solteiro", "sombrio", "sonata", "sondar", "sonegar", "sonhador", "sono", "soprano", "soquete", "sorrir", "sorteio", "sossego", "sotaque", "soterrar", "sovado", "sozinho", "suavizar", "subida", "submerso", "subsolo", "subtrair", "sucata", "sucesso", "suco", "sudeste", "sufixo", "sugador", "sugerir", "sujeito", "sulfato", "sumir", "suor", "superior", "suplicar", "suposto", "suprimir", "surdina", "surfista", "surpresa", "surreal", "surtir", "suspiro", "sustento", "tabela", "tablete", "tabuada", "tacho", "tagarela", "talher", "talo", "talvez", "tamanho", "tamborim", "tampa", "tangente", "tanto", "tapar", "tapioca", "tardio", "tarefa", "tarja", "tarraxa", "tatuagem", "taurino", "taxativo", "taxista", "teatral", "tecer", "tecido", "teclado", "tedioso", "teia", "teimar", "telefone", "telhado", "tempero", "tenente", "tensor", "tentar", "termal", "terno", "terreno", "tese", "tesoura", "testado", "teto", "textura", "texugo", "tiara", "tigela", "tijolo", "timbrar", "timidez", "tingido", "tinteiro", "tiragem", "titular", "toalha", "tocha", "tolerar", "tolice", "tomada", "tomilho", "tonel", "tontura", "topete", "tora", "torcido", "torneio", "torque", "torrada", "torto", "tostar", "touca", "toupeira", "toxina", "trabalho", "tracejar", "tradutor", "trafegar", "trajeto", "trama", "trancar", "trapo", "traseiro", "tratador", "travar", "treino", "tremer", "trepidar", "trevo", "triagem", "tribo", "triciclo", "tridente", "trilogia", "trindade", "triplo", "triturar", "triunfal", "trocar", "trombeta", "trova", "trunfo", "truque", "tubular", "tucano", "tudo", "tulipa", "tupi", "turbo", "turma", "turquesa", "tutelar", "tutorial", "uivar", "umbigo", "unha", "unidade", "uniforme", "urologia", "urso", "urtiga", "urubu", "usado", "usina", "usufruir", "vacina", "vadiar", "vagaroso", "vaidoso", "vala", "valente", "validade", "valores", "vantagem", "vaqueiro", "varanda", "vareta", "varrer", "vascular", "vasilha", "vassoura", "vazar", "vazio", "veado", "vedar", "vegetar", "veicular", "veleiro", "velhice", "veludo", "vencedor", "vendaval", "venerar", "ventre", "verbal", "verdade", "vereador", "vergonha", "vermelho", "verniz", "versar", "vertente", "vespa", "vestido", "vetorial", "viaduto", "viagem", "viajar", "viatura", "vibrador", "videira", "vidraria", "viela", "viga", "vigente", "vigiar", "vigorar", "vilarejo", "vinco", "vinheta", "vinil", "violeta", "virada", "virtude", "visitar", "visto", "vitral", "viveiro", "vizinho", "voador", "voar", "vogal", "volante", "voleibol", "voltagem", "volumoso", "vontade", "vulto", "vuvuzela", "xadrez", "xarope", "xeque", "xeretar", "xerife", "xingar", "zangado", "zarpar", "zebu", "zelador", "zombar", "zoologia", "zumbido"];
var require$$9 = ["abandon", "ability", "able", "about", "above", "absent", "absorb", "abstract", "absurd", "abuse", "access", "accident", "account", "accuse", "achieve", "acid", "acoustic", "acquire", "across", "act", "action", "actor", "actress", "actual", "adapt", "add", "addict", "address", "adjust", "admit", "adult", "advance", "advice", "aerobic", "affair", "afford", "afraid", "again", "age", "agent", "agree", "ahead", "aim", "air", "airport", "aisle", "alarm", "album", "alcohol", "alert", "alien", "all", "alley", "allow", "almost", "alone", "alpha", "already", "also", "alter", "always", "amateur", "amazing", "among", "amount", "amused", "analyst", "anchor", "ancient", "anger", "angle", "angry", "animal", "ankle", "announce", "annual", "another", "answer", "antenna", "antique", "anxiety", "any", "apart", "apology", "appear", "apple", "approve", "april", "arch", "arctic", "area", "arena", "argue", "arm", "armed", "armor", "army", "around", "arrange", "arrest", "arrive", "arrow", "art", "artefact", "artist", "artwork", "ask", "aspect", "assault", "asset", "assist", "assume", "asthma", "athlete", "atom", "attack", "attend", "attitude", "attract", "auction", "audit", "august", "aunt", "author", "auto", "autumn", "average", "avocado", "avoid", "awake", "aware", "away", "awesome", "awful", "awkward", "axis", "baby", "bachelor", "bacon", "badge", "bag", "balance", "balcony", "ball", "bamboo", "banana", "banner", "bar", "barely", "bargain", "barrel", "base", "basic", "basket", "battle", "beach", "bean", "beauty", "because", "become", "beef", "before", "begin", "behave", "behind", "believe", "below", "belt", "bench", "benefit", "best", "betray", "better", "between", "beyond", "bicycle", "bid", "bike", "bind", "biology", "bird", "birth", "bitter", "black", "blade", "blame", "blanket", "blast", "bleak", "bless", "blind", "blood", "blossom", "blouse", "blue", "blur", "blush", "board", "boat", "body", "boil", "bomb", "bone", "bonus", "book", "boost", "border", "boring", "borrow", "boss", "bottom", "bounce", "box", "boy", "bracket", "brain", "brand", "brass", "brave", "bread", "breeze", "brick", "bridge", "brief", "bright", "bring", "brisk", "broccoli", "broken", "bronze", "broom", "brother", "brown", "brush", "bubble", "buddy", "budget", "buffalo", "build", "bulb", "bulk", "bullet", "bundle", "bunker", "burden", "burger", "burst", "bus", "business", "busy", "butter", "buyer", "buzz", "cabbage", "cabin", "cable", "cactus", "cage", "cake", "call", "calm", "camera", "camp", "can", "canal", "cancel", "candy", "cannon", "canoe", "canvas", "canyon", "capable", "capital", "captain", "car", "carbon", "card", "cargo", "carpet", "carry", "cart", "case", "cash", "casino", "castle", "casual", "cat", "catalog", "catch", "category", "cattle", "caught", "cause", "caution", "cave", "ceiling", "celery", "cement", "census", "century", "cereal", "certain", "chair", "chalk", "champion", "change", "chaos", "chapter", "charge", "chase", "chat", "cheap", "check", "cheese", "chef", "cherry", "chest", "chicken", "chief", "child", "chimney", "choice", "choose", "chronic", "chuckle", "chunk", "churn", "cigar", "cinnamon", "circle", "citizen", "city", "civil", "claim", "clap", "clarify", "claw", "clay", "clean", "clerk", "clever", "click", "client", "cliff", "climb", "clinic", "clip", "clock", "clog", "close", "cloth", "cloud", "clown", "club", "clump", "cluster", "clutch", "coach", "coast", "coconut", "code", "coffee", "coil", "coin", "collect", "color", "column", "combine", "come", "comfort", "comic", "common", "company", "concert", "conduct", "confirm", "congress", "connect", "consider", "control", "convince", "cook", "cool", "copper", "copy", "coral", "core", "corn", "correct", "cost", "cotton", "couch", "country", "couple", "course", "cousin", "cover", "coyote", "crack", "cradle", "craft", "cram", "crane", "crash", "crater", "crawl", "crazy", "cream", "credit", "creek", "crew", "cricket", "crime", "crisp", "critic", "crop", "cross", "crouch", "crowd", "crucial", "cruel", "cruise", "crumble", "crunch", "crush", "cry", "crystal", "cube", "culture", "cup", "cupboard", "curious", "current", "curtain", "curve", "cushion", "custom", "cute", "cycle", "dad", "damage", "damp", "dance", "danger", "daring", "dash", "daughter", "dawn", "day", "deal", "debate", "debris", "decade", "december", "decide", "decline", "decorate", "decrease", "deer", "defense", "define", "defy", "degree", "delay", "deliver", "demand", "demise", "denial", "dentist", "deny", "depart", "depend", "deposit", "depth", "deputy", "derive", "describe", "desert", "design", "desk", "despair", "destroy", "detail", "detect", "develop", "device", "devote", "diagram", "dial", "diamond", "diary", "dice", "diesel", "diet", "differ", "digital", "dignity", "dilemma", "dinner", "dinosaur", "direct", "dirt", "disagree", "discover", "disease", "dish", "dismiss", "disorder", "display", "distance", "divert", "divide", "divorce", "dizzy", "doctor", "document", "dog", "doll", "dolphin", "domain", "donate", "donkey", "donor", "door", "dose", "double", "dove", "draft", "dragon", "drama", "drastic", "draw", "dream", "dress", "drift", "drill", "drink", "drip", "drive", "drop", "drum", "dry", "duck", "dumb", "dune", "during", "dust", "dutch", "duty", "dwarf", "dynamic", "eager", "eagle", "early", "earn", "earth", "easily", "east", "easy", "echo", "ecology", "economy", "edge", "edit", "educate", "effort", "egg", "eight", "either", "elbow", "elder", "electric", "elegant", "element", "elephant", "elevator", "elite", "else", "embark", "embody", "embrace", "emerge", "emotion", "employ", "empower", "empty", "enable", "enact", "end", "endless", "endorse", "enemy", "energy", "enforce", "engage", "engine", "enhance", "enjoy", "enlist", "enough", "enrich", "enroll", "ensure", "enter", "entire", "entry", "envelope", "episode", "equal", "equip", "era", "erase", "erode", "erosion", "error", "erupt", "escape", "essay", "essence", "estate", "eternal", "ethics", "evidence", "evil", "evoke", "evolve", "exact", "example", "excess", "exchange", "excite", "exclude", "excuse", "execute", "exercise", "exhaust", "exhibit", "exile", "exist", "exit", "exotic", "expand", "expect", "expire", "explain", "expose", "express", "extend", "extra", "eye", "eyebrow", "fabric", "face", "faculty", "fade", "faint", "faith", "fall", "false", "fame", "family", "famous", "fan", "fancy", "fantasy", "farm", "fashion", "fat", "fatal", "father", "fatigue", "fault", "favorite", "feature", "february", "federal", "fee", "feed", "feel", "female", "fence", "festival", "fetch", "fever", "few", "fiber", "fiction", "field", "figure", "file", "film", "filter", "final", "find", "fine", "finger", "finish", "fire", "firm", "first", "fiscal", "fish", "fit", "fitness", "fix", "flag", "flame", "flash", "flat", "flavor", "flee", "flight", "flip", "float", "flock", "floor", "flower", "fluid", "flush", "fly", "foam", "focus", "fog", "foil", "fold", "follow", "food", "foot", "force", "forest", "forget", "fork", "fortune", "forum", "forward", "fossil", "foster", "found", "fox", "fragile", "frame", "frequent", "fresh", "friend", "fringe", "frog", "front", "frost", "frown", "frozen", "fruit", "fuel", "fun", "funny", "furnace", "fury", "future", "gadget", "gain", "galaxy", "gallery", "game", "gap", "garage", "garbage", "garden", "garlic", "garment", "gas", "gasp", "gate", "gather", "gauge", "gaze", "general", "genius", "genre", "gentle", "genuine", "gesture", "ghost", "giant", "gift", "giggle", "ginger", "giraffe", "girl", "give", "glad", "glance", "glare", "glass", "glide", "glimpse", "globe", "gloom", "glory", "glove", "glow", "glue", "goat", "goddess", "gold", "good", "goose", "gorilla", "gospel", "gossip", "govern", "gown", "grab", "grace", "grain", "grant", "grape", "grass", "gravity", "great", "green", "grid", "grief", "grit", "grocery", "group", "grow", "grunt", "guard", "guess", "guide", "guilt", "guitar", "gun", "gym", "habit", "hair", "half", "hammer", "hamster", "hand", "happy", "harbor", "hard", "harsh", "harvest", "hat", "have", "hawk", "hazard", "head", "health", "heart", "heavy", "hedgehog", "height", "hello", "helmet", "help", "hen", "hero", "hidden", "high", "hill", "hint", "hip", "hire", "history", "hobby", "hockey", "hold", "hole", "holiday", "hollow", "home", "honey", "hood", "hope", "horn", "horror", "horse", "hospital", "host", "hotel", "hour", "hover", "hub", "huge", "human", "humble", "humor", "hundred", "hungry", "hunt", "hurdle", "hurry", "hurt", "husband", "hybrid", "ice", "icon", "idea", "identify", "idle", "ignore", "ill", "illegal", "illness", "image", "imitate", "immense", "immune", "impact", "impose", "improve", "impulse", "inch", "include", "income", "increase", "index", "indicate", "indoor", "industry", "infant", "inflict", "inform", "inhale", "inherit", "initial", "inject", "injury", "inmate", "inner", "innocent", "input", "inquiry", "insane", "insect", "inside", "inspire", "install", "intact", "interest", "into", "invest", "invite", "involve", "iron", "island", "isolate", "issue", "item", "ivory", "jacket", "jaguar", "jar", "jazz", "jealous", "jeans", "jelly", "jewel", "job", "join", "joke", "journey", "joy", "judge", "juice", "jump", "jungle", "junior", "junk", "just", "kangaroo", "keen", "keep", "ketchup", "key", "kick", "kid", "kidney", "kind", "kingdom", "kiss", "kit", "kitchen", "kite", "kitten", "kiwi", "knee", "knife", "knock", "know", "lab", "label", "labor", "ladder", "lady", "lake", "lamp", "language", "laptop", "large", "later", "latin", "laugh", "laundry", "lava", "law", "lawn", "lawsuit", "layer", "lazy", "leader", "leaf", "learn", "leave", "lecture", "left", "leg", "legal", "legend", "leisure", "lemon", "lend", "length", "lens", "leopard", "lesson", "letter", "level", "liar", "liberty", "library", "license", "life", "lift", "light", "like", "limb", "limit", "link", "lion", "liquid", "list", "little", "live", "lizard", "load", "loan", "lobster", "local", "lock", "logic", "lonely", "long", "loop", "lottery", "loud", "lounge", "love", "loyal", "lucky", "luggage", "lumber", "lunar", "lunch", "luxury", "lyrics", "machine", "mad", "magic", "magnet", "maid", "mail", "main", "major", "make", "mammal", "man", "manage", "mandate", "mango", "mansion", "manual", "maple", "marble", "march", "margin", "marine", "market", "marriage", "mask", "mass", "master", "match", "material", "math", "matrix", "matter", "maximum", "maze", "meadow", "mean", "measure", "meat", "mechanic", "medal", "media", "melody", "melt", "member", "memory", "mention", "menu", "mercy", "merge", "merit", "merry", "mesh", "message", "metal", "method", "middle", "midnight", "milk", "million", "mimic", "mind", "minimum", "minor", "minute", "miracle", "mirror", "misery", "miss", "mistake", "mix", "mixed", "mixture", "mobile", "model", "modify", "mom", "moment", "monitor", "monkey", "monster", "month", "moon", "moral", "more", "morning", "mosquito", "mother", "motion", "motor", "mountain", "mouse", "move", "movie", "much", "muffin", "mule", "multiply", "muscle", "museum", "mushroom", "music", "must", "mutual", "myself", "mystery", "myth", "naive", "name", "napkin", "narrow", "nasty", "nation", "nature", "near", "neck", "need", "negative", "neglect", "neither", "nephew", "nerve", "nest", "net", "network", "neutral", "never", "news", "next", "nice", "night", "noble", "noise", "nominee", "noodle", "normal", "north", "nose", "notable", "note", "nothing", "notice", "novel", "now", "nuclear", "number", "nurse", "nut", "oak", "obey", "object", "oblige", "obscure", "observe", "obtain", "obvious", "occur", "ocean", "october", "odor", "off", "offer", "office", "often", "oil", "okay", "old", "olive", "olympic", "omit", "once", "one", "onion", "online", "only", "open", "opera", "opinion", "oppose", "option", "orange", "orbit", "orchard", "order", "ordinary", "organ", "orient", "original", "orphan", "ostrich", "other", "outdoor", "outer", "output", "outside", "oval", "oven", "over", "own", "owner", "oxygen", "oyster", "ozone", "pact", "paddle", "page", "pair", "palace", "palm", "panda", "panel", "panic", "panther", "paper", "parade", "parent", "park", "parrot", "party", "pass", "patch", "path", "patient", "patrol", "pattern", "pause", "pave", "payment", "peace", "peanut", "pear", "peasant", "pelican", "pen", "penalty", "pencil", "people", "pepper", "perfect", "permit", "person", "pet", "phone", "photo", "phrase", "physical", "piano", "picnic", "picture", "piece", "pig", "pigeon", "pill", "pilot", "pink", "pioneer", "pipe", "pistol", "pitch", "pizza", "place", "planet", "plastic", "plate", "play", "please", "pledge", "pluck", "plug", "plunge", "poem", "poet", "point", "polar", "pole", "police", "pond", "pony", "pool", "popular", "portion", "position", "possible", "post", "potato", "pottery", "poverty", "powder", "power", "practice", "praise", "predict", "prefer", "prepare", "present", "pretty", "prevent", "price", "pride", "primary", "print", "priority", "prison", "private", "prize", "problem", "process", "produce", "profit", "program", "project", "promote", "proof", "property", "prosper", "protect", "proud", "provide", "public", "pudding", "pull", "pulp", "pulse", "pumpkin", "punch", "pupil", "puppy", "purchase", "purity", "purpose", "purse", "push", "put", "puzzle", "pyramid", "quality", "quantum", "quarter", "question", "quick", "quit", "quiz", "quote", "rabbit", "raccoon", "race", "rack", "radar", "radio", "rail", "rain", "raise", "rally", "ramp", "ranch", "random", "range", "rapid", "rare", "rate", "rather", "raven", "raw", "razor", "ready", "real", "reason", "rebel", "rebuild", "recall", "receive", "recipe", "record", "recycle", "reduce", "reflect", "reform", "refuse", "region", "regret", "regular", "reject", "relax", "release", "relief", "rely", "remain", "remember", "remind", "remove", "render", "renew", "rent", "reopen", "repair", "repeat", "replace", "report", "require", "rescue", "resemble", "resist", "resource", "response", "result", "retire", "retreat", "return", "reunion", "reveal", "review", "reward", "rhythm", "rib", "ribbon", "rice", "rich", "ride", "ridge", "rifle", "right", "rigid", "ring", "riot", "ripple", "risk", "ritual", "rival", "river", "road", "roast", "robot", "robust", "rocket", "romance", "roof", "rookie", "room", "rose", "rotate", "rough", "round", "route", "royal", "rubber", "rude", "rug", "rule", "run", "runway", "rural", "sad", "saddle", "sadness", "safe", "sail", "salad", "salmon", "salon", "salt", "salute", "same", "sample", "sand", "satisfy", "satoshi", "sauce", "sausage", "save", "say", "scale", "scan", "scare", "scatter", "scene", "scheme", "school", "science", "scissors", "scorpion", "scout", "scrap", "screen", "script", "scrub", "sea", "search", "season", "seat", "second", "secret", "section", "security", "seed", "seek", "segment", "select", "sell", "seminar", "senior", "sense", "sentence", "series", "service", "session", "settle", "setup", "seven", "shadow", "shaft", "shallow", "share", "shed", "shell", "sheriff", "shield", "shift", "shine", "ship", "shiver", "shock", "shoe", "shoot", "shop", "short", "shoulder", "shove", "shrimp", "shrug", "shuffle", "shy", "sibling", "sick", "side", "siege", "sight", "sign", "silent", "silk", "silly", "silver", "similar", "simple", "since", "sing", "siren", "sister", "situate", "six", "size", "skate", "sketch", "ski", "skill", "skin", "skirt", "skull", "slab", "slam", "sleep", "slender", "slice", "slide", "slight", "slim", "slogan", "slot", "slow", "slush", "small", "smart", "smile", "smoke", "smooth", "snack", "snake", "snap", "sniff", "snow", "soap", "soccer", "social", "sock", "soda", "soft", "solar", "soldier", "solid", "solution", "solve", "someone", "song", "soon", "sorry", "sort", "soul", "sound", "soup", "source", "south", "space", "spare", "spatial", "spawn", "speak", "special", "speed", "spell", "spend", "sphere", "spice", "spider", "spike", "spin", "spirit", "split", "spoil", "sponsor", "spoon", "sport", "spot", "spray", "spread", "spring", "spy", "square", "squeeze", "squirrel", "stable", "stadium", "staff", "stage", "stairs", "stamp", "stand", "start", "state", "stay", "steak", "steel", "stem", "step", "stereo", "stick", "still", "sting", "stock", "stomach", "stone", "stool", "story", "stove", "strategy", "street", "strike", "strong", "struggle", "student", "stuff", "stumble", "style", "subject", "submit", "subway", "success", "such", "sudden", "suffer", "sugar", "suggest", "suit", "summer", "sun", "sunny", "sunset", "super", "supply", "supreme", "sure", "surface", "surge", "surprise", "surround", "survey", "suspect", "sustain", "swallow", "swamp", "swap", "swarm", "swear", "sweet", "swift", "swim", "swing", "switch", "sword", "symbol", "symptom", "syrup", "system", "table", "tackle", "tag", "tail", "talent", "talk", "tank", "tape", "target", "task", "taste", "tattoo", "taxi", "teach", "team", "tell", "ten", "tenant", "tennis", "tent", "term", "test", "text", "thank", "that", "theme", "then", "theory", "there", "they", "thing", "this", "thought", "three", "thrive", "throw", "thumb", "thunder", "ticket", "tide", "tiger", "tilt", "timber", "time", "tiny", "tip", "tired", "tissue", "title", "toast", "tobacco", "today", "toddler", "toe", "together", "toilet", "token", "tomato", "tomorrow", "tone", "tongue", "tonight", "tool", "tooth", "top", "topic", "topple", "torch", "tornado", "tortoise", "toss", "total", "tourist", "toward", "tower", "town", "toy", "track", "trade", "traffic", "tragic", "train", "transfer", "trap", "trash", "travel", "tray", "treat", "tree", "trend", "trial", "tribe", "trick", "trigger", "trim", "trip", "trophy", "trouble", "truck", "true", "truly", "trumpet", "trust", "truth", "try", "tube", "tuition", "tumble", "tuna", "tunnel", "turkey", "turn", "turtle", "twelve", "twenty", "twice", "twin", "twist", "two", "type", "typical", "ugly", "umbrella", "unable", "unaware", "uncle", "uncover", "under", "undo", "unfair", "unfold", "unhappy", "uniform", "unique", "unit", "universe", "unknown", "unlock", "until", "unusual", "unveil", "update", "upgrade", "uphold", "upon", "upper", "upset", "urban", "urge", "usage", "use", "used", "useful", "useless", "usual", "utility", "vacant", "vacuum", "vague", "valid", "valley", "valve", "van", "vanish", "vapor", "various", "vast", "vault", "vehicle", "velvet", "vendor", "venture", "venue", "verb", "verify", "version", "very", "vessel", "veteran", "viable", "vibrant", "vicious", "victory", "video", "view", "village", "vintage", "violin", "virtual", "virus", "visa", "visit", "visual", "vital", "vivid", "vocal", "voice", "void", "volcano", "volume", "vote", "voyage", "wage", "wagon", "wait", "walk", "wall", "walnut", "want", "warfare", "warm", "warrior", "wash", "wasp", "waste", "water", "wave", "way", "wealth", "weapon", "wear", "weasel", "weather", "web", "wedding", "weekend", "weird", "welcome", "west", "wet", "whale", "what", "wheat", "wheel", "when", "where", "whip", "whisper", "wide", "width", "wife", "wild", "will", "win", "window", "wine", "wing", "wink", "winner", "winter", "wire", "wisdom", "wise", "wish", "witness", "wolf", "woman", "wonder", "wood", "wool", "word", "work", "world", "worry", "worth", "wrap", "wreck", "wrestle", "wrist", "write", "wrong", "yard", "year", "yellow", "you", "young", "youth", "zebra", "zero", "zone", "zoo"];
Object.defineProperty(_wordlists, "__esModule", { value: true });
var wordlists = {};
_wordlists.wordlists = wordlists;
var _default;
var _default_1 = _wordlists._default = _default;
try {
  _default_1 = _wordlists._default = _default = require$$0$5;
  wordlists.czech = _default;
} catch (err) {
}
try {
  _default_1 = _wordlists._default = _default = require$$1;
  wordlists.chinese_simplified = _default;
} catch (err) {
}
try {
  _default_1 = _wordlists._default = _default = require$$2;
  wordlists.chinese_traditional = _default;
} catch (err) {
}
try {
  _default_1 = _wordlists._default = _default = require$$3$1;
  wordlists.korean = _default;
} catch (err) {
}
try {
  _default_1 = _wordlists._default = _default = require$$4$2;
  wordlists.french = _default;
} catch (err) {
}
try {
  _default_1 = _wordlists._default = _default = require$$5$2;
  wordlists.italian = _default;
} catch (err) {
}
try {
  _default_1 = _wordlists._default = _default = require$$6$1;
  wordlists.spanish = _default;
} catch (err) {
}
try {
  _default_1 = _wordlists._default = _default = require$$7;
  wordlists.japanese = _default;
  wordlists.JA = _default;
} catch (err) {
}
try {
  _default_1 = _wordlists._default = _default = require$$8;
  wordlists.portuguese = _default;
} catch (err) {
}
try {
  _default_1 = _wordlists._default = _default = require$$9;
  wordlists.english = _default;
  wordlists.EN = _default;
} catch (err) {
}
Object.defineProperty(src$2, "__esModule", { value: true });
var sha256_1 = sha256$8;
var sha512_1 = sha512$7;
var pbkdf2_1$1 = pbkdf2$5;
var utils_1 = utils$e;
var _wordlists_1 = _wordlists;
var DEFAULT_WORDLIST = _wordlists_1._default;
var INVALID_MNEMONIC = "Invalid mnemonic";
var INVALID_ENTROPY = "Invalid entropy";
var INVALID_CHECKSUM = "Invalid mnemonic checksum";
var WORDLIST_REQUIRED = "A wordlist is required but a default could not be found.\nPlease pass a 2048 word array explicitly.";
function normalize(str) {
  return (str || "").normalize("NFKD");
}
function lpad(str, padString2, length3) {
  while (str.length < length3) {
    str = padString2 + str;
  }
  return str;
}
function binaryToByte(bin) {
  return parseInt(bin, 2);
}
function bytesToBinary(bytes) {
  return bytes.map(function(x2) {
    return lpad(x2.toString(2), "0", 8);
  }).join("");
}
function deriveChecksumBits(entropyBuffer) {
  var ENT = entropyBuffer.length * 8;
  var CS = ENT / 32;
  var hash2 = sha256_1.sha256(Uint8Array.from(entropyBuffer));
  return bytesToBinary(Array.from(hash2)).slice(0, CS);
}
function salt(password) {
  return "mnemonic" + (password || "");
}
function mnemonicToSeedSync(mnemonic, password) {
  var mnemonicBuffer = Uint8Array.from(Buffer.from(normalize(mnemonic), "utf8"));
  var saltBuffer = Uint8Array.from(Buffer.from(salt(normalize(password)), "utf8"));
  var res = pbkdf2_1$1.pbkdf2(sha512_1.sha512, mnemonicBuffer, saltBuffer, { c: 2048, dkLen: 64 });
  return Buffer.from(res);
}
src$2.mnemonicToSeedSync = mnemonicToSeedSync;
function mnemonicToSeed(mnemonic, password) {
  var mnemonicBuffer = Uint8Array.from(Buffer.from(normalize(mnemonic), "utf8"));
  var saltBuffer = Uint8Array.from(Buffer.from(salt(normalize(password)), "utf8"));
  return pbkdf2_1$1.pbkdf2Async(sha512_1.sha512, mnemonicBuffer, saltBuffer, { c: 2048, dkLen: 64 }).then(function(res) {
    return Buffer.from(res);
  });
}
var mnemonicToSeed_1 = src$2.mnemonicToSeed = mnemonicToSeed;
function mnemonicToEntropy(mnemonic, wordlist) {
  wordlist = wordlist || DEFAULT_WORDLIST;
  if (!wordlist) {
    throw new Error(WORDLIST_REQUIRED);
  }
  var words = normalize(mnemonic).split(" ");
  if (words.length % 3 !== 0) {
    throw new Error(INVALID_MNEMONIC);
  }
  var bits = words.map(function(word) {
    var index = wordlist.indexOf(word);
    if (index === -1) {
      throw new Error(INVALID_MNEMONIC);
    }
    return lpad(index.toString(2), "0", 11);
  }).join("");
  var dividerIndex = Math.floor(bits.length / 33) * 32;
  var entropyBits = bits.slice(0, dividerIndex);
  var checksumBits = bits.slice(dividerIndex);
  var entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);
  if (entropyBytes.length < 16) {
    throw new Error(INVALID_ENTROPY);
  }
  if (entropyBytes.length > 32) {
    throw new Error(INVALID_ENTROPY);
  }
  if (entropyBytes.length % 4 !== 0) {
    throw new Error(INVALID_ENTROPY);
  }
  var entropy = Buffer.from(entropyBytes);
  var newChecksum = deriveChecksumBits(entropy);
  if (newChecksum !== checksumBits) {
    throw new Error(INVALID_CHECKSUM);
  }
  return entropy.toString("hex");
}
src$2.mnemonicToEntropy = mnemonicToEntropy;
function entropyToMnemonic(entropy, wordlist) {
  if (!Buffer.isBuffer(entropy)) {
    entropy = Buffer.from(entropy, "hex");
  }
  wordlist = wordlist || DEFAULT_WORDLIST;
  if (!wordlist) {
    throw new Error(WORDLIST_REQUIRED);
  }
  if (entropy.length < 16) {
    throw new TypeError(INVALID_ENTROPY);
  }
  if (entropy.length > 32) {
    throw new TypeError(INVALID_ENTROPY);
  }
  if (entropy.length % 4 !== 0) {
    throw new TypeError(INVALID_ENTROPY);
  }
  var entropyBits = bytesToBinary(Array.from(entropy));
  var checksumBits = deriveChecksumBits(entropy);
  var bits = entropyBits + checksumBits;
  var chunks2 = bits.match(/(.{1,11})/g);
  var words = chunks2.map(function(binary) {
    var index = binaryToByte(binary);
    return wordlist[index];
  });
  return wordlist[0] === "" ? words.join("") : words.join(" ");
}
src$2.entropyToMnemonic = entropyToMnemonic;
function generateMnemonic$1(strength, rng, wordlist) {
  strength = strength || 128;
  if (strength % 32 !== 0) {
    throw new TypeError(INVALID_ENTROPY);
  }
  rng = rng || function(size) {
    return Buffer.from(utils_1.randomBytes(size));
  };
  return entropyToMnemonic(rng(strength / 8), wordlist);
}
var generateMnemonic_1 = src$2.generateMnemonic = generateMnemonic$1;
function validateMnemonic(mnemonic, wordlist) {
  try {
    mnemonicToEntropy(mnemonic, wordlist);
  } catch (e2) {
    return false;
  }
  return true;
}
src$2.validateMnemonic = validateMnemonic;
function setDefaultWordlist(language) {
  var result = _wordlists_1.wordlists[language];
  if (result) {
    DEFAULT_WORDLIST = result;
  } else {
    throw new Error('Could not find wordlist for language "' + language + '"');
  }
}
src$2.setDefaultWordlist = setDefaultWordlist;
function getDefaultWordlist() {
  if (!DEFAULT_WORDLIST) {
    throw new Error("No Default Wordlist set");
  }
  return Object.keys(_wordlists_1.wordlists).filter(function(lang) {
    if (lang === "JA" || lang === "EN") {
      return false;
    }
    return _wordlists_1.wordlists[lang].every(function(word, index) {
      return word === DEFAULT_WORDLIST[index];
    });
  })[0];
}
src$2.getDefaultWordlist = getDefaultWordlist;
var _wordlists_2 = _wordlists;
src$2.wordlists = _wordlists_2.wordlists;
var objectTag$2 = "[object Object]";
function isHostObject(value) {
  var result = false;
  if (value != null && typeof value.toString != "function") {
    try {
      result = !!(value + "");
    } catch (e2) {
    }
  }
  return result;
}
function overArg$3(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var funcProto$1 = Function.prototype;
var objectProto$8 = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$5 = objectProto$8.hasOwnProperty;
var objectCtorString$1 = funcToString$1.call(Object);
var objectToString$2 = objectProto$8.toString;
var getPrototype$2 = overArg$3(Object.getPrototypeOf, Object);
function isObjectLike$5(value) {
  return !!value && _typeof(value) == "object";
}
function isPlainObject$3(value) {
  if (!isObjectLike$5(value) || objectToString$2.call(value) != objectTag$2 || isHostObject(value)) {
    return false;
  }
  var proto = getPrototype$2(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$5.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString$1.call(Ctor) == objectCtorString$1;
}
var lodash_isplainobject = isPlainObject$3;
var isPlainObject$4 = getDefaultExportFromCjs(lodash_isplainobject);
function forEachObject(obj2, fn, path2) {
  for (var _key15 in obj2) {
    var deepPath = path2 ? "".concat(path2, ".").concat(_key15) : _key15;
    fn.call(obj2, obj2[_key15], _key15, obj2, deepPath);
    forEach(obj2[_key15], fn, deepPath);
  }
}
function forEachArray(array, fn, path2) {
  array.forEach(function(value, index, arr) {
    var deepPath = "".concat(path2, "[").concat(index, "]");
    fn.call(arr, value, index, arr, deepPath);
    forEach(arr[index], fn, deepPath);
  });
}
function forEach(value, fn, path2) {
  path2 = path2 || "";
  if (Array.isArray(value)) {
    forEachArray(value, fn, path2);
  } else if (isPlainObject$4(value)) {
    forEachObject(value, fn, path2);
  }
}
var toString$3 = Object.prototype.toString;
var kindOf = function kindOf2(val) {
  if (val === void 0)
    return "undefined";
  if (val === null)
    return "null";
  var type = _typeof(val);
  if (type === "boolean")
    return "boolean";
  if (type === "string")
    return "string";
  if (type === "number")
    return "number";
  if (type === "symbol")
    return "symbol";
  if (type === "function") {
    return isGeneratorFn(val) ? "generatorfunction" : "function";
  }
  if (isArray$2(val))
    return "array";
  if (isBuffer$2(val))
    return "buffer";
  if (isArguments$2(val))
    return "arguments";
  if (isDate(val))
    return "date";
  if (isError(val))
    return "error";
  if (isRegexp(val))
    return "regexp";
  switch (ctorName(val)) {
    case "Symbol":
      return "symbol";
    case "Promise":
      return "promise";
    case "WeakMap":
      return "weakmap";
    case "WeakSet":
      return "weakset";
    case "Map":
      return "map";
    case "Set":
      return "set";
    case "Int8Array":
      return "int8array";
    case "Uint8Array":
      return "uint8array";
    case "Uint8ClampedArray":
      return "uint8clampedarray";
    case "Int16Array":
      return "int16array";
    case "Uint16Array":
      return "uint16array";
    case "Int32Array":
      return "int32array";
    case "Uint32Array":
      return "uint32array";
    case "Float32Array":
      return "float32array";
    case "Float64Array":
      return "float64array";
  }
  if (isGeneratorObj(val)) {
    return "generator";
  }
  type = toString$3.call(val);
  switch (type) {
    case "[object Object]":
      return "object";
    case "[object Map Iterator]":
      return "mapiterator";
    case "[object Set Iterator]":
      return "setiterator";
    case "[object String Iterator]":
      return "stringiterator";
    case "[object Array Iterator]":
      return "arrayiterator";
  }
  return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
};
function ctorName(val) {
  return typeof val.constructor === "function" ? val.constructor.name : null;
}
function isArray$2(val) {
  if (Array.isArray)
    return Array.isArray(val);
  return val instanceof Array;
}
function isError(val) {
  return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
}
function isDate(val) {
  if (val instanceof Date)
    return true;
  return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
}
function isRegexp(val) {
  if (val instanceof RegExp)
    return true;
  return typeof val.flags === "string" && typeof val.ignoreCase === "boolean" && typeof val.multiline === "boolean" && typeof val.global === "boolean";
}
function isGeneratorFn(name2, val) {
  return ctorName(name2) === "GeneratorFunction";
}
function isGeneratorObj(val) {
  return typeof val.throw === "function" && typeof val.return === "function" && typeof val.next === "function";
}
function isArguments$2(val) {
  try {
    if (typeof val.length === "number" && typeof val.callee === "function") {
      return true;
    }
  } catch (err) {
    if (err.message.indexOf("callee") !== -1) {
      return true;
    }
  }
  return false;
}
function isBuffer$2(val) {
  if (val.constructor && typeof val.constructor.isBuffer === "function") {
    return val.constructor.isBuffer(val);
  }
  return false;
}
var valueOf = Symbol.prototype.valueOf;
var typeOf$1 = kindOf;
function clone$1(val, deep) {
  switch (typeOf$1(val)) {
    case "array":
      return val.slice();
    case "object":
      return Object.assign({}, val);
    case "date":
      return new val.constructor(Number(val));
    case "map":
      return new Map(val);
    case "set":
      return new Set(val);
    case "buffer":
      return cloneBuffer(val);
    case "symbol":
      return cloneSymbol(val);
    case "arraybuffer":
      return cloneArrayBuffer(val);
    case "float32array":
    case "float64array":
    case "int16array":
    case "int32array":
    case "int8array":
    case "uint16array":
    case "uint32array":
    case "uint8clampedarray":
    case "uint8array":
      return cloneTypedArray(val);
    case "regexp":
      return cloneRegExp(val);
    case "error":
      return Object.create(val);
    default: {
      return val;
    }
  }
}
function cloneRegExp(val) {
  var flags = val.flags !== void 0 ? val.flags : /\w+$/.exec(val) || void 0;
  var re = new val.constructor(val.source, flags);
  re.lastIndex = val.lastIndex;
  return re;
}
function cloneArrayBuffer(val) {
  var res = new val.constructor(val.byteLength);
  new Uint8Array(res).set(new Uint8Array(val));
  return res;
}
function cloneTypedArray(val, deep) {
  return new val.constructor(val.buffer, val.byteOffset, val.length);
}
function cloneBuffer(val) {
  var len2 = val.length;
  var buf = Buffer.allocUnsafe ? Buffer.allocUnsafe(len2) : Buffer.from(len2);
  val.copy(buf);
  return buf;
}
function cloneSymbol(val) {
  return valueOf ? Object(valueOf.call(val)) : {};
}
var shallowClone = clone$1;
var isobject = function isObject2(val) {
  return val != null && _typeof(val) === "object" && Array.isArray(val) === false;
};
var isObject$2 = isobject;
function isObjectObject(o2) {
  return isObject$2(o2) === true && Object.prototype.toString.call(o2) === "[object Object]";
}
var isPlainObject$2 = function isPlainObject3(o2) {
  var ctor, prot;
  if (isObjectObject(o2) === false)
    return false;
  ctor = o2.constructor;
  if (typeof ctor !== "function")
    return false;
  prot = ctor.prototype;
  if (isObjectObject(prot) === false)
    return false;
  if (prot.hasOwnProperty("isPrototypeOf") === false) {
    return false;
  }
  return true;
};
var clone = shallowClone;
var typeOf = kindOf;
var isPlainObject$1 = isPlainObject$2;
function cloneDeep(val, instanceClone) {
  switch (typeOf(val)) {
    case "object":
      return cloneObjectDeep(val, instanceClone);
    case "array":
      return cloneArrayDeep(val, instanceClone);
    default: {
      return clone(val);
    }
  }
}
function cloneObjectDeep(val, instanceClone) {
  if (typeof instanceClone === "function") {
    return instanceClone(val);
  }
  if (instanceClone || isPlainObject$1(val)) {
    var res = new val.constructor();
    for (var _key16 in val) {
      res[_key16] = cloneDeep(val[_key16], instanceClone);
    }
    return res;
  }
  return val;
}
function cloneArrayDeep(val, instanceClone) {
  var res = new val.constructor(val.length);
  for (var _i25 = 0; _i25 < val.length; _i25++) {
    res[_i25] = cloneDeep(val[_i25], instanceClone);
  }
  return res;
}
var cloneDeep_1 = cloneDeep;
var cloneDeep$1 = getDefaultExportFromCjs(cloneDeep_1);
var asn1$7 = {};
var bn = { exports: {} };
var __viteBrowserExternal = {};
var __viteBrowserExternal$1 = Object.freeze(Object.defineProperty({ __proto__: null, default: __viteBrowserExternal }, Symbol.toStringTag, { value: "Module" }));
var require$$0$4 = getAugmentedNamespace(__viteBrowserExternal$1);
bn.exports;
(function(module) {
  (function(module2, exports) {
    function assert2(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    function inherits2(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function TempCtor2() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
    function BN(number, base3, endian) {
      if (BN.isBN(number)) {
        return number;
      }
      this.negative = 0;
      this.words = null;
      this.length = 0;
      this.red = null;
      if (number !== null) {
        if (base3 === "le" || base3 === "be") {
          endian = base3;
          base3 = 10;
        }
        this._init(number || 0, base3 || 10, endian || "be");
      }
    }
    if (_typeof(module2) === "object") {
      module2.exports = BN;
    } else {
      exports.BN = BN;
    }
    BN.BN = BN;
    BN.wordSize = 26;
    var Buffer2;
    try {
      if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
        Buffer2 = window.Buffer;
      } else {
        Buffer2 = require$$0$4.Buffer;
      }
    } catch (e2) {
    }
    BN.isBN = function isBN(num) {
      if (num instanceof BN) {
        return true;
      }
      return num !== null && _typeof(num) === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
    };
    BN.max = function max(left, right) {
      if (left.cmp(right) > 0)
        return left;
      return right;
    };
    BN.min = function min(left, right) {
      if (left.cmp(right) < 0)
        return left;
      return right;
    };
    BN.prototype._init = function init5(number, base3, endian) {
      if (typeof number === "number") {
        return this._initNumber(number, base3, endian);
      }
      if (_typeof(number) === "object") {
        return this._initArray(number, base3, endian);
      }
      if (base3 === "hex") {
        base3 = 16;
      }
      assert2(base3 === (base3 | 0) && base3 >= 2 && base3 <= 36);
      number = number.toString().replace(/\s+/g, "");
      var start = 0;
      if (number[0] === "-") {
        start++;
        this.negative = 1;
      }
      if (start < number.length) {
        if (base3 === 16) {
          this._parseHex(number, start, endian);
        } else {
          this._parseBase(number, base3, start);
          if (endian === "le") {
            this._initArray(this.toArray(), base3, endian);
          }
        }
      }
    };
    BN.prototype._initNumber = function _initNumber(number, base3, endian) {
      if (number < 0) {
        this.negative = 1;
        number = -number;
      }
      if (number < 67108864) {
        this.words = [number & 67108863];
        this.length = 1;
      } else if (number < 4503599627370496) {
        this.words = [number & 67108863, number / 67108864 & 67108863];
        this.length = 2;
      } else {
        assert2(number < 9007199254740992);
        this.words = [number & 67108863, number / 67108864 & 67108863, 1];
        this.length = 3;
      }
      if (endian !== "le")
        return;
      this._initArray(this.toArray(), base3, endian);
    };
    BN.prototype._initArray = function _initArray(number, base3, endian) {
      assert2(typeof number.length === "number");
      if (number.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number.length / 3);
      this.words = new Array(this.length);
      for (var i2 = 0; i2 < this.length; i2++) {
        this.words[i2] = 0;
      }
      var j3, w2;
      var off2 = 0;
      if (endian === "be") {
        for (i2 = number.length - 1, j3 = 0; i2 >= 0; i2 -= 3) {
          w2 = number[i2] | number[i2 - 1] << 8 | number[i2 - 2] << 16;
          this.words[j3] |= w2 << off2 & 67108863;
          this.words[j3 + 1] = w2 >>> 26 - off2 & 67108863;
          off2 += 24;
          if (off2 >= 26) {
            off2 -= 26;
            j3++;
          }
        }
      } else if (endian === "le") {
        for (i2 = 0, j3 = 0; i2 < number.length; i2 += 3) {
          w2 = number[i2] | number[i2 + 1] << 8 | number[i2 + 2] << 16;
          this.words[j3] |= w2 << off2 & 67108863;
          this.words[j3 + 1] = w2 >>> 26 - off2 & 67108863;
          off2 += 24;
          if (off2 >= 26) {
            off2 -= 26;
            j3++;
          }
        }
      }
      return this.strip();
    };
    function parseHex4Bits(string2, index) {
      var c3 = string2.charCodeAt(index);
      if (c3 >= 65 && c3 <= 70) {
        return c3 - 55;
      } else if (c3 >= 97 && c3 <= 102) {
        return c3 - 87;
      } else {
        return c3 - 48 & 15;
      }
    }
    function parseHexByte(string2, lowerBound, index) {
      var r2 = parseHex4Bits(string2, index);
      if (index - 1 >= lowerBound) {
        r2 |= parseHex4Bits(string2, index - 1) << 4;
      }
      return r2;
    }
    BN.prototype._parseHex = function _parseHex(number, start, endian) {
      this.length = Math.ceil((number.length - start) / 6);
      this.words = new Array(this.length);
      for (var i2 = 0; i2 < this.length; i2++) {
        this.words[i2] = 0;
      }
      var off2 = 0;
      var j3 = 0;
      var w2;
      if (endian === "be") {
        for (i2 = number.length - 1; i2 >= start; i2 -= 2) {
          w2 = parseHexByte(number, start, i2) << off2;
          this.words[j3] |= w2 & 67108863;
          if (off2 >= 18) {
            off2 -= 18;
            j3 += 1;
            this.words[j3] |= w2 >>> 26;
          } else {
            off2 += 8;
          }
        }
      } else {
        var parseLength = number.length - start;
        for (i2 = parseLength % 2 === 0 ? start + 1 : start; i2 < number.length; i2 += 2) {
          w2 = parseHexByte(number, start, i2) << off2;
          this.words[j3] |= w2 & 67108863;
          if (off2 >= 18) {
            off2 -= 18;
            j3 += 1;
            this.words[j3] |= w2 >>> 26;
          } else {
            off2 += 8;
          }
        }
      }
      this.strip();
    };
    function parseBase(str, start, end2, mul) {
      var r2 = 0;
      var len2 = Math.min(str.length, end2);
      for (var i2 = start; i2 < len2; i2++) {
        var c3 = str.charCodeAt(i2) - 48;
        r2 *= mul;
        if (c3 >= 49) {
          r2 += c3 - 49 + 10;
        } else if (c3 >= 17) {
          r2 += c3 - 17 + 10;
        } else {
          r2 += c3;
        }
      }
      return r2;
    }
    BN.prototype._parseBase = function _parseBase(number, base3, start) {
      this.words = [0];
      this.length = 1;
      for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base3) {
        limbLen++;
      }
      limbLen--;
      limbPow = limbPow / base3 | 0;
      var total = number.length - start;
      var mod2 = total % limbLen;
      var end2 = Math.min(total, total - mod2) + start;
      var word = 0;
      for (var i2 = start; i2 < end2; i2 += limbLen) {
        word = parseBase(number, i2, i2 + limbLen, base3);
        this.imuln(limbPow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      if (mod2 !== 0) {
        var pow = 1;
        word = parseBase(number, i2, number.length, base3);
        for (i2 = 0; i2 < mod2; i2++) {
          pow *= base3;
        }
        this.imuln(pow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      this.strip();
    };
    BN.prototype.copy = function copy(dest) {
      dest.words = new Array(this.length);
      for (var i2 = 0; i2 < this.length; i2++) {
        dest.words[i2] = this.words[i2];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
    BN.prototype.clone = function clone3() {
      var r2 = new BN(null);
      this.copy(r2);
      return r2;
    };
    BN.prototype._expand = function _expand(size) {
      while (this.length < size) {
        this.words[this.length++] = 0;
      }
      return this;
    };
    BN.prototype.strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
    BN.prototype._normSign = function _normSign() {
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };
    BN.prototype.inspect = function inspect() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var zeros = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"];
    var groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5];
    var groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    BN.prototype.toString = function toString3(base3, padding) {
      base3 = base3 || 10;
      padding = padding | 0 || 1;
      var out;
      if (base3 === 16 || base3 === "hex") {
        out = "";
        var off2 = 0;
        var carry = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var w2 = this.words[i2];
          var word = ((w2 << off2 | carry) & 16777215).toString(16);
          carry = w2 >>> 24 - off2 & 16777215;
          off2 += 2;
          if (off2 >= 26) {
            off2 -= 26;
            i2--;
          }
          if (carry !== 0 || i2 !== this.length - 1) {
            out = zeros[6 - word.length] + word + out;
          } else {
            out = word + out;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      if (base3 === (base3 | 0) && base3 >= 2 && base3 <= 36) {
        var groupSize = groupSizes[base3];
        var groupBase = groupBases[base3];
        out = "";
        var c3 = this.clone();
        c3.negative = 0;
        while (!c3.isZero()) {
          var r2 = c3.modn(groupBase).toString(base3);
          c3 = c3.idivn(groupBase);
          if (!c3.isZero()) {
            out = zeros[groupSize - r2.length] + r2 + out;
          } else {
            out = r2 + out;
          }
        }
        if (this.isZero()) {
          out = "0" + out;
        }
        while (out.length % padding !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      assert2(false, "Base should be between 2 and 36");
    };
    BN.prototype.toNumber = function toNumber() {
      var ret = this.words[0];
      if (this.length === 2) {
        ret += this.words[1] * 67108864;
      } else if (this.length === 3 && this.words[2] === 1) {
        ret += 4503599627370496 + this.words[1] * 67108864;
      } else if (this.length > 2) {
        assert2(false, "Number can only safely store up to 53 bits");
      }
      return this.negative !== 0 ? -ret : ret;
    };
    BN.prototype.toJSON = function toJSON2() {
      return this.toString(16);
    };
    BN.prototype.toBuffer = function toBuffer2(endian, length3) {
      assert2(typeof Buffer2 !== "undefined");
      return this.toArrayLike(Buffer2, endian, length3);
    };
    BN.prototype.toArray = function toArray2(endian, length3) {
      return this.toArrayLike(Array, endian, length3);
    };
    BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length3) {
      var byteLength2 = this.byteLength();
      var reqLength = length3 || Math.max(1, byteLength2);
      assert2(byteLength2 <= reqLength, "byte array longer than desired length");
      assert2(reqLength > 0, "Requested array length <= 0");
      this.strip();
      var littleEndian = endian === "le";
      var res = new ArrayType(reqLength);
      var b3, i2;
      var q3 = this.clone();
      if (!littleEndian) {
        for (i2 = 0; i2 < reqLength - byteLength2; i2++) {
          res[i2] = 0;
        }
        for (i2 = 0; !q3.isZero(); i2++) {
          b3 = q3.andln(255);
          q3.iushrn(8);
          res[reqLength - i2 - 1] = b3;
        }
      } else {
        for (i2 = 0; !q3.isZero(); i2++) {
          b3 = q3.andln(255);
          q3.iushrn(8);
          res[i2] = b3;
        }
        for (; i2 < reqLength; i2++) {
          res[i2] = 0;
        }
      }
      return res;
    };
    if (Math.clz32) {
      BN.prototype._countBits = function _countBits(w2) {
        return 32 - Math.clz32(w2);
      };
    } else {
      BN.prototype._countBits = function _countBits(w2) {
        var t2 = w2;
        var r2 = 0;
        if (t2 >= 4096) {
          r2 += 13;
          t2 >>>= 13;
        }
        if (t2 >= 64) {
          r2 += 7;
          t2 >>>= 7;
        }
        if (t2 >= 8) {
          r2 += 4;
          t2 >>>= 4;
        }
        if (t2 >= 2) {
          r2 += 2;
          t2 >>>= 2;
        }
        return r2 + t2;
      };
    }
    BN.prototype._zeroBits = function _zeroBits(w2) {
      if (w2 === 0)
        return 26;
      var t2 = w2;
      var r2 = 0;
      if ((t2 & 8191) === 0) {
        r2 += 13;
        t2 >>>= 13;
      }
      if ((t2 & 127) === 0) {
        r2 += 7;
        t2 >>>= 7;
      }
      if ((t2 & 15) === 0) {
        r2 += 4;
        t2 >>>= 4;
      }
      if ((t2 & 3) === 0) {
        r2 += 2;
        t2 >>>= 2;
      }
      if ((t2 & 1) === 0) {
        r2++;
      }
      return r2;
    };
    BN.prototype.bitLength = function bitLength() {
      var w2 = this.words[this.length - 1];
      var hi = this._countBits(w2);
      return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
      var w2 = new Array(num.bitLength());
      for (var bit = 0; bit < w2.length; bit++) {
        var off2 = bit / 26 | 0;
        var wbit = bit % 26;
        w2[bit] = (num.words[off2] & 1 << wbit) >>> wbit;
      }
      return w2;
    }
    BN.prototype.zeroBits = function zeroBits() {
      if (this.isZero())
        return 0;
      var r2 = 0;
      for (var i2 = 0; i2 < this.length; i2++) {
        var b3 = this._zeroBits(this.words[i2]);
        r2 += b3;
        if (b3 !== 26)
          break;
      }
      return r2;
    };
    BN.prototype.byteLength = function byteLength2() {
      return Math.ceil(this.bitLength() / 8);
    };
    BN.prototype.toTwos = function toTwos(width) {
      if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }
      return this.clone();
    };
    BN.prototype.fromTwos = function fromTwos(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }
      return this.clone();
    };
    BN.prototype.isNeg = function isNeg() {
      return this.negative !== 0;
    };
    BN.prototype.neg = function neg() {
      return this.clone().ineg();
    };
    BN.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
      return this;
    };
    BN.prototype.iuor = function iuor(num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
      for (var i2 = 0; i2 < num.length; i2++) {
        this.words[i2] = this.words[i2] | num.words[i2];
      }
      return this.strip();
    };
    BN.prototype.ior = function ior(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuor(num);
    };
    BN.prototype.or = function or(num) {
      if (this.length > num.length)
        return this.clone().ior(num);
      return num.clone().ior(this);
    };
    BN.prototype.uor = function uor(num) {
      if (this.length > num.length)
        return this.clone().iuor(num);
      return num.clone().iuor(this);
    };
    BN.prototype.iuand = function iuand(num) {
      var b3;
      if (this.length > num.length) {
        b3 = num;
      } else {
        b3 = this;
      }
      for (var i2 = 0; i2 < b3.length; i2++) {
        this.words[i2] = this.words[i2] & num.words[i2];
      }
      this.length = b3.length;
      return this.strip();
    };
    BN.prototype.iand = function iand(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuand(num);
    };
    BN.prototype.and = function and(num) {
      if (this.length > num.length)
        return this.clone().iand(num);
      return num.clone().iand(this);
    };
    BN.prototype.uand = function uand(num) {
      if (this.length > num.length)
        return this.clone().iuand(num);
      return num.clone().iuand(this);
    };
    BN.prototype.iuxor = function iuxor(num) {
      var a2;
      var b3;
      if (this.length > num.length) {
        a2 = this;
        b3 = num;
      } else {
        a2 = num;
        b3 = this;
      }
      for (var i2 = 0; i2 < b3.length; i2++) {
        this.words[i2] = a2.words[i2] ^ b3.words[i2];
      }
      if (this !== a2) {
        for (; i2 < a2.length; i2++) {
          this.words[i2] = a2.words[i2];
        }
      }
      this.length = a2.length;
      return this.strip();
    };
    BN.prototype.ixor = function ixor(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };
    BN.prototype.xor = function xor(num) {
      if (this.length > num.length)
        return this.clone().ixor(num);
      return num.clone().ixor(this);
    };
    BN.prototype.uxor = function uxor(num) {
      if (this.length > num.length)
        return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    };
    BN.prototype.inotn = function inotn(width) {
      assert2(typeof width === "number" && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26;
      this._expand(bytesNeeded);
      if (bitsLeft > 0) {
        bytesNeeded--;
      }
      for (var i2 = 0; i2 < bytesNeeded; i2++) {
        this.words[i2] = ~this.words[i2] & 67108863;
      }
      if (bitsLeft > 0) {
        this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
      }
      return this.strip();
    };
    BN.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    };
    BN.prototype.setn = function setn(bit, val) {
      assert2(typeof bit === "number" && bit >= 0);
      var off2 = bit / 26 | 0;
      var wbit = bit % 26;
      this._expand(off2 + 1);
      if (val) {
        this.words[off2] = this.words[off2] | 1 << wbit;
      } else {
        this.words[off2] = this.words[off2] & ~(1 << wbit);
      }
      return this.strip();
    };
    BN.prototype.iadd = function iadd(num) {
      var r2;
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r2 = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r2 = this.isub(num);
        num.negative = 1;
        return r2._normSign();
      }
      var a2, b3;
      if (this.length > num.length) {
        a2 = this;
        b3 = num;
      } else {
        a2 = num;
        b3 = this;
      }
      var carry = 0;
      for (var i2 = 0; i2 < b3.length; i2++) {
        r2 = (a2.words[i2] | 0) + (b3.words[i2] | 0) + carry;
        this.words[i2] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      for (; carry !== 0 && i2 < a2.length; i2++) {
        r2 = (a2.words[i2] | 0) + carry;
        this.words[i2] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      this.length = a2.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      } else if (a2 !== this) {
        for (; i2 < a2.length; i2++) {
          this.words[i2] = a2.words[i2];
        }
      }
      return this;
    };
    BN.prototype.add = function add2(num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
      if (this.length > num.length)
        return this.clone().iadd(num);
      return num.clone().iadd(this);
    };
    BN.prototype.isub = function isub(num) {
      if (num.negative !== 0) {
        num.negative = 0;
        var r2 = this.iadd(num);
        num.negative = 1;
        return r2._normSign();
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }
      var cmp = this.cmp(num);
      if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
      var a2, b3;
      if (cmp > 0) {
        a2 = this;
        b3 = num;
      } else {
        a2 = num;
        b3 = this;
      }
      var carry = 0;
      for (var i2 = 0; i2 < b3.length; i2++) {
        r2 = (a2.words[i2] | 0) - (b3.words[i2] | 0) + carry;
        carry = r2 >> 26;
        this.words[i2] = r2 & 67108863;
      }
      for (; carry !== 0 && i2 < a2.length; i2++) {
        r2 = (a2.words[i2] | 0) + carry;
        carry = r2 >> 26;
        this.words[i2] = r2 & 67108863;
      }
      if (carry === 0 && i2 < a2.length && a2 !== this) {
        for (; i2 < a2.length; i2++) {
          this.words[i2] = a2.words[i2];
        }
      }
      this.length = Math.max(this.length, i2);
      if (a2 !== this) {
        this.negative = 1;
      }
      return this.strip();
    };
    BN.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    function smallMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      var len2 = self2.length + num.length | 0;
      out.length = len2;
      len2 = len2 - 1 | 0;
      var a2 = self2.words[0] | 0;
      var b3 = num.words[0] | 0;
      var r2 = a2 * b3;
      var lo = r2 & 67108863;
      var carry = r2 / 67108864 | 0;
      out.words[0] = lo;
      for (var k3 = 1; k3 < len2; k3++) {
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k3, num.length - 1);
        for (var j3 = Math.max(0, k3 - self2.length + 1); j3 <= maxJ; j3++) {
          var i2 = k3 - j3 | 0;
          a2 = self2.words[i2] | 0;
          b3 = num.words[j3] | 0;
          r2 = a2 * b3 + rword;
          ncarry += r2 / 67108864 | 0;
          rword = r2 & 67108863;
        }
        out.words[k3] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k3] = carry | 0;
      } else {
        out.length--;
      }
      return out.strip();
    }
    var comb10MulTo = function comb10MulTo2(self2, num, out) {
      var a2 = self2.words;
      var b3 = num.words;
      var o2 = out.words;
      var c3 = 0;
      var lo;
      var mid;
      var hi;
      var a0 = a2[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a2[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a22 = a2[2] | 0;
      var al2 = a22 & 8191;
      var ah2 = a22 >>> 13;
      var a3 = a2[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a2[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a2[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a2[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a2[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a2[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a2[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b3[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b3[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b22 = b3[2] | 0;
      var bl2 = b22 & 8191;
      var bh2 = b22 >>> 13;
      var b32 = b3[3] | 0;
      var bl3 = b32 & 8191;
      var bh3 = b32 >>> 13;
      var b4 = b3[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b3[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b3[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b3[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b3[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b3[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self2.negative ^ num.negative;
      out.length = 19;
      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi = Math.imul(ah0, bh0);
      var w0 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
      c3 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi = hi + Math.imul(ah0, bh1) | 0;
      var w1 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
      c3 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi = hi + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi = hi + Math.imul(ah0, bh2) | 0;
      var w2 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
      c3 = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi = hi + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi = hi + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi = hi + Math.imul(ah0, bh3) | 0;
      var w3 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
      c3 = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi = hi + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi = hi + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi = hi + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi = hi + Math.imul(ah0, bh4) | 0;
      var w4 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
      c3 = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi = hi + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi = hi + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi = hi + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi = hi + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi = hi + Math.imul(ah0, bh5) | 0;
      var w5 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
      c3 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi = hi + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi = hi + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi = hi + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi = hi + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi = hi + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi = hi + Math.imul(ah0, bh6) | 0;
      var w6 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
      c3 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi = hi + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi = hi + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi = hi + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi = hi + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi = hi + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi = hi + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi = hi + Math.imul(ah0, bh7) | 0;
      var w7 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
      c3 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi = hi + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi = hi + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi = hi + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi = hi + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi = hi + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi = hi + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi = hi + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi = hi + Math.imul(ah0, bh8) | 0;
      var w8 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
      c3 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi = hi + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi = hi + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi = hi + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi = hi + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi = hi + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi = hi + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi = hi + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi = hi + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi = hi + Math.imul(ah0, bh9) | 0;
      var w9 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
      c3 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi = hi + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi = hi + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi = hi + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi = hi + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi = hi + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi = hi + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi = hi + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi = hi + Math.imul(ah1, bh9) | 0;
      var w10 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
      c3 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi = hi + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi = hi + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi = hi + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi = hi + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi = hi + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi = hi + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi = hi + Math.imul(ah2, bh9) | 0;
      var w11 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
      c3 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi = hi + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi = hi + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi = hi + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi = hi + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi = hi + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi = hi + Math.imul(ah3, bh9) | 0;
      var w12 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
      c3 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi = hi + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi = hi + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi = hi + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi = hi + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi = hi + Math.imul(ah4, bh9) | 0;
      var w13 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
      c3 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi = hi + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi = hi + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi = hi + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi = hi + Math.imul(ah5, bh9) | 0;
      var w14 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
      c3 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi = hi + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi = hi + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi = hi + Math.imul(ah6, bh9) | 0;
      var w15 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
      c3 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi = hi + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi = hi + Math.imul(ah7, bh9) | 0;
      var w16 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
      c3 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi = hi + Math.imul(ah8, bh9) | 0;
      var w17 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
      c3 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi = Math.imul(ah9, bh9);
      var w18 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
      c3 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o2[0] = w0;
      o2[1] = w1;
      o2[2] = w2;
      o2[3] = w3;
      o2[4] = w4;
      o2[5] = w5;
      o2[6] = w6;
      o2[7] = w7;
      o2[8] = w8;
      o2[9] = w9;
      o2[10] = w10;
      o2[11] = w11;
      o2[12] = w12;
      o2[13] = w13;
      o2[14] = w14;
      o2[15] = w15;
      o2[16] = w16;
      o2[17] = w17;
      o2[18] = w18;
      if (c3 !== 0) {
        o2[19] = c3;
        out.length++;
      }
      return out;
    };
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
    function bigMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      out.length = self2.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k3 = 0; k3 < out.length - 1; k3++) {
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k3, num.length - 1);
        for (var j3 = Math.max(0, k3 - self2.length + 1); j3 <= maxJ; j3++) {
          var i2 = k3 - j3;
          var a2 = self2.words[i2] | 0;
          var b3 = num.words[j3] | 0;
          var r2 = a2 * b3;
          var lo = r2 & 67108863;
          ncarry = ncarry + (r2 / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }
        out.words[k3] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k3] = carry;
      } else {
        out.length--;
      }
      return out.strip();
    }
    function jumboMulTo(self2, num, out) {
      var fftm = new FFTM();
      return fftm.mulp(self2, num, out);
    }
    BN.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len2 = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len2 < 63) {
        res = smallMulTo(this, num, out);
      } else if (len2 < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
      return res;
    };
    function FFTM(x2, y3) {
      this.x = x2;
      this.y = y3;
    }
    FFTM.prototype.makeRBT = function makeRBT(N10) {
      var t2 = new Array(N10);
      var l2 = BN.prototype._countBits(N10) - 1;
      for (var i2 = 0; i2 < N10; i2++) {
        t2[i2] = this.revBin(i2, l2, N10);
      }
      return t2;
    };
    FFTM.prototype.revBin = function revBin(x2, l2, N10) {
      if (x2 === 0 || x2 === N10 - 1)
        return x2;
      var rb = 0;
      for (var i2 = 0; i2 < l2; i2++) {
        rb |= (x2 & 1) << l2 - i2 - 1;
        x2 >>= 1;
      }
      return rb;
    };
    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N10) {
      for (var i2 = 0; i2 < N10; i2++) {
        rtws[i2] = rws[rbt[i2]];
        itws[i2] = iws[rbt[i2]];
      }
    };
    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N10, rbt) {
      this.permute(rbt, rws, iws, rtws, itws, N10);
      for (var s2 = 1; s2 < N10; s2 <<= 1) {
        var l2 = s2 << 1;
        var rtwdf = Math.cos(2 * Math.PI / l2);
        var itwdf = Math.sin(2 * Math.PI / l2);
        for (var p2 = 0; p2 < N10; p2 += l2) {
          var rtwdf_ = rtwdf;
          var itwdf_ = itwdf;
          for (var j3 = 0; j3 < s2; j3++) {
            var re = rtws[p2 + j3];
            var ie = itws[p2 + j3];
            var ro = rtws[p2 + j3 + s2];
            var io = itws[p2 + j3 + s2];
            var rx = rtwdf_ * ro - itwdf_ * io;
            io = rtwdf_ * io + itwdf_ * ro;
            ro = rx;
            rtws[p2 + j3] = re + ro;
            itws[p2 + j3] = ie + io;
            rtws[p2 + j3 + s2] = re - ro;
            itws[p2 + j3 + s2] = ie - io;
            if (j3 !== l2) {
              rx = rtwdf * rtwdf_ - itwdf * itwdf_;
              itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
              rtwdf_ = rx;
            }
          }
        }
      }
    };
    FFTM.prototype.guessLen13b = function guessLen13b(n2, m2) {
      var N10 = Math.max(m2, n2) | 1;
      var odd = N10 & 1;
      var i2 = 0;
      for (N10 = N10 / 2 | 0; N10; N10 = N10 >>> 1) {
        i2++;
      }
      return 1 << i2 + 1 + odd;
    };
    FFTM.prototype.conjugate = function conjugate(rws, iws, N10) {
      if (N10 <= 1)
        return;
      for (var i2 = 0; i2 < N10 / 2; i2++) {
        var t2 = rws[i2];
        rws[i2] = rws[N10 - i2 - 1];
        rws[N10 - i2 - 1] = t2;
        t2 = iws[i2];
        iws[i2] = -iws[N10 - i2 - 1];
        iws[N10 - i2 - 1] = -t2;
      }
    };
    FFTM.prototype.normalize13b = function normalize13b(ws, N10) {
      var carry = 0;
      for (var i2 = 0; i2 < N10 / 2; i2++) {
        var w2 = Math.round(ws[2 * i2 + 1] / N10) * 8192 + Math.round(ws[2 * i2] / N10) + carry;
        ws[i2] = w2 & 67108863;
        if (w2 < 67108864) {
          carry = 0;
        } else {
          carry = w2 / 67108864 | 0;
        }
      }
      return ws;
    };
    FFTM.prototype.convert13b = function convert13b(ws, len2, rws, N10) {
      var carry = 0;
      for (var i2 = 0; i2 < len2; i2++) {
        carry = carry + (ws[i2] | 0);
        rws[2 * i2] = carry & 8191;
        carry = carry >>> 13;
        rws[2 * i2 + 1] = carry & 8191;
        carry = carry >>> 13;
      }
      for (i2 = 2 * len2; i2 < N10; ++i2) {
        rws[i2] = 0;
      }
      assert2(carry === 0);
      assert2((carry & ~8191) === 0);
    };
    FFTM.prototype.stub = function stub(N10) {
      var ph = new Array(N10);
      for (var i2 = 0; i2 < N10; i2++) {
        ph[i2] = 0;
      }
      return ph;
    };
    FFTM.prototype.mulp = function mulp(x2, y3, out) {
      var N10 = 2 * this.guessLen13b(x2.length, y3.length);
      var rbt = this.makeRBT(N10);
      var _ = this.stub(N10);
      var rws = new Array(N10);
      var rwst = new Array(N10);
      var iwst = new Array(N10);
      var nrws = new Array(N10);
      var nrwst = new Array(N10);
      var niwst = new Array(N10);
      var rmws = out.words;
      rmws.length = N10;
      this.convert13b(x2.words, x2.length, rws, N10);
      this.convert13b(y3.words, y3.length, nrws, N10);
      this.transform(rws, _, rwst, iwst, N10, rbt);
      this.transform(nrws, _, nrwst, niwst, N10, rbt);
      for (var i2 = 0; i2 < N10; i2++) {
        var rx = rwst[i2] * nrwst[i2] - iwst[i2] * niwst[i2];
        iwst[i2] = rwst[i2] * niwst[i2] + iwst[i2] * nrwst[i2];
        rwst[i2] = rx;
      }
      this.conjugate(rwst, iwst, N10);
      this.transform(rwst, iwst, rmws, _, N10, rbt);
      this.conjugate(rmws, _, N10);
      this.normalize13b(rmws, N10);
      out.negative = x2.negative ^ y3.negative;
      out.length = x2.length + y3.length;
      return out.strip();
    };
    BN.prototype.mul = function mul(num) {
      var out = new BN(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    BN.prototype.mulf = function mulf(num) {
      var out = new BN(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };
    BN.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this);
    };
    BN.prototype.imuln = function imuln(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      var carry = 0;
      for (var i2 = 0; i2 < this.length; i2++) {
        var w2 = (this.words[i2] | 0) * num;
        var lo = (w2 & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w2 / 67108864 | 0;
        carry += lo >>> 26;
        this.words[i2] = lo & 67108863;
      }
      if (carry !== 0) {
        this.words[i2] = carry;
        this.length++;
      }
      return this;
    };
    BN.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    };
    BN.prototype.sqr = function sqr() {
      return this.mul(this);
    };
    BN.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    };
    BN.prototype.pow = function pow(num) {
      var w2 = toBitArray(num);
      if (w2.length === 0)
        return new BN(1);
      var res = this;
      for (var i2 = 0; i2 < w2.length; i2++, res = res.sqr()) {
        if (w2[i2] !== 0)
          break;
      }
      if (++i2 < w2.length) {
        for (var q3 = res.sqr(); i2 < w2.length; i2++, q3 = q3.sqr()) {
          if (w2[i2] === 0)
            continue;
          res = res.mul(q3);
        }
      }
      return res;
    };
    BN.prototype.iushln = function iushln(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
      var i2;
      if (r2 !== 0) {
        var carry = 0;
        for (i2 = 0; i2 < this.length; i2++) {
          var newCarry = this.words[i2] & carryMask;
          var c3 = (this.words[i2] | 0) - newCarry << r2;
          this.words[i2] = c3 | carry;
          carry = newCarry >>> 26 - r2;
        }
        if (carry) {
          this.words[i2] = carry;
          this.length++;
        }
      }
      if (s2 !== 0) {
        for (i2 = this.length - 1; i2 >= 0; i2--) {
          this.words[i2 + s2] = this.words[i2];
        }
        for (i2 = 0; i2 < s2; i2++) {
          this.words[i2] = 0;
        }
        this.length += s2;
      }
      return this.strip();
    };
    BN.prototype.ishln = function ishln(bits) {
      assert2(this.negative === 0);
      return this.iushln(bits);
    };
    BN.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert2(typeof bits === "number" && bits >= 0);
      var h2;
      if (hint) {
        h2 = (hint - hint % 26) / 26;
      } else {
        h2 = 0;
      }
      var r2 = bits % 26;
      var s2 = Math.min((bits - r2) / 26, this.length);
      var mask = 67108863 ^ 67108863 >>> r2 << r2;
      var maskedWords = extended;
      h2 -= s2;
      h2 = Math.max(0, h2);
      if (maskedWords) {
        for (var i2 = 0; i2 < s2; i2++) {
          maskedWords.words[i2] = this.words[i2];
        }
        maskedWords.length = s2;
      }
      if (s2 === 0)
        ;
      else if (this.length > s2) {
        this.length -= s2;
        for (i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = this.words[i2 + s2];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (i2 = this.length - 1; i2 >= 0 && (carry !== 0 || i2 >= h2); i2--) {
        var word = this.words[i2] | 0;
        this.words[i2] = carry << 26 - r2 | word >>> r2;
        carry = word & mask;
      }
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      return this.strip();
    };
    BN.prototype.ishrn = function ishrn(bits, hint, extended) {
      assert2(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };
    BN.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    BN.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    };
    BN.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    BN.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    };
    BN.prototype.testn = function testn(bit) {
      assert2(typeof bit === "number" && bit >= 0);
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q3 = 1 << r2;
      if (this.length <= s2)
        return false;
      var w2 = this.words[s2];
      return !!(w2 & q3);
    };
    BN.prototype.imaskn = function imaskn(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      assert2(this.negative === 0, "imaskn works only with positive numbers");
      if (this.length <= s2) {
        return this;
      }
      if (r2 !== 0) {
        s2++;
      }
      this.length = Math.min(s2, this.length);
      if (r2 !== 0) {
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        this.words[this.length - 1] &= mask;
      }
      return this.strip();
    };
    BN.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };
    BN.prototype.iaddn = function iaddn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.isubn(-num);
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) < num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }
      return this._iaddn(num);
    };
    BN.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;
      for (var i2 = 0; i2 < this.length && this.words[i2] >= 67108864; i2++) {
        this.words[i2] -= 67108864;
        if (i2 === this.length - 1) {
          this.words[i2 + 1] = 1;
        } else {
          this.words[i2 + 1]++;
        }
      }
      this.length = Math.max(this.length, i2 + 1);
      return this;
    };
    BN.prototype.isubn = function isubn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.iaddn(-num);
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
      this.words[0] -= num;
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        for (var i2 = 0; i2 < this.length && this.words[i2] < 0; i2++) {
          this.words[i2] += 67108864;
          this.words[i2 + 1] -= 1;
        }
      }
      return this.strip();
    };
    BN.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    BN.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    BN.prototype.iabs = function iabs() {
      this.negative = 0;
      return this;
    };
    BN.prototype.abs = function abs() {
      return this.clone().iabs();
    };
    BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
      var len2 = num.length + shift;
      var i2;
      this._expand(len2);
      var w2;
      var carry = 0;
      for (i2 = 0; i2 < num.length; i2++) {
        w2 = (this.words[i2 + shift] | 0) + carry;
        var right = (num.words[i2] | 0) * mul;
        w2 -= right & 67108863;
        carry = (w2 >> 26) - (right / 67108864 | 0);
        this.words[i2 + shift] = w2 & 67108863;
      }
      for (; i2 < this.length - shift; i2++) {
        w2 = (this.words[i2 + shift] | 0) + carry;
        carry = w2 >> 26;
        this.words[i2 + shift] = w2 & 67108863;
      }
      if (carry === 0)
        return this.strip();
      assert2(carry === -1);
      carry = 0;
      for (i2 = 0; i2 < this.length; i2++) {
        w2 = -(this.words[i2] | 0) + carry;
        carry = w2 >> 26;
        this.words[i2] = w2 & 67108863;
      }
      this.negative = 1;
      return this.strip();
    };
    BN.prototype._wordDiv = function _wordDiv(num, mode) {
      var shift = this.length - num.length;
      var a2 = this.clone();
      var b3 = num;
      var bhi = b3.words[b3.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift = 26 - bhiBits;
      if (shift !== 0) {
        b3 = b3.ushln(shift);
        a2.iushln(shift);
        bhi = b3.words[b3.length - 1] | 0;
      }
      var m2 = a2.length - b3.length;
      var q3;
      if (mode !== "mod") {
        q3 = new BN(null);
        q3.length = m2 + 1;
        q3.words = new Array(q3.length);
        for (var i2 = 0; i2 < q3.length; i2++) {
          q3.words[i2] = 0;
        }
      }
      var diff = a2.clone()._ishlnsubmul(b3, 1, m2);
      if (diff.negative === 0) {
        a2 = diff;
        if (q3) {
          q3.words[m2] = 1;
        }
      }
      for (var j3 = m2 - 1; j3 >= 0; j3--) {
        var qj = (a2.words[b3.length + j3] | 0) * 67108864 + (a2.words[b3.length + j3 - 1] | 0);
        qj = Math.min(qj / bhi | 0, 67108863);
        a2._ishlnsubmul(b3, qj, j3);
        while (a2.negative !== 0) {
          qj--;
          a2.negative = 0;
          a2._ishlnsubmul(b3, 1, j3);
          if (!a2.isZero()) {
            a2.negative ^= 1;
          }
        }
        if (q3) {
          q3.words[j3] = qj;
        }
      }
      if (q3) {
        q3.strip();
      }
      a2.strip();
      if (mode !== "div" && shift !== 0) {
        a2.iushrn(shift);
      }
      return { div: q3 || null, mod: a2 };
    };
    BN.prototype.divmod = function divmod(num, mode, positive) {
      assert2(!num.isZero());
      if (this.isZero()) {
        return { div: new BN(0), mod: new BN(0) };
      }
      var div, mod2, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        if (mode !== "div") {
          mod2 = res.mod.neg();
          if (positive && mod2.negative !== 0) {
            mod2.iadd(num);
          }
        }
        return { div, mod: mod2 };
      }
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        return { div, mod: res.mod };
      }
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode);
        if (mode !== "div") {
          mod2 = res.mod.neg();
          if (positive && mod2.negative !== 0) {
            mod2.isub(num);
          }
        }
        return { div: res.div, mod: mod2 };
      }
      if (num.length > this.length || this.cmp(num) < 0) {
        return { div: new BN(0), mod: this };
      }
      if (num.length === 1) {
        if (mode === "div") {
          return { div: this.divn(num.words[0]), mod: null };
        }
        if (mode === "mod") {
          return { div: null, mod: new BN(this.modn(num.words[0])) };
        }
        return { div: this.divn(num.words[0]), mod: new BN(this.modn(num.words[0])) };
      }
      return this._wordDiv(num, mode);
    };
    BN.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    };
    BN.prototype.mod = function mod2(num) {
      return this.divmod(num, "mod", false).mod;
    };
    BN.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    };
    BN.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);
      if (dm.mod.isZero())
        return dm.div;
      var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod2.cmp(half);
      if (cmp < 0 || r2 === 1 && cmp === 0)
        return dm.div;
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN.prototype.modn = function modn(num) {
      assert2(num <= 67108863);
      var p2 = (1 << 26) % num;
      var acc = 0;
      for (var i2 = this.length - 1; i2 >= 0; i2--) {
        acc = (p2 * acc + (this.words[i2] | 0)) % num;
      }
      return acc;
    };
    BN.prototype.idivn = function idivn(num) {
      assert2(num <= 67108863);
      var carry = 0;
      for (var i2 = this.length - 1; i2 >= 0; i2--) {
        var w2 = (this.words[i2] | 0) + carry * 67108864;
        this.words[i2] = w2 / num | 0;
        carry = w2 % num;
      }
      return this.strip();
    };
    BN.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    BN.prototype.egcd = function egcd(p2) {
      assert2(p2.negative === 0);
      assert2(!p2.isZero());
      var x2 = this;
      var y3 = p2.clone();
      if (x2.negative !== 0) {
        x2 = x2.umod(p2);
      } else {
        x2 = x2.clone();
      }
      var A2 = new BN(1);
      var B2 = new BN(0);
      var C3 = new BN(0);
      var D3 = new BN(1);
      var g2 = 0;
      while (x2.isEven() && y3.isEven()) {
        x2.iushrn(1);
        y3.iushrn(1);
        ++g2;
      }
      var yp = y3.clone();
      var xp = x2.clone();
      while (!x2.isZero()) {
        for (var i2 = 0, im = 1; (x2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
          ;
        if (i2 > 0) {
          x2.iushrn(i2);
          while (i2-- > 0) {
            if (A2.isOdd() || B2.isOdd()) {
              A2.iadd(yp);
              B2.isub(xp);
            }
            A2.iushrn(1);
            B2.iushrn(1);
          }
        }
        for (var j3 = 0, jm = 1; (y3.words[0] & jm) === 0 && j3 < 26; ++j3, jm <<= 1)
          ;
        if (j3 > 0) {
          y3.iushrn(j3);
          while (j3-- > 0) {
            if (C3.isOdd() || D3.isOdd()) {
              C3.iadd(yp);
              D3.isub(xp);
            }
            C3.iushrn(1);
            D3.iushrn(1);
          }
        }
        if (x2.cmp(y3) >= 0) {
          x2.isub(y3);
          A2.isub(C3);
          B2.isub(D3);
        } else {
          y3.isub(x2);
          C3.isub(A2);
          D3.isub(B2);
        }
      }
      return { a: C3, b: D3, gcd: y3.iushln(g2) };
    };
    BN.prototype._invmp = function _invmp(p2) {
      assert2(p2.negative === 0);
      assert2(!p2.isZero());
      var a2 = this;
      var b3 = p2.clone();
      if (a2.negative !== 0) {
        a2 = a2.umod(p2);
      } else {
        a2 = a2.clone();
      }
      var x1 = new BN(1);
      var x2 = new BN(0);
      var delta = b3.clone();
      while (a2.cmpn(1) > 0 && b3.cmpn(1) > 0) {
        for (var i2 = 0, im = 1; (a2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
          ;
        if (i2 > 0) {
          a2.iushrn(i2);
          while (i2-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
            x1.iushrn(1);
          }
        }
        for (var j3 = 0, jm = 1; (b3.words[0] & jm) === 0 && j3 < 26; ++j3, jm <<= 1)
          ;
        if (j3 > 0) {
          b3.iushrn(j3);
          while (j3-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
            x2.iushrn(1);
          }
        }
        if (a2.cmp(b3) >= 0) {
          a2.isub(b3);
          x1.isub(x2);
        } else {
          b3.isub(a2);
          x2.isub(x1);
        }
      }
      var res;
      if (a2.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
      if (res.cmpn(0) < 0) {
        res.iadd(p2);
      }
      return res;
    };
    BN.prototype.gcd = function gcd(num) {
      if (this.isZero())
        return num.abs();
      if (num.isZero())
        return this.abs();
      var a2 = this.clone();
      var b3 = num.clone();
      a2.negative = 0;
      b3.negative = 0;
      for (var shift = 0; a2.isEven() && b3.isEven(); shift++) {
        a2.iushrn(1);
        b3.iushrn(1);
      }
      do {
        while (a2.isEven()) {
          a2.iushrn(1);
        }
        while (b3.isEven()) {
          b3.iushrn(1);
        }
        var r2 = a2.cmp(b3);
        if (r2 < 0) {
          var t2 = a2;
          a2 = b3;
          b3 = t2;
        } else if (r2 === 0 || b3.cmpn(1) === 0) {
          break;
        }
        a2.isub(b3);
      } while (true);
      return b3.iushln(shift);
    };
    BN.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };
    BN.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    BN.prototype.isOdd = function isOdd() {
      return (this.words[0] & 1) === 1;
    };
    BN.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };
    BN.prototype.bincn = function bincn(bit) {
      assert2(typeof bit === "number");
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q3 = 1 << r2;
      if (this.length <= s2) {
        this._expand(s2 + 1);
        this.words[s2] |= q3;
        return this;
      }
      var carry = q3;
      for (var i2 = s2; carry !== 0 && i2 < this.length; i2++) {
        var w2 = this.words[i2] | 0;
        w2 += carry;
        carry = w2 >>> 26;
        w2 &= 67108863;
        this.words[i2] = w2;
      }
      if (carry !== 0) {
        this.words[i2] = carry;
        this.length++;
      }
      return this;
    };
    BN.prototype.isZero = function isZero() {
      return this.length === 1 && this.words[0] === 0;
    };
    BN.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative)
        return -1;
      if (this.negative === 0 && negative)
        return 1;
      this.strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
        assert2(num <= 67108863, "Number is too big");
        var w2 = this.words[0] | 0;
        res = w2 === num ? 0 : w2 < num ? -1 : 1;
      }
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN.prototype.cmp = function cmp(num) {
      if (this.negative !== 0 && num.negative === 0)
        return -1;
      if (this.negative === 0 && num.negative !== 0)
        return 1;
      var res = this.ucmp(num);
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN.prototype.ucmp = function ucmp(num) {
      if (this.length > num.length)
        return 1;
      if (this.length < num.length)
        return -1;
      var res = 0;
      for (var i2 = this.length - 1; i2 >= 0; i2--) {
        var a2 = this.words[i2] | 0;
        var b3 = num.words[i2] | 0;
        if (a2 === b3)
          continue;
        if (a2 < b3) {
          res = -1;
        } else if (a2 > b3) {
          res = 1;
        }
        break;
      }
      return res;
    };
    BN.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };
    BN.prototype.gt = function gt(num) {
      return this.cmp(num) === 1;
    };
    BN.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };
    BN.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };
    BN.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };
    BN.prototype.lt = function lt(num) {
      return this.cmp(num) === -1;
    };
    BN.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };
    BN.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };
    BN.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };
    BN.prototype.eq = function eq(num) {
      return this.cmp(num) === 0;
    };
    BN.red = function red(num) {
      return new Red(num);
    };
    BN.prototype.toRed = function toRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      assert2(this.negative === 0, "red works only with positives");
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN.prototype.fromRed = function fromRed() {
      assert2(this.red, "fromRed works only with numbers in reduction context");
      return this.red.convertFrom(this);
    };
    BN.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    BN.prototype.forceRed = function forceRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };
    BN.prototype.redAdd = function redAdd(num) {
      assert2(this.red, "redAdd works only with red numbers");
      return this.red.add(this, num);
    };
    BN.prototype.redIAdd = function redIAdd(num) {
      assert2(this.red, "redIAdd works only with red numbers");
      return this.red.iadd(this, num);
    };
    BN.prototype.redSub = function redSub(num) {
      assert2(this.red, "redSub works only with red numbers");
      return this.red.sub(this, num);
    };
    BN.prototype.redISub = function redISub(num) {
      assert2(this.red, "redISub works only with red numbers");
      return this.red.isub(this, num);
    };
    BN.prototype.redShl = function redShl(num) {
      assert2(this.red, "redShl works only with red numbers");
      return this.red.shl(this, num);
    };
    BN.prototype.redMul = function redMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN.prototype.redIMul = function redIMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN.prototype.redSqr = function redSqr() {
      assert2(this.red, "redSqr works only with red numbers");
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN.prototype.redISqr = function redISqr() {
      assert2(this.red, "redISqr works only with red numbers");
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    BN.prototype.redSqrt = function redSqrt() {
      assert2(this.red, "redSqrt works only with red numbers");
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN.prototype.redInvm = function redInvm() {
      assert2(this.red, "redInvm works only with red numbers");
      this.red._verify1(this);
      return this.red.invm(this);
    };
    BN.prototype.redNeg = function redNeg() {
      assert2(this.red, "redNeg works only with red numbers");
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN.prototype.redPow = function redPow(num) {
      assert2(this.red && !num.red, "redPow(normalNum)");
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    var primes = { k256: null, p224: null, p192: null, p25519: null };
    function MPrime(name2, p2) {
      this.name = name2;
      this.p = new BN(p2, 16);
      this.n = this.p.bitLength();
      this.k = new BN(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
      var r2 = num;
      var rlen;
      do {
        this.split(r2, this.tmp);
        r2 = this.imulK(r2);
        r2 = r2.iadd(this.tmp);
        rlen = r2.bitLength();
      } while (rlen > this.n);
      var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
      if (cmp === 0) {
        r2.words[0] = 0;
        r2.length = 1;
      } else if (cmp > 0) {
        r2.isub(this.p);
      } else {
        if (r2.strip !== void 0) {
          r2.strip();
        } else {
          r2._strip();
        }
      }
      return r2;
    };
    MPrime.prototype.split = function split2(input, out) {
      input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    function K256() {
      MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    inherits2(K256, MPrime);
    K256.prototype.split = function split2(input, output) {
      var mask = 4194303;
      var outLen = Math.min(input.length, 9);
      for (var i2 = 0; i2 < outLen; i2++) {
        output.words[i2] = input.words[i2];
      }
      output.length = outLen;
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }
      var prev = input.words[9];
      output.words[output.length++] = prev & mask;
      for (i2 = 10; i2 < input.length; i2++) {
        var next = input.words[i2] | 0;
        input.words[i2 - 10] = (next & mask) << 4 | prev >>> 22;
        prev = next;
      }
      prev >>>= 22;
      input.words[i2 - 10] = prev;
      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };
    K256.prototype.imulK = function imulK(num) {
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
      var lo = 0;
      for (var i2 = 0; i2 < num.length; i2++) {
        var w2 = num.words[i2] | 0;
        lo += w2 * 977;
        num.words[i2] = lo & 67108863;
        lo = w2 * 64 + (lo / 67108864 | 0);
      }
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
    function P224() {
      MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    inherits2(P224, MPrime);
    function P192() {
      MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    inherits2(P192, MPrime);
    function P25519() {
      MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    inherits2(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
      var carry = 0;
      for (var i2 = 0; i2 < num.length; i2++) {
        var hi = (num.words[i2] | 0) * 19 + carry;
        var lo = hi & 67108863;
        hi >>>= 26;
        num.words[i2] = lo;
        carry = hi;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };
    BN._prime = function prime(name2) {
      if (primes[name2])
        return primes[name2];
      var prime2;
      if (name2 === "k256") {
        prime2 = new K256();
      } else if (name2 === "p224") {
        prime2 = new P224();
      } else if (name2 === "p192") {
        prime2 = new P192();
      } else if (name2 === "p25519") {
        prime2 = new P25519();
      } else {
        throw new Error("Unknown prime " + name2);
      }
      primes[name2] = prime2;
      return prime2;
    };
    function Red(m2) {
      if (typeof m2 === "string") {
        var prime = BN._prime(m2);
        this.m = prime.p;
        this.prime = prime;
      } else {
        assert2(m2.gtn(1), "modulus must be greater than 1");
        this.m = m2;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1(a2) {
      assert2(a2.negative === 0, "red works only with positives");
      assert2(a2.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a2, b3) {
      assert2((a2.negative | b3.negative) === 0, "red works only with positives");
      assert2(a2.red && a2.red === b3.red, "red works only with red numbers");
    };
    Red.prototype.imod = function imod(a2) {
      if (this.prime)
        return this.prime.ireduce(a2)._forceRed(this);
      return a2.umod(this.m)._forceRed(this);
    };
    Red.prototype.neg = function neg(a2) {
      if (a2.isZero()) {
        return a2.clone();
      }
      return this.m.sub(a2)._forceRed(this);
    };
    Red.prototype.add = function add2(a2, b3) {
      this._verify2(a2, b3);
      var res = a2.add(b3);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a2, b3) {
      this._verify2(a2, b3);
      var res = a2.iadd(b3);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
    Red.prototype.sub = function sub(a2, b3) {
      this._verify2(a2, b3);
      var res = a2.sub(b3);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a2, b3) {
      this._verify2(a2, b3);
      var res = a2.isub(b3);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
    Red.prototype.shl = function shl(a2, num) {
      this._verify1(a2);
      return this.imod(a2.ushln(num));
    };
    Red.prototype.imul = function imul(a2, b3) {
      this._verify2(a2, b3);
      return this.imod(a2.imul(b3));
    };
    Red.prototype.mul = function mul(a2, b3) {
      this._verify2(a2, b3);
      return this.imod(a2.mul(b3));
    };
    Red.prototype.isqr = function isqr(a2) {
      return this.imul(a2, a2.clone());
    };
    Red.prototype.sqr = function sqr(a2) {
      return this.mul(a2, a2);
    };
    Red.prototype.sqrt = function sqrt(a2) {
      if (a2.isZero())
        return a2.clone();
      var mod3 = this.m.andln(3);
      assert2(mod3 % 2 === 1);
      if (mod3 === 3) {
        var pow = this.m.add(new BN(1)).iushrn(2);
        return this.pow(a2, pow);
      }
      var q3 = this.m.subn(1);
      var s2 = 0;
      while (!q3.isZero() && q3.andln(1) === 0) {
        s2++;
        q3.iushrn(1);
      }
      assert2(!q3.isZero());
      var one = new BN(1).toRed(this);
      var nOne = one.redNeg();
      var lpow = this.m.subn(1).iushrn(1);
      var z2 = this.m.bitLength();
      z2 = new BN(2 * z2 * z2).toRed(this);
      while (this.pow(z2, lpow).cmp(nOne) !== 0) {
        z2.redIAdd(nOne);
      }
      var c3 = this.pow(z2, q3);
      var r2 = this.pow(a2, q3.addn(1).iushrn(1));
      var t2 = this.pow(a2, q3);
      var m2 = s2;
      while (t2.cmp(one) !== 0) {
        var tmp = t2;
        for (var i2 = 0; tmp.cmp(one) !== 0; i2++) {
          tmp = tmp.redSqr();
        }
        assert2(i2 < m2);
        var b3 = this.pow(c3, new BN(1).iushln(m2 - i2 - 1));
        r2 = r2.redMul(b3);
        c3 = b3.redSqr();
        t2 = t2.redMul(c3);
        m2 = i2;
      }
      return r2;
    };
    Red.prototype.invm = function invm(a2) {
      var inv = a2._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow(a2, num) {
      if (num.isZero())
        return new BN(1).toRed(this);
      if (num.cmpn(1) === 0)
        return a2.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN(1).toRed(this);
      wnd[1] = a2;
      for (var i2 = 2; i2 < wnd.length; i2++) {
        wnd[i2] = this.mul(wnd[i2 - 1], a2);
      }
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;
      if (start === 0) {
        start = 26;
      }
      for (i2 = num.length - 1; i2 >= 0; i2--) {
        var word = num.words[i2];
        for (var j3 = start - 1; j3 >= 0; j3--) {
          var bit = word >> j3 & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i2 !== 0 || j3 !== 0))
            continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start = 26;
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
      var r2 = num.umod(this.m);
      return r2 === num ? r2.clone() : r2;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    BN.mont = function mont2(num) {
      return new Mont(num);
    };
    function Mont(m2) {
      Red.call(this, m2);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
      }
      this.r = new BN(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits2(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
      var r2 = this.imod(num.mul(this.rinv));
      r2.red = null;
      return r2;
    };
    Mont.prototype.imul = function imul(a2, b3) {
      if (a2.isZero() || b3.isZero()) {
        a2.words[0] = 0;
        a2.length = 1;
        return a2;
      }
      var t2 = a2.imul(b3);
      var c3 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u2 = t2.isub(c3).iushrn(this.shift);
      var res = u2;
      if (u2.cmp(this.m) >= 0) {
        res = u2.isub(this.m);
      } else if (u2.cmpn(0) < 0) {
        res = u2.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul(a2, b3) {
      if (a2.isZero() || b3.isZero())
        return new BN(0)._forceRed(this);
      var t2 = a2.mul(b3);
      var c3 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u2 = t2.isub(c3).iushrn(this.shift);
      var res = u2;
      if (u2.cmp(this.m) >= 0) {
        res = u2.isub(this.m);
      } else if (u2.cmpn(0) < 0) {
        res = u2.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a2) {
      var res = this.imod(a2._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(module, commonjsGlobal);
})(bn);
var bnExports = bn.exports;
var api$3 = {};
var encoders = {};
var inherits_browser = { exports: {} };
if (typeof Object.create === "function") {
  inherits_browser.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, { constructor: { value: ctor, enumerable: false, writable: true, configurable: true } });
    }
  };
} else {
  inherits_browser.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function TempCtor2() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}
var inherits_browserExports = inherits_browser.exports;
var buffer$2 = {};
var ieee754 = {};
ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
  var e2, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i2 = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s2 = buffer2[offset + i2];
  i2 += d2;
  e2 = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e2 = e2 * 256 + buffer2[offset + i2], i2 += d2, nBits -= 8) {
  }
  m2 = e2 & (1 << -nBits) - 1;
  e2 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset + i2], i2 += d2, nBits -= 8) {
  }
  if (e2 === 0) {
    e2 = 1 - eBias;
  } else if (e2 === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e2 = e2 - eBias;
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
};
ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
  var e2, m2, c3;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i2 = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m2 = isNaN(value) ? 1 : 0;
    e2 = eMax;
  } else {
    e2 = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c3 = Math.pow(2, -e2)) < 1) {
      e2--;
      c3 *= 2;
    }
    if (e2 + eBias >= 1) {
      value += rt / c3;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c3 >= 2) {
      e2++;
      c3 /= 2;
    }
    if (e2 + eBias >= eMax) {
      m2 = 0;
      e2 = eMax;
    } else if (e2 + eBias >= 1) {
      m2 = (value * c3 - 1) * Math.pow(2, mLen);
      e2 = e2 + eBias;
    } else {
      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e2 = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
  }
  e2 = e2 << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i2] = e2 & 255, i2 += d2, e2 /= 256, eLen -= 8) {
  }
  buffer2[offset + i2 - d2] |= s2 * 128;
};
(function(exports) {
  var base642 = base64Js;
  var ieee754$1 = ieee754;
  var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports.Buffer = Buffer2;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  var K_MAX_LENGTH = 2147483647;
  exports.kMaxLength = K_MAX_LENGTH;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  }
  function typedArraySupport() {
    try {
      var arr = new Uint8Array(1);
      var proto = { foo: function foo() {
        return 42;
      } };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e2) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", { enumerable: true, get: function get5() {
    if (!Buffer2.isBuffer(this))
      return void 0;
    return this.buffer;
  } });
  Object.defineProperty(Buffer2.prototype, "offset", { enumerable: true, get: function get5() {
    if (!Buffer2.isBuffer(this))
      return void 0;
    return this.byteOffset;
  } });
  function createBuffer(length3) {
    if (length3 > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length3 + '" is invalid for option "size"');
    }
    var buf = new Uint8Array(length3);
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function Buffer2(arg, encodingOrOffset, length3) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError('The "string" argument must be of type string. Received type number');
      }
      return allocUnsafe2(arg);
    }
    return from3(arg, encodingOrOffset, length3);
  }
  Buffer2.poolSize = 8192;
  function from3(value, encodingOrOffset, length3) {
    if (typeof value === "string") {
      return fromString2(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + _typeof(value));
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length3);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length3);
    }
    if (typeof value === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    var valueOf2 = value.valueOf && value.valueOf();
    if (valueOf2 != null && valueOf2 !== value) {
      return Buffer2.from(valueOf2, encodingOrOffset, length3);
    }
    var b3 = fromObject(value);
    if (b3)
      return b3;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length3);
    }
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + _typeof(value));
  }
  Buffer2.from = function(value, encodingOrOffset, length3) {
    return from3(value, encodingOrOffset, length3);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc2(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer2.alloc = function(size, fill, encoding) {
    return alloc2(size, fill, encoding);
  };
  function allocUnsafe2(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer2.allocUnsafe = function(size) {
    return allocUnsafe2(size);
  };
  Buffer2.allocUnsafeSlow = function(size) {
    return allocUnsafe2(size);
  };
  function fromString2(string2, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    var length3 = byteLength2(string2, encoding) | 0;
    var buf = createBuffer(length3);
    var actual = buf.write(string2, encoding);
    if (actual !== length3) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    var length3 = array.length < 0 ? 0 : checked(array.length) | 0;
    var buf = createBuffer(length3);
    for (var _i26 = 0; _i26 < length3; _i26 += 1) {
      buf[_i26] = array[_i26] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      var copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length3) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length3 || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    var buf;
    if (byteOffset === void 0 && length3 === void 0) {
      buf = new Uint8Array(array);
    } else if (length3 === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length3);
    }
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function fromObject(obj2) {
    if (Buffer2.isBuffer(obj2)) {
      var _len10 = checked(obj2.length) | 0;
      var buf = createBuffer(_len10);
      if (buf.length === 0) {
        return buf;
      }
      obj2.copy(buf, 0, 0, _len10);
      return buf;
    }
    if (obj2.length !== void 0) {
      if (typeof obj2.length !== "number" || numberIsNaN(obj2.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj2);
    }
    if (obj2.type === "Buffer" && Array.isArray(obj2.data)) {
      return fromArrayLike(obj2.data);
    }
  }
  function checked(length3) {
    if (length3 >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length3 | 0;
  }
  function SlowBuffer(length3) {
    if (+length3 != length3) {
      length3 = 0;
    }
    return Buffer2.alloc(+length3);
  }
  Buffer2.isBuffer = function isBuffer2(b3) {
    return b3 != null && b3._isBuffer === true && b3 !== Buffer2.prototype;
  };
  Buffer2.compare = function compare(a2, b3) {
    if (isInstance(a2, Uint8Array))
      a2 = Buffer2.from(a2, a2.offset, a2.byteLength);
    if (isInstance(b3, Uint8Array))
      b3 = Buffer2.from(b3, b3.offset, b3.byteLength);
    if (!Buffer2.isBuffer(a2) || !Buffer2.isBuffer(b3)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a2 === b3)
      return 0;
    var x2 = a2.length;
    var y3 = b3.length;
    for (var _i27 = 0, _len11 = Math.min(x2, y3); _i27 < _len11; ++_i27) {
      if (a2[_i27] !== b3[_i27]) {
        x2 = a2[_i27];
        y3 = b3[_i27];
        break;
      }
    }
    if (x2 < y3)
      return -1;
    if (y3 < x2)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat2(list, length3) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    var i2;
    if (length3 === void 0) {
      length3 = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        length3 += list[i2].length;
      }
    }
    var buffer2 = Buffer2.allocUnsafe(length3);
    var pos = 0;
    for (i2 = 0; i2 < list.length; ++i2) {
      var buf = list[i2];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer2.isBuffer(buf))
            buf = Buffer2.from(buf);
          buf.copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(buffer2, buf, pos);
        }
      } else if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string2, encoding) {
    if (Buffer2.isBuffer(string2)) {
      return string2.length;
    }
    if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
      return string2.byteLength;
    }
    if (typeof string2 !== "string") {
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + _typeof(string2));
    }
    var len2 = string2.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len2 === 0)
      return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len2;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string2).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len2 * 2;
        case "hex":
          return len2 >>> 1;
        case "base64":
          return base64ToBytes(string2).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string2).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding, start, end2) {
    var loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end2 === void 0 || end2 > this.length) {
      end2 = this.length;
    }
    if (end2 <= 0) {
      return "";
    }
    end2 >>>= 0;
    start >>>= 0;
    if (end2 <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end2);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end2);
        case "ascii":
          return asciiSlice(this, start, end2);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end2);
        case "base64":
          return base64Slice(this, start, end2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end2);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b3, n2, m2) {
    var i2 = b3[n2];
    b3[n2] = b3[m2];
    b3[m2] = i2;
  }
  Buffer2.prototype.swap16 = function swap16() {
    var len2 = this.length;
    if (len2 % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (var _i28 = 0; _i28 < len2; _i28 += 2) {
      swap(this, _i28, _i28 + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    var len2 = this.length;
    if (len2 % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (var _i29 = 0; _i29 < len2; _i29 += 4) {
      swap(this, _i29, _i29 + 3);
      swap(this, _i29 + 1, _i29 + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    var len2 = this.length;
    if (len2 % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (var _i30 = 0; _i30 < len2; _i30 += 8) {
      swap(this, _i30, _i30 + 7);
      swap(this, _i30 + 1, _i30 + 6);
      swap(this, _i30 + 2, _i30 + 5);
      swap(this, _i30 + 3, _i30 + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString3() {
    var length3 = this.length;
    if (length3 === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length3);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals2(b3) {
    if (!Buffer2.isBuffer(b3))
      throw new TypeError("Argument must be a Buffer");
    if (this === b3)
      return true;
    return Buffer2.compare(this, b3) === 0;
  };
  Buffer2.prototype.inspect = function inspect() {
    var str = "";
    var max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare(target, start, end2, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + _typeof(target));
    }
    if (start === void 0) {
      start = 0;
    }
    if (end2 === void 0) {
      end2 = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end2 > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end2) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end2) {
      return 1;
    }
    start >>>= 0;
    end2 >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    var x2 = thisEnd - thisStart;
    var y3 = end2 - start;
    var len2 = Math.min(x2, y3);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end2);
    for (var _i31 = 0; _i31 < len2; ++_i31) {
      if (thisCopy[_i31] !== targetCopy[_i31]) {
        x2 = thisCopy[_i31];
        y3 = targetCopy[_i31];
        break;
      }
    }
    if (x2 < y3)
      return -1;
    if (y3 < x2)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read4(buf, i3) {
      if (indexSize === 1) {
        return buf[i3];
      } else {
        return buf.readUInt16BE(i3 * indexSize);
      }
    }
    var i2;
    if (dir) {
      var foundIndex = -1;
      for (i2 = byteOffset; i2 < arrLength; i2++) {
        if (read4(arr, i2) === read4(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i2;
          if (i2 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i2 -= i2 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i2 = byteOffset; i2 >= 0; i2--) {
        var found = true;
        for (var _j = 0; _j < valLength; _j++) {
          if (read4(arr, i2 + _j) !== read4(val, _j)) {
            found = false;
            break;
          }
        }
        if (found)
          return i2;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string2, offset, length3) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length3) {
      length3 = remaining;
    } else {
      length3 = Number(length3);
      if (length3 > remaining) {
        length3 = remaining;
      }
    }
    var strLen = string2.length;
    if (length3 > strLen / 2) {
      length3 = strLen / 2;
    }
    var i2;
    for (i2 = 0; i2 < length3; ++i2) {
      var parsed = parseInt(string2.substr(i2 * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i2;
      buf[offset + i2] = parsed;
    }
    return i2;
  }
  function utf8Write(buf, string2, offset, length3) {
    return blitBuffer(utf8ToBytes(string2, buf.length - offset), buf, offset, length3);
  }
  function asciiWrite(buf, string2, offset, length3) {
    return blitBuffer(asciiToBytes(string2), buf, offset, length3);
  }
  function base64Write(buf, string2, offset, length3) {
    return blitBuffer(base64ToBytes(string2), buf, offset, length3);
  }
  function ucs2Write(buf, string2, offset, length3) {
    return blitBuffer(utf16leToBytes(string2, buf.length - offset), buf, offset, length3);
  }
  Buffer2.prototype.write = function write3(string2, offset, length3, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length3 = this.length;
      offset = 0;
    } else if (length3 === void 0 && typeof offset === "string") {
      encoding = offset;
      length3 = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length3)) {
        length3 = length3 >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length3;
        length3 = void 0;
      }
    } else {
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    }
    var remaining = this.length - offset;
    if (length3 === void 0 || length3 > remaining)
      length3 = remaining;
    if (string2.length > 0 && (length3 < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string2, offset, length3);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string2, offset, length3);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string2, offset, length3);
        case "base64":
          return base64Write(this, string2, offset, length3);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string2, offset, length3);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON2() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  function base64Slice(buf, start, end2) {
    if (start === 0 && end2 === buf.length) {
      return base642.fromByteArray(buf);
    } else {
      return base642.fromByteArray(buf.slice(start, end2));
    }
  }
  function utf8Slice(buf, start, end2) {
    end2 = Math.min(buf.length, end2);
    var res = [];
    var i2 = start;
    while (i2 < end2) {
      var firstByte = buf[i2];
      var codePoint = null;
      var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i2 + bytesPerSequence <= end2) {
        var secondByte = void 0, thirdByte = void 0, fourthByte = void 0, tempCodePoint = void 0;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i2 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            fourthByte = buf[i2 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i2 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  var MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    var len2 = codePoints.length;
    if (len2 <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    var res = "";
    var i2 = 0;
    while (i2 < len2) {
      res += String.fromCharCode.apply(String, codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start, end2) {
    var ret = "";
    end2 = Math.min(buf.length, end2);
    for (var _i32 = start; _i32 < end2; ++_i32) {
      ret += String.fromCharCode(buf[_i32] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end2) {
    var ret = "";
    end2 = Math.min(buf.length, end2);
    for (var _i33 = start; _i33 < end2; ++_i33) {
      ret += String.fromCharCode(buf[_i33]);
    }
    return ret;
  }
  function hexSlice(buf, start, end2) {
    var len2 = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end2 || end2 < 0 || end2 > len2)
      end2 = len2;
    var out = "";
    for (var _i34 = start; _i34 < end2; ++_i34) {
      out += hexSliceLookupTable[buf[_i34]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end2) {
    var bytes = buf.slice(start, end2);
    var res = "";
    for (var _i35 = 0; _i35 < bytes.length - 1; _i35 += 2) {
      res += String.fromCharCode(bytes[_i35] + bytes[_i35 + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice(start, end2) {
    var len2 = this.length;
    start = ~~start;
    end2 = end2 === void 0 ? len2 : ~~end2;
    if (start < 0) {
      start += len2;
      if (start < 0)
        start = 0;
    } else if (start > len2) {
      start = len2;
    }
    if (end2 < 0) {
      end2 += len2;
      if (end2 < 0)
        end2 = 0;
    } else if (end2 > len2) {
      end2 = len2;
    }
    if (end2 < start)
      end2 = start;
    var newBuf = this.subarray(start, end2);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length3) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length3)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    var val = this[offset];
    var mul = 1;
    var i2 = 0;
    while (++i2 < byteLength3 && (mul *= 256)) {
      val += this[offset + i2] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    var val = this[offset + --byteLength3];
    var mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength3] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt82(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    var first = this[offset];
    var last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    var lo = first + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 24);
    var hi = this[++offset] + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + last * Math.pow(2, 24);
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    var first = this[offset];
    var last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    var hi = first * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + this[++offset];
    var lo = this[++offset] * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    var val = this[offset];
    var mul = 1;
    var i2 = 0;
    while (++i2 < byteLength3 && (mul *= 256)) {
      val += this[offset + i2] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    var i2 = byteLength3;
    var mul = 1;
    var val = this[offset + --i2];
    while (i2 > 0 && (mul *= 256)) {
      val += this[offset + --i2] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    var first = this[offset];
    var last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    var val = this[offset + 4] + this[offset + 5] * Math.pow(2, 8) + this[offset + 6] * Math.pow(2, 16) + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 24));
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    var first = this[offset];
    var last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    var val = (first << 24) + // Overflow
    this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + last);
  });
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer2.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    var mul = 1;
    var i2 = 0;
    this[offset] = value & 255;
    while (++i2 < byteLength3 && (mul *= 256)) {
      this[offset + i2] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    var i2 = byteLength3 - 1;
    var mul = 1;
    this[offset + i2] = value & 255;
    while (--i2 >= 0 && (mul *= 256)) {
      this[offset + i2] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    var lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    var hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    var lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    var hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
  }
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value) {
    var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value) {
    var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    var i2 = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 255;
    while (++i2 < byteLength3 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i2] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    var i2 = byteLength3 - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i2] = value & 255;
    while (--i2 >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i2] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value) {
    var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value) {
    var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy(target, targetStart, start, end2) {
    if (!Buffer2.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end2 && end2 !== 0)
      end2 = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end2 > 0 && end2 < start)
      end2 = start;
    if (end2 === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end2 < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end2 > this.length)
      end2 = this.length;
    if (target.length - targetStart < end2 - start) {
      end2 = target.length - targetStart + start;
    }
    var len2 = end2 - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end2);
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, end2), targetStart);
    }
    return len2;
  };
  Buffer2.prototype.fill = function fill(val, start, end2, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end2 = this.length;
      } else if (typeof end2 === "string") {
        encoding = end2;
        end2 = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        var _code = val.charCodeAt(0);
        if (encoding === "utf8" && _code < 128 || encoding === "latin1") {
          val = _code;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end2) {
      throw new RangeError("Out of range index");
    }
    if (end2 <= start) {
      return this;
    }
    start = start >>> 0;
    end2 = end2 === void 0 ? this.length : end2 >>> 0;
    if (!val)
      val = 0;
    var i2;
    if (typeof val === "number") {
      for (i2 = start; i2 < end2; ++i2) {
        this[i2] = val;
      }
    } else {
      var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
      var _len12 = bytes.length;
      if (_len12 === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i2 = 0; i2 < end2 - start; ++i2) {
        this[i2 + start] = bytes[i2 % _len12];
      }
    }
    return this;
  };
  var errors = {};
  function E2(sym, getMessage, Base) {
    errors[sym] = function(_Base) {
      function NodeError() {
        var _this22;
        _classCallCheck2(this, NodeError);
        _this22 = _callSuper(this, NodeError);
        Object.defineProperty(_this22, "message", { value: getMessage.apply(_this22, arguments), writable: true, configurable: true });
        _this22.name = "".concat(_this22.name, " [").concat(sym, "]");
        _this22.stack;
        delete _this22.name;
        return _this22;
      }
      _inherits2(NodeError, _Base);
      return _createClass(NodeError, [{ key: "code", get: function get5() {
        return sym;
      }, set: function set(value) {
        Object.defineProperty(this, "code", { configurable: true, enumerable: true, value, writable: true });
      } }, { key: "toString", value: function toString3() {
        return "".concat(this.name, " [").concat(sym, "]: ").concat(this.message);
      } }]);
    }(Base);
  }
  E2("ERR_BUFFER_OUT_OF_BOUNDS", function(name2) {
    if (name2) {
      return "".concat(name2, " is outside of buffer bounds");
    }
    return "Attempt to access memory outside buffer bounds";
  }, RangeError);
  E2("ERR_INVALID_ARG_TYPE", function(name2, actual) {
    return 'The "'.concat(name2, '" argument must be of type number. Received type ').concat(_typeof(actual));
  }, TypeError);
  E2("ERR_OUT_OF_RANGE", function(str, range, input) {
    var msg = 'The value of "'.concat(str, '" is out of range.');
    var received = input;
    if (Number.isInteger(input) && Math.abs(input) > Math.pow(2, 32)) {
      received = addNumericalSeparator(String(input));
    } else if (typeof input === "bigint") {
      received = String(input);
      if (input > Math.pow(BigInt(2), BigInt(32)) || input < -Math.pow(BigInt(2), BigInt(32))) {
        received = addNumericalSeparator(received);
      }
      received += "n";
    }
    msg += " It must be ".concat(range, ". Received ").concat(received);
    return msg;
  }, RangeError);
  function addNumericalSeparator(val) {
    var res = "";
    var i2 = val.length;
    var start = val[0] === "-" ? 1 : 0;
    for (; i2 >= start + 4; i2 -= 3) {
      res = "_".concat(val.slice(i2 - 3, i2)).concat(res);
    }
    return "".concat(val.slice(0, i2)).concat(res);
  }
  function checkBounds(buf, offset, byteLength3) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
      boundsError(offset, buf.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value, min, max, buf, offset, byteLength3) {
    if (value > max || value < min) {
      var _n2 = typeof min === "bigint" ? "n" : "";
      var range;
      if (byteLength3 > 3) {
        if (min === 0 || min === BigInt(0)) {
          range = ">= 0".concat(_n2, " and < 2").concat(_n2, " ** ").concat((byteLength3 + 1) * 8).concat(_n2);
        } else {
          range = ">= -(2".concat(_n2, " ** ").concat((byteLength3 + 1) * 8 - 1).concat(_n2, ") and < 2 ** ") + "".concat((byteLength3 + 1) * 8 - 1).concat(_n2);
        }
      } else {
        range = ">= ".concat(min).concat(_n2, " and <= ").concat(max).concat(_n2);
      }
      throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength3);
  }
  function validateNumber(value, name2) {
    if (typeof value !== "number") {
      throw new errors.ERR_INVALID_ARG_TYPE(name2, "number", value);
    }
  }
  function boundsError(value, length3, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type);
      throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length3 < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(type || "offset", ">= ".concat(type ? 1 : 0, " and <= ").concat(length3), value);
  }
  var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string2, units) {
    units = units || Infinity;
    var codePoint;
    var length3 = string2.length;
    var leadSurrogate = null;
    var bytes = [];
    for (var _i36 = 0; _i36 < length3; ++_i36) {
      codePoint = string2.charCodeAt(_i36);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (_i36 + 1 === length3) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    var byteArray = [];
    for (var _i37 = 0; _i37 < str.length; ++_i37) {
      byteArray.push(str.charCodeAt(_i37) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    var c3, hi, lo;
    var byteArray = [];
    for (var _i38 = 0; _i38 < str.length; ++_i38) {
      if ((units -= 2) < 0)
        break;
      c3 = str.charCodeAt(_i38);
      hi = c3 >> 8;
      lo = c3 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base642.toByteArray(base64clean(str));
  }
  function blitBuffer(src2, dst, offset, length3) {
    var i2;
    for (i2 = 0; i2 < length3; ++i2) {
      if (i2 + offset >= dst.length || i2 >= src2.length)
        break;
      dst[i2 + offset] = src2[i2];
    }
    return i2;
  }
  function isInstance(obj2, type) {
    return obj2 instanceof type || obj2 != null && obj2.constructor != null && obj2.constructor.name != null && obj2.constructor.name === type.name;
  }
  function numberIsNaN(obj2) {
    return obj2 !== obj2;
  }
  var hexSliceLookupTable = function() {
    var alphabet2 = "0123456789abcdef";
    var table = new Array(256);
    for (var _i39 = 0; _i39 < 16; ++_i39) {
      var i16 = _i39 * 16;
      for (var _j2 = 0; _j2 < 16; ++_j2) {
        table[i16 + _j2] = alphabet2[_i39] + alphabet2[_j2];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(buffer$2);
var reporter = {};
var inherits$6 = inherits_browserExports;
function Reporter$2(options) {
  this._reporterState = { obj: null, path: [], options: options || {}, errors: [] };
}
reporter.Reporter = Reporter$2;
Reporter$2.prototype.isError = function isError2(obj2) {
  return obj2 instanceof ReporterError;
};
Reporter$2.prototype.save = function save4() {
  var state = this._reporterState;
  return { obj: state.obj, pathLen: state.path.length };
};
Reporter$2.prototype.restore = function restore2(data) {
  var state = this._reporterState;
  state.obj = data.obj;
  state.path = state.path.slice(0, data.pathLen);
};
Reporter$2.prototype.enterKey = function enterKey(key3) {
  return this._reporterState.path.push(key3);
};
Reporter$2.prototype.exitKey = function exitKey(index) {
  var state = this._reporterState;
  state.path = state.path.slice(0, index - 1);
};
Reporter$2.prototype.leaveKey = function leaveKey(index, key3, value) {
  var state = this._reporterState;
  this.exitKey(index);
  if (state.obj !== null)
    state.obj[key3] = value;
};
Reporter$2.prototype.path = function path() {
  return this._reporterState.path.join("/");
};
Reporter$2.prototype.enterObject = function enterObject() {
  var state = this._reporterState;
  var prev = state.obj;
  state.obj = {};
  return prev;
};
Reporter$2.prototype.leaveObject = function leaveObject(prev) {
  var state = this._reporterState;
  var now = state.obj;
  state.obj = prev;
  return now;
};
Reporter$2.prototype.error = function error2(msg) {
  var err;
  var state = this._reporterState;
  var inherited = msg instanceof ReporterError;
  if (inherited) {
    err = msg;
  } else {
    err = new ReporterError(state.path.map(function(elem) {
      return "[" + JSON.stringify(elem) + "]";
    }).join(""), msg.message || msg, msg.stack);
  }
  if (!state.options.partial)
    throw err;
  if (!inherited)
    state.errors.push(err);
  return err;
};
Reporter$2.prototype.wrapResult = function wrapResult(result) {
  var state = this._reporterState;
  if (!state.options.partial)
    return result;
  return { result: this.isError(result) ? null : result, errors: state.errors };
};
function ReporterError(path2, msg) {
  this.path = path2;
  this.rethrow(msg);
}
inherits$6(ReporterError, Error);
ReporterError.prototype.rethrow = function rethrow(msg) {
  this.message = msg + " at: " + (this.path || "(shallow)");
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, ReporterError);
  if (!this.stack) {
    try {
      throw new Error(this.message);
    } catch (e2) {
      this.stack = e2.stack;
    }
  }
  return this;
};
var buffer$1 = {};
var inherits$5 = inherits_browserExports;
var Reporter$1 = reporter.Reporter;
var Buffer$3 = buffer$2.Buffer;
function DecoderBuffer$2(base3, options) {
  Reporter$1.call(this, options);
  if (!Buffer$3.isBuffer(base3)) {
    this.error("Input not Buffer");
    return;
  }
  this.base = base3;
  this.offset = 0;
  this.length = base3.length;
}
inherits$5(DecoderBuffer$2, Reporter$1);
buffer$1.DecoderBuffer = DecoderBuffer$2;
DecoderBuffer$2.prototype.save = function save5() {
  return { offset: this.offset, reporter: Reporter$1.prototype.save.call(this) };
};
DecoderBuffer$2.prototype.restore = function restore3(save6) {
  var res = new DecoderBuffer$2(this.base);
  res.offset = save6.offset;
  res.length = this.offset;
  this.offset = save6.offset;
  Reporter$1.prototype.restore.call(this, save6.reporter);
  return res;
};
DecoderBuffer$2.prototype.isEmpty = function isEmpty() {
  return this.offset === this.length;
};
DecoderBuffer$2.prototype.readUInt8 = function readUInt8(fail) {
  if (this.offset + 1 <= this.length)
    return this.base.readUInt8(this.offset++, true);
  else
    return this.error(fail || "DecoderBuffer overrun");
};
DecoderBuffer$2.prototype.skip = function skip(bytes, fail) {
  if (!(this.offset + bytes <= this.length))
    return this.error(fail || "DecoderBuffer overrun");
  var res = new DecoderBuffer$2(this.base);
  res._reporterState = this._reporterState;
  res.offset = this.offset;
  res.length = this.offset + bytes;
  this.offset += bytes;
  return res;
};
DecoderBuffer$2.prototype.raw = function raw(save6) {
  return this.base.slice(save6 ? save6.offset : this.offset, this.length);
};
function EncoderBuffer$1(value, reporter2) {
  if (Array.isArray(value)) {
    this.length = 0;
    this.value = value.map(function(item) {
      if (!(item instanceof EncoderBuffer$1))
        item = new EncoderBuffer$1(item, reporter2);
      this.length += item.length;
      return item;
    }, this);
  } else if (typeof value === "number") {
    if (!(0 <= value && value <= 255))
      return reporter2.error("non-byte EncoderBuffer value");
    this.value = value;
    this.length = 1;
  } else if (typeof value === "string") {
    this.value = value;
    this.length = Buffer$3.byteLength(value);
  } else if (Buffer$3.isBuffer(value)) {
    this.value = value;
    this.length = value.length;
  } else {
    return reporter2.error("Unsupported type: " + _typeof(value));
  }
}
buffer$1.EncoderBuffer = EncoderBuffer$1;
EncoderBuffer$1.prototype.join = function join(out, offset) {
  if (!out)
    out = new Buffer$3(this.length);
  if (!offset)
    offset = 0;
  if (this.length === 0)
    return out;
  if (Array.isArray(this.value)) {
    this.value.forEach(function(item) {
      item.join(out, offset);
      offset += item.length;
    });
  } else {
    if (typeof this.value === "number")
      out[offset] = this.value;
    else if (typeof this.value === "string")
      out.write(this.value, offset);
    else if (Buffer$3.isBuffer(this.value))
      this.value.copy(out, offset);
    offset += this.length;
  }
  return out;
};
var minimalisticAssert = assert$7;
function assert$7(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert$7.equal = function assertEqual(l2, r2, msg) {
  if (l2 != r2)
    throw new Error(msg || "Assertion failed: " + l2 + " != " + r2);
};
var Reporter = reporter.Reporter;
var EncoderBuffer = buffer$1.EncoderBuffer;
var DecoderBuffer$1 = buffer$1.DecoderBuffer;
var assert$6 = minimalisticAssert;
var tags = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"];
var methods = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(tags);
var overrided = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"];
function Node$2(enc, parent) {
  var state = {};
  this._baseState = state;
  state.enc = enc;
  state.parent = parent || null;
  state.children = null;
  state.tag = null;
  state.args = null;
  state.reverseArgs = null;
  state.choice = null;
  state.optional = false;
  state.any = false;
  state.obj = false;
  state.use = null;
  state.useDecoder = null;
  state.key = null;
  state["default"] = null;
  state.explicit = null;
  state.implicit = null;
  state.contains = null;
  if (!state.parent) {
    state.children = [];
    this._wrap();
  }
}
var node = Node$2;
var stateProps = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
Node$2.prototype.clone = function clone2() {
  var state = this._baseState;
  var cstate = {};
  stateProps.forEach(function(prop) {
    cstate[prop] = state[prop];
  });
  var res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};
Node$2.prototype._wrap = function wrap() {
  var state = this._baseState;
  methods.forEach(function(method) {
    this[method] = function _wrappedMethod() {
      var clone3 = new this.constructor(this);
      state.children.push(clone3);
      return clone3[method].apply(clone3, arguments);
    };
  }, this);
};
Node$2.prototype._init = function init2(body) {
  var state = this._baseState;
  assert$6(state.parent === null);
  body.call(this);
  state.children = state.children.filter(function(child) {
    return child._baseState.parent === this;
  }, this);
  assert$6.equal(state.children.length, 1, "Root node can have only one child");
};
Node$2.prototype._useArgs = function useArgs(args) {
  var state = this._baseState;
  var children = args.filter(function(arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function(arg) {
    return !(arg instanceof this.constructor);
  }, this);
  if (children.length !== 0) {
    assert$6(state.children === null);
    state.children = children;
    children.forEach(function(child) {
      child._baseState.parent = this;
    }, this);
  }
  if (args.length !== 0) {
    assert$6(state.args === null);
    state.args = args;
    state.reverseArgs = args.map(function(arg) {
      if (_typeof(arg) !== "object" || arg.constructor !== Object)
        return arg;
      var res = {};
      Object.keys(arg).forEach(function(key3) {
        if (key3 == (key3 | 0))
          key3 |= 0;
        var value = arg[key3];
        res[value] = key3;
      });
      return res;
    });
  }
};
overrided.forEach(function(method) {
  Node$2.prototype[method] = function _overrided() {
    var state = this._baseState;
    throw new Error(method + " not implemented for encoding: " + state.enc);
  };
});
tags.forEach(function(tag) {
  Node$2.prototype[tag] = function _tagMethod() {
    var state = this._baseState;
    var args = Array.prototype.slice.call(arguments);
    assert$6(state.tag === null);
    state.tag = tag;
    this._useArgs(args);
    return this;
  };
});
Node$2.prototype.use = function use(item) {
  assert$6(item);
  var state = this._baseState;
  assert$6(state.use === null);
  state.use = item;
  return this;
};
Node$2.prototype.optional = function optional() {
  var state = this._baseState;
  state.optional = true;
  return this;
};
Node$2.prototype.def = function def(val) {
  var state = this._baseState;
  assert$6(state["default"] === null);
  state["default"] = val;
  state.optional = true;
  return this;
};
Node$2.prototype.explicit = function explicit(num) {
  var state = this._baseState;
  assert$6(state.explicit === null && state.implicit === null);
  state.explicit = num;
  return this;
};
Node$2.prototype.implicit = function implicit(num) {
  var state = this._baseState;
  assert$6(state.explicit === null && state.implicit === null);
  state.implicit = num;
  return this;
};
Node$2.prototype.obj = function obj() {
  var state = this._baseState;
  var args = Array.prototype.slice.call(arguments);
  state.obj = true;
  if (args.length !== 0)
    this._useArgs(args);
  return this;
};
Node$2.prototype.key = function key2(newKey) {
  var state = this._baseState;
  assert$6(state.key === null);
  state.key = newKey;
  return this;
};
Node$2.prototype.any = function any() {
  var state = this._baseState;
  state.any = true;
  return this;
};
Node$2.prototype.choice = function choice(obj2) {
  var state = this._baseState;
  assert$6(state.choice === null);
  state.choice = obj2;
  this._useArgs(Object.keys(obj2).map(function(key3) {
    return obj2[key3];
  }));
  return this;
};
Node$2.prototype.contains = function contains(item) {
  var state = this._baseState;
  assert$6(state.use === null);
  state.contains = item;
  return this;
};
Node$2.prototype._decode = function decode2(input, options) {
  var state = this._baseState;
  if (state.parent === null)
    return input.wrapResult(state.children[0]._decode(input, options));
  var result = state["default"];
  var present = true;
  var prevKey = null;
  if (state.key !== null)
    prevKey = input.enterKey(state.key);
  if (state.optional) {
    var tag = null;
    if (state.explicit !== null)
      tag = state.explicit;
    else if (state.implicit !== null)
      tag = state.implicit;
    else if (state.tag !== null)
      tag = state.tag;
    if (tag === null && !state.any) {
      var save6 = input.save();
      try {
        if (state.choice === null)
          this._decodeGeneric(state.tag, input, options);
        else
          this._decodeChoice(input, options);
        present = true;
      } catch (e2) {
        present = false;
      }
      input.restore(save6);
    } else {
      present = this._peekTag(input, tag, state.any);
      if (input.isError(present))
        return present;
    }
  }
  var prevObj;
  if (state.obj && present)
    prevObj = input.enterObject();
  if (present) {
    if (state.explicit !== null) {
      var explicit2 = this._decodeTag(input, state.explicit);
      if (input.isError(explicit2))
        return explicit2;
      input = explicit2;
    }
    var start = input.offset;
    if (state.use === null && state.choice === null) {
      var _save;
      if (state.any)
        _save = input.save();
      var body = this._decodeTag(input, state.implicit !== null ? state.implicit : state.tag, state.any);
      if (input.isError(body))
        return body;
      if (state.any)
        result = input.raw(_save);
      else
        input = body;
    }
    if (options && options.track && state.tag !== null)
      options.track(input.path(), start, input.length, "tagged");
    if (options && options.track && state.tag !== null)
      options.track(input.path(), input.offset, input.length, "content");
    if (state.any)
      ;
    else if (state.choice === null) {
      result = this._decodeGeneric(state.tag, input, options);
    } else {
      result = this._decodeChoice(input, options);
    }
    if (input.isError(result))
      return result;
    if (!state.any && state.choice === null && state.children !== null) {
      state.children.forEach(function decodeChildren(child) {
        child._decode(input, options);
      });
    }
    if (state.contains && (state.tag === "octstr" || state.tag === "bitstr")) {
      var data = new DecoderBuffer$1(result);
      result = this._getUse(state.contains, input._reporterState.obj)._decode(data, options);
    }
  }
  if (state.obj && present)
    result = input.leaveObject(prevObj);
  if (state.key !== null && (result !== null || present === true))
    input.leaveKey(prevKey, state.key, result);
  else if (prevKey !== null)
    input.exitKey(prevKey);
  return result;
};
Node$2.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
  var state = this._baseState;
  if (tag === "seq" || tag === "set")
    return null;
  if (tag === "seqof" || tag === "setof")
    return this._decodeList(input, tag, state.args[0], options);
  else if (/str$/.test(tag))
    return this._decodeStr(input, tag, options);
  else if (tag === "objid" && state.args)
    return this._decodeObjid(input, state.args[0], state.args[1], options);
  else if (tag === "objid")
    return this._decodeObjid(input, null, null, options);
  else if (tag === "gentime" || tag === "utctime")
    return this._decodeTime(input, tag, options);
  else if (tag === "null_")
    return this._decodeNull(input, options);
  else if (tag === "bool")
    return this._decodeBool(input, options);
  else if (tag === "objDesc")
    return this._decodeStr(input, tag, options);
  else if (tag === "int" || tag === "enum")
    return this._decodeInt(input, state.args && state.args[0], options);
  if (state.use !== null) {
    return this._getUse(state.use, input._reporterState.obj)._decode(input, options);
  } else {
    return input.error("unknown tag: " + tag);
  }
};
Node$2.prototype._getUse = function _getUse(entity, obj2) {
  var state = this._baseState;
  state.useDecoder = this._use(entity, obj2);
  assert$6(state.useDecoder._baseState.parent === null);
  state.useDecoder = state.useDecoder._baseState.children[0];
  if (state.implicit !== state.useDecoder._baseState.implicit) {
    state.useDecoder = state.useDecoder.clone();
    state.useDecoder._baseState.implicit = state.implicit;
  }
  return state.useDecoder;
};
Node$2.prototype._decodeChoice = function decodeChoice(input, options) {
  var state = this._baseState;
  var result = null;
  var match = false;
  Object.keys(state.choice).some(function(key3) {
    var save6 = input.save();
    var node2 = state.choice[key3];
    try {
      var value = node2._decode(input, options);
      if (input.isError(value))
        return false;
      result = { type: key3, value };
      match = true;
    } catch (e2) {
      input.restore(save6);
      return false;
    }
    return true;
  }, this);
  if (!match)
    return input.error("Choice not matched");
  return result;
};
Node$2.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
  return new EncoderBuffer(data, this.reporter);
};
Node$2.prototype._encode = function encode2(data, reporter2, parent) {
  var state = this._baseState;
  if (state["default"] !== null && state["default"] === data)
    return;
  var result = this._encodeValue(data, reporter2, parent);
  if (result === void 0)
    return;
  if (this._skipDefault(result, reporter2, parent))
    return;
  return result;
};
Node$2.prototype._encodeValue = function encode3(data, reporter2, parent) {
  var state = this._baseState;
  if (state.parent === null)
    return state.children[0]._encode(data, reporter2 || new Reporter());
  var result = null;
  this.reporter = reporter2;
  if (state.optional && data === void 0) {
    if (state["default"] !== null)
      data = state["default"];
    else
      return;
  }
  var content = null;
  var primitive = false;
  if (state.any) {
    result = this._createEncoderBuffer(data);
  } else if (state.choice) {
    result = this._encodeChoice(data, reporter2);
  } else if (state.contains) {
    content = this._getUse(state.contains, parent)._encode(data, reporter2);
    primitive = true;
  } else if (state.children) {
    content = state.children.map(function(child2) {
      if (child2._baseState.tag === "null_")
        return child2._encode(null, reporter2, data);
      if (child2._baseState.key === null)
        return reporter2.error("Child should have a key");
      var prevKey = reporter2.enterKey(child2._baseState.key);
      if (_typeof(data) !== "object")
        return reporter2.error("Child expected, but input is not object");
      var res = child2._encode(data[child2._baseState.key], reporter2, data);
      reporter2.leaveKey(prevKey);
      return res;
    }, this).filter(function(child2) {
      return child2;
    });
    content = this._createEncoderBuffer(content);
  } else {
    if (state.tag === "seqof" || state.tag === "setof") {
      if (!(state.args && state.args.length === 1))
        return reporter2.error("Too many args for : " + state.tag);
      if (!Array.isArray(data))
        return reporter2.error("seqof/setof, but data is not Array");
      var child = this.clone();
      child._baseState.implicit = null;
      content = this._createEncoderBuffer(data.map(function(item) {
        var state2 = this._baseState;
        return this._getUse(state2.args[0], data)._encode(item, reporter2);
      }, child));
    } else if (state.use !== null) {
      result = this._getUse(state.use, parent)._encode(data, reporter2);
    } else {
      content = this._encodePrimitive(state.tag, data);
      primitive = true;
    }
  }
  if (!state.any && state.choice === null) {
    var tag = state.implicit !== null ? state.implicit : state.tag;
    var cls = state.implicit === null ? "universal" : "context";
    if (tag === null) {
      if (state.use === null)
        reporter2.error("Tag could be omitted only for .use()");
    } else {
      if (state.use === null)
        result = this._encodeComposite(tag, primitive, cls, content);
    }
  }
  if (state.explicit !== null)
    result = this._encodeComposite(state.explicit, false, "context", result);
  return result;
};
Node$2.prototype._encodeChoice = function encodeChoice(data, reporter2) {
  var state = this._baseState;
  var node2 = state.choice[data.type];
  if (!node2) {
    assert$6(false, data.type + " not found in " + JSON.stringify(Object.keys(state.choice)));
  }
  return node2._encode(data.value, reporter2);
};
Node$2.prototype._encodePrimitive = function encodePrimitive(tag, data) {
  var state = this._baseState;
  if (/str$/.test(tag))
    return this._encodeStr(data, tag);
  else if (tag === "objid" && state.args)
    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
  else if (tag === "objid")
    return this._encodeObjid(data, null, null);
  else if (tag === "gentime" || tag === "utctime")
    return this._encodeTime(data, tag);
  else if (tag === "null_")
    return this._encodeNull();
  else if (tag === "int" || tag === "enum")
    return this._encodeInt(data, state.args && state.reverseArgs[0]);
  else if (tag === "bool")
    return this._encodeBool(data);
  else if (tag === "objDesc")
    return this._encodeStr(data, tag);
  else
    throw new Error("Unsupported tag: " + tag);
};
Node$2.prototype._isNumstr = function isNumstr(str) {
  return /^[0-9 ]*$/.test(str);
};
Node$2.prototype._isPrintstr = function isPrintstr(str) {
  return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str);
};
var der$2 = {};
(function(exports) {
  function reverse(map) {
    var res = {};
    Object.keys(map).forEach(function(key3) {
      if ((key3 | 0) == key3)
        key3 = key3 | 0;
      var value = map[key3];
      res[value] = key3;
    });
    return res;
  }
  exports.tagClass = { 0: "universal", 1: "application", 2: "context", 3: "private" };
  exports.tagClassByName = reverse(exports.tagClass);
  exports.tag = { 0: "end", 1: "bool", 2: "int", 3: "bitstr", 4: "octstr", 5: "null_", 6: "objid", 7: "objDesc", 8: "external", 9: "real", 10: "enum", 11: "embed", 12: "utf8str", 13: "relativeOid", 16: "seq", 17: "set", 18: "numstr", 19: "printstr", 20: "t61str", 21: "videostr", 22: "ia5str", 23: "utctime", 24: "gentime", 25: "graphstr", 26: "iso646str", 27: "genstr", 28: "unistr", 29: "charstr", 30: "bmpstr" };
  exports.tagByName = reverse(exports.tag);
})(der$2);
var inherits$4 = inherits_browserExports;
var Buffer$2 = buffer$2.Buffer;
var Node$1 = node;
var der$1 = der$2;
function DEREncoder$1(entity) {
  this.enc = "der";
  this.name = entity.name;
  this.entity = entity;
  this.tree = new DERNode$1();
  this.tree._init(entity.body);
}
var der_1$1 = DEREncoder$1;
DEREncoder$1.prototype.encode = function encode4(data, reporter2) {
  return this.tree._encode(data, reporter2).join();
};
function DERNode$1(parent) {
  Node$1.call(this, "der", parent);
}
inherits$4(DERNode$1, Node$1);
DERNode$1.prototype._encodeComposite = function encodeComposite(tag, primitive, cls, content) {
  var encodedTag = encodeTag(tag, primitive, cls, this.reporter);
  if (content.length < 128) {
    var _header2 = new Buffer$2(2);
    _header2[0] = encodedTag;
    _header2[1] = content.length;
    return this._createEncoderBuffer([_header2, content]);
  }
  var lenOctets = 1;
  for (var _i40 = content.length; _i40 >= 256; _i40 >>= 8)
    lenOctets++;
  var header = new Buffer$2(1 + 1 + lenOctets);
  header[0] = encodedTag;
  header[1] = 128 | lenOctets;
  for (var _i41 = 1 + lenOctets, _j3 = content.length; _j3 > 0; _i41--, _j3 >>= 8)
    header[_i41] = _j3 & 255;
  return this._createEncoderBuffer([header, content]);
};
DERNode$1.prototype._encodeStr = function encodeStr(str, tag) {
  if (tag === "bitstr") {
    return this._createEncoderBuffer([str.unused | 0, str.data]);
  } else if (tag === "bmpstr") {
    var buf = new Buffer$2(str.length * 2);
    for (var _i42 = 0; _i42 < str.length; _i42++) {
      buf.writeUInt16BE(str.charCodeAt(_i42), _i42 * 2);
    }
    return this._createEncoderBuffer(buf);
  } else if (tag === "numstr") {
    if (!this._isNumstr(str)) {
      return this.reporter.error("Encoding of string type: numstr supports only digits and space");
    }
    return this._createEncoderBuffer(str);
  } else if (tag === "printstr") {
    if (!this._isPrintstr(str)) {
      return this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark");
    }
    return this._createEncoderBuffer(str);
  } else if (/str$/.test(tag)) {
    return this._createEncoderBuffer(str);
  } else if (tag === "objDesc") {
    return this._createEncoderBuffer(str);
  } else {
    return this.reporter.error("Encoding of string type: " + tag + " unsupported");
  }
};
DERNode$1.prototype._encodeObjid = function encodeObjid(id, values, relative) {
  if (typeof id === "string") {
    if (!values)
      return this.reporter.error("string objid given, but no values map found");
    if (!values.hasOwnProperty(id))
      return this.reporter.error("objid not found in values map");
    id = values[id].split(/[\s.]+/g);
    for (var _i43 = 0; _i43 < id.length; _i43++)
      id[_i43] |= 0;
  } else if (Array.isArray(id)) {
    id = id.slice();
    for (var _i44 = 0; _i44 < id.length; _i44++)
      id[_i44] |= 0;
  }
  if (!Array.isArray(id)) {
    return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(id));
  }
  if (!relative) {
    if (id[1] >= 40)
      return this.reporter.error("Second objid identifier OOB");
    id.splice(0, 2, id[0] * 40 + id[1]);
  }
  var size = 0;
  for (var _i45 = 0; _i45 < id.length; _i45++) {
    var ident = id[_i45];
    for (size++; ident >= 128; ident >>= 7)
      size++;
  }
  var objid = new Buffer$2(size);
  var offset = objid.length - 1;
  for (var _i46 = id.length - 1; _i46 >= 0; _i46--) {
    var _ident = id[_i46];
    objid[offset--] = _ident & 127;
    while ((_ident >>= 7) > 0)
      objid[offset--] = 128 | _ident & 127;
  }
  return this._createEncoderBuffer(objid);
};
function two(num) {
  if (num < 10)
    return "0" + num;
  else
    return num;
}
DERNode$1.prototype._encodeTime = function encodeTime(time, tag) {
  var str;
  var date = new Date(time);
  if (tag === "gentime") {
    str = [two(date.getUTCFullYear()), two(date.getUTCMonth() + 1), two(date.getUTCDate()), two(date.getUTCHours()), two(date.getUTCMinutes()), two(date.getUTCSeconds()), "Z"].join("");
  } else if (tag === "utctime") {
    str = [two(date.getUTCFullYear() % 100), two(date.getUTCMonth() + 1), two(date.getUTCDate()), two(date.getUTCHours()), two(date.getUTCMinutes()), two(date.getUTCSeconds()), "Z"].join("");
  } else {
    this.reporter.error("Encoding " + tag + " time is not supported yet");
  }
  return this._encodeStr(str, "octstr");
};
DERNode$1.prototype._encodeNull = function encodeNull() {
  return this._createEncoderBuffer("");
};
DERNode$1.prototype._encodeInt = function encodeInt(num, values) {
  if (typeof num === "string") {
    if (!values)
      return this.reporter.error("String int or enum given, but no values map");
    if (!values.hasOwnProperty(num)) {
      return this.reporter.error("Values map doesn't contain: " + JSON.stringify(num));
    }
    num = values[num];
  }
  if (typeof num !== "number" && !Buffer$2.isBuffer(num)) {
    var numArray = num.toArray();
    if (!num.sign && numArray[0] & 128) {
      numArray.unshift(0);
    }
    num = new Buffer$2(numArray);
  }
  if (Buffer$2.isBuffer(num)) {
    var _size = num.length;
    if (num.length === 0)
      _size++;
    var _out = new Buffer$2(_size);
    num.copy(_out);
    if (num.length === 0)
      _out[0] = 0;
    return this._createEncoderBuffer(_out);
  }
  if (num < 128)
    return this._createEncoderBuffer(num);
  if (num < 256)
    return this._createEncoderBuffer([0, num]);
  var size = 1;
  for (var _i47 = num; _i47 >= 256; _i47 >>= 8)
    size++;
  var out = new Array(size);
  for (var _i48 = out.length - 1; _i48 >= 0; _i48--) {
    out[_i48] = num & 255;
    num >>= 8;
  }
  if (out[0] & 128) {
    out.unshift(0);
  }
  return this._createEncoderBuffer(new Buffer$2(out));
};
DERNode$1.prototype._encodeBool = function encodeBool(value) {
  return this._createEncoderBuffer(value ? 255 : 0);
};
DERNode$1.prototype._use = function use2(entity, obj2) {
  if (typeof entity === "function")
    entity = entity(obj2);
  return entity._getEncoder("der").tree;
};
DERNode$1.prototype._skipDefault = function skipDefault(dataBuffer, reporter2, parent) {
  var state = this._baseState;
  var i2;
  if (state["default"] === null)
    return false;
  var data = dataBuffer.join();
  if (state.defaultBuffer === void 0)
    state.defaultBuffer = this._encodeValue(state["default"], reporter2, parent).join();
  if (data.length !== state.defaultBuffer.length)
    return false;
  for (i2 = 0; i2 < data.length; i2++)
    if (data[i2] !== state.defaultBuffer[i2])
      return false;
  return true;
};
function encodeTag(tag, primitive, cls, reporter2) {
  var res;
  if (tag === "seqof")
    tag = "seq";
  else if (tag === "setof")
    tag = "set";
  if (der$1.tagByName.hasOwnProperty(tag))
    res = der$1.tagByName[tag];
  else if (typeof tag === "number" && (tag | 0) === tag)
    res = tag;
  else
    return reporter2.error("Unknown tag: " + tag);
  if (res >= 31)
    return reporter2.error("Multi-octet tag encoding unsupported");
  if (!primitive)
    res |= 32;
  res |= der$1.tagClassByName[cls || "universal"] << 6;
  return res;
}
var inherits$3 = inherits_browserExports;
var DEREncoder = der_1$1;
function PEMEncoder(entity) {
  DEREncoder.call(this, entity);
  this.enc = "pem";
}
inherits$3(PEMEncoder, DEREncoder);
var pem$4 = PEMEncoder;
PEMEncoder.prototype.encode = function encode5(data, options) {
  var buf = DEREncoder.prototype.encode.call(this, data);
  var p2 = buf.toString("base64");
  var out = ["-----BEGIN " + options.label + "-----"];
  for (var _i49 = 0; _i49 < p2.length; _i49 += 64)
    out.push(p2.slice(_i49, _i49 + 64));
  out.push("-----END " + options.label + "-----");
  return out.join("\n");
};
(function(exports) {
  var encoders2 = exports;
  encoders2.der = der_1$1;
  encoders2.pem = pem$4;
})(encoders);
var decoders = {};
var inherits$2 = inherits_browserExports;
var bignum = bnExports;
var DecoderBuffer = buffer$1.DecoderBuffer;
var Node = node;
var der = der$2;
function DERDecoder$1(entity) {
  this.enc = "der";
  this.name = entity.name;
  this.entity = entity;
  this.tree = new DERNode();
  this.tree._init(entity.body);
}
var der_1 = DERDecoder$1;
DERDecoder$1.prototype.decode = function decode3(data, options) {
  if (!(data instanceof DecoderBuffer))
    data = new DecoderBuffer(data, options);
  return this.tree._decode(data, options);
};
function DERNode(parent) {
  Node.call(this, "der", parent);
}
inherits$2(DERNode, Node);
DERNode.prototype._peekTag = function peekTag(buffer2, tag, any2) {
  if (buffer2.isEmpty())
    return false;
  var state = buffer2.save();
  var decodedTag = derDecodeTag(buffer2, 'Failed to peek tag: "' + tag + '"');
  if (buffer2.isError(decodedTag))
    return decodedTag;
  buffer2.restore(state);
  return decodedTag.tag === tag || decodedTag.tagStr === tag || decodedTag.tagStr + "of" === tag || any2;
};
DERNode.prototype._decodeTag = function decodeTag(buffer2, tag, any2) {
  var decodedTag = derDecodeTag(buffer2, 'Failed to decode tag of "' + tag + '"');
  if (buffer2.isError(decodedTag))
    return decodedTag;
  var len2 = derDecodeLen(buffer2, decodedTag.primitive, 'Failed to get length of "' + tag + '"');
  if (buffer2.isError(len2))
    return len2;
  if (!any2 && decodedTag.tag !== tag && decodedTag.tagStr !== tag && decodedTag.tagStr + "of" !== tag) {
    return buffer2.error('Failed to match tag: "' + tag + '"');
  }
  if (decodedTag.primitive || len2 !== null)
    return buffer2.skip(len2, 'Failed to match body of: "' + tag + '"');
  var state = buffer2.save();
  var res = this._skipUntilEnd(buffer2, 'Failed to skip indefinite length body: "' + this.tag + '"');
  if (buffer2.isError(res))
    return res;
  len2 = buffer2.offset - state.offset;
  buffer2.restore(state);
  return buffer2.skip(len2, 'Failed to match body of: "' + tag + '"');
};
DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer2, fail) {
  for (; ; ) {
    var tag = derDecodeTag(buffer2, fail);
    if (buffer2.isError(tag))
      return tag;
    var _len13 = derDecodeLen(buffer2, tag.primitive, fail);
    if (buffer2.isError(_len13))
      return _len13;
    var res = void 0;
    if (tag.primitive || _len13 !== null)
      res = buffer2.skip(_len13);
    else
      res = this._skipUntilEnd(buffer2, fail);
    if (buffer2.isError(res))
      return res;
    if (tag.tagStr === "end")
      break;
  }
};
DERNode.prototype._decodeList = function decodeList(buffer2, tag, decoder, options) {
  var result = [];
  while (!buffer2.isEmpty()) {
    var possibleEnd = this._peekTag(buffer2, "end");
    if (buffer2.isError(possibleEnd))
      return possibleEnd;
    var res = decoder.decode(buffer2, "der", options);
    if (buffer2.isError(res) && possibleEnd)
      break;
    result.push(res);
  }
  return result;
};
DERNode.prototype._decodeStr = function decodeStr(buffer2, tag) {
  if (tag === "bitstr") {
    var unused = buffer2.readUInt8();
    if (buffer2.isError(unused))
      return unused;
    return { unused, data: buffer2.raw() };
  } else if (tag === "bmpstr") {
    var raw2 = buffer2.raw();
    if (raw2.length % 2 === 1)
      return buffer2.error("Decoding of string type: bmpstr length mismatch");
    var str = "";
    for (var _i50 = 0; _i50 < raw2.length / 2; _i50++) {
      str += String.fromCharCode(raw2.readUInt16BE(_i50 * 2));
    }
    return str;
  } else if (tag === "numstr") {
    var numstr = buffer2.raw().toString("ascii");
    if (!this._isNumstr(numstr)) {
      return buffer2.error("Decoding of string type: numstr unsupported characters");
    }
    return numstr;
  } else if (tag === "octstr") {
    return buffer2.raw();
  } else if (tag === "objDesc") {
    return buffer2.raw();
  } else if (tag === "printstr") {
    var printstr = buffer2.raw().toString("ascii");
    if (!this._isPrintstr(printstr)) {
      return buffer2.error("Decoding of string type: printstr unsupported characters");
    }
    return printstr;
  } else if (/str$/.test(tag)) {
    return buffer2.raw().toString();
  } else {
    return buffer2.error("Decoding of string type: " + tag + " unsupported");
  }
};
DERNode.prototype._decodeObjid = function decodeObjid(buffer2, values, relative) {
  var result;
  var identifiers = [];
  var ident = 0;
  var subident = 0;
  while (!buffer2.isEmpty()) {
    subident = buffer2.readUInt8();
    ident <<= 7;
    ident |= subident & 127;
    if ((subident & 128) === 0) {
      identifiers.push(ident);
      ident = 0;
    }
  }
  if (subident & 128)
    identifiers.push(ident);
  var first = identifiers[0] / 40 | 0;
  var second = identifiers[0] % 40;
  if (relative)
    result = identifiers;
  else
    result = [first, second].concat(identifiers.slice(1));
  if (values) {
    var tmp = values[result.join(" ")];
    if (tmp === void 0)
      tmp = values[result.join(".")];
    if (tmp !== void 0)
      result = tmp;
  }
  return result;
};
DERNode.prototype._decodeTime = function decodeTime(buffer2, tag) {
  var str = buffer2.raw().toString();
  var year;
  var mon;
  var day;
  var hour;
  var min;
  var sec;
  if (tag === "gentime") {
    year = str.slice(0, 4) | 0;
    mon = str.slice(4, 6) | 0;
    day = str.slice(6, 8) | 0;
    hour = str.slice(8, 10) | 0;
    min = str.slice(10, 12) | 0;
    sec = str.slice(12, 14) | 0;
  } else if (tag === "utctime") {
    year = str.slice(0, 2) | 0;
    mon = str.slice(2, 4) | 0;
    day = str.slice(4, 6) | 0;
    hour = str.slice(6, 8) | 0;
    min = str.slice(8, 10) | 0;
    sec = str.slice(10, 12) | 0;
    if (year < 70)
      year = 2e3 + year;
    else
      year = 1900 + year;
  } else {
    return buffer2.error("Decoding " + tag + " time is not supported yet");
  }
  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
};
DERNode.prototype._decodeNull = function decodeNull() {
  return null;
};
DERNode.prototype._decodeBool = function decodeBool(buffer2) {
  var res = buffer2.readUInt8();
  if (buffer2.isError(res))
    return res;
  else
    return res !== 0;
};
DERNode.prototype._decodeInt = function decodeInt(buffer2, values) {
  var raw2 = buffer2.raw();
  var res = new bignum(raw2);
  if (values)
    res = values[res.toString(10)] || res;
  return res;
};
DERNode.prototype._use = function use3(entity, obj2) {
  if (typeof entity === "function")
    entity = entity(obj2);
  return entity._getDecoder("der").tree;
};
function derDecodeTag(buf, fail) {
  var tag = buf.readUInt8(fail);
  if (buf.isError(tag))
    return tag;
  var cls = der.tagClass[tag >> 6];
  var primitive = (tag & 32) === 0;
  if ((tag & 31) === 31) {
    var oct = tag;
    tag = 0;
    while ((oct & 128) === 128) {
      oct = buf.readUInt8(fail);
      if (buf.isError(oct))
        return oct;
      tag <<= 7;
      tag |= oct & 127;
    }
  } else {
    tag &= 31;
  }
  var tagStr = der.tag[tag];
  return { cls, primitive, tag, tagStr };
}
function derDecodeLen(buf, primitive, fail) {
  var len2 = buf.readUInt8(fail);
  if (buf.isError(len2))
    return len2;
  if (!primitive && len2 === 128)
    return null;
  if ((len2 & 128) === 0) {
    return len2;
  }
  var num = len2 & 127;
  if (num > 4)
    return buf.error("length octect is too long");
  len2 = 0;
  for (var _i51 = 0; _i51 < num; _i51++) {
    len2 <<= 8;
    var _j4 = buf.readUInt8(fail);
    if (buf.isError(_j4))
      return _j4;
    len2 |= _j4;
  }
  return len2;
}
var inherits$1 = inherits_browserExports;
var Buffer$1 = buffer$2.Buffer;
var DERDecoder = der_1;
function PEMDecoder(entity) {
  DERDecoder.call(this, entity);
  this.enc = "pem";
}
inherits$1(PEMDecoder, DERDecoder);
var pem$3 = PEMDecoder;
PEMDecoder.prototype.decode = function decode4(data, options) {
  var lines = data.toString().split(/[\r\n]+/g);
  var label = options.label.toUpperCase();
  var re = /^-----(BEGIN|END) ([^-]+)-----$/;
  var start = -1;
  var end2 = -1;
  for (var _i52 = 0; _i52 < lines.length; _i52++) {
    var match = lines[_i52].match(re);
    if (match === null)
      continue;
    if (match[2] !== label)
      continue;
    if (start === -1) {
      if (match[1] !== "BEGIN")
        break;
      start = _i52;
    } else {
      if (match[1] !== "END")
        break;
      end2 = _i52;
      break;
    }
  }
  if (start === -1 || end2 === -1)
    throw new Error("PEM section not found for: " + label);
  var base642 = lines.slice(start + 1, end2).join("");
  base642.replace(/[^a-z0-9+/=]+/gi, "");
  var input = new Buffer$1(base642, "base64");
  return DERDecoder.prototype.decode.call(this, input, options);
};
(function(exports) {
  var decoders2 = exports;
  decoders2.der = der_1;
  decoders2.pem = pem$3;
})(decoders);
(function(exports) {
  var encoders$1 = encoders;
  var decoders$1 = decoders;
  var inherits2 = inherits_browserExports;
  var api2 = exports;
  api2.define = function define3(name2, body) {
    return new Entity(name2, body);
  };
  function Entity(name2, body) {
    this.name = name2;
    this.body = body;
    this.decoders = {};
    this.encoders = {};
  }
  Entity.prototype._createNamed = function createNamed(base3) {
    var named;
    try {
      named = require$$0$4.runInThisContext("(function " + this.name + "(entity) {\n  this._initNamed(entity);\n})");
    } catch (e2) {
      named = function named2(entity) {
        this._initNamed(entity);
      };
    }
    inherits2(named, base3);
    named.prototype._initNamed = function initnamed(entity) {
      base3.call(this, entity);
    };
    return new named(this);
  };
  Entity.prototype._getDecoder = function _getDecoder(enc) {
    enc = enc || "der";
    if (!this.decoders.hasOwnProperty(enc))
      this.decoders[enc] = this._createNamed(decoders$1[enc]);
    return this.decoders[enc];
  };
  Entity.prototype.decode = function decode6(data, enc, options) {
    return this._getDecoder(enc).decode(data, options);
  };
  Entity.prototype._getEncoder = function _getEncoder(enc) {
    enc = enc || "der";
    if (!this.encoders.hasOwnProperty(enc))
      this.encoders[enc] = this._createNamed(encoders$1[enc]);
    return this.encoders[enc];
  };
  Entity.prototype.encode = function encode7(data, enc, reporter2) {
    return this._getEncoder(enc).encode(data, reporter2);
  };
})(api$3);
var base$2 = {};
(function(exports) {
  var base3 = exports;
  base3.Reporter = reporter.Reporter;
  base3.DecoderBuffer = buffer$1.DecoderBuffer;
  base3.EncoderBuffer = buffer$1.EncoderBuffer;
  base3.Node = node;
})(base$2);
var constants = {};
(function(exports) {
  var constants2 = exports;
  constants2._reverse = function reverse(map) {
    var res = {};
    Object.keys(map).forEach(function(key3) {
      if ((key3 | 0) == key3)
        key3 = key3 | 0;
      var value = map[key3];
      res[value] = key3;
    });
    return res;
  };
  constants2.der = der$2;
})(constants);
(function(exports) {
  var asn12 = exports;
  asn12.bignum = bnExports;
  asn12.define = api$3.define;
  asn12.base = base$2;
  asn12.constants = constants;
  asn12.decoders = decoders;
  asn12.encoders = encoders;
})(asn1$7);
var asn1$6 = getDefaultExportFromCjs(asn1$7);
var buffer = {};
(function(exports) {
  var base642 = base64Js;
  var ieee754$1 = ieee754;
  var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports.Buffer = Buffer2;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  var K_MAX_LENGTH = 2147483647;
  exports.kMaxLength = K_MAX_LENGTH;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  }
  function typedArraySupport() {
    try {
      var arr = new Uint8Array(1);
      var proto = { foo: function foo() {
        return 42;
      } };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e2) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", { enumerable: true, get: function get5() {
    if (!Buffer2.isBuffer(this))
      return void 0;
    return this.buffer;
  } });
  Object.defineProperty(Buffer2.prototype, "offset", { enumerable: true, get: function get5() {
    if (!Buffer2.isBuffer(this))
      return void 0;
    return this.byteOffset;
  } });
  function createBuffer(length3) {
    if (length3 > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length3 + '" is invalid for option "size"');
    }
    var buf = new Uint8Array(length3);
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function Buffer2(arg, encodingOrOffset, length3) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError('The "string" argument must be of type string. Received type number');
      }
      return allocUnsafe2(arg);
    }
    return from3(arg, encodingOrOffset, length3);
  }
  Buffer2.poolSize = 8192;
  function from3(value, encodingOrOffset, length3) {
    if (typeof value === "string") {
      return fromString2(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + _typeof(value));
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length3);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length3);
    }
    if (typeof value === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    var valueOf2 = value.valueOf && value.valueOf();
    if (valueOf2 != null && valueOf2 !== value) {
      return Buffer2.from(valueOf2, encodingOrOffset, length3);
    }
    var b3 = fromObject(value);
    if (b3)
      return b3;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length3);
    }
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + _typeof(value));
  }
  Buffer2.from = function(value, encodingOrOffset, length3) {
    return from3(value, encodingOrOffset, length3);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc2(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer2.alloc = function(size, fill, encoding) {
    return alloc2(size, fill, encoding);
  };
  function allocUnsafe2(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer2.allocUnsafe = function(size) {
    return allocUnsafe2(size);
  };
  Buffer2.allocUnsafeSlow = function(size) {
    return allocUnsafe2(size);
  };
  function fromString2(string2, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    var length3 = byteLength2(string2, encoding) | 0;
    var buf = createBuffer(length3);
    var actual = buf.write(string2, encoding);
    if (actual !== length3) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    var length3 = array.length < 0 ? 0 : checked(array.length) | 0;
    var buf = createBuffer(length3);
    for (var i2 = 0; i2 < length3; i2 += 1) {
      buf[i2] = array[i2] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      var copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length3) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length3 || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    var buf;
    if (byteOffset === void 0 && length3 === void 0) {
      buf = new Uint8Array(array);
    } else if (length3 === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length3);
    }
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function fromObject(obj2) {
    if (Buffer2.isBuffer(obj2)) {
      var len2 = checked(obj2.length) | 0;
      var buf = createBuffer(len2);
      if (buf.length === 0) {
        return buf;
      }
      obj2.copy(buf, 0, 0, len2);
      return buf;
    }
    if (obj2.length !== void 0) {
      if (typeof obj2.length !== "number" || numberIsNaN(obj2.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj2);
    }
    if (obj2.type === "Buffer" && Array.isArray(obj2.data)) {
      return fromArrayLike(obj2.data);
    }
  }
  function checked(length3) {
    if (length3 >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length3 | 0;
  }
  function SlowBuffer(length3) {
    if (+length3 != length3) {
      length3 = 0;
    }
    return Buffer2.alloc(+length3);
  }
  Buffer2.isBuffer = function isBuffer2(b3) {
    return b3 != null && b3._isBuffer === true && b3 !== Buffer2.prototype;
  };
  Buffer2.compare = function compare(a2, b3) {
    if (isInstance(a2, Uint8Array))
      a2 = Buffer2.from(a2, a2.offset, a2.byteLength);
    if (isInstance(b3, Uint8Array))
      b3 = Buffer2.from(b3, b3.offset, b3.byteLength);
    if (!Buffer2.isBuffer(a2) || !Buffer2.isBuffer(b3)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a2 === b3)
      return 0;
    var x2 = a2.length;
    var y3 = b3.length;
    for (var i2 = 0, len2 = Math.min(x2, y3); i2 < len2; ++i2) {
      if (a2[i2] !== b3[i2]) {
        x2 = a2[i2];
        y3 = b3[i2];
        break;
      }
    }
    if (x2 < y3)
      return -1;
    if (y3 < x2)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat2(list, length3) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    var i2;
    if (length3 === void 0) {
      length3 = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        length3 += list[i2].length;
      }
    }
    var buffer2 = Buffer2.allocUnsafe(length3);
    var pos = 0;
    for (i2 = 0; i2 < list.length; ++i2) {
      var buf = list[i2];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          Buffer2.from(buf).copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(buffer2, buf, pos);
        }
      } else if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string2, encoding) {
    if (Buffer2.isBuffer(string2)) {
      return string2.length;
    }
    if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
      return string2.byteLength;
    }
    if (typeof string2 !== "string") {
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + _typeof(string2));
    }
    var len2 = string2.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len2 === 0)
      return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len2;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string2).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len2 * 2;
        case "hex":
          return len2 >>> 1;
        case "base64":
          return base64ToBytes(string2).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string2).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding, start, end2) {
    var loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end2 === void 0 || end2 > this.length) {
      end2 = this.length;
    }
    if (end2 <= 0) {
      return "";
    }
    end2 >>>= 0;
    start >>>= 0;
    if (end2 <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end2);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end2);
        case "ascii":
          return asciiSlice(this, start, end2);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end2);
        case "base64":
          return base64Slice(this, start, end2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end2);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b3, n2, m2) {
    var i2 = b3[n2];
    b3[n2] = b3[m2];
    b3[m2] = i2;
  }
  Buffer2.prototype.swap16 = function swap16() {
    var len2 = this.length;
    if (len2 % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (var i2 = 0; i2 < len2; i2 += 2) {
      swap(this, i2, i2 + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    var len2 = this.length;
    if (len2 % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (var i2 = 0; i2 < len2; i2 += 4) {
      swap(this, i2, i2 + 3);
      swap(this, i2 + 1, i2 + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    var len2 = this.length;
    if (len2 % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (var i2 = 0; i2 < len2; i2 += 8) {
      swap(this, i2, i2 + 7);
      swap(this, i2 + 1, i2 + 6);
      swap(this, i2 + 2, i2 + 5);
      swap(this, i2 + 3, i2 + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString3() {
    var length3 = this.length;
    if (length3 === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length3);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals2(b3) {
    if (!Buffer2.isBuffer(b3))
      throw new TypeError("Argument must be a Buffer");
    if (this === b3)
      return true;
    return Buffer2.compare(this, b3) === 0;
  };
  Buffer2.prototype.inspect = function inspect() {
    var str = "";
    var max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare(target, start, end2, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + _typeof(target));
    }
    if (start === void 0) {
      start = 0;
    }
    if (end2 === void 0) {
      end2 = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end2 > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end2) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end2) {
      return 1;
    }
    start >>>= 0;
    end2 >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    var x2 = thisEnd - thisStart;
    var y3 = end2 - start;
    var len2 = Math.min(x2, y3);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end2);
    for (var i2 = 0; i2 < len2; ++i2) {
      if (thisCopy[i2] !== targetCopy[i2]) {
        x2 = thisCopy[i2];
        y3 = targetCopy[i2];
        break;
      }
    }
    if (x2 < y3)
      return -1;
    if (y3 < x2)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read4(buf, i3) {
      if (indexSize === 1) {
        return buf[i3];
      } else {
        return buf.readUInt16BE(i3 * indexSize);
      }
    }
    var i2;
    if (dir) {
      var foundIndex = -1;
      for (i2 = byteOffset; i2 < arrLength; i2++) {
        if (read4(arr, i2) === read4(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i2;
          if (i2 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i2 -= i2 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i2 = byteOffset; i2 >= 0; i2--) {
        var found = true;
        for (var j3 = 0; j3 < valLength; j3++) {
          if (read4(arr, i2 + j3) !== read4(val, j3)) {
            found = false;
            break;
          }
        }
        if (found)
          return i2;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string2, offset, length3) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length3) {
      length3 = remaining;
    } else {
      length3 = Number(length3);
      if (length3 > remaining) {
        length3 = remaining;
      }
    }
    var strLen = string2.length;
    if (length3 > strLen / 2) {
      length3 = strLen / 2;
    }
    for (var i2 = 0; i2 < length3; ++i2) {
      var parsed = parseInt(string2.substr(i2 * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i2;
      buf[offset + i2] = parsed;
    }
    return i2;
  }
  function utf8Write(buf, string2, offset, length3) {
    return blitBuffer(utf8ToBytes(string2, buf.length - offset), buf, offset, length3);
  }
  function asciiWrite(buf, string2, offset, length3) {
    return blitBuffer(asciiToBytes(string2), buf, offset, length3);
  }
  function base64Write(buf, string2, offset, length3) {
    return blitBuffer(base64ToBytes(string2), buf, offset, length3);
  }
  function ucs2Write(buf, string2, offset, length3) {
    return blitBuffer(utf16leToBytes(string2, buf.length - offset), buf, offset, length3);
  }
  Buffer2.prototype.write = function write3(string2, offset, length3, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length3 = this.length;
      offset = 0;
    } else if (length3 === void 0 && typeof offset === "string") {
      encoding = offset;
      length3 = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length3)) {
        length3 = length3 >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length3;
        length3 = void 0;
      }
    } else {
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    }
    var remaining = this.length - offset;
    if (length3 === void 0 || length3 > remaining)
      length3 = remaining;
    if (string2.length > 0 && (length3 < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string2, offset, length3);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string2, offset, length3);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string2, offset, length3);
        case "base64":
          return base64Write(this, string2, offset, length3);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string2, offset, length3);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON2() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  function base64Slice(buf, start, end2) {
    if (start === 0 && end2 === buf.length) {
      return base642.fromByteArray(buf);
    } else {
      return base642.fromByteArray(buf.slice(start, end2));
    }
  }
  function utf8Slice(buf, start, end2) {
    end2 = Math.min(buf.length, end2);
    var res = [];
    var i2 = start;
    while (i2 < end2) {
      var firstByte = buf[i2];
      var codePoint = null;
      var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i2 + bytesPerSequence <= end2) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i2 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            fourthByte = buf[i2 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i2 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  var MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    var len2 = codePoints.length;
    if (len2 <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    var res = "";
    var i2 = 0;
    while (i2 < len2) {
      res += String.fromCharCode.apply(String, codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start, end2) {
    var ret = "";
    end2 = Math.min(buf.length, end2);
    for (var i2 = start; i2 < end2; ++i2) {
      ret += String.fromCharCode(buf[i2] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end2) {
    var ret = "";
    end2 = Math.min(buf.length, end2);
    for (var i2 = start; i2 < end2; ++i2) {
      ret += String.fromCharCode(buf[i2]);
    }
    return ret;
  }
  function hexSlice(buf, start, end2) {
    var len2 = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end2 || end2 < 0 || end2 > len2)
      end2 = len2;
    var out = "";
    for (var i2 = start; i2 < end2; ++i2) {
      out += hexSliceLookupTable[buf[i2]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end2) {
    var bytes = buf.slice(start, end2);
    var res = "";
    for (var i2 = 0; i2 < bytes.length - 1; i2 += 2) {
      res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice(start, end2) {
    var len2 = this.length;
    start = ~~start;
    end2 = end2 === void 0 ? len2 : ~~end2;
    if (start < 0) {
      start += len2;
      if (start < 0)
        start = 0;
    } else if (start > len2) {
      start = len2;
    }
    if (end2 < 0) {
      end2 += len2;
      if (end2 < 0)
        end2 = 0;
    } else if (end2 > len2) {
      end2 = len2;
    }
    if (end2 < start)
      end2 = start;
    var newBuf = this.subarray(start, end2);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length3) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length3)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    var val = this[offset];
    var mul = 1;
    var i2 = 0;
    while (++i2 < byteLength3 && (mul *= 256)) {
      val += this[offset + i2] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    var val = this[offset + --byteLength3];
    var mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength3] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt82(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    var val = this[offset];
    var mul = 1;
    var i2 = 0;
    while (++i2 < byteLength3 && (mul *= 256)) {
      val += this[offset + i2] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    var i2 = byteLength3;
    var mul = 1;
    var val = this[offset + --i2];
    while (i2 > 0 && (mul *= 256)) {
      val += this[offset + --i2] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer2.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    var mul = 1;
    var i2 = 0;
    this[offset] = value & 255;
    while (++i2 < byteLength3 && (mul *= 256)) {
      this[offset + i2] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    var i2 = byteLength3 - 1;
    var mul = 1;
    this[offset + i2] = value & 255;
    while (--i2 >= 0 && (mul *= 256)) {
      this[offset + i2] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    var i2 = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 255;
    while (++i2 < byteLength3 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i2] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    var i2 = byteLength3 - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i2] = value & 255;
    while (--i2 >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i2] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy(target, targetStart, start, end2) {
    if (!Buffer2.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end2 && end2 !== 0)
      end2 = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end2 > 0 && end2 < start)
      end2 = start;
    if (end2 === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end2 < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end2 > this.length)
      end2 = this.length;
    if (target.length - targetStart < end2 - start) {
      end2 = target.length - targetStart + start;
    }
    var len2 = end2 - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end2);
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, end2), targetStart);
    }
    return len2;
  };
  Buffer2.prototype.fill = function fill(val, start, end2, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end2 = this.length;
      } else if (typeof end2 === "string") {
        encoding = end2;
        end2 = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        var code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end2) {
      throw new RangeError("Out of range index");
    }
    if (end2 <= start) {
      return this;
    }
    start = start >>> 0;
    end2 = end2 === void 0 ? this.length : end2 >>> 0;
    if (!val)
      val = 0;
    var i2;
    if (typeof val === "number") {
      for (i2 = start; i2 < end2; ++i2) {
        this[i2] = val;
      }
    } else {
      var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
      var len2 = bytes.length;
      if (len2 === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i2 = 0; i2 < end2 - start; ++i2) {
        this[i2 + start] = bytes[i2 % len2];
      }
    }
    return this;
  };
  var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string2, units) {
    units = units || Infinity;
    var codePoint;
    var length3 = string2.length;
    var leadSurrogate = null;
    var bytes = [];
    for (var i2 = 0; i2 < length3; ++i2) {
      codePoint = string2.charCodeAt(i2);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i2 + 1 === length3) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    var byteArray = [];
    for (var i2 = 0; i2 < str.length; ++i2) {
      byteArray.push(str.charCodeAt(i2) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    var c3, hi, lo;
    var byteArray = [];
    for (var i2 = 0; i2 < str.length; ++i2) {
      if ((units -= 2) < 0)
        break;
      c3 = str.charCodeAt(i2);
      hi = c3 >> 8;
      lo = c3 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base642.toByteArray(base64clean(str));
  }
  function blitBuffer(src2, dst, offset, length3) {
    for (var i2 = 0; i2 < length3; ++i2) {
      if (i2 + offset >= dst.length || i2 >= src2.length)
        break;
      dst[i2 + offset] = src2[i2];
    }
    return i2;
  }
  function isInstance(obj2, type) {
    return obj2 instanceof type || obj2 != null && obj2.constructor != null && obj2.constructor.name != null && obj2.constructor.name === type.name;
  }
  function numberIsNaN(obj2) {
    return obj2 !== obj2;
  }
  var hexSliceLookupTable = function() {
    var alphabet2 = "0123456789abcdef";
    var table = new Array(256);
    for (var i2 = 0; i2 < 16; ++i2) {
      var i16 = i2 * 16;
      for (var j3 = 0; j3 < 16; ++j3) {
        table[i16 + j3] = alphabet2[i2] + alphabet2[j3];
      }
    }
    return table;
  }();
})(buffer);
var binaryStringToUint8Array = function binaryStringToUint8Array2(str) {
  var len2 = str.length;
  var uint8Array = new Uint8Array(len2);
  for (var _i53 = 0; _i53 < len2; _i53 += 1) {
    uint8Array[_i53] = str.charCodeAt(_i53);
  }
  return uint8Array;
};
var uint8ArrayToBinaryString = function uint8ArrayToBinaryString2(uint8Array) {
  return String.fromCharCode.apply(null, uint8Array);
};
var hexStringToUint8Array = function hexStringToUint8Array2(str) {
  return new Uint8Array(str.match(/.{1,2}/g).map(function(byte) {
    return parseInt(byte, 16);
  }));
};
var uint8ArrayToHexString = function uint8ArrayToHexString2(uint8Array) {
  return Array.prototype.map.call(uint8Array, function(x2) {
    return "00".concat(x2.toString(16)).slice(-2);
  }).join("");
};
var typedArrayToUint8Array$1 = function typedArrayToUint8Array$12(typedArray) {
  return new Uint8Array(typedArray.buffer.slice(typedArray.byteOffset, typedArray.byteOffset + typedArray.byteLength));
};
var bnToUint8Array = function bnToUint8Array2(bn2) {
  var numArray = bn2.toArray();
  if (!bn2.negative && numArray[0] & 128) {
    numArray.unshift(0);
  }
  return Uint8Array.from(numArray);
};
var uint8ArrayToInteger = function uint8ArrayToInteger2(uint8Array) {
  if (uint8Array.byteLength > 32) {
    throw new Error("Only 32 byte integers is supported");
  }
  var integer = 0;
  var byteCount = 0;
  do {
    integer = (integer << 8) + uint8Array[byteCount];
    byteCount += 1;
  } while (uint8Array.byteLength > byteCount);
  return integer;
};
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (_typeof(call) === "object" || typeof call === "function") ? call : self2;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
function _extendableBuiltin(cls) {
  function ExtendableBuiltin() {
    cls.apply(this, arguments);
  }
  ExtendableBuiltin.prototype = Object.create(cls.prototype, { constructor: { value: cls, enumerable: false, writable: true, configurable: true } });
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ExtendableBuiltin, cls);
  } else {
    ExtendableBuiltin.__proto__ = cls;
  }
  return ExtendableBuiltin;
}
var ExtendableError = function(_extendableBuiltin2) {
  _inherits(ExtendableError2, _extendableBuiltin2);
  function ExtendableError2() {
    var message = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    _classCallCheck(this, ExtendableError2);
    var _this = _possibleConstructorReturn(this, (ExtendableError2.__proto__ || Object.getPrototypeOf(ExtendableError2)).call(this, message));
    Object.defineProperty(_this, "message", { configurable: true, enumerable: false, value: message, writable: true });
    Object.defineProperty(_this, "name", { configurable: true, enumerable: false, value: _this.constructor.name, writable: true });
    if (Error.hasOwnProperty("captureStackTrace")) {
      Error.captureStackTrace(_this, _this.constructor);
      return _possibleConstructorReturn(_this);
    }
    Object.defineProperty(_this, "stack", { configurable: true, enumerable: false, value: new Error(message).stack, writable: true });
    return _this;
  }
  return ExtendableError2;
}(_extendableBuiltin(Error));
var BaseError$1 = function(_ExtendableError) {
  function BaseError2(message, name2, code2, props) {
    var _this23;
    _classCallCheck2(this, BaseError2);
    _this23 = _callSuper(this, BaseError2, [message]);
    _this23.name = name2 || "BaseError";
    if (code2) {
      _this23.code = code2;
    }
    Object.assign(_this23, props);
    return _this23;
  }
  _inherits2(BaseError2, _ExtendableError);
  return _createClass(BaseError2);
}(ExtendableError);
var UnexpectedTypeError = function(_BaseError$) {
  function UnexpectedTypeError2(message, props) {
    _classCallCheck2(this, UnexpectedTypeError2);
    return _callSuper(this, UnexpectedTypeError2, [message, "UnexpectedTypeError", "UNEXPECTED_TYPE", props]);
  }
  _inherits2(UnexpectedTypeError2, _BaseError$);
  return _createClass(UnexpectedTypeError2);
}(BaseError$1);
var AggregatedError = function(_BaseError$2) {
  function AggregatedError2(message, errors, props) {
    _classCallCheck2(this, AggregatedError2);
    return _callSuper(this, AggregatedError2, [message, "AggregatedError", "AGGREGATED_ERROR", _objectSpread(_objectSpread({}, props), {}, { errors })]);
  }
  _inherits2(AggregatedError2, _BaseError$2);
  return _createClass(AggregatedError2);
}(BaseError$1);
var UnsupportedFormatError = function(_BaseError$3) {
  function UnsupportedFormatError2(format, props) {
    _classCallCheck2(this, UnsupportedFormatError2);
    return _callSuper(this, UnsupportedFormatError2, ["Unsupported format '".concat(format, "'"), "UnsupportedFormatError", "UNSUPPORTED_FORMAT", props]);
  }
  _inherits2(UnsupportedFormatError2, _BaseError$3);
  return _createClass(UnsupportedFormatError2);
}(BaseError$1);
var UnsupportedAlgorithmError = function(_BaseError$4) {
  function UnsupportedAlgorithmError2(message, props) {
    _classCallCheck2(this, UnsupportedAlgorithmError2);
    return _callSuper(this, UnsupportedAlgorithmError2, [message, "UnsupportedAlgorithmError", "UNSUPPORTED_ALGORITHM", props]);
  }
  _inherits2(UnsupportedAlgorithmError2, _BaseError$4);
  return _createClass(UnsupportedAlgorithmError2);
}(BaseError$1);
var MissingPasswordError = function(_BaseError$5) {
  function MissingPasswordError2(message, props) {
    _classCallCheck2(this, MissingPasswordError2);
    return _callSuper(this, MissingPasswordError2, [message, "MissingPasswordError", "MISSING_PASSWORD", props]);
  }
  _inherits2(MissingPasswordError2, _BaseError$5);
  return _createClass(MissingPasswordError2);
}(BaseError$1);
var DecryptionFailedError = function(_BaseError$6) {
  function DecryptionFailedError2(message, props) {
    _classCallCheck2(this, DecryptionFailedError2);
    return _callSuper(this, DecryptionFailedError2, [message, "DecryptionFailedError", "DECRYPTION_FAILED", props]);
  }
  _inherits2(DecryptionFailedError2, _BaseError$6);
  return _createClass(DecryptionFailedError2);
}(BaseError$1);
var DecodeAsn1FailedError = function(_BaseError$7) {
  function DecodeAsn1FailedError2(message, modelName, props) {
    _classCallCheck2(this, DecodeAsn1FailedError2);
    return _callSuper(this, DecodeAsn1FailedError2, [message, "DecodeAsn1FailedError", "DECODE_ASN1_FAILED", _objectSpread(_objectSpread({}, props), {}, { modelName })]);
  }
  _inherits2(DecodeAsn1FailedError2, _BaseError$7);
  return _createClass(DecodeAsn1FailedError2);
}(BaseError$1);
var EncodeAsn1FailedError = function(_BaseError$8) {
  function EncodeAsn1FailedError2(message, modelName, props) {
    _classCallCheck2(this, EncodeAsn1FailedError2);
    return _callSuper(this, EncodeAsn1FailedError2, [message, "EncodeAsn1FailedError", "ENCODE_ASN1_FAILED", _objectSpread(_objectSpread({}, props), {}, { modelName })]);
  }
  _inherits2(EncodeAsn1FailedError2, _BaseError$8);
  return _createClass(EncodeAsn1FailedError2);
}(BaseError$1);
var DecodePemFailedError = function(_BaseError$9) {
  function DecodePemFailedError2(message, props) {
    _classCallCheck2(this, DecodePemFailedError2);
    return _callSuper(this, DecodePemFailedError2, [message, "DecodePemFailedError", "DECODE_PEM_FAILED", props]);
  }
  _inherits2(DecodePemFailedError2, _BaseError$9);
  return _createClass(DecodePemFailedError2);
}(BaseError$1);
var EncodePemFailedError = function(_BaseError$10) {
  function EncodePemFailedError2(message, props) {
    _classCallCheck2(this, EncodePemFailedError2);
    return _callSuper(this, EncodePemFailedError2, [message, "EncodePemFailedError", "ENCODE_PEM_FAILED", props]);
  }
  _inherits2(EncodePemFailedError2, _BaseError$10);
  return _createClass(EncodePemFailedError2);
}(BaseError$1);
var objidValues = new Proxy({}, { get: function get4(obj2, key3) {
  if (key3 === "hasOwnProperty") {
    return function(key4) {
      return key4.indexOf(".") > 0;
    };
  }
  return key3.indexOf(".") > 0 ? key3 : void 0;
} });
var define = function define2(name2, fn) {
  return asn1$6.define(name2, function() {
    fn(this);
  });
};
var decodeAsn1 = function decodeAsn12(encodedEntity, Model) {
  var decodedEntity;
  try {
    decodedEntity = Model.decode(buffer.Buffer.from(encodedEntity), "der");
  } catch (err) {
    throw new DecodeAsn1FailedError("Failed to decode ".concat(Model.name), Model.name, { originalError: err });
  }
  var mapValue = function mapValue2(value) {
    if (ArrayBuffer.isView(value)) {
      return typedArrayToUint8Array$1(value);
    }
    if (value && value.toArrayLike) {
      return bnToUint8Array(value);
    }
    return value;
  };
  forEach(decodedEntity, function(value, key3, subject) {
    subject[key3] = mapValue(value);
  });
  return mapValue(decodedEntity);
};
var encodeAsn1 = function encodeAsn12(decodedEntity, Model) {
  var mapValue = function mapValue2(value) {
    if (value instanceof Uint8Array) {
      return buffer.Buffer.from(value);
    }
    return value;
  };
  decodedEntity = cloneDeep$1(decodedEntity);
  decodedEntity = mapValue(decodedEntity);
  forEach(decodedEntity, function(value, key3, subject) {
    subject[key3] = mapValue(value);
  });
  var encodedEntity;
  try {
    encodedEntity = Model.encode(decodedEntity, "der");
  } catch (err) {
    throw new EncodeAsn1FailedError("Failed to encode ".concat(Model.name), Model.name, { originalError: err });
  }
  return typedArrayToUint8Array$1(encodedEntity);
};
function constant$1(value) {
  return function() {
    return value;
  };
}
var constant_1 = constant$1;
function createBaseFor$1(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1, iterable = Object(object), props = keysFunc(object), length3 = props.length;
    while (length3--) {
      var key3 = props[fromRight ? length3 : ++index];
      if (iteratee(iterable[key3], key3, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var _createBaseFor = createBaseFor$1;
var createBaseFor = _createBaseFor;
var baseFor$1 = createBaseFor();
var _baseFor = baseFor$1;
function baseTimes$1(n2, iteratee) {
  var index = -1, result = Array(n2);
  while (++index < n2) {
    result[index] = iteratee(index);
  }
  return result;
}
var _baseTimes = baseTimes$1;
var freeGlobal$1 = _typeof(commonjsGlobal) == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == "object" && self && self.Object === Object && self;
var root$1 = freeGlobal || freeSelf || Function("return this")();
var _root = root$1;
var root = _root;
var Symbol$3 = root.Symbol;
var _Symbol = Symbol$3;
var Symbol$2 = _Symbol;
var objectProto$7 = Object.prototype;
var hasOwnProperty$4 = objectProto$7.hasOwnProperty;
var nativeObjectToString$2 = objectProto$7.toString;
var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$4.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString$2.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto$6 = Object.prototype;
var nativeObjectToString$1 = objectProto$6.toString;
function objectToString$1(value) {
  return nativeObjectToString$1.call(value);
}
var _objectToString = objectToString$1;
var Symbol$1 = _Symbol;
var getRawTag = _getRawTag;
var objectToString = _objectToString;
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
function baseGetTag$4(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
var _baseGetTag = baseGetTag$4;
function isObjectLike$4(value) {
  return value != null && _typeof(value) == "object";
}
var isObjectLike_1 = isObjectLike$4;
var baseGetTag$3 = _baseGetTag;
var isObjectLike$3 = isObjectLike_1;
var argsTag$1 = "[object Arguments]";
function baseIsArguments$1(value) {
  return isObjectLike$3(value) && baseGetTag$3(value) == argsTag$1;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments;
var isObjectLike$2 = isObjectLike_1;
var objectProto$5 = Object.prototype;
var hasOwnProperty$3 = objectProto$5.hasOwnProperty;
var propertyIsEnumerable = objectProto$5.propertyIsEnumerable;
var isArguments$1 = baseIsArguments(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike$2(value) && hasOwnProperty$3.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_1 = isArguments$1;
var isArray$1 = Array.isArray;
var isArray_1 = isArray$1;
var isBuffer$1 = { exports: {} };
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
isBuffer$1.exports;
(function(module, exports) {
  var root2 = _root, stubFalse2 = stubFalse_1;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root2.Buffer : void 0;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
  var isBuffer2 = nativeIsBuffer || stubFalse2;
  module.exports = isBuffer2;
})(isBuffer$1, isBuffer$1.exports);
var isBufferExports = isBuffer$1.exports;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$1(value, length3) {
  var type = _typeof(value);
  length3 = length3 == null ? MAX_SAFE_INTEGER$1 : length3;
  return !!length3 && (type == "number" || type != "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length3;
}
var _isIndex = isIndex$1;
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength$2(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
var isLength_1 = isLength$2;
var baseGetTag$2 = _baseGetTag;
var isLength$1 = isLength_1;
var isObjectLike$1 = isObjectLike_1;
var argsTag = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag$1 = "[object Function]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag$1 = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag$1] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray$1(value) {
  return isObjectLike$1(value) && isLength$1(value.length) && !!typedArrayTags[baseGetTag$2(value)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$1(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary = baseUnary$1;
var _nodeUtil = { exports: {} };
_nodeUtil.exports;
(function(module, exports) {
  var freeGlobal2 = _freeGlobal;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types = freeModule && freeModule.require && freeModule.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e2) {
    }
  }();
  module.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var _nodeUtilExports = _nodeUtil.exports;
var baseIsTypedArray = _baseIsTypedArray;
var baseUnary = _baseUnary;
var nodeUtil = _nodeUtilExports;
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
var isTypedArray$1 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$1;
var baseTimes = _baseTimes;
var isArguments = isArguments_1;
var isArray = isArray_1;
var isBuffer = isBufferExports;
var isIndex = _isIndex;
var isTypedArray = isTypedArray_1;
var objectProto$4 = Object.prototype;
var hasOwnProperty$2 = objectProto$4.hasOwnProperty;
function arrayLikeKeys$1(value, inherited) {
  var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length3 = result.length;
  for (var key3 in value) {
    if ((inherited || hasOwnProperty$2.call(value, key3)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key3 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key3 == "offset" || key3 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key3 == "buffer" || key3 == "byteLength" || key3 == "byteOffset") || // Skip index properties.
    isIndex(key3, length3)))) {
      result.push(key3);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$1;
var objectProto$3 = Object.prototype;
function isPrototype$1(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$3;
  return value === proto;
}
var _isPrototype = isPrototype$1;
function overArg$2(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var _overArg = overArg$2;
var overArg$1 = _overArg;
var nativeKeys$1 = overArg$1(Object.keys, Object);
var _nativeKeys = nativeKeys$1;
var isPrototype = _isPrototype;
var nativeKeys = _nativeKeys;
var objectProto$2 = Object.prototype;
var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
function baseKeys$1(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key3 in Object(object)) {
    if (hasOwnProperty$1.call(object, key3) && key3 != "constructor") {
      result.push(key3);
    }
  }
  return result;
}
var _baseKeys = baseKeys$1;
function isObject$1(value) {
  var type = _typeof(value);
  return value != null && (type == "object" || type == "function");
}
var isObject_1 = isObject$1;
var baseGetTag$1 = _baseGetTag;
var isObject = isObject_1;
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction$1(value) {
  if (!isObject(value)) {
    return false;
  }
  var tag = baseGetTag$1(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction$1;
var isFunction = isFunction_1;
var isLength = isLength_1;
function isArrayLike$1(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}
var isArrayLike_1 = isArrayLike$1;
var arrayLikeKeys = _arrayLikeKeys;
var baseKeys = _baseKeys;
var isArrayLike = isArrayLike_1;
function keys$4(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
var keys_1 = keys$4;
var baseFor = _baseFor;
var keys$3 = keys_1;
function baseForOwn$1(object, iteratee) {
  return object && baseFor(object, iteratee, keys$3);
}
var _baseForOwn = baseForOwn$1;
var baseForOwn = _baseForOwn;
function baseInverter$1(object, setter, iteratee, accumulator) {
  baseForOwn(object, function(value, key3, object2) {
    setter(accumulator, iteratee(value), key3, object2);
  });
  return accumulator;
}
var _baseInverter = baseInverter$1;
var baseInverter = _baseInverter;
function createInverter$1(setter, toIteratee) {
  return function(object, iteratee) {
    return baseInverter(object, setter, toIteratee(iteratee), {});
  };
}
var _createInverter = createInverter$1;
function identity$5(value) {
  return value;
}
var identity_1 = identity$5;
var constant = constant_1;
var createInverter = _createInverter;
var identity$4 = identity_1;
var objectProto$1 = Object.prototype;
var nativeObjectToString = objectProto$1.toString;
var invert = createInverter(function(result, value, key3) {
  if (value != null && typeof value.toString != "function") {
    value = nativeObjectToString.call(value);
  }
  result[value] = key3;
}, constant(identity$4));
var invert_1 = invert;
var _invert = getDefaultExportFromCjs(invert_1);
var OIDS = {
  // RSA
  "1.2.840.113549.1.1.1": "rsa-encryption",
  "1.2.840.113549.1.1.2": "md2-with-rsa-encryption",
  "1.2.840.113549.1.1.3": "md4-with-rsa-encryption",
  "1.2.840.113549.1.1.4": "md5-with-rsa-encryption",
  "1.2.840.113549.1.1.5": "sha1-with-rsa-encryption",
  "1.2.840.113549.1.1.14": "sha224-with-rsa-encryption",
  "1.2.840.113549.1.1.11": "sha256-with-rsa-encryption",
  "1.2.840.113549.1.1.12": "sha384-with-rsa-encryption",
  "1.2.840.113549.1.1.13": "sha512-with-rsa-encryption",
  "1.2.840.113549.1.1.15": "sha512-224-with-rsa-encryption",
  "1.2.840.113549.1.1.16": "sha512-256-with-rsa-encryption",
  "1.2.840.113549.1.1.7": "rsaes-oaep",
  "1.2.840.113549.1.1.10": "rsassa-pss",
  // Ed25519
  "1.3.101.112": "ed25519",
  // EC & its curves
  "1.2.840.10045.2.1": "ec-public-key",
  "1.3.132.1.12": "ec-dh",
  "1.3.132.1.13": "ec-mqv",
  "1.3.132.0.1": "sect163k1",
  "1.3.132.0.2": "sect163r1",
  "1.3.132.0.3": "sect239k1",
  "1.3.132.0.4": "sect113r1",
  "1.3.132.0.5": "sect113r2",
  "1.3.132.0.6": "secp112r1",
  "1.3.132.0.7": "secp112r2",
  "1.3.132.0.8": "secp160r1",
  "1.3.132.0.9": "secp160k1",
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.15": "sect163r2",
  "1.3.132.0.16": "sect283k1",
  "1.3.132.0.17": "sect283r1",
  "1.3.132.0.22": "sect131r1",
  "1.3.132.0.23": "sect131r2",
  "1.3.132.0.24": "sect193r1",
  "1.3.132.0.25": "sect193r2",
  "1.3.132.0.26": "sect233k1",
  "1.3.132.0.27": "sect233r1",
  "1.3.132.0.28": "secp128r1",
  "1.3.132.0.29": "secp128r2",
  "1.3.132.0.30": "secp160r2",
  "1.3.132.0.31": "secp192k1",
  "1.3.132.0.32": "secp224k1",
  "1.3.132.0.33": "secp224r1",
  "1.3.132.0.34": "secp384r1",
  "1.3.132.0.35": "secp521r1",
  "1.3.132.0.36": "sect409k1",
  "1.3.132.0.37": "sect409r1",
  "1.3.132.0.38": "sect571k1",
  "1.3.132.0.39": "sect571r1",
  "1.2.840.10045.3.1.1": "secp192r1",
  "1.2.840.10045.3.1.7": "secp256r1",
  // PBE related
  "2.16.840.1.101.3.4.1.2": "aes128-cbc",
  "2.16.840.1.101.3.4.1.22": "aes192-cbc",
  "2.16.840.1.101.3.4.1.42": "aes256-cbc",
  "1.2.840.113549.3.2": "rc2-cbc",
  "1.3.14.3.2.7": "des-cbc",
  "1.2.840.113549.3.7": "des-ede3-cbc",
  "1.2.840.113549.1.5.13": "pbes2",
  "1.2.840.113549.1.5.12": "pbkdf2",
  "1.2.840.113549.2.7": "hmac-with-sha1",
  "1.2.840.113549.2.8": "hmac-with-sha224",
  "1.2.840.113549.2.9": "hmac-with-sha256",
  "1.2.840.113549.2.10": "hmac-with-sha384",
  "1.2.840.113549.2.11": "hmac-with-sha512"
};
var FLIPPED_OIDS = _invert(OIDS);
var OtherPrimeInfo = define("OtherPrimeInfo", function(asn12) {
  asn12.seq().obj(asn12.key("prime").int(), asn12.key("exponent").int(), asn12.key("coefficient").int());
});
var RsaPrivateKey$1 = define("RSAPrivateKey", function(asn12) {
  asn12.seq().obj(asn12.key("version").int(), asn12.key("modulus").int(), asn12.key("publicExponent").int(), asn12.key("privateExponent").int(), asn12.key("prime1").int(), asn12.key("prime2").int(), asn12.key("exponent1").int(), asn12.key("exponent2").int(), asn12.key("coefficient").int(), asn12.key("otherPrimeInfos").seqof(OtherPrimeInfo).optional());
});
var RsaPublicKey$1 = define("RSAPublicKey", function(asn12) {
  asn12.seq().obj(asn12.key("modulus").int(), asn12.key("publicExponent").int());
});
var EcPrivateKey = define("ECPrivateKey", function(asn12) {
  asn12.seq().obj(asn12.key("version").int(), asn12.key("privateKey").octstr(), asn12.key("parameters").explicit(0).optional().use(EcParameters), asn12.key("publicKey").explicit(1).optional().bitstr());
});
var EcParameters = define("ECParameters", function(asn12) {
  asn12.choice({ namedCurve: asn12.objid(objidValues) });
});
var AlgorithmIdentifier = define("AlgorithmIdentifier", function(asn12) {
  asn12.seq().obj(asn12.key("id").objid(objidValues), asn12.key("parameters").optional().any());
});
var PrivateKeyInfo = define("PrivateKeyInfo", function(asn12) {
  asn12.seq().obj(asn12.key("version").int(), asn12.key("privateKeyAlgorithm").use(AlgorithmIdentifier), asn12.key("privateKey").octstr(), asn12.key("attributes").implicit(0).optional().any(), asn12.key("publicKey").implicit(1).optional().bitstr());
});
var EncryptedPrivateKeyInfo = define("EncryptedPrivateKeyInfo", function(asn12) {
  asn12.seq().obj(asn12.key("encryptionAlgorithm").use(AlgorithmIdentifier), asn12.key("encryptedData").octstr());
});
var Pbes2Algorithms = define("PBES2Algorithms", function(asn12) {
  asn12.seq().obj(asn12.key("keyDerivationFunc").use(AlgorithmIdentifier), asn12.key("encryptionScheme").use(AlgorithmIdentifier));
});
var Pbes2EsParams = { "des-cbc": define("desCBC", function(asn12) {
  return asn12.octstr();
}), "des-ede3-cbc": define("des-EDE3-CBC", function(asn12) {
  return asn12.octstr();
}), "aes128-cbc": define("aes128-CBC", function(asn12) {
  return asn12.octstr();
}), "aes192-cbc": define("aes192-CBC", function(asn12) {
  return asn12.octstr();
}), "aes256-cbc": define("aes256-CBC", function(asn12) {
  return asn12.octstr();
}) };
var Pbkdf2Params = define("PBKDF2-params", function(asn12) {
  asn12.seq().obj(asn12.key("salt").choice({ specified: asn12.octstr(), otherSource: asn12.use(AlgorithmIdentifier) }), asn12.key("iterationCount").int(), asn12.key("keyLength").int().optional(), asn12.key("prf").use(AlgorithmIdentifier).def({ id: FLIPPED_OIDS["hmac-with-sha1"], parameters: buffer.Buffer.from([5, 0]) }));
});
var Rc2CbcParameter = define("RC2-CBC-Parameter", function(asn12) {
  asn12.seq().obj(asn12.key("rc2ParameterVersion").int().optional(), asn12.key("iv").octstr());
});
var CurvePrivateKey = define("CurvePrivateKey", function(asn12) {
  asn12.octstr();
});
var SubjectPublicKeyInfo = define("SubjectPublicKeyInfo", function(asn12) {
  asn12.seq().obj(asn12.key("algorithm").use(AlgorithmIdentifier), asn12.key("publicKey").bitstr());
});
var getEcFieldSize = function getEcFieldSize2(namedCurve) {
  return (
    // Get the the curve's field size in bytes by extracting the number of bits from it and converting it to bytes
    // Note that the number of bits may not be multiples of 8
    Math.floor((Number(namedCurve.match(/\d+/)[0]) + 7) / 8)
  );
};
var decodeEcPoint = function decodeEcPoint2(namedCurve, publicKey) {
  var fieldSizeBytes = getEcFieldSize(namedCurve);
  if (publicKey[0] !== 4) {
    throw new UnsupportedAlgorithmError("Only uncompressed EC points are supported");
  }
  if (publicKey.length !== fieldSizeBytes * 2 + 1) {
    throw new UnsupportedAlgorithmError("Expecting EC public key to have length ".concat(fieldSizeBytes * 2 - 1));
  }
  return { x: publicKey.slice(1, fieldSizeBytes + 1), y: publicKey.slice(fieldSizeBytes + 1) };
};
var encodeEcPoint = function encodeEcPoint2(namedCurve, x2, y3) {
  var fieldSizeBytes = getEcFieldSize(namedCurve);
  if (!y3) {
    throw new UnsupportedAlgorithmError("Only uncompressed EC points are supported (y must be specified)");
  }
  if (!x2 || x2.length !== fieldSizeBytes || !y3 || y3.length !== fieldSizeBytes) {
    throw new UnsupportedAlgorithmError("Expecting x & y points to have length ".concat(fieldSizeBytes, " bytes"));
  }
  return new Uint8Array([4].concat(_toConsumableArray(x2), _toConsumableArray(y3)));
};
var validateEcD = function validateEcD2(namedCurve, d2) {
  var fieldSizeBytes = getEcFieldSize(namedCurve);
  if (!d2 || d2.length < fieldSizeBytes) {
    throw new UnsupportedAlgorithmError("Expecting d length to be >= ".concat(fieldSizeBytes, " bytes"));
  }
  return d2;
};
var KEY_TYPES = {
  // RSA key types
  "rsa-encryption": "rsa",
  "md2-with-rsa-encryption": "rsa",
  "md4-with-rsa-encryption": "rsa",
  "md5-with-rsa-encryption": "rsa",
  "sha1-with-rsa-encryption": "rsa",
  "sha224-with-rsa-encryption": "rsa",
  "sha256-with-rsa-encryption": "rsa",
  "sha384-with-rsa-encryption": "rsa",
  "sha512-with-rsa-encryption": "rsa",
  "sha512-224-with-rsa-encryption": "rsa",
  "sha512-256-with-rsa-encryption": "rsa",
  "rsaes-oaep": "rsa",
  "rsassa-pss": "rsa",
  // EC key types
  "ec-public-key": "ec",
  "ec-dh": "ec",
  "ec-mqv": "ec",
  // ED25519 key types
  ed25519: "ed25519"
};
var KEY_ALIASES = { rsa: { id: "rsa-encryption" }, ec: { id: "ec-public-key" } };
var SUPPORTED_KEY_TYPES = { private: ["rsa", "ec"], public: ["rsa"] };
var decomposeRsaPrivateKey = function decomposeRsaPrivateKey2(rsaPrivateKeyAsn1) {
  var _decodeAsn = decodeAsn1(rsaPrivateKeyAsn1, RsaPrivateKey$1), version2 = _decodeAsn.version, keyData = _objectWithoutProperties(_decodeAsn, _excluded);
  return { keyAlgorithm: { id: "rsa-encryption" }, keyData };
};
var composeRsaPrivateKey = function composeRsaPrivateKey2(keyAlgorithm, keyData) {
  var otherPrimeInfos = keyData.otherPrimeInfos;
  var hasMultiplePrimes = otherPrimeInfos && otherPrimeInfos.length > 0;
  var rsaPrivateKey = _objectSpread(_objectSpread({}, keyData), {}, { version: hasMultiplePrimes ? 1 : 0, otherPrimeInfos: hasMultiplePrimes ? otherPrimeInfos : void 0 });
  return encodeAsn1(rsaPrivateKey, RsaPrivateKey$1);
};
var decomposeRsaPublicKey = function decomposeRsaPublicKey2(rsaPublicKeyAsn1) {
  var _decodeAsn2 = decodeAsn1(rsaPublicKeyAsn1, RsaPublicKey$1), version2 = _decodeAsn2.version, keyData = _objectWithoutProperties(_decodeAsn2, _excluded2);
  return { keyAlgorithm: { id: "rsa-encryption" }, keyData };
};
var composeRsaPublicKey = function composeRsaPublicKey2(keyAlgorithm, keyData) {
  return encodeAsn1(keyData, RsaPublicKey$1);
};
var decomposeEcPrivateKey = function decomposeEcPrivateKey2(ecPrivateKeyAsn1) {
  var ecPrivateKey = decodeAsn1(ecPrivateKeyAsn1, EcPrivateKey);
  if (!ecPrivateKey.parameters) {
    throw new UnsupportedAlgorithmError("Missing parameters from ECPrivateKey");
  }
  if (ecPrivateKey.parameters.type !== "namedCurve") {
    throw new UnsupportedAlgorithmError("Only EC named curves are supported");
  }
  if (!ecPrivateKey.publicKey) {
    throw new UnsupportedAlgorithmError("Missing publicKey from ECPrivateKey");
  }
  var namedCurve = OIDS[ecPrivateKey.parameters.value];
  if (!namedCurve) {
    throw new UnsupportedAlgorithmError("Unsupported named curve OID '".concat(ecPrivateKey.parameters.value, "'"));
  }
  var _decodeEcPoint = decodeEcPoint(namedCurve, ecPrivateKey.publicKey.data), x2 = _decodeEcPoint.x, y3 = _decodeEcPoint.y;
  return { keyAlgorithm: { id: "ec-public-key", namedCurve }, keyData: { d: ecPrivateKey.privateKey, x: x2, y: y3 } };
};
var composeEcPrivateKey = function composeEcPrivateKey2(keyAlgorithm, keyData) {
  var namedCurveOid = FLIPPED_OIDS[keyAlgorithm.namedCurve];
  if (!namedCurveOid) {
    throw new UnsupportedAlgorithmError("Unsupported named curve '".concat(keyAlgorithm.namedCurve, "'"));
  }
  var privateKey = validateEcD(keyAlgorithm.namedCurve, keyData.d);
  var publicKey = encodeEcPoint(keyAlgorithm.namedCurve, keyData.x, keyData.y);
  var ecPrivateKey = { version: 1, privateKey, parameters: { type: "namedCurve", value: namedCurveOid }, publicKey: { unused: 0, data: publicKey } };
  return encodeAsn1(ecPrivateKey, EcPrivateKey);
};
var decomposeRawPrivateKey = function decomposeRawPrivateKey2(keyType, privateKeyAsn1) {
  switch (keyType) {
    case "rsa":
      return decomposeRsaPrivateKey(privateKeyAsn1);
    case "ec":
      return decomposeEcPrivateKey(privateKeyAsn1);
    default:
      throw new UnsupportedAlgorithmError("Unsupported key type '".concat(keyType, "'"));
  }
};
var composeRawPrivateKey = function composeRawPrivateKey2(keyAlgorithm, keyData) {
  var keyType = KEY_TYPES[keyAlgorithm.id];
  switch (keyType) {
    case "rsa":
      return composeRsaPrivateKey(keyAlgorithm, keyData);
    case "ec":
      return composeEcPrivateKey(keyAlgorithm, keyData);
    default:
      throw new UnsupportedAlgorithmError("Unsupported key algorithm id '".concat(keyAlgorithm.id, "'"));
  }
};
var decomposeRawPublicKey = function decomposeRawPublicKey2(keyType, publicKeyAsn1) {
  switch (keyType) {
    case "rsa":
      return decomposeRsaPublicKey(publicKeyAsn1);
    default:
      throw new UnsupportedAlgorithmError("Unsupported key type '".concat(keyType, "'"));
  }
};
var composeRawPublicKey = function composeRawPublicKey2(keyAlgorithm, keyData) {
  var keyType = KEY_TYPES[keyAlgorithm.id];
  switch (keyType) {
    case "rsa":
      return composeRsaPublicKey(keyAlgorithm, keyData);
    default:
      throw new UnsupportedAlgorithmError("Unsupported key algorithm id '".concat(keyAlgorithm.id, "'"));
  }
};
var decomposePrivateKey$5 = function decomposePrivateKey$52(rsaPrivateKeyAsn1) {
  var decomposedRsaKey;
  try {
    decomposedRsaKey = decomposeRsaPrivateKey(rsaPrivateKeyAsn1);
  } catch (err) {
    err.invalidInputKey = err instanceof DecodeAsn1FailedError;
    throw err;
  }
  var _decomposedRsaKey = decomposedRsaKey, keyAlgorithm = _decomposedRsaKey.keyAlgorithm, keyData = _decomposedRsaKey.keyData;
  return { format: "pkcs1-der", encryptionAlgorithm: null, keyAlgorithm, keyData };
};
var composePrivateKey$6 = function composePrivateKey$62(_ref38) {
  var keyAlgorithm = _ref38.keyAlgorithm, keyData = _ref38.keyData, encryptionAlgorithm = _ref38.encryptionAlgorithm;
  var keyType = KEY_TYPES[keyAlgorithm.id];
  if (keyType !== "rsa") {
    throw new UnsupportedAlgorithmError("The key algorithm id for PKCS1 must be one of RSA's");
  }
  if (encryptionAlgorithm) {
    throw new UnsupportedAlgorithmError("The PKCS1 DER format does not support encryption");
  }
  return composeRsaPrivateKey(keyAlgorithm, keyData);
};
var pkcs1Der = Object.freeze(Object.defineProperty({ __proto__: null, composePrivateKey: composePrivateKey$6, decomposePrivateKey: decomposePrivateKey$5 }, Symbol.toStringTag, { value: "Module" }));
var util$c = { exports: {} };
var forge$R = {
  // default options
  options: { usePureJavaScript: false }
};
var api$2 = {};
var baseN$3 = api$2;
var _reverseAlphabets$1 = {};
api$2.encode = function(input, alphabet2, maxline) {
  if (typeof alphabet2 !== "string") {
    throw new TypeError('"alphabet" must be a string.');
  }
  if (maxline !== void 0 && typeof maxline !== "number") {
    throw new TypeError('"maxline" must be a number.');
  }
  var output = "";
  if (!(input instanceof Uint8Array)) {
    output = _encodeWithByteBuffer$1(input, alphabet2);
  } else {
    var i2 = 0;
    var base3 = alphabet2.length;
    var first = alphabet2.charAt(0);
    var digits = [0];
    for (i2 = 0; i2 < input.length; ++i2) {
      for (var j3 = 0, carry = input[i2]; j3 < digits.length; ++j3) {
        carry += digits[j3] << 8;
        digits[j3] = carry % base3;
        carry = carry / base3 | 0;
      }
      while (carry > 0) {
        digits.push(carry % base3);
        carry = carry / base3 | 0;
      }
    }
    for (i2 = 0; input[i2] === 0 && i2 < input.length - 1; ++i2) {
      output += first;
    }
    for (i2 = digits.length - 1; i2 >= 0; --i2) {
      output += alphabet2[digits[i2]];
    }
  }
  if (maxline) {
    var regex = new RegExp(".{1," + maxline + "}", "g");
    output = output.match(regex).join("\r\n");
  }
  return output;
};
api$2.decode = function(input, alphabet2) {
  if (typeof input !== "string") {
    throw new TypeError('"input" must be a string.');
  }
  if (typeof alphabet2 !== "string") {
    throw new TypeError('"alphabet" must be a string.');
  }
  var table = _reverseAlphabets$1[alphabet2];
  if (!table) {
    table = _reverseAlphabets$1[alphabet2] = [];
    for (var i2 = 0; i2 < alphabet2.length; ++i2) {
      table[alphabet2.charCodeAt(i2)] = i2;
    }
  }
  input = input.replace(/\s/g, "");
  var base3 = alphabet2.length;
  var first = alphabet2.charAt(0);
  var bytes = [0];
  for (var i2 = 0; i2 < input.length; i2++) {
    var value = table[input.charCodeAt(i2)];
    if (value === void 0) {
      return;
    }
    for (var j3 = 0, carry = value; j3 < bytes.length; ++j3) {
      carry += bytes[j3] * base3;
      bytes[j3] = carry & 255;
      carry >>= 8;
    }
    while (carry > 0) {
      bytes.push(carry & 255);
      carry >>= 8;
    }
  }
  for (var k3 = 0; input[k3] === first && k3 < input.length - 1; ++k3) {
    bytes.push(0);
  }
  if (typeof Buffer !== "undefined") {
    return Buffer.from(bytes.reverse());
  }
  return new Uint8Array(bytes.reverse());
};
function _encodeWithByteBuffer$1(input, alphabet2) {
  var i2 = 0;
  var base3 = alphabet2.length;
  var first = alphabet2.charAt(0);
  var digits = [0];
  for (i2 = 0; i2 < input.length(); ++i2) {
    for (var j3 = 0, carry = input.at(i2); j3 < digits.length; ++j3) {
      carry += digits[j3] << 8;
      digits[j3] = carry % base3;
      carry = carry / base3 | 0;
    }
    while (carry > 0) {
      digits.push(carry % base3);
      carry = carry / base3 | 0;
    }
  }
  var output = "";
  for (i2 = 0; input.at(i2) === 0 && i2 < input.length() - 1; ++i2) {
    output += first;
  }
  for (i2 = digits.length - 1; i2 >= 0; --i2) {
    output += alphabet2[digits[i2]];
  }
  return output;
}
var forge$Q = forge$R;
var baseN$2 = baseN$3;
var util$a = util$c.exports = forge$Q.util = forge$Q.util || {};
(function() {
  if (typeof process !== "undefined" && process.nextTick && !process.browser) {
    util$a.nextTick = process.nextTick;
    if (typeof setImmediate === "function") {
      util$a.setImmediate = setImmediate;
    } else {
      util$a.setImmediate = util$a.nextTick;
    }
    return;
  }
  if (typeof setImmediate === "function") {
    util$a.setImmediate = function() {
      return setImmediate.apply(void 0, arguments);
    };
    util$a.nextTick = function(callback) {
      return setImmediate(callback);
    };
    return;
  }
  util$a.setImmediate = function(callback) {
    setTimeout(callback, 0);
  };
  if (typeof window !== "undefined" && typeof window.postMessage === "function") {
    let handler = function(event) {
      if (event.source === window && event.data === msg) {
        event.stopPropagation();
        var copy = callbacks.slice();
        callbacks.length = 0;
        copy.forEach(function(callback) {
          callback();
        });
      }
    };
    var msg = "forge.setImmediate";
    var callbacks = [];
    util$a.setImmediate = function(callback) {
      callbacks.push(callback);
      if (callbacks.length === 1) {
        window.postMessage(msg, "*");
      }
    };
    window.addEventListener("message", handler, true);
  }
  if (typeof MutationObserver !== "undefined") {
    var now = Date.now();
    var attr = true;
    var div = document.createElement("div");
    var callbacks = [];
    new MutationObserver(function() {
      var copy = callbacks.slice();
      callbacks.length = 0;
      copy.forEach(function(callback) {
        callback();
      });
    }).observe(div, { attributes: true });
    var oldSetImmediate = util$a.setImmediate;
    util$a.setImmediate = function(callback) {
      if (Date.now() - now > 15) {
        now = Date.now();
        oldSetImmediate(callback);
      } else {
        callbacks.push(callback);
        if (callbacks.length === 1) {
          div.setAttribute("a", attr = !attr);
        }
      }
    };
  }
  util$a.nextTick = util$a.setImmediate;
})();
util$a.isNodejs = typeof process !== "undefined" && process.versions && process.versions.node;
util$a.globalScope = function() {
  if (util$a.isNodejs) {
    return commonjsGlobal;
  }
  return typeof self === "undefined" ? window : self;
}();
util$a.isArray = Array.isArray || function(x2) {
  return Object.prototype.toString.call(x2) === "[object Array]";
};
util$a.isArrayBuffer = function(x2) {
  return typeof ArrayBuffer !== "undefined" && x2 instanceof ArrayBuffer;
};
util$a.isArrayBufferView = function(x2) {
  return x2 && util$a.isArrayBuffer(x2.buffer) && x2.byteLength !== void 0;
};
function _checkBitsParam$1(n2) {
  if (!(n2 === 8 || n2 === 16 || n2 === 24 || n2 === 32)) {
    throw new Error("Only 8, 16, 24, or 32 bits supported: " + n2);
  }
}
util$a.ByteBuffer = ByteStringBuffer$1;
function ByteStringBuffer$1(b3) {
  this.data = "";
  this.read = 0;
  if (typeof b3 === "string") {
    this.data = b3;
  } else if (util$a.isArrayBuffer(b3) || util$a.isArrayBufferView(b3)) {
    if (typeof Buffer !== "undefined" && b3 instanceof Buffer) {
      this.data = b3.toString("binary");
    } else {
      var arr = new Uint8Array(b3);
      try {
        this.data = String.fromCharCode.apply(null, arr);
      } catch (e2) {
        for (var i2 = 0; i2 < arr.length; ++i2) {
          this.putByte(arr[i2]);
        }
      }
    }
  } else if (b3 instanceof ByteStringBuffer$1 || _typeof(b3) === "object" && typeof b3.data === "string" && typeof b3.read === "number") {
    this.data = b3.data;
    this.read = b3.read;
  }
  this._constructedStringLength = 0;
}
util$a.ByteStringBuffer = ByteStringBuffer$1;
var _MAX_CONSTRUCTED_STRING_LENGTH$1 = 4096;
util$a.ByteStringBuffer.prototype._optimizeConstructedString = function(x2) {
  this._constructedStringLength += x2;
  if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH$1) {
    this.data.substr(0, 1);
    this._constructedStringLength = 0;
  }
};
util$a.ByteStringBuffer.prototype.length = function() {
  return this.data.length - this.read;
};
util$a.ByteStringBuffer.prototype.isEmpty = function() {
  return this.length() <= 0;
};
util$a.ByteStringBuffer.prototype.putByte = function(b3) {
  return this.putBytes(String.fromCharCode(b3));
};
util$a.ByteStringBuffer.prototype.fillWithByte = function(b3, n2) {
  b3 = String.fromCharCode(b3);
  var d2 = this.data;
  while (n2 > 0) {
    if (n2 & 1) {
      d2 += b3;
    }
    n2 >>>= 1;
    if (n2 > 0) {
      b3 += b3;
    }
  }
  this.data = d2;
  this._optimizeConstructedString(n2);
  return this;
};
util$a.ByteStringBuffer.prototype.putBytes = function(bytes) {
  this.data += bytes;
  this._optimizeConstructedString(bytes.length);
  return this;
};
util$a.ByteStringBuffer.prototype.putString = function(str) {
  return this.putBytes(util$a.encodeUtf8(str));
};
util$a.ByteStringBuffer.prototype.putInt16 = function(i2) {
  return this.putBytes(String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255));
};
util$a.ByteStringBuffer.prototype.putInt24 = function(i2) {
  return this.putBytes(String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255));
};
util$a.ByteStringBuffer.prototype.putInt32 = function(i2) {
  return this.putBytes(String.fromCharCode(i2 >> 24 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255));
};
util$a.ByteStringBuffer.prototype.putInt16Le = function(i2) {
  return this.putBytes(String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255));
};
util$a.ByteStringBuffer.prototype.putInt24Le = function(i2) {
  return this.putBytes(String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 >> 16 & 255));
};
util$a.ByteStringBuffer.prototype.putInt32Le = function(i2) {
  return this.putBytes(String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 24 & 255));
};
util$a.ByteStringBuffer.prototype.putInt = function(i2, n2) {
  _checkBitsParam$1(n2);
  var bytes = "";
  do {
    n2 -= 8;
    bytes += String.fromCharCode(i2 >> n2 & 255);
  } while (n2 > 0);
  return this.putBytes(bytes);
};
util$a.ByteStringBuffer.prototype.putSignedInt = function(i2, n2) {
  if (i2 < 0) {
    i2 += 2 << n2 - 1;
  }
  return this.putInt(i2, n2);
};
util$a.ByteStringBuffer.prototype.putBuffer = function(buffer2) {
  return this.putBytes(buffer2.getBytes());
};
util$a.ByteStringBuffer.prototype.getByte = function() {
  return this.data.charCodeAt(this.read++);
};
util$a.ByteStringBuffer.prototype.getInt16 = function() {
  var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
  this.read += 2;
  return rval;
};
util$a.ByteStringBuffer.prototype.getInt24 = function() {
  var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
  this.read += 3;
  return rval;
};
util$a.ByteStringBuffer.prototype.getInt32 = function() {
  var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
  this.read += 4;
  return rval;
};
util$a.ByteStringBuffer.prototype.getInt16Le = function() {
  var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
  this.read += 2;
  return rval;
};
util$a.ByteStringBuffer.prototype.getInt24Le = function() {
  var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
  this.read += 3;
  return rval;
};
util$a.ByteStringBuffer.prototype.getInt32Le = function() {
  var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
  this.read += 4;
  return rval;
};
util$a.ByteStringBuffer.prototype.getInt = function(n2) {
  _checkBitsParam$1(n2);
  var rval = 0;
  do {
    rval = (rval << 8) + this.data.charCodeAt(this.read++);
    n2 -= 8;
  } while (n2 > 0);
  return rval;
};
util$a.ByteStringBuffer.prototype.getSignedInt = function(n2) {
  var x2 = this.getInt(n2);
  var max = 2 << n2 - 2;
  if (x2 >= max) {
    x2 -= max << 1;
  }
  return x2;
};
util$a.ByteStringBuffer.prototype.getBytes = function(count) {
  var rval;
  if (count) {
    count = Math.min(this.length(), count);
    rval = this.data.slice(this.read, this.read + count);
    this.read += count;
  } else if (count === 0) {
    rval = "";
  } else {
    rval = this.read === 0 ? this.data : this.data.slice(this.read);
    this.clear();
  }
  return rval;
};
util$a.ByteStringBuffer.prototype.bytes = function(count) {
  return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
};
util$a.ByteStringBuffer.prototype.at = function(i2) {
  return this.data.charCodeAt(this.read + i2);
};
util$a.ByteStringBuffer.prototype.setAt = function(i2, b3) {
  this.data = this.data.substr(0, this.read + i2) + String.fromCharCode(b3) + this.data.substr(this.read + i2 + 1);
  return this;
};
util$a.ByteStringBuffer.prototype.last = function() {
  return this.data.charCodeAt(this.data.length - 1);
};
util$a.ByteStringBuffer.prototype.copy = function() {
  var c3 = util$a.createBuffer(this.data);
  c3.read = this.read;
  return c3;
};
util$a.ByteStringBuffer.prototype.compact = function() {
  if (this.read > 0) {
    this.data = this.data.slice(this.read);
    this.read = 0;
  }
  return this;
};
util$a.ByteStringBuffer.prototype.clear = function() {
  this.data = "";
  this.read = 0;
  return this;
};
util$a.ByteStringBuffer.prototype.truncate = function(count) {
  var len2 = Math.max(0, this.length() - count);
  this.data = this.data.substr(this.read, len2);
  this.read = 0;
  return this;
};
util$a.ByteStringBuffer.prototype.toHex = function() {
  var rval = "";
  for (var i2 = this.read; i2 < this.data.length; ++i2) {
    var b3 = this.data.charCodeAt(i2);
    if (b3 < 16) {
      rval += "0";
    }
    rval += b3.toString(16);
  }
  return rval;
};
util$a.ByteStringBuffer.prototype.toString = function() {
  return util$a.decodeUtf8(this.bytes());
};
function DataBuffer$1(b3, options) {
  options = options || {};
  this.read = options.readOffset || 0;
  this.growSize = options.growSize || 1024;
  var isArrayBuffer2 = util$a.isArrayBuffer(b3);
  var isArrayBufferView2 = util$a.isArrayBufferView(b3);
  if (isArrayBuffer2 || isArrayBufferView2) {
    if (isArrayBuffer2) {
      this.data = new DataView(b3);
    } else {
      this.data = new DataView(b3.buffer, b3.byteOffset, b3.byteLength);
    }
    this.write = "writeOffset" in options ? options.writeOffset : this.data.byteLength;
    return;
  }
  this.data = new DataView(new ArrayBuffer(0));
  this.write = 0;
  if (b3 !== null && b3 !== void 0) {
    this.putBytes(b3);
  }
  if ("writeOffset" in options) {
    this.write = options.writeOffset;
  }
}
util$a.DataBuffer = DataBuffer$1;
util$a.DataBuffer.prototype.length = function() {
  return this.write - this.read;
};
util$a.DataBuffer.prototype.isEmpty = function() {
  return this.length() <= 0;
};
util$a.DataBuffer.prototype.accommodate = function(amount, growSize) {
  if (this.length() >= amount) {
    return this;
  }
  growSize = Math.max(growSize || this.growSize, amount);
  var src2 = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength);
  var dst = new Uint8Array(this.length() + growSize);
  dst.set(src2);
  this.data = new DataView(dst.buffer);
  return this;
};
util$a.DataBuffer.prototype.putByte = function(b3) {
  this.accommodate(1);
  this.data.setUint8(this.write++, b3);
  return this;
};
util$a.DataBuffer.prototype.fillWithByte = function(b3, n2) {
  this.accommodate(n2);
  for (var i2 = 0; i2 < n2; ++i2) {
    this.data.setUint8(b3);
  }
  return this;
};
util$a.DataBuffer.prototype.putBytes = function(bytes, encoding) {
  if (util$a.isArrayBufferView(bytes)) {
    var src2 = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    var len2 = src2.byteLength - src2.byteOffset;
    this.accommodate(len2);
    var dst = new Uint8Array(this.data.buffer, this.write);
    dst.set(src2);
    this.write += len2;
    return this;
  }
  if (util$a.isArrayBuffer(bytes)) {
    var src2 = new Uint8Array(bytes);
    this.accommodate(src2.byteLength);
    var dst = new Uint8Array(this.data.buffer);
    dst.set(src2, this.write);
    this.write += src2.byteLength;
    return this;
  }
  if (bytes instanceof util$a.DataBuffer || _typeof(bytes) === "object" && typeof bytes.read === "number" && typeof bytes.write === "number" && util$a.isArrayBufferView(bytes.data)) {
    var src2 = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());
    this.accommodate(src2.byteLength);
    var dst = new Uint8Array(bytes.data.byteLength, this.write);
    dst.set(src2);
    this.write += src2.byteLength;
    return this;
  }
  if (bytes instanceof util$a.ByteStringBuffer) {
    bytes = bytes.data;
    encoding = "binary";
  }
  encoding = encoding || "binary";
  if (typeof bytes === "string") {
    var view;
    if (encoding === "hex") {
      this.accommodate(Math.ceil(bytes.length / 2));
      view = new Uint8Array(this.data.buffer, this.write);
      this.write += util$a.binary.hex.decode(bytes, view, this.write);
      return this;
    }
    if (encoding === "base64") {
      this.accommodate(Math.ceil(bytes.length / 4) * 3);
      view = new Uint8Array(this.data.buffer, this.write);
      this.write += util$a.binary.base64.decode(bytes, view, this.write);
      return this;
    }
    if (encoding === "utf8") {
      bytes = util$a.encodeUtf8(bytes);
      encoding = "binary";
    }
    if (encoding === "binary" || encoding === "raw") {
      this.accommodate(bytes.length);
      view = new Uint8Array(this.data.buffer, this.write);
      this.write += util$a.binary.raw.decode(view);
      return this;
    }
    if (encoding === "utf16") {
      this.accommodate(bytes.length * 2);
      view = new Uint16Array(this.data.buffer, this.write);
      this.write += util$a.text.utf16.encode(view);
      return this;
    }
    throw new Error("Invalid encoding: " + encoding);
  }
  throw Error("Invalid parameter: " + bytes);
};
util$a.DataBuffer.prototype.putBuffer = function(buffer2) {
  this.putBytes(buffer2);
  buffer2.clear();
  return this;
};
util$a.DataBuffer.prototype.putString = function(str) {
  return this.putBytes(str, "utf16");
};
util$a.DataBuffer.prototype.putInt16 = function(i2) {
  this.accommodate(2);
  this.data.setInt16(this.write, i2);
  this.write += 2;
  return this;
};
util$a.DataBuffer.prototype.putInt24 = function(i2) {
  this.accommodate(3);
  this.data.setInt16(this.write, i2 >> 8 & 65535);
  this.data.setInt8(this.write, i2 >> 16 & 255);
  this.write += 3;
  return this;
};
util$a.DataBuffer.prototype.putInt32 = function(i2) {
  this.accommodate(4);
  this.data.setInt32(this.write, i2);
  this.write += 4;
  return this;
};
util$a.DataBuffer.prototype.putInt16Le = function(i2) {
  this.accommodate(2);
  this.data.setInt16(this.write, i2, true);
  this.write += 2;
  return this;
};
util$a.DataBuffer.prototype.putInt24Le = function(i2) {
  this.accommodate(3);
  this.data.setInt8(this.write, i2 >> 16 & 255);
  this.data.setInt16(this.write, i2 >> 8 & 65535, true);
  this.write += 3;
  return this;
};
util$a.DataBuffer.prototype.putInt32Le = function(i2) {
  this.accommodate(4);
  this.data.setInt32(this.write, i2, true);
  this.write += 4;
  return this;
};
util$a.DataBuffer.prototype.putInt = function(i2, n2) {
  _checkBitsParam$1(n2);
  this.accommodate(n2 / 8);
  do {
    n2 -= 8;
    this.data.setInt8(this.write++, i2 >> n2 & 255);
  } while (n2 > 0);
  return this;
};
util$a.DataBuffer.prototype.putSignedInt = function(i2, n2) {
  _checkBitsParam$1(n2);
  this.accommodate(n2 / 8);
  if (i2 < 0) {
    i2 += 2 << n2 - 1;
  }
  return this.putInt(i2, n2);
};
util$a.DataBuffer.prototype.getByte = function() {
  return this.data.getInt8(this.read++);
};
util$a.DataBuffer.prototype.getInt16 = function() {
  var rval = this.data.getInt16(this.read);
  this.read += 2;
  return rval;
};
util$a.DataBuffer.prototype.getInt24 = function() {
  var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
  this.read += 3;
  return rval;
};
util$a.DataBuffer.prototype.getInt32 = function() {
  var rval = this.data.getInt32(this.read);
  this.read += 4;
  return rval;
};
util$a.DataBuffer.prototype.getInt16Le = function() {
  var rval = this.data.getInt16(this.read, true);
  this.read += 2;
  return rval;
};
util$a.DataBuffer.prototype.getInt24Le = function() {
  var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
  this.read += 3;
  return rval;
};
util$a.DataBuffer.prototype.getInt32Le = function() {
  var rval = this.data.getInt32(this.read, true);
  this.read += 4;
  return rval;
};
util$a.DataBuffer.prototype.getInt = function(n2) {
  _checkBitsParam$1(n2);
  var rval = 0;
  do {
    rval = (rval << 8) + this.data.getInt8(this.read++);
    n2 -= 8;
  } while (n2 > 0);
  return rval;
};
util$a.DataBuffer.prototype.getSignedInt = function(n2) {
  var x2 = this.getInt(n2);
  var max = 2 << n2 - 2;
  if (x2 >= max) {
    x2 -= max << 1;
  }
  return x2;
};
util$a.DataBuffer.prototype.getBytes = function(count) {
  var rval;
  if (count) {
    count = Math.min(this.length(), count);
    rval = this.data.slice(this.read, this.read + count);
    this.read += count;
  } else if (count === 0) {
    rval = "";
  } else {
    rval = this.read === 0 ? this.data : this.data.slice(this.read);
    this.clear();
  }
  return rval;
};
util$a.DataBuffer.prototype.bytes = function(count) {
  return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
};
util$a.DataBuffer.prototype.at = function(i2) {
  return this.data.getUint8(this.read + i2);
};
util$a.DataBuffer.prototype.setAt = function(i2, b3) {
  this.data.setUint8(i2, b3);
  return this;
};
util$a.DataBuffer.prototype.last = function() {
  return this.data.getUint8(this.write - 1);
};
util$a.DataBuffer.prototype.copy = function() {
  return new util$a.DataBuffer(this);
};
util$a.DataBuffer.prototype.compact = function() {
  if (this.read > 0) {
    var src2 = new Uint8Array(this.data.buffer, this.read);
    var dst = new Uint8Array(src2.byteLength);
    dst.set(src2);
    this.data = new DataView(dst);
    this.write -= this.read;
    this.read = 0;
  }
  return this;
};
util$a.DataBuffer.prototype.clear = function() {
  this.data = new DataView(new ArrayBuffer(0));
  this.read = this.write = 0;
  return this;
};
util$a.DataBuffer.prototype.truncate = function(count) {
  this.write = Math.max(0, this.length() - count);
  this.read = Math.min(this.read, this.write);
  return this;
};
util$a.DataBuffer.prototype.toHex = function() {
  var rval = "";
  for (var i2 = this.read; i2 < this.data.byteLength; ++i2) {
    var b3 = this.data.getUint8(i2);
    if (b3 < 16) {
      rval += "0";
    }
    rval += b3.toString(16);
  }
  return rval;
};
util$a.DataBuffer.prototype.toString = function(encoding) {
  var view = new Uint8Array(this.data, this.read, this.length());
  encoding = encoding || "utf8";
  if (encoding === "binary" || encoding === "raw") {
    return util$a.binary.raw.encode(view);
  }
  if (encoding === "hex") {
    return util$a.binary.hex.encode(view);
  }
  if (encoding === "base64") {
    return util$a.binary.base64.encode(view);
  }
  if (encoding === "utf8") {
    return util$a.text.utf8.decode(view);
  }
  if (encoding === "utf16") {
    return util$a.text.utf16.decode(view);
  }
  throw new Error("Invalid encoding: " + encoding);
};
util$a.createBuffer = function(input, encoding) {
  encoding = encoding || "raw";
  if (input !== void 0 && encoding === "utf8") {
    input = util$a.encodeUtf8(input);
  }
  return new util$a.ByteBuffer(input);
};
util$a.fillString = function(c3, n2) {
  var s2 = "";
  while (n2 > 0) {
    if (n2 & 1) {
      s2 += c3;
    }
    n2 >>>= 1;
    if (n2 > 0) {
      c3 += c3;
    }
  }
  return s2;
};
util$a.xorBytes = function(s1, s2, n2) {
  var s3 = "";
  var b3 = "";
  var t2 = "";
  var i2 = 0;
  var c3 = 0;
  for (; n2 > 0; --n2, ++i2) {
    b3 = s1.charCodeAt(i2) ^ s2.charCodeAt(i2);
    if (c3 >= 10) {
      s3 += t2;
      t2 = "";
      c3 = 0;
    }
    t2 += String.fromCharCode(b3);
    ++c3;
  }
  s3 += t2;
  return s3;
};
util$a.hexToBytes = function(hex) {
  var rval = "";
  var i2 = 0;
  if (hex.length & true) {
    i2 = 1;
    rval += String.fromCharCode(parseInt(hex[0], 16));
  }
  for (; i2 < hex.length; i2 += 2) {
    rval += String.fromCharCode(parseInt(hex.substr(i2, 2), 16));
  }
  return rval;
};
util$a.bytesToHex = function(bytes) {
  return util$a.createBuffer(bytes).toHex();
};
util$a.int32ToBytes = function(i2) {
  return String.fromCharCode(i2 >> 24 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255);
};
var _base64$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var _base64Idx$1 = [
  /*43 -43 = 0*/
  /*'+',  1,  2,  3,'/' */
  62,
  -1,
  -1,
  -1,
  63,
  /*'0','1','2','3','4','5','6','7','8','9' */
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  /*15, 16, 17,'=', 19, 20, 21 */
  -1,
  -1,
  -1,
  64,
  -1,
  -1,
  -1,
  /*65 - 43 = 22*/
  /*'A','B','C','D','E','F','G','H','I','J','K','L','M', */
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  /*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  /*91 - 43 = 48 */
  /*48, 49, 50, 51, 52, 53 */
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  /*97 - 43 = 54*/
  /*'a','b','c','d','e','f','g','h','i','j','k','l','m' */
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  /*'n','o','p','q','r','s','t','u','v','w','x','y','z' */
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51
];
var _base58$1 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
util$a.encode64 = function(input, maxline) {
  var line = "";
  var output = "";
  var chr1, chr2, chr3;
  var i2 = 0;
  while (i2 < input.length) {
    chr1 = input.charCodeAt(i2++);
    chr2 = input.charCodeAt(i2++);
    chr3 = input.charCodeAt(i2++);
    line += _base64$1.charAt(chr1 >> 2);
    line += _base64$1.charAt((chr1 & 3) << 4 | chr2 >> 4);
    if (isNaN(chr2)) {
      line += "==";
    } else {
      line += _base64$1.charAt((chr2 & 15) << 2 | chr3 >> 6);
      line += isNaN(chr3) ? "=" : _base64$1.charAt(chr3 & 63);
    }
    if (maxline && line.length > maxline) {
      output += line.substr(0, maxline) + "\r\n";
      line = line.substr(maxline);
    }
  }
  output += line;
  return output;
};
util$a.decode64 = function(input) {
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
  var output = "";
  var enc1, enc2, enc3, enc4;
  var i2 = 0;
  while (i2 < input.length) {
    enc1 = _base64Idx$1[input.charCodeAt(i2++) - 43];
    enc2 = _base64Idx$1[input.charCodeAt(i2++) - 43];
    enc3 = _base64Idx$1[input.charCodeAt(i2++) - 43];
    enc4 = _base64Idx$1[input.charCodeAt(i2++) - 43];
    output += String.fromCharCode(enc1 << 2 | enc2 >> 4);
    if (enc3 !== 64) {
      output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);
      if (enc4 !== 64) {
        output += String.fromCharCode((enc3 & 3) << 6 | enc4);
      }
    }
  }
  return output;
};
util$a.encodeUtf8 = function(str) {
  return unescape(encodeURIComponent(str));
};
util$a.decodeUtf8 = function(str) {
  return decodeURIComponent(escape(str));
};
util$a.binary = { raw: {}, hex: {}, base64: {}, base58: {}, baseN: { encode: baseN$2.encode, decode: baseN$2.decode } };
util$a.binary.raw.encode = function(bytes) {
  return String.fromCharCode.apply(null, bytes);
};
util$a.binary.raw.decode = function(str, output, offset) {
  var out = output;
  if (!out) {
    out = new Uint8Array(str.length);
  }
  offset = offset || 0;
  var j3 = offset;
  for (var i2 = 0; i2 < str.length; ++i2) {
    out[j3++] = str.charCodeAt(i2);
  }
  return output ? j3 - offset : out;
};
util$a.binary.hex.encode = util$a.bytesToHex;
util$a.binary.hex.decode = function(hex, output, offset) {
  var out = output;
  if (!out) {
    out = new Uint8Array(Math.ceil(hex.length / 2));
  }
  offset = offset || 0;
  var i2 = 0, j3 = offset;
  if (hex.length & 1) {
    i2 = 1;
    out[j3++] = parseInt(hex[0], 16);
  }
  for (; i2 < hex.length; i2 += 2) {
    out[j3++] = parseInt(hex.substr(i2, 2), 16);
  }
  return output ? j3 - offset : out;
};
util$a.binary.base64.encode = function(input, maxline) {
  var line = "";
  var output = "";
  var chr1, chr2, chr3;
  var i2 = 0;
  while (i2 < input.byteLength) {
    chr1 = input[i2++];
    chr2 = input[i2++];
    chr3 = input[i2++];
    line += _base64$1.charAt(chr1 >> 2);
    line += _base64$1.charAt((chr1 & 3) << 4 | chr2 >> 4);
    if (isNaN(chr2)) {
      line += "==";
    } else {
      line += _base64$1.charAt((chr2 & 15) << 2 | chr3 >> 6);
      line += isNaN(chr3) ? "=" : _base64$1.charAt(chr3 & 63);
    }
    if (maxline && line.length > maxline) {
      output += line.substr(0, maxline) + "\r\n";
      line = line.substr(maxline);
    }
  }
  output += line;
  return output;
};
util$a.binary.base64.decode = function(input, output, offset) {
  var out = output;
  if (!out) {
    out = new Uint8Array(Math.ceil(input.length / 4) * 3);
  }
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
  offset = offset || 0;
  var enc1, enc2, enc3, enc4;
  var i2 = 0, j3 = offset;
  while (i2 < input.length) {
    enc1 = _base64Idx$1[input.charCodeAt(i2++) - 43];
    enc2 = _base64Idx$1[input.charCodeAt(i2++) - 43];
    enc3 = _base64Idx$1[input.charCodeAt(i2++) - 43];
    enc4 = _base64Idx$1[input.charCodeAt(i2++) - 43];
    out[j3++] = enc1 << 2 | enc2 >> 4;
    if (enc3 !== 64) {
      out[j3++] = (enc2 & 15) << 4 | enc3 >> 2;
      if (enc4 !== 64) {
        out[j3++] = (enc3 & 3) << 6 | enc4;
      }
    }
  }
  return output ? j3 - offset : out.subarray(0, j3);
};
util$a.binary.base58.encode = function(input, maxline) {
  return util$a.binary.baseN.encode(input, _base58$1, maxline);
};
util$a.binary.base58.decode = function(input, maxline) {
  return util$a.binary.baseN.decode(input, _base58$1, maxline);
};
util$a.text = { utf8: {}, utf16: {} };
util$a.text.utf8.encode = function(str, output, offset) {
  str = util$a.encodeUtf8(str);
  var out = output;
  if (!out) {
    out = new Uint8Array(str.length);
  }
  offset = offset || 0;
  var j3 = offset;
  for (var i2 = 0; i2 < str.length; ++i2) {
    out[j3++] = str.charCodeAt(i2);
  }
  return output ? j3 - offset : out;
};
util$a.text.utf8.decode = function(bytes) {
  return util$a.decodeUtf8(String.fromCharCode.apply(null, bytes));
};
util$a.text.utf16.encode = function(str, output, offset) {
  var out = output;
  if (!out) {
    out = new Uint8Array(str.length * 2);
  }
  var view = new Uint16Array(out.buffer);
  offset = offset || 0;
  var j3 = offset;
  var k3 = offset;
  for (var i2 = 0; i2 < str.length; ++i2) {
    view[k3++] = str.charCodeAt(i2);
    j3 += 2;
  }
  return output ? j3 - offset : out;
};
util$a.text.utf16.decode = function(bytes) {
  return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));
};
util$a.deflate = function(api2, bytes, raw2) {
  bytes = util$a.decode64(api2.deflate(util$a.encode64(bytes)).rval);
  if (raw2) {
    var start = 2;
    var flg = bytes.charCodeAt(1);
    if (flg & 32) {
      start = 6;
    }
    bytes = bytes.substring(start, bytes.length - 4);
  }
  return bytes;
};
util$a.inflate = function(api2, bytes, raw2) {
  var rval = api2.inflate(util$a.encode64(bytes)).rval;
  return rval === null ? null : util$a.decode64(rval);
};
var _setStorageObject$1 = function _setStorageObject$12(api2, id, obj2) {
  if (!api2) {
    throw new Error("WebStorage not available.");
  }
  var rval;
  if (obj2 === null) {
    rval = api2.removeItem(id);
  } else {
    obj2 = util$a.encode64(JSON.stringify(obj2));
    rval = api2.setItem(id, obj2);
  }
  if (typeof rval !== "undefined" && rval.rval !== true) {
    var error3 = new Error(rval.error.message);
    error3.id = rval.error.id;
    error3.name = rval.error.name;
    throw error3;
  }
};
var _getStorageObject$1 = function _getStorageObject$12(api2, id) {
  if (!api2) {
    throw new Error("WebStorage not available.");
  }
  var rval = api2.getItem(id);
  if (api2.init) {
    if (rval.rval === null) {
      if (rval.error) {
        var error3 = new Error(rval.error.message);
        error3.id = rval.error.id;
        error3.name = rval.error.name;
        throw error3;
      }
      rval = null;
    } else {
      rval = rval.rval;
    }
  }
  if (rval !== null) {
    rval = JSON.parse(util$a.decode64(rval));
  }
  return rval;
};
var _setItem$1 = function _setItem$12(api2, id, key3, data) {
  var obj2 = _getStorageObject$1(api2, id);
  if (obj2 === null) {
    obj2 = {};
  }
  obj2[key3] = data;
  _setStorageObject$1(api2, id, obj2);
};
var _getItem$1 = function _getItem$12(api2, id, key3) {
  var rval = _getStorageObject$1(api2, id);
  if (rval !== null) {
    rval = key3 in rval ? rval[key3] : null;
  }
  return rval;
};
var _removeItem$1 = function _removeItem$12(api2, id, key3) {
  var obj2 = _getStorageObject$1(api2, id);
  if (obj2 !== null && key3 in obj2) {
    delete obj2[key3];
    var empty = true;
    for (var prop in obj2) {
      empty = false;
      break;
    }
    if (empty) {
      obj2 = null;
    }
    _setStorageObject$1(api2, id, obj2);
  }
};
var _clearItems$1 = function _clearItems$12(api2, id) {
  _setStorageObject$1(api2, id, null);
};
var _callStorageFunction$1 = function _callStorageFunction$12(func, args, location2) {
  var rval = null;
  if (typeof location2 === "undefined") {
    location2 = ["web", "flash"];
  }
  var type;
  var done = false;
  var exception = null;
  for (var idx in location2) {
    type = location2[idx];
    try {
      if (type === "flash" || type === "both") {
        if (args[0] === null) {
          throw new Error("Flash local storage not available.");
        }
        rval = func.apply(this, args);
        done = type === "flash";
      }
      if (type === "web" || type === "both") {
        args[0] = localStorage;
        rval = func.apply(this, args);
        done = true;
      }
    } catch (ex) {
      exception = ex;
    }
    if (done) {
      break;
    }
  }
  if (!done) {
    throw exception;
  }
  return rval;
};
util$a.setItem = function(api2, id, key3, data, location2) {
  _callStorageFunction$1(_setItem$1, arguments, location2);
};
util$a.getItem = function(api2, id, key3, location2) {
  return _callStorageFunction$1(_getItem$1, arguments, location2);
};
util$a.removeItem = function(api2, id, key3, location2) {
  _callStorageFunction$1(_removeItem$1, arguments, location2);
};
util$a.clearItems = function(api2, id, location2) {
  _callStorageFunction$1(_clearItems$1, arguments, location2);
};
util$a.parseUrl = function(str) {
  var regex = /^(https?):\/\/([^:&^\/]*):?(\d*)(.*)$/g;
  regex.lastIndex = 0;
  var m2 = regex.exec(str);
  var url = m2 === null ? null : { full: str, scheme: m2[1], host: m2[2], port: m2[3], path: m2[4] };
  if (url) {
    url.fullHost = url.host;
    if (url.port) {
      if (url.port !== 80 && url.scheme === "http") {
        url.fullHost += ":" + url.port;
      } else if (url.port !== 443 && url.scheme === "https") {
        url.fullHost += ":" + url.port;
      }
    } else if (url.scheme === "http") {
      url.port = 80;
    } else if (url.scheme === "https") {
      url.port = 443;
    }
    url.full = url.scheme + "://" + url.fullHost;
  }
  return url;
};
var _queryVariables$1 = null;
util$a.getQueryVariables = function(query) {
  var parse = function parse2(q3) {
    var rval2 = {};
    var kvpairs = q3.split("&");
    for (var i2 = 0; i2 < kvpairs.length; i2++) {
      var pos = kvpairs[i2].indexOf("=");
      var key3;
      var val;
      if (pos > 0) {
        key3 = kvpairs[i2].substring(0, pos);
        val = kvpairs[i2].substring(pos + 1);
      } else {
        key3 = kvpairs[i2];
        val = null;
      }
      if (!(key3 in rval2)) {
        rval2[key3] = [];
      }
      if (!(key3 in Object.prototype) && val !== null) {
        rval2[key3].push(unescape(val));
      }
    }
    return rval2;
  };
  var rval;
  if (typeof query === "undefined") {
    if (_queryVariables$1 === null) {
      if (typeof window !== "undefined" && window.location && window.location.search) {
        _queryVariables$1 = parse(window.location.search.substring(1));
      } else {
        _queryVariables$1 = {};
      }
    }
    rval = _queryVariables$1;
  } else {
    rval = parse(query);
  }
  return rval;
};
util$a.parseFragment = function(fragment) {
  var fp = fragment;
  var fq = "";
  var pos = fragment.indexOf("?");
  if (pos > 0) {
    fp = fragment.substring(0, pos);
    fq = fragment.substring(pos + 1);
  }
  var path2 = fp.split("/");
  if (path2.length > 0 && path2[0] === "") {
    path2.shift();
  }
  var query = fq === "" ? {} : util$a.getQueryVariables(fq);
  return { pathString: fp, queryString: fq, path: path2, query };
};
util$a.makeRequest = function(reqString) {
  var frag = util$a.parseFragment(reqString);
  var req = {
    // full path string
    path: frag.pathString,
    // full query string
    query: frag.queryString,
    /**
    * Get path or element in path.
    *
    * @param i optional path index.
    *
    * @return path or part of path if i provided.
    */
    getPath: function getPath(i2) {
      return typeof i2 === "undefined" ? frag.path : frag.path[i2];
    },
    /**
    * Get query, values for a key, or value for a key index.
    *
    * @param k optional query key.
    * @param i optional query key index.
    *
    * @return query, values for a key, or value for a key index.
    */
    getQuery: function getQuery(k3, i2) {
      var rval;
      if (typeof k3 === "undefined") {
        rval = frag.query;
      } else {
        rval = frag.query[k3];
        if (rval && typeof i2 !== "undefined") {
          rval = rval[i2];
        }
      }
      return rval;
    },
    getQueryLast: function getQueryLast(k3, _default2) {
      var rval;
      var vals = req.getQuery(k3);
      if (vals) {
        rval = vals[vals.length - 1];
      } else {
        rval = _default2;
      }
      return rval;
    }
  };
  return req;
};
util$a.makeLink = function(path2, query, fragment) {
  path2 = jQuery.isArray(path2) ? path2.join("/") : path2;
  var qstr = jQuery.param(query || {});
  fragment = fragment || "";
  return path2 + (qstr.length > 0 ? "?" + qstr : "") + (fragment.length > 0 ? "#" + fragment : "");
};
util$a.setPath = function(object, keys2, value) {
  if (_typeof(object) === "object" && object !== null) {
    var i2 = 0;
    var len2 = keys2.length;
    while (i2 < len2) {
      var next = keys2[i2++];
      if (i2 == len2) {
        object[next] = value;
      } else {
        var hasNext = next in object;
        if (!hasNext || hasNext && _typeof(object[next]) !== "object" || hasNext && object[next] === null) {
          object[next] = {};
        }
        object = object[next];
      }
    }
  }
};
util$a.getPath = function(object, keys2, _default2) {
  var i2 = 0;
  var len2 = keys2.length;
  var hasNext = true;
  while (hasNext && i2 < len2 && _typeof(object) === "object" && object !== null) {
    var next = keys2[i2++];
    hasNext = next in object;
    if (hasNext) {
      object = object[next];
    }
  }
  return hasNext ? object : _default2;
};
util$a.deletePath = function(object, keys2) {
  if (_typeof(object) === "object" && object !== null) {
    var i2 = 0;
    var len2 = keys2.length;
    while (i2 < len2) {
      var next = keys2[i2++];
      if (i2 == len2) {
        delete object[next];
      } else {
        if (!(next in object) || _typeof(object[next]) !== "object" || object[next] === null) {
          break;
        }
        object = object[next];
      }
    }
  }
};
util$a.isEmpty = function(obj2) {
  for (var prop in obj2) {
    if (obj2.hasOwnProperty(prop)) {
      return false;
    }
  }
  return true;
};
util$a.format = function(format) {
  var re = /%./g;
  var match;
  var part;
  var argi = 0;
  var parts = [];
  var last = 0;
  while (match = re.exec(format)) {
    part = format.substring(last, re.lastIndex - 2);
    if (part.length > 0) {
      parts.push(part);
    }
    last = re.lastIndex;
    var code2 = match[0][1];
    switch (code2) {
      case "s":
      case "o":
        if (argi < arguments.length) {
          parts.push(arguments[argi++ + 1]);
        } else {
          parts.push("<?>");
        }
        break;
      case "%":
        parts.push("%");
        break;
      default:
        parts.push("<%" + code2 + "?>");
    }
  }
  parts.push(format.substring(last));
  return parts.join("");
};
util$a.formatNumber = function(number, decimals, dec_point, thousands_sep) {
  var n2 = number, c3 = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
  var d2 = dec_point === void 0 ? "," : dec_point;
  var t2 = thousands_sep === void 0 ? "." : thousands_sep, s2 = n2 < 0 ? "-" : "";
  var i2 = parseInt(n2 = Math.abs(+n2 || 0).toFixed(c3), 10) + "";
  var j3 = i2.length > 3 ? i2.length % 3 : 0;
  return s2 + (j3 ? i2.substr(0, j3) + t2 : "") + i2.substr(j3).replace(/(\d{3})(?=\d)/g, "$1" + t2) + (c3 ? d2 + Math.abs(n2 - i2).toFixed(c3).slice(2) : "");
};
util$a.formatSize = function(size) {
  if (size >= 1073741824) {
    size = util$a.formatNumber(size / 1073741824, 2, ".", "") + " GiB";
  } else if (size >= 1048576) {
    size = util$a.formatNumber(size / 1048576, 2, ".", "") + " MiB";
  } else if (size >= 1024) {
    size = util$a.formatNumber(size / 1024, 0) + " KiB";
  } else {
    size = util$a.formatNumber(size, 0) + " bytes";
  }
  return size;
};
util$a.bytesFromIP = function(ip) {
  if (ip.indexOf(".") !== -1) {
    return util$a.bytesFromIPv4(ip);
  }
  if (ip.indexOf(":") !== -1) {
    return util$a.bytesFromIPv6(ip);
  }
  return null;
};
util$a.bytesFromIPv4 = function(ip) {
  ip = ip.split(".");
  if (ip.length !== 4) {
    return null;
  }
  var b3 = util$a.createBuffer();
  for (var i2 = 0; i2 < ip.length; ++i2) {
    var num = parseInt(ip[i2], 10);
    if (isNaN(num)) {
      return null;
    }
    b3.putByte(num);
  }
  return b3.getBytes();
};
util$a.bytesFromIPv6 = function(ip) {
  var blanks = 0;
  ip = ip.split(":").filter(function(e2) {
    if (e2.length === 0)
      ++blanks;
    return true;
  });
  var zeros = (8 - ip.length + blanks) * 2;
  var b3 = util$a.createBuffer();
  for (var i2 = 0; i2 < 8; ++i2) {
    if (!ip[i2] || ip[i2].length === 0) {
      b3.fillWithByte(0, zeros);
      zeros = 0;
      continue;
    }
    var bytes = util$a.hexToBytes(ip[i2]);
    if (bytes.length < 2) {
      b3.putByte(0);
    }
    b3.putBytes(bytes);
  }
  return b3.getBytes();
};
util$a.bytesToIP = function(bytes) {
  if (bytes.length === 4) {
    return util$a.bytesToIPv4(bytes);
  }
  if (bytes.length === 16) {
    return util$a.bytesToIPv6(bytes);
  }
  return null;
};
util$a.bytesToIPv4 = function(bytes) {
  if (bytes.length !== 4) {
    return null;
  }
  var ip = [];
  for (var i2 = 0; i2 < bytes.length; ++i2) {
    ip.push(bytes.charCodeAt(i2));
  }
  return ip.join(".");
};
util$a.bytesToIPv6 = function(bytes) {
  if (bytes.length !== 16) {
    return null;
  }
  var ip = [];
  var zeroGroups = [];
  var zeroMaxGroup = 0;
  for (var i2 = 0; i2 < bytes.length; i2 += 2) {
    var hex = util$a.bytesToHex(bytes[i2] + bytes[i2 + 1]);
    while (hex[0] === "0" && hex !== "0") {
      hex = hex.substr(1);
    }
    if (hex === "0") {
      var last = zeroGroups[zeroGroups.length - 1];
      var idx = ip.length;
      if (!last || idx !== last.end + 1) {
        zeroGroups.push({ start: idx, end: idx });
      } else {
        last.end = idx;
        if (last.end - last.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) {
          zeroMaxGroup = zeroGroups.length - 1;
        }
      }
    }
    ip.push(hex);
  }
  if (zeroGroups.length > 0) {
    var group = zeroGroups[zeroMaxGroup];
    if (group.end - group.start > 0) {
      ip.splice(group.start, group.end - group.start + 1, "");
      if (group.start === 0) {
        ip.unshift("");
      }
      if (group.end === 7) {
        ip.push("");
      }
    }
  }
  return ip.join(":");
};
util$a.estimateCores = function(options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = {};
  }
  options = options || {};
  if ("cores" in util$a && !options.update) {
    return callback(null, util$a.cores);
  }
  if (typeof navigator !== "undefined" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) {
    util$a.cores = navigator.hardwareConcurrency;
    return callback(null, util$a.cores);
  }
  if (typeof Worker === "undefined") {
    util$a.cores = 1;
    return callback(null, util$a.cores);
  }
  if (typeof Blob === "undefined") {
    util$a.cores = 2;
    return callback(null, util$a.cores);
  }
  var blobUrl = URL.createObjectURL(new Blob(["(", (function() {
    self.addEventListener("message", function(e2) {
      var st = Date.now();
      var et = st + 4;
      self.postMessage({ st, et });
    });
  }).toString(), ")()"], { type: "application/javascript" }));
  sample([], 5, 16);
  function sample(max, samples, numWorkers) {
    if (samples === 0) {
      var avg = Math.floor(max.reduce(function(avg2, x2) {
        return avg2 + x2;
      }, 0) / max.length);
      util$a.cores = Math.max(1, avg);
      URL.revokeObjectURL(blobUrl);
      return callback(null, util$a.cores);
    }
    map(numWorkers, function(err, results) {
      max.push(reduce2(numWorkers, results));
      sample(max, samples - 1, numWorkers);
    });
  }
  function map(numWorkers, callback2) {
    var workers = [];
    var results = [];
    for (var i2 = 0; i2 < numWorkers; ++i2) {
      var worker = new Worker(blobUrl);
      worker.addEventListener("message", function(e2) {
        results.push(e2.data);
        if (results.length === numWorkers) {
          for (var i3 = 0; i3 < numWorkers; ++i3) {
            workers[i3].terminate();
          }
          callback2(null, results);
        }
      });
      workers.push(worker);
    }
    for (var i2 = 0; i2 < numWorkers; ++i2) {
      workers[i2].postMessage(i2);
    }
  }
  function reduce2(numWorkers, results) {
    var overlaps = [];
    for (var n2 = 0; n2 < numWorkers; ++n2) {
      var r1 = results[n2];
      var overlap = overlaps[n2] = [];
      for (var i2 = 0; i2 < numWorkers; ++i2) {
        if (n2 === i2) {
          continue;
        }
        var r2 = results[i2];
        if (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) {
          overlap.push(i2);
        }
      }
    }
    return overlaps.reduce(function(max, overlap2) {
      return Math.max(max, overlap2.length);
    }, 0);
  }
};
var utilExports$1 = util$c.exports;
var util$b = getDefaultExportFromCjs(utilExports$1);
var sha1$3 = { exports: {} };
var forge$P = forge$R;
forge$P.md = forge$P.md || {};
forge$P.md.algorithms = forge$P.md.algorithms || {};
var forge$O = forge$R;
var sha1$1 = sha1$3.exports = forge$O.sha1 = forge$O.sha1 || {};
forge$O.md.sha1 = forge$O.md.algorithms.sha1 = sha1$1;
sha1$1.create = function() {
  if (!_initialized$6) {
    _init$6();
  }
  var _state = null;
  var _input = forge$O.util.createBuffer();
  var _w = new Array(80);
  var md = {
    algorithm: "sha1",
    blockLength: 64,
    digestLength: 20,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 8
  };
  md.start = function() {
    md.messageLength = 0;
    md.fullMessageLength = md.messageLength64 = [];
    var int32s = md.messageLengthSize / 4;
    for (var i2 = 0; i2 < int32s; ++i2) {
      md.fullMessageLength.push(0);
    }
    _input = forge$O.util.createBuffer();
    _state = { h0: 1732584193, h1: 4023233417, h2: 2562383102, h3: 271733878, h4: 3285377520 };
    return md;
  };
  md.start();
  md.update = function(msg, encoding) {
    if (encoding === "utf8") {
      msg = forge$O.util.encodeUtf8(msg);
    }
    var len2 = msg.length;
    md.messageLength += len2;
    len2 = [len2 / 4294967296 >>> 0, len2 >>> 0];
    for (var i2 = md.fullMessageLength.length - 1; i2 >= 0; --i2) {
      md.fullMessageLength[i2] += len2[1];
      len2[1] = len2[0] + (md.fullMessageLength[i2] / 4294967296 >>> 0);
      md.fullMessageLength[i2] = md.fullMessageLength[i2] >>> 0;
      len2[0] = len2[1] / 4294967296 >>> 0;
    }
    _input.putBytes(msg);
    _update$6(_state, _w, _input);
    if (_input.read > 2048 || _input.length() === 0) {
      _input.compact();
    }
    return md;
  };
  md.digest = function() {
    var finalBlock = forge$O.util.createBuffer();
    finalBlock.putBytes(_input.bytes());
    var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
    var overflow = remaining & md.blockLength - 1;
    finalBlock.putBytes(_padding$6.substr(0, md.blockLength - overflow));
    var next, carry;
    var bits = md.fullMessageLength[0] * 8;
    for (var i2 = 0; i2 < md.fullMessageLength.length - 1; ++i2) {
      next = md.fullMessageLength[i2 + 1] * 8;
      carry = next / 4294967296 >>> 0;
      bits += carry;
      finalBlock.putInt32(bits >>> 0);
      bits = next >>> 0;
    }
    finalBlock.putInt32(bits);
    var s2 = { h0: _state.h0, h1: _state.h1, h2: _state.h2, h3: _state.h3, h4: _state.h4 };
    _update$6(s2, _w, finalBlock);
    var rval = forge$O.util.createBuffer();
    rval.putInt32(s2.h0);
    rval.putInt32(s2.h1);
    rval.putInt32(s2.h2);
    rval.putInt32(s2.h3);
    rval.putInt32(s2.h4);
    return rval;
  };
  return md;
};
var _padding$6 = null;
var _initialized$6 = false;
function _init$6() {
  _padding$6 = String.fromCharCode(128);
  _padding$6 += forge$O.util.fillString(String.fromCharCode(0), 64);
  _initialized$6 = true;
}
function _update$6(s2, w2, bytes) {
  var t2, a2, b3, c3, d2, e2, f2, i2;
  var len2 = bytes.length();
  while (len2 >= 64) {
    a2 = s2.h0;
    b3 = s2.h1;
    c3 = s2.h2;
    d2 = s2.h3;
    e2 = s2.h4;
    for (i2 = 0; i2 < 16; ++i2) {
      t2 = bytes.getInt32();
      w2[i2] = t2;
      f2 = d2 ^ b3 & (c3 ^ d2);
      t2 = (a2 << 5 | a2 >>> 27) + f2 + e2 + 1518500249 + t2;
      e2 = d2;
      d2 = c3;
      c3 = (b3 << 30 | b3 >>> 2) >>> 0;
      b3 = a2;
      a2 = t2;
    }
    for (; i2 < 20; ++i2) {
      t2 = w2[i2 - 3] ^ w2[i2 - 8] ^ w2[i2 - 14] ^ w2[i2 - 16];
      t2 = t2 << 1 | t2 >>> 31;
      w2[i2] = t2;
      f2 = d2 ^ b3 & (c3 ^ d2);
      t2 = (a2 << 5 | a2 >>> 27) + f2 + e2 + 1518500249 + t2;
      e2 = d2;
      d2 = c3;
      c3 = (b3 << 30 | b3 >>> 2) >>> 0;
      b3 = a2;
      a2 = t2;
    }
    for (; i2 < 32; ++i2) {
      t2 = w2[i2 - 3] ^ w2[i2 - 8] ^ w2[i2 - 14] ^ w2[i2 - 16];
      t2 = t2 << 1 | t2 >>> 31;
      w2[i2] = t2;
      f2 = b3 ^ c3 ^ d2;
      t2 = (a2 << 5 | a2 >>> 27) + f2 + e2 + 1859775393 + t2;
      e2 = d2;
      d2 = c3;
      c3 = (b3 << 30 | b3 >>> 2) >>> 0;
      b3 = a2;
      a2 = t2;
    }
    for (; i2 < 40; ++i2) {
      t2 = w2[i2 - 6] ^ w2[i2 - 16] ^ w2[i2 - 28] ^ w2[i2 - 32];
      t2 = t2 << 2 | t2 >>> 30;
      w2[i2] = t2;
      f2 = b3 ^ c3 ^ d2;
      t2 = (a2 << 5 | a2 >>> 27) + f2 + e2 + 1859775393 + t2;
      e2 = d2;
      d2 = c3;
      c3 = (b3 << 30 | b3 >>> 2) >>> 0;
      b3 = a2;
      a2 = t2;
    }
    for (; i2 < 60; ++i2) {
      t2 = w2[i2 - 6] ^ w2[i2 - 16] ^ w2[i2 - 28] ^ w2[i2 - 32];
      t2 = t2 << 2 | t2 >>> 30;
      w2[i2] = t2;
      f2 = b3 & c3 | d2 & (b3 ^ c3);
      t2 = (a2 << 5 | a2 >>> 27) + f2 + e2 + 2400959708 + t2;
      e2 = d2;
      d2 = c3;
      c3 = (b3 << 30 | b3 >>> 2) >>> 0;
      b3 = a2;
      a2 = t2;
    }
    for (; i2 < 80; ++i2) {
      t2 = w2[i2 - 6] ^ w2[i2 - 16] ^ w2[i2 - 28] ^ w2[i2 - 32];
      t2 = t2 << 2 | t2 >>> 30;
      w2[i2] = t2;
      f2 = b3 ^ c3 ^ d2;
      t2 = (a2 << 5 | a2 >>> 27) + f2 + e2 + 3395469782 + t2;
      e2 = d2;
      d2 = c3;
      c3 = (b3 << 30 | b3 >>> 2) >>> 0;
      b3 = a2;
      a2 = t2;
    }
    s2.h0 = s2.h0 + a2 | 0;
    s2.h1 = s2.h1 + b3 | 0;
    s2.h2 = s2.h2 + c3 | 0;
    s2.h3 = s2.h3 + d2 | 0;
    s2.h4 = s2.h4 + e2 | 0;
    len2 -= 64;
  }
}
var sha1Exports = sha1$3.exports;
var sha1$2 = getDefaultExportFromCjs(sha1Exports);
var sha256$7 = { exports: {} };
var forge$N = forge$R;
var sha256$5 = sha256$7.exports = forge$N.sha256 = forge$N.sha256 || {};
forge$N.md.sha256 = forge$N.md.algorithms.sha256 = sha256$5;
sha256$5.create = function() {
  if (!_initialized$5) {
    _init$5();
  }
  var _state = null;
  var _input = forge$N.util.createBuffer();
  var _w = new Array(64);
  var md = {
    algorithm: "sha256",
    blockLength: 64,
    digestLength: 32,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 8
  };
  md.start = function() {
    md.messageLength = 0;
    md.fullMessageLength = md.messageLength64 = [];
    var int32s = md.messageLengthSize / 4;
    for (var i2 = 0; i2 < int32s; ++i2) {
      md.fullMessageLength.push(0);
    }
    _input = forge$N.util.createBuffer();
    _state = { h0: 1779033703, h1: 3144134277, h2: 1013904242, h3: 2773480762, h4: 1359893119, h5: 2600822924, h6: 528734635, h7: 1541459225 };
    return md;
  };
  md.start();
  md.update = function(msg, encoding) {
    if (encoding === "utf8") {
      msg = forge$N.util.encodeUtf8(msg);
    }
    var len2 = msg.length;
    md.messageLength += len2;
    len2 = [len2 / 4294967296 >>> 0, len2 >>> 0];
    for (var i2 = md.fullMessageLength.length - 1; i2 >= 0; --i2) {
      md.fullMessageLength[i2] += len2[1];
      len2[1] = len2[0] + (md.fullMessageLength[i2] / 4294967296 >>> 0);
      md.fullMessageLength[i2] = md.fullMessageLength[i2] >>> 0;
      len2[0] = len2[1] / 4294967296 >>> 0;
    }
    _input.putBytes(msg);
    _update$5(_state, _w, _input);
    if (_input.read > 2048 || _input.length() === 0) {
      _input.compact();
    }
    return md;
  };
  md.digest = function() {
    var finalBlock = forge$N.util.createBuffer();
    finalBlock.putBytes(_input.bytes());
    var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
    var overflow = remaining & md.blockLength - 1;
    finalBlock.putBytes(_padding$5.substr(0, md.blockLength - overflow));
    var next, carry;
    var bits = md.fullMessageLength[0] * 8;
    for (var i2 = 0; i2 < md.fullMessageLength.length - 1; ++i2) {
      next = md.fullMessageLength[i2 + 1] * 8;
      carry = next / 4294967296 >>> 0;
      bits += carry;
      finalBlock.putInt32(bits >>> 0);
      bits = next >>> 0;
    }
    finalBlock.putInt32(bits);
    var s2 = { h0: _state.h0, h1: _state.h1, h2: _state.h2, h3: _state.h3, h4: _state.h4, h5: _state.h5, h6: _state.h6, h7: _state.h7 };
    _update$5(s2, _w, finalBlock);
    var rval = forge$N.util.createBuffer();
    rval.putInt32(s2.h0);
    rval.putInt32(s2.h1);
    rval.putInt32(s2.h2);
    rval.putInt32(s2.h3);
    rval.putInt32(s2.h4);
    rval.putInt32(s2.h5);
    rval.putInt32(s2.h6);
    rval.putInt32(s2.h7);
    return rval;
  };
  return md;
};
var _padding$5 = null;
var _initialized$5 = false;
var _k$4 = null;
function _init$5() {
  _padding$5 = String.fromCharCode(128);
  _padding$5 += forge$N.util.fillString(String.fromCharCode(0), 64);
  _k$4 = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
  _initialized$5 = true;
}
function _update$5(s2, w2, bytes) {
  var t1, t2, s0, s1, ch, maj, i2, a2, b3, c3, d2, e2, f2, g2, h2;
  var len2 = bytes.length();
  while (len2 >= 64) {
    for (i2 = 0; i2 < 16; ++i2) {
      w2[i2] = bytes.getInt32();
    }
    for (; i2 < 64; ++i2) {
      t1 = w2[i2 - 2];
      t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
      t2 = w2[i2 - 15];
      t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;
      w2[i2] = t1 + w2[i2 - 7] + t2 + w2[i2 - 16] | 0;
    }
    a2 = s2.h0;
    b3 = s2.h1;
    c3 = s2.h2;
    d2 = s2.h3;
    e2 = s2.h4;
    f2 = s2.h5;
    g2 = s2.h6;
    h2 = s2.h7;
    for (i2 = 0; i2 < 64; ++i2) {
      s1 = (e2 >>> 6 | e2 << 26) ^ (e2 >>> 11 | e2 << 21) ^ (e2 >>> 25 | e2 << 7);
      ch = g2 ^ e2 & (f2 ^ g2);
      s0 = (a2 >>> 2 | a2 << 30) ^ (a2 >>> 13 | a2 << 19) ^ (a2 >>> 22 | a2 << 10);
      maj = a2 & b3 | c3 & (a2 ^ b3);
      t1 = h2 + s1 + ch + _k$4[i2] + w2[i2];
      t2 = s0 + maj;
      h2 = g2;
      g2 = f2;
      f2 = e2;
      e2 = d2 + t1 >>> 0;
      d2 = c3;
      c3 = b3;
      b3 = a2;
      a2 = t1 + t2 >>> 0;
    }
    s2.h0 = s2.h0 + a2 | 0;
    s2.h1 = s2.h1 + b3 | 0;
    s2.h2 = s2.h2 + c3 | 0;
    s2.h3 = s2.h3 + d2 | 0;
    s2.h4 = s2.h4 + e2 | 0;
    s2.h5 = s2.h5 + f2 | 0;
    s2.h6 = s2.h6 + g2 | 0;
    s2.h7 = s2.h7 + h2 | 0;
    len2 -= 64;
  }
}
var sha256Exports = sha256$7.exports;
var sha256$6 = getDefaultExportFromCjs(sha256Exports);
var sha512$6 = { exports: {} };
var forge$M = forge$R;
var sha512$4 = sha512$6.exports = forge$M.sha512 = forge$M.sha512 || {};
forge$M.md.sha512 = forge$M.md.algorithms.sha512 = sha512$4;
var sha384$1 = forge$M.sha384 = forge$M.sha512.sha384 = forge$M.sha512.sha384 || {};
sha384$1.create = function() {
  return sha512$4.create("SHA-384");
};
forge$M.md.sha384 = forge$M.md.algorithms.sha384 = sha384$1;
forge$M.sha512.sha256 = forge$M.sha512.sha256 || { create: function create2() {
  return sha512$4.create("SHA-512/256");
} };
forge$M.md["sha512/256"] = forge$M.md.algorithms["sha512/256"] = forge$M.sha512.sha256;
forge$M.sha512.sha224 = forge$M.sha512.sha224 || { create: function create3() {
  return sha512$4.create("SHA-512/224");
} };
forge$M.md["sha512/224"] = forge$M.md.algorithms["sha512/224"] = forge$M.sha512.sha224;
sha512$4.create = function(algorithm) {
  if (!_initialized$4) {
    _init$4();
  }
  if (typeof algorithm === "undefined") {
    algorithm = "SHA-512";
  }
  if (!(algorithm in _states$1)) {
    throw new Error("Invalid SHA-512 algorithm: " + algorithm);
  }
  var _state = _states$1[algorithm];
  var _h = null;
  var _input = forge$M.util.createBuffer();
  var _w = new Array(80);
  for (var wi = 0; wi < 80; ++wi) {
    _w[wi] = new Array(2);
  }
  var digestLength = 64;
  switch (algorithm) {
    case "SHA-384":
      digestLength = 48;
      break;
    case "SHA-512/256":
      digestLength = 32;
      break;
    case "SHA-512/224":
      digestLength = 28;
      break;
  }
  var md = {
    // SHA-512 => sha512
    algorithm: algorithm.replace("-", "").toLowerCase(),
    blockLength: 128,
    digestLength,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 16
  };
  md.start = function() {
    md.messageLength = 0;
    md.fullMessageLength = md.messageLength128 = [];
    var int32s = md.messageLengthSize / 4;
    for (var i2 = 0; i2 < int32s; ++i2) {
      md.fullMessageLength.push(0);
    }
    _input = forge$M.util.createBuffer();
    _h = new Array(_state.length);
    for (var i2 = 0; i2 < _state.length; ++i2) {
      _h[i2] = _state[i2].slice(0);
    }
    return md;
  };
  md.start();
  md.update = function(msg, encoding) {
    if (encoding === "utf8") {
      msg = forge$M.util.encodeUtf8(msg);
    }
    var len2 = msg.length;
    md.messageLength += len2;
    len2 = [len2 / 4294967296 >>> 0, len2 >>> 0];
    for (var i2 = md.fullMessageLength.length - 1; i2 >= 0; --i2) {
      md.fullMessageLength[i2] += len2[1];
      len2[1] = len2[0] + (md.fullMessageLength[i2] / 4294967296 >>> 0);
      md.fullMessageLength[i2] = md.fullMessageLength[i2] >>> 0;
      len2[0] = len2[1] / 4294967296 >>> 0;
    }
    _input.putBytes(msg);
    _update$4(_h, _w, _input);
    if (_input.read > 2048 || _input.length() === 0) {
      _input.compact();
    }
    return md;
  };
  md.digest = function() {
    var finalBlock = forge$M.util.createBuffer();
    finalBlock.putBytes(_input.bytes());
    var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
    var overflow = remaining & md.blockLength - 1;
    finalBlock.putBytes(_padding$4.substr(0, md.blockLength - overflow));
    var next, carry;
    var bits = md.fullMessageLength[0] * 8;
    for (var i2 = 0; i2 < md.fullMessageLength.length - 1; ++i2) {
      next = md.fullMessageLength[i2 + 1] * 8;
      carry = next / 4294967296 >>> 0;
      bits += carry;
      finalBlock.putInt32(bits >>> 0);
      bits = next >>> 0;
    }
    finalBlock.putInt32(bits);
    var h2 = new Array(_h.length);
    for (var i2 = 0; i2 < _h.length; ++i2) {
      h2[i2] = _h[i2].slice(0);
    }
    _update$4(h2, _w, finalBlock);
    var rval = forge$M.util.createBuffer();
    var hlen;
    if (algorithm === "SHA-512") {
      hlen = h2.length;
    } else if (algorithm === "SHA-384") {
      hlen = h2.length - 2;
    } else {
      hlen = h2.length - 4;
    }
    for (var i2 = 0; i2 < hlen; ++i2) {
      rval.putInt32(h2[i2][0]);
      if (i2 !== hlen - 1 || algorithm !== "SHA-512/224") {
        rval.putInt32(h2[i2][1]);
      }
    }
    return rval;
  };
  return md;
};
var _padding$4 = null;
var _initialized$4 = false;
var _k$3 = null;
var _states$1 = null;
function _init$4() {
  _padding$4 = String.fromCharCode(128);
  _padding$4 += forge$M.util.fillString(String.fromCharCode(0), 128);
  _k$3 = [[1116352408, 3609767458], [1899447441, 602891725], [3049323471, 3964484399], [3921009573, 2173295548], [961987163, 4081628472], [1508970993, 3053834265], [2453635748, 2937671579], [2870763221, 3664609560], [3624381080, 2734883394], [310598401, 1164996542], [607225278, 1323610764], [1426881987, 3590304994], [1925078388, 4068182383], [2162078206, 991336113], [2614888103, 633803317], [3248222580, 3479774868], [3835390401, 2666613458], [4022224774, 944711139], [264347078, 2341262773], [604807628, 2007800933], [770255983, 1495990901], [1249150122, 1856431235], [1555081692, 3175218132], [1996064986, 2198950837], [2554220882, 3999719339], [2821834349, 766784016], [2952996808, 2566594879], [3210313671, 3203337956], [3336571891, 1034457026], [3584528711, 2466948901], [113926993, 3758326383], [338241895, 168717936], [666307205, 1188179964], [773529912, 1546045734], [1294757372, 1522805485], [1396182291, 2643833823], [1695183700, 2343527390], [1986661051, 1014477480], [2177026350, 1206759142], [2456956037, 344077627], [2730485921, 1290863460], [2820302411, 3158454273], [3259730800, 3505952657], [3345764771, 106217008], [3516065817, 3606008344], [3600352804, 1432725776], [4094571909, 1467031594], [275423344, 851169720], [430227734, 3100823752], [506948616, 1363258195], [659060556, 3750685593], [883997877, 3785050280], [958139571, 3318307427], [1322822218, 3812723403], [1537002063, 2003034995], [1747873779, 3602036899], [1955562222, 1575990012], [2024104815, 1125592928], [2227730452, 2716904306], [2361852424, 442776044], [2428436474, 593698344], [2756734187, 3733110249], [3204031479, 2999351573], [3329325298, 3815920427], [3391569614, 3928383900], [3515267271, 566280711], [3940187606, 3454069534], [4118630271, 4000239992], [116418474, 1914138554], [174292421, 2731055270], [289380356, 3203993006], [460393269, 320620315], [685471733, 587496836], [852142971, 1086792851], [1017036298, 365543100], [1126000580, 2618297676], [1288033470, 3409855158], [1501505948, 4234509866], [1607167915, 987167468], [1816402316, 1246189591]];
  _states$1 = {};
  _states$1["SHA-512"] = [[1779033703, 4089235720], [3144134277, 2227873595], [1013904242, 4271175723], [2773480762, 1595750129], [1359893119, 2917565137], [2600822924, 725511199], [528734635, 4215389547], [1541459225, 327033209]];
  _states$1["SHA-384"] = [[3418070365, 3238371032], [1654270250, 914150663], [2438529370, 812702999], [355462360, 4144912697], [1731405415, 4290775857], [2394180231, 1750603025], [3675008525, 1694076839], [1203062813, 3204075428]];
  _states$1["SHA-512/256"] = [[573645204, 4230739756], [2673172387, 3360449730], [596883563, 1867755857], [2520282905, 1497426621], [2519219938, 2827943907], [3193839141, 1401305490], [721525244, 746961066], [246885852, 2177182882]];
  _states$1["SHA-512/224"] = [[2352822216, 424955298], [1944164710, 2312950998], [502970286, 855612546], [1738396948, 1479516111], [258812777, 2077511080], [2011393907, 79989058], [1067287976, 1780299464], [286451373, 2446758561]];
  _initialized$4 = true;
}
function _update$4(s2, w2, bytes) {
  var t1_hi, t1_lo;
  var t2_hi, t2_lo;
  var s0_hi, s0_lo;
  var s1_hi, s1_lo;
  var ch_hi, ch_lo;
  var maj_hi, maj_lo;
  var a_hi, a_lo;
  var b_hi, b_lo;
  var c_hi, c_lo;
  var d_hi, d_lo;
  var e_hi, e_lo;
  var f_hi, f_lo;
  var g_hi, g_lo;
  var h_hi, h_lo;
  var i2, hi, lo, w22, w7, w15, w16;
  var len2 = bytes.length();
  while (len2 >= 128) {
    for (i2 = 0; i2 < 16; ++i2) {
      w2[i2][0] = bytes.getInt32() >>> 0;
      w2[i2][1] = bytes.getInt32() >>> 0;
    }
    for (; i2 < 80; ++i2) {
      w22 = w2[i2 - 2];
      hi = w22[0];
      lo = w22[1];
      t1_hi = ((hi >>> 19 | lo << 13) ^ // ROTR 19
      (lo >>> 29 | hi << 3) ^ // ROTR 61/(swap + ROTR 29)
      hi >>> 6) >>> 0;
      t1_lo = ((hi << 13 | lo >>> 19) ^ // ROTR 19
      (lo << 3 | hi >>> 29) ^ // ROTR 61/(swap + ROTR 29)
      (hi << 26 | lo >>> 6)) >>> 0;
      w15 = w2[i2 - 15];
      hi = w15[0];
      lo = w15[1];
      t2_hi = ((hi >>> 1 | lo << 31) ^ // ROTR 1
      (hi >>> 8 | lo << 24) ^ // ROTR 8
      hi >>> 7) >>> 0;
      t2_lo = ((hi << 31 | lo >>> 1) ^ // ROTR 1
      (hi << 24 | lo >>> 8) ^ // ROTR 8
      (hi << 25 | lo >>> 7)) >>> 0;
      w7 = w2[i2 - 7];
      w16 = w2[i2 - 16];
      lo = t1_lo + w7[1] + t2_lo + w16[1];
      w2[i2][0] = t1_hi + w7[0] + t2_hi + w16[0] + (lo / 4294967296 >>> 0) >>> 0;
      w2[i2][1] = lo >>> 0;
    }
    a_hi = s2[0][0];
    a_lo = s2[0][1];
    b_hi = s2[1][0];
    b_lo = s2[1][1];
    c_hi = s2[2][0];
    c_lo = s2[2][1];
    d_hi = s2[3][0];
    d_lo = s2[3][1];
    e_hi = s2[4][0];
    e_lo = s2[4][1];
    f_hi = s2[5][0];
    f_lo = s2[5][1];
    g_hi = s2[6][0];
    g_lo = s2[6][1];
    h_hi = s2[7][0];
    h_lo = s2[7][1];
    for (i2 = 0; i2 < 80; ++i2) {
      s1_hi = ((e_hi >>> 14 | e_lo << 18) ^ // ROTR 14
      (e_hi >>> 18 | e_lo << 14) ^ // ROTR 18
      (e_lo >>> 9 | e_hi << 23)) >>> 0;
      s1_lo = ((e_hi << 18 | e_lo >>> 14) ^ // ROTR 14
      (e_hi << 14 | e_lo >>> 18) ^ // ROTR 18
      (e_lo << 23 | e_hi >>> 9)) >>> 0;
      ch_hi = (g_hi ^ e_hi & (f_hi ^ g_hi)) >>> 0;
      ch_lo = (g_lo ^ e_lo & (f_lo ^ g_lo)) >>> 0;
      s0_hi = ((a_hi >>> 28 | a_lo << 4) ^ // ROTR 28
      (a_lo >>> 2 | a_hi << 30) ^ // ROTR 34/(swap + ROTR 2)
      (a_lo >>> 7 | a_hi << 25)) >>> 0;
      s0_lo = ((a_hi << 4 | a_lo >>> 28) ^ // ROTR 28
      (a_lo << 30 | a_hi >>> 2) ^ // ROTR 34/(swap + ROTR 2)
      (a_lo << 25 | a_hi >>> 7)) >>> 0;
      maj_hi = (a_hi & b_hi | c_hi & (a_hi ^ b_hi)) >>> 0;
      maj_lo = (a_lo & b_lo | c_lo & (a_lo ^ b_lo)) >>> 0;
      lo = h_lo + s1_lo + ch_lo + _k$3[i2][1] + w2[i2][1];
      t1_hi = h_hi + s1_hi + ch_hi + _k$3[i2][0] + w2[i2][0] + (lo / 4294967296 >>> 0) >>> 0;
      t1_lo = lo >>> 0;
      lo = s0_lo + maj_lo;
      t2_hi = s0_hi + maj_hi + (lo / 4294967296 >>> 0) >>> 0;
      t2_lo = lo >>> 0;
      h_hi = g_hi;
      h_lo = g_lo;
      g_hi = f_hi;
      g_lo = f_lo;
      f_hi = e_hi;
      f_lo = e_lo;
      lo = d_lo + t1_lo;
      e_hi = d_hi + t1_hi + (lo / 4294967296 >>> 0) >>> 0;
      e_lo = lo >>> 0;
      d_hi = c_hi;
      d_lo = c_lo;
      c_hi = b_hi;
      c_lo = b_lo;
      b_hi = a_hi;
      b_lo = a_lo;
      lo = t1_lo + t2_lo;
      a_hi = t1_hi + t2_hi + (lo / 4294967296 >>> 0) >>> 0;
      a_lo = lo >>> 0;
    }
    lo = s2[0][1] + a_lo;
    s2[0][0] = s2[0][0] + a_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[0][1] = lo >>> 0;
    lo = s2[1][1] + b_lo;
    s2[1][0] = s2[1][0] + b_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[1][1] = lo >>> 0;
    lo = s2[2][1] + c_lo;
    s2[2][0] = s2[2][0] + c_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[2][1] = lo >>> 0;
    lo = s2[3][1] + d_lo;
    s2[3][0] = s2[3][0] + d_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[3][1] = lo >>> 0;
    lo = s2[4][1] + e_lo;
    s2[4][0] = s2[4][0] + e_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[4][1] = lo >>> 0;
    lo = s2[5][1] + f_lo;
    s2[5][0] = s2[5][0] + f_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[5][1] = lo >>> 0;
    lo = s2[6][1] + g_lo;
    s2[6][0] = s2[6][0] + g_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[6][1] = lo >>> 0;
    lo = s2[7][1] + h_lo;
    s2[7][0] = s2[7][0] + h_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[7][1] = lo >>> 0;
    len2 -= 128;
  }
}
var sha512Exports = sha512$6.exports;
var sha512$5 = getDefaultExportFromCjs(sha512Exports);
var md5$2 = { exports: {} };
var forge$L = forge$R;
var md5 = md5$2.exports = forge$L.md5 = forge$L.md5 || {};
forge$L.md.md5 = forge$L.md.algorithms.md5 = md5;
md5.create = function() {
  if (!_initialized$3) {
    _init$3();
  }
  var _state = null;
  var _input = forge$L.util.createBuffer();
  var _w = new Array(16);
  var md = {
    algorithm: "md5",
    blockLength: 64,
    digestLength: 16,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 8
  };
  md.start = function() {
    md.messageLength = 0;
    md.fullMessageLength = md.messageLength64 = [];
    var int32s = md.messageLengthSize / 4;
    for (var i2 = 0; i2 < int32s; ++i2) {
      md.fullMessageLength.push(0);
    }
    _input = forge$L.util.createBuffer();
    _state = { h0: 1732584193, h1: 4023233417, h2: 2562383102, h3: 271733878 };
    return md;
  };
  md.start();
  md.update = function(msg, encoding) {
    if (encoding === "utf8") {
      msg = forge$L.util.encodeUtf8(msg);
    }
    var len2 = msg.length;
    md.messageLength += len2;
    len2 = [len2 / 4294967296 >>> 0, len2 >>> 0];
    for (var i2 = md.fullMessageLength.length - 1; i2 >= 0; --i2) {
      md.fullMessageLength[i2] += len2[1];
      len2[1] = len2[0] + (md.fullMessageLength[i2] / 4294967296 >>> 0);
      md.fullMessageLength[i2] = md.fullMessageLength[i2] >>> 0;
      len2[0] = len2[1] / 4294967296 >>> 0;
    }
    _input.putBytes(msg);
    _update$3(_state, _w, _input);
    if (_input.read > 2048 || _input.length() === 0) {
      _input.compact();
    }
    return md;
  };
  md.digest = function() {
    var finalBlock = forge$L.util.createBuffer();
    finalBlock.putBytes(_input.bytes());
    var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
    var overflow = remaining & md.blockLength - 1;
    finalBlock.putBytes(_padding$3.substr(0, md.blockLength - overflow));
    var bits, carry = 0;
    for (var i2 = md.fullMessageLength.length - 1; i2 >= 0; --i2) {
      bits = md.fullMessageLength[i2] * 8 + carry;
      carry = bits / 4294967296 >>> 0;
      finalBlock.putInt32Le(bits >>> 0);
    }
    var s2 = { h0: _state.h0, h1: _state.h1, h2: _state.h2, h3: _state.h3 };
    _update$3(s2, _w, finalBlock);
    var rval = forge$L.util.createBuffer();
    rval.putInt32Le(s2.h0);
    rval.putInt32Le(s2.h1);
    rval.putInt32Le(s2.h2);
    rval.putInt32Le(s2.h3);
    return rval;
  };
  return md;
};
var _padding$3 = null;
var _g = null;
var _r = null;
var _k$2 = null;
var _initialized$3 = false;
function _init$3() {
  _padding$3 = String.fromCharCode(128);
  _padding$3 += forge$L.util.fillString(String.fromCharCode(0), 64);
  _g = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1, 6, 11, 0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12, 5, 8, 11, 14, 1, 4, 7, 10, 13, 0, 3, 6, 9, 12, 15, 2, 0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13, 4, 11, 2, 9];
  _r = [7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21];
  _k$2 = new Array(64);
  for (var i2 = 0; i2 < 64; ++i2) {
    _k$2[i2] = Math.floor(Math.abs(Math.sin(i2 + 1)) * 4294967296);
  }
  _initialized$3 = true;
}
function _update$3(s2, w2, bytes) {
  var t2, a2, b3, c3, d2, f2, r2, i2;
  var len2 = bytes.length();
  while (len2 >= 64) {
    a2 = s2.h0;
    b3 = s2.h1;
    c3 = s2.h2;
    d2 = s2.h3;
    for (i2 = 0; i2 < 16; ++i2) {
      w2[i2] = bytes.getInt32Le();
      f2 = d2 ^ b3 & (c3 ^ d2);
      t2 = a2 + f2 + _k$2[i2] + w2[i2];
      r2 = _r[i2];
      a2 = d2;
      d2 = c3;
      c3 = b3;
      b3 += t2 << r2 | t2 >>> 32 - r2;
    }
    for (; i2 < 32; ++i2) {
      f2 = c3 ^ d2 & (b3 ^ c3);
      t2 = a2 + f2 + _k$2[i2] + w2[_g[i2]];
      r2 = _r[i2];
      a2 = d2;
      d2 = c3;
      c3 = b3;
      b3 += t2 << r2 | t2 >>> 32 - r2;
    }
    for (; i2 < 48; ++i2) {
      f2 = b3 ^ c3 ^ d2;
      t2 = a2 + f2 + _k$2[i2] + w2[_g[i2]];
      r2 = _r[i2];
      a2 = d2;
      d2 = c3;
      c3 = b3;
      b3 += t2 << r2 | t2 >>> 32 - r2;
    }
    for (; i2 < 64; ++i2) {
      f2 = c3 ^ (b3 | ~d2);
      t2 = a2 + f2 + _k$2[i2] + w2[_g[i2]];
      r2 = _r[i2];
      a2 = d2;
      d2 = c3;
      c3 = b3;
      b3 += t2 << r2 | t2 >>> 32 - r2;
    }
    s2.h0 = s2.h0 + a2 | 0;
    s2.h1 = s2.h1 + b3 | 0;
    s2.h2 = s2.h2 + c3 | 0;
    s2.h3 = s2.h3 + d2 | 0;
    len2 -= 64;
  }
}
var md5Exports = md5$2.exports;
var md5$1 = getDefaultExportFromCjs(md5Exports);
var forge$K = forge$R;
var hmac$3 = forge$K.hmac = forge$K.hmac || {};
hmac$3.create = function() {
  var _key = null;
  var _md2 = null;
  var _ipadding = null;
  var _opadding = null;
  var ctx = {};
  ctx.start = function(md, key3) {
    if (md !== null) {
      if (typeof md === "string") {
        md = md.toLowerCase();
        if (md in forge$K.md.algorithms) {
          _md2 = forge$K.md.algorithms[md].create();
        } else {
          throw new Error('Unknown hash algorithm "' + md + '"');
        }
      } else {
        _md2 = md;
      }
    }
    if (key3 === null) {
      key3 = _key;
    } else {
      if (typeof key3 === "string") {
        key3 = forge$K.util.createBuffer(key3);
      } else if (forge$K.util.isArray(key3)) {
        var tmp = key3;
        key3 = forge$K.util.createBuffer();
        for (var i2 = 0; i2 < tmp.length; ++i2) {
          key3.putByte(tmp[i2]);
        }
      }
      var keylen = key3.length();
      if (keylen > _md2.blockLength) {
        _md2.start();
        _md2.update(key3.bytes());
        key3 = _md2.digest();
      }
      _ipadding = forge$K.util.createBuffer();
      _opadding = forge$K.util.createBuffer();
      keylen = key3.length();
      for (var i2 = 0; i2 < keylen; ++i2) {
        var tmp = key3.at(i2);
        _ipadding.putByte(54 ^ tmp);
        _opadding.putByte(92 ^ tmp);
      }
      if (keylen < _md2.blockLength) {
        var tmp = _md2.blockLength - keylen;
        for (var i2 = 0; i2 < tmp; ++i2) {
          _ipadding.putByte(54);
          _opadding.putByte(92);
        }
      }
      _key = key3;
      _ipadding = _ipadding.bytes();
      _opadding = _opadding.bytes();
    }
    _md2.start();
    _md2.update(_ipadding);
  };
  ctx.update = function(bytes) {
    _md2.update(bytes);
  };
  ctx.getMac = function() {
    var inner = _md2.digest().bytes();
    _md2.start();
    _md2.update(_opadding);
    _md2.update(inner);
    return _md2.digest();
  };
  ctx.digest = ctx.getMac;
  return ctx;
};
var forge$J = forge$R;
var pkcs5$1 = forge$J.pkcs5 = forge$J.pkcs5 || {};
var crypto$4;
if (forge$J.util.isNodejs && !forge$J.options.usePureJavaScript) {
  crypto$4 = require$$0$4;
}
var pbkdf2$2 = forge$J.pbkdf2 = pkcs5$1.pbkdf2 = function(p2, s2, c3, dkLen, md, callback) {
  if (typeof md === "function") {
    callback = md;
    md = null;
  }
  if (forge$J.util.isNodejs && !forge$J.options.usePureJavaScript && crypto$4.pbkdf2 && (md === null || _typeof(md) !== "object") && (crypto$4.pbkdf2Sync.length > 4 || !md || md === "sha1")) {
    if (typeof md !== "string") {
      md = "sha1";
    }
    p2 = Buffer.from(p2, "binary");
    s2 = Buffer.from(s2, "binary");
    if (!callback) {
      if (crypto$4.pbkdf2Sync.length === 4) {
        return crypto$4.pbkdf2Sync(p2, s2, c3, dkLen).toString("binary");
      }
      return crypto$4.pbkdf2Sync(p2, s2, c3, dkLen, md).toString("binary");
    }
    if (crypto$4.pbkdf2Sync.length === 4) {
      return crypto$4.pbkdf2(p2, s2, c3, dkLen, function(err2, key3) {
        if (err2) {
          return callback(err2);
        }
        callback(null, key3.toString("binary"));
      });
    }
    return crypto$4.pbkdf2(p2, s2, c3, dkLen, md, function(err2, key3) {
      if (err2) {
        return callback(err2);
      }
      callback(null, key3.toString("binary"));
    });
  }
  if (typeof md === "undefined" || md === null) {
    md = "sha1";
  }
  if (typeof md === "string") {
    if (!(md in forge$J.md.algorithms)) {
      throw new Error("Unknown hash algorithm: " + md);
    }
    md = forge$J.md[md].create();
  }
  var hLen = md.digestLength;
  if (dkLen > 4294967295 * hLen) {
    var err = new Error("Derived key is too long.");
    if (callback) {
      return callback(err);
    }
    throw err;
  }
  var len2 = Math.ceil(dkLen / hLen);
  var r2 = dkLen - (len2 - 1) * hLen;
  var prf = forge$J.hmac.create();
  prf.start(md, p2);
  var dk = "";
  var xor, u_c, u_c1;
  if (!callback) {
    for (var i2 = 1; i2 <= len2; ++i2) {
      prf.start(null, null);
      prf.update(s2);
      prf.update(forge$J.util.int32ToBytes(i2));
      xor = u_c1 = prf.digest().getBytes();
      for (var j3 = 2; j3 <= c3; ++j3) {
        prf.start(null, null);
        prf.update(u_c1);
        u_c = prf.digest().getBytes();
        xor = forge$J.util.xorBytes(xor, u_c, hLen);
        u_c1 = u_c;
      }
      dk += i2 < len2 ? xor : xor.substr(0, r2);
    }
    return dk;
  }
  var i2 = 1, j3;
  function outer() {
    if (i2 > len2) {
      return callback(null, dk);
    }
    prf.start(null, null);
    prf.update(s2);
    prf.update(forge$J.util.int32ToBytes(i2));
    xor = u_c1 = prf.digest().getBytes();
    j3 = 2;
    inner();
  }
  function inner() {
    if (j3 <= c3) {
      prf.start(null, null);
      prf.update(u_c1);
      u_c = prf.digest().getBytes();
      xor = forge$J.util.xorBytes(xor, u_c, hLen);
      u_c1 = u_c;
      ++j3;
      return forge$J.util.setImmediate(inner);
    }
    dk += i2 < len2 ? xor : xor.substr(0, r2);
    ++i2;
    outer();
  }
  outer();
};
var pbkdf2$3 = getDefaultExportFromCjs(pbkdf2$2);
var forge$I = forge$R;
forge$I.cipher = forge$I.cipher || {};
forge$I.cipher.algorithms = forge$I.cipher.algorithms || {};
forge$I.cipher.createCipher = function(algorithm, key3) {
  var api2 = algorithm;
  if (typeof api2 === "string") {
    api2 = forge$I.cipher.getAlgorithm(api2);
    if (api2) {
      api2 = api2();
    }
  }
  if (!api2) {
    throw new Error("Unsupported algorithm: " + algorithm);
  }
  return new forge$I.cipher.BlockCipher({ algorithm: api2, key: key3, decrypt: false });
};
forge$I.cipher.createDecipher = function(algorithm, key3) {
  var api2 = algorithm;
  if (typeof api2 === "string") {
    api2 = forge$I.cipher.getAlgorithm(api2);
    if (api2) {
      api2 = api2();
    }
  }
  if (!api2) {
    throw new Error("Unsupported algorithm: " + algorithm);
  }
  return new forge$I.cipher.BlockCipher({ algorithm: api2, key: key3, decrypt: true });
};
forge$I.cipher.registerAlgorithm = function(name2, algorithm) {
  name2 = name2.toUpperCase();
  forge$I.cipher.algorithms[name2] = algorithm;
};
forge$I.cipher.getAlgorithm = function(name2) {
  name2 = name2.toUpperCase();
  if (name2 in forge$I.cipher.algorithms) {
    return forge$I.cipher.algorithms[name2];
  }
  return null;
};
var BlockCipher$1 = forge$I.cipher.BlockCipher = function(options) {
  this.algorithm = options.algorithm;
  this.mode = this.algorithm.mode;
  this.blockSize = this.mode.blockSize;
  this._finish = false;
  this._input = null;
  this.output = null;
  this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
  this._decrypt = options.decrypt;
  this.algorithm.initialize(options);
};
BlockCipher$1.prototype.start = function(options) {
  options = options || {};
  var opts = {};
  for (var key3 in options) {
    opts[key3] = options[key3];
  }
  opts.decrypt = this._decrypt;
  this._finish = false;
  this._input = forge$I.util.createBuffer();
  this.output = options.output || forge$I.util.createBuffer();
  this.mode.start(opts);
};
BlockCipher$1.prototype.update = function(input) {
  if (input) {
    this._input.putBuffer(input);
  }
  while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {
  }
  this._input.compact();
};
BlockCipher$1.prototype.finish = function(pad2) {
  if (pad2 && (this.mode.name === "ECB" || this.mode.name === "CBC")) {
    this.mode.pad = function(input) {
      return pad2(this.blockSize, input, false);
    };
    this.mode.unpad = function(output) {
      return pad2(this.blockSize, output, true);
    };
  }
  var options = {};
  options.decrypt = this._decrypt;
  options.overflow = this._input.length() % this.blockSize;
  if (!this._decrypt && this.mode.pad) {
    if (!this.mode.pad(this._input, options)) {
      return false;
    }
  }
  this._finish = true;
  this.update();
  if (this._decrypt && this.mode.unpad) {
    if (!this.mode.unpad(this.output, options)) {
      return false;
    }
  }
  if (this.mode.afterFinish) {
    if (!this.mode.afterFinish(this.output, options)) {
      return false;
    }
  }
  return true;
};
var forge$H = forge$R;
forge$H.cipher = forge$H.cipher || {};
var modes$1 = forge$H.cipher.modes = forge$H.cipher.modes || {};
modes$1.ecb = function(options) {
  options = options || {};
  this.name = "ECB";
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = new Array(this._ints);
  this._outBlock = new Array(this._ints);
};
modes$1.ecb.prototype.start = function(options) {
};
modes$1.ecb.prototype.encrypt = function(input, output, finish2) {
  if (input.length() < this.blockSize && !(finish2 && input.length() > 0)) {
    return true;
  }
  for (var i2 = 0; i2 < this._ints; ++i2) {
    this._inBlock[i2] = input.getInt32();
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  for (var i2 = 0; i2 < this._ints; ++i2) {
    output.putInt32(this._outBlock[i2]);
  }
};
modes$1.ecb.prototype.decrypt = function(input, output, finish2) {
  if (input.length() < this.blockSize && !(finish2 && input.length() > 0)) {
    return true;
  }
  for (var i2 = 0; i2 < this._ints; ++i2) {
    this._inBlock[i2] = input.getInt32();
  }
  this.cipher.decrypt(this._inBlock, this._outBlock);
  for (var i2 = 0; i2 < this._ints; ++i2) {
    output.putInt32(this._outBlock[i2]);
  }
};
modes$1.ecb.prototype.pad = function(input, options) {
  var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
  input.fillWithByte(padding, padding);
  return true;
};
modes$1.ecb.prototype.unpad = function(output, options) {
  if (options.overflow > 0) {
    return false;
  }
  var len2 = output.length();
  var count = output.at(len2 - 1);
  if (count > this.blockSize << 2) {
    return false;
  }
  output.truncate(count);
  return true;
};
modes$1.cbc = function(options) {
  options = options || {};
  this.name = "CBC";
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = new Array(this._ints);
  this._outBlock = new Array(this._ints);
};
modes$1.cbc.prototype.start = function(options) {
  if (options.iv === null) {
    if (!this._prev) {
      throw new Error("Invalid IV parameter.");
    }
    this._iv = this._prev.slice(0);
  } else if (!("iv" in options)) {
    throw new Error("Invalid IV parameter.");
  } else {
    this._iv = transformIV$1(options.iv);
    this._prev = this._iv.slice(0);
  }
};
modes$1.cbc.prototype.encrypt = function(input, output, finish2) {
  if (input.length() < this.blockSize && !(finish2 && input.length() > 0)) {
    return true;
  }
  for (var i2 = 0; i2 < this._ints; ++i2) {
    this._inBlock[i2] = this._prev[i2] ^ input.getInt32();
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  for (var i2 = 0; i2 < this._ints; ++i2) {
    output.putInt32(this._outBlock[i2]);
  }
  this._prev = this._outBlock;
};
modes$1.cbc.prototype.decrypt = function(input, output, finish2) {
  if (input.length() < this.blockSize && !(finish2 && input.length() > 0)) {
    return true;
  }
  for (var i2 = 0; i2 < this._ints; ++i2) {
    this._inBlock[i2] = input.getInt32();
  }
  this.cipher.decrypt(this._inBlock, this._outBlock);
  for (var i2 = 0; i2 < this._ints; ++i2) {
    output.putInt32(this._prev[i2] ^ this._outBlock[i2]);
  }
  this._prev = this._inBlock.slice(0);
};
modes$1.cbc.prototype.pad = function(input, options) {
  var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
  input.fillWithByte(padding, padding);
  return true;
};
modes$1.cbc.prototype.unpad = function(output, options) {
  if (options.overflow > 0) {
    return false;
  }
  var len2 = output.length();
  var count = output.at(len2 - 1);
  if (count > this.blockSize << 2) {
    return false;
  }
  output.truncate(count);
  return true;
};
modes$1.cfb = function(options) {
  options = options || {};
  this.name = "CFB";
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = null;
  this._outBlock = new Array(this._ints);
  this._partialBlock = new Array(this._ints);
  this._partialOutput = forge$H.util.createBuffer();
  this._partialBytes = 0;
};
modes$1.cfb.prototype.start = function(options) {
  if (!("iv" in options)) {
    throw new Error("Invalid IV parameter.");
  }
  this._iv = transformIV$1(options.iv);
  this._inBlock = this._iv.slice(0);
  this._partialBytes = 0;
};
modes$1.cfb.prototype.encrypt = function(input, output, finish2) {
  var inputLength = input.length();
  if (inputLength === 0) {
    return true;
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  if (this._partialBytes === 0 && inputLength >= this.blockSize) {
    for (var i2 = 0; i2 < this._ints; ++i2) {
      this._inBlock[i2] = input.getInt32() ^ this._outBlock[i2];
      output.putInt32(this._inBlock[i2]);
    }
    return;
  }
  var partialBytes = (this.blockSize - inputLength) % this.blockSize;
  if (partialBytes > 0) {
    partialBytes = this.blockSize - partialBytes;
  }
  this._partialOutput.clear();
  for (var i2 = 0; i2 < this._ints; ++i2) {
    this._partialBlock[i2] = input.getInt32() ^ this._outBlock[i2];
    this._partialOutput.putInt32(this._partialBlock[i2]);
  }
  if (partialBytes > 0) {
    input.read -= this.blockSize;
  } else {
    for (var i2 = 0; i2 < this._ints; ++i2) {
      this._inBlock[i2] = this._partialBlock[i2];
    }
  }
  if (this._partialBytes > 0) {
    this._partialOutput.getBytes(this._partialBytes);
  }
  if (partialBytes > 0 && !finish2) {
    output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
    this._partialBytes = partialBytes;
    return true;
  }
  output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
  this._partialBytes = 0;
};
modes$1.cfb.prototype.decrypt = function(input, output, finish2) {
  var inputLength = input.length();
  if (inputLength === 0) {
    return true;
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  if (this._partialBytes === 0 && inputLength >= this.blockSize) {
    for (var i2 = 0; i2 < this._ints; ++i2) {
      this._inBlock[i2] = input.getInt32();
      output.putInt32(this._inBlock[i2] ^ this._outBlock[i2]);
    }
    return;
  }
  var partialBytes = (this.blockSize - inputLength) % this.blockSize;
  if (partialBytes > 0) {
    partialBytes = this.blockSize - partialBytes;
  }
  this._partialOutput.clear();
  for (var i2 = 0; i2 < this._ints; ++i2) {
    this._partialBlock[i2] = input.getInt32();
    this._partialOutput.putInt32(this._partialBlock[i2] ^ this._outBlock[i2]);
  }
  if (partialBytes > 0) {
    input.read -= this.blockSize;
  } else {
    for (var i2 = 0; i2 < this._ints; ++i2) {
      this._inBlock[i2] = this._partialBlock[i2];
    }
  }
  if (this._partialBytes > 0) {
    this._partialOutput.getBytes(this._partialBytes);
  }
  if (partialBytes > 0 && !finish2) {
    output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
    this._partialBytes = partialBytes;
    return true;
  }
  output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
  this._partialBytes = 0;
};
modes$1.ofb = function(options) {
  options = options || {};
  this.name = "OFB";
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = null;
  this._outBlock = new Array(this._ints);
  this._partialOutput = forge$H.util.createBuffer();
  this._partialBytes = 0;
};
modes$1.ofb.prototype.start = function(options) {
  if (!("iv" in options)) {
    throw new Error("Invalid IV parameter.");
  }
  this._iv = transformIV$1(options.iv);
  this._inBlock = this._iv.slice(0);
  this._partialBytes = 0;
};
modes$1.ofb.prototype.encrypt = function(input, output, finish2) {
  var inputLength = input.length();
  if (input.length() === 0) {
    return true;
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  if (this._partialBytes === 0 && inputLength >= this.blockSize) {
    for (var i2 = 0; i2 < this._ints; ++i2) {
      output.putInt32(input.getInt32() ^ this._outBlock[i2]);
      this._inBlock[i2] = this._outBlock[i2];
    }
    return;
  }
  var partialBytes = (this.blockSize - inputLength) % this.blockSize;
  if (partialBytes > 0) {
    partialBytes = this.blockSize - partialBytes;
  }
  this._partialOutput.clear();
  for (var i2 = 0; i2 < this._ints; ++i2) {
    this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
  }
  if (partialBytes > 0) {
    input.read -= this.blockSize;
  } else {
    for (var i2 = 0; i2 < this._ints; ++i2) {
      this._inBlock[i2] = this._outBlock[i2];
    }
  }
  if (this._partialBytes > 0) {
    this._partialOutput.getBytes(this._partialBytes);
  }
  if (partialBytes > 0 && !finish2) {
    output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
    this._partialBytes = partialBytes;
    return true;
  }
  output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
  this._partialBytes = 0;
};
modes$1.ofb.prototype.decrypt = modes$1.ofb.prototype.encrypt;
modes$1.ctr = function(options) {
  options = options || {};
  this.name = "CTR";
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = null;
  this._outBlock = new Array(this._ints);
  this._partialOutput = forge$H.util.createBuffer();
  this._partialBytes = 0;
};
modes$1.ctr.prototype.start = function(options) {
  if (!("iv" in options)) {
    throw new Error("Invalid IV parameter.");
  }
  this._iv = transformIV$1(options.iv);
  this._inBlock = this._iv.slice(0);
  this._partialBytes = 0;
};
modes$1.ctr.prototype.encrypt = function(input, output, finish2) {
  var inputLength = input.length();
  if (inputLength === 0) {
    return true;
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  if (this._partialBytes === 0 && inputLength >= this.blockSize) {
    for (var i2 = 0; i2 < this._ints; ++i2) {
      output.putInt32(input.getInt32() ^ this._outBlock[i2]);
    }
  } else {
    var partialBytes = (this.blockSize - inputLength) % this.blockSize;
    if (partialBytes > 0) {
      partialBytes = this.blockSize - partialBytes;
    }
    this._partialOutput.clear();
    for (var i2 = 0; i2 < this._ints; ++i2) {
      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
    }
    if (partialBytes > 0) {
      input.read -= this.blockSize;
    }
    if (this._partialBytes > 0) {
      this._partialOutput.getBytes(this._partialBytes);
    }
    if (partialBytes > 0 && !finish2) {
      output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
      this._partialBytes = partialBytes;
      return true;
    }
    output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
    this._partialBytes = 0;
  }
  inc32$1(this._inBlock);
};
modes$1.ctr.prototype.decrypt = modes$1.ctr.prototype.encrypt;
modes$1.gcm = function(options) {
  options = options || {};
  this.name = "GCM";
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = new Array(this._ints);
  this._outBlock = new Array(this._ints);
  this._partialOutput = forge$H.util.createBuffer();
  this._partialBytes = 0;
  this._R = 3774873600;
};
modes$1.gcm.prototype.start = function(options) {
  if (!("iv" in options)) {
    throw new Error("Invalid IV parameter.");
  }
  var iv = forge$H.util.createBuffer(options.iv);
  this._cipherLength = 0;
  var additionalData;
  if ("additionalData" in options) {
    additionalData = forge$H.util.createBuffer(options.additionalData);
  } else {
    additionalData = forge$H.util.createBuffer();
  }
  if ("tagLength" in options) {
    this._tagLength = options.tagLength;
  } else {
    this._tagLength = 128;
  }
  this._tag = null;
  if (options.decrypt) {
    this._tag = forge$H.util.createBuffer(options.tag).getBytes();
    if (this._tag.length !== this._tagLength / 8) {
      throw new Error("Authentication tag does not match tag length.");
    }
  }
  this._hashBlock = new Array(this._ints);
  this.tag = null;
  this._hashSubkey = new Array(this._ints);
  this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);
  this.componentBits = 4;
  this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
  var ivLength = iv.length();
  if (ivLength === 12) {
    this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];
  } else {
    this._j0 = [0, 0, 0, 0];
    while (iv.length() > 0) {
      this._j0 = this.ghash(this._hashSubkey, this._j0, [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]);
    }
    this._j0 = this.ghash(this._hashSubkey, this._j0, [0, 0].concat(from64To32$1(ivLength * 8)));
  }
  this._inBlock = this._j0.slice(0);
  inc32$1(this._inBlock);
  this._partialBytes = 0;
  additionalData = forge$H.util.createBuffer(additionalData);
  this._aDataLength = from64To32$1(additionalData.length() * 8);
  var overflow = additionalData.length() % this.blockSize;
  if (overflow) {
    additionalData.fillWithByte(0, this.blockSize - overflow);
  }
  this._s = [0, 0, 0, 0];
  while (additionalData.length() > 0) {
    this._s = this.ghash(this._hashSubkey, this._s, [additionalData.getInt32(), additionalData.getInt32(), additionalData.getInt32(), additionalData.getInt32()]);
  }
};
modes$1.gcm.prototype.encrypt = function(input, output, finish2) {
  var inputLength = input.length();
  if (inputLength === 0) {
    return true;
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  if (this._partialBytes === 0 && inputLength >= this.blockSize) {
    for (var i2 = 0; i2 < this._ints; ++i2) {
      output.putInt32(this._outBlock[i2] ^= input.getInt32());
    }
    this._cipherLength += this.blockSize;
  } else {
    var partialBytes = (this.blockSize - inputLength) % this.blockSize;
    if (partialBytes > 0) {
      partialBytes = this.blockSize - partialBytes;
    }
    this._partialOutput.clear();
    for (var i2 = 0; i2 < this._ints; ++i2) {
      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
    }
    if (partialBytes <= 0 || finish2) {
      if (finish2) {
        var overflow = inputLength % this.blockSize;
        this._cipherLength += overflow;
        this._partialOutput.truncate(this.blockSize - overflow);
      } else {
        this._cipherLength += this.blockSize;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._outBlock[i2] = this._partialOutput.getInt32();
      }
      this._partialOutput.read -= this.blockSize;
    }
    if (this._partialBytes > 0) {
      this._partialOutput.getBytes(this._partialBytes);
    }
    if (partialBytes > 0 && !finish2) {
      input.read -= this.blockSize;
      output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
      this._partialBytes = partialBytes;
      return true;
    }
    output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
    this._partialBytes = 0;
  }
  this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);
  inc32$1(this._inBlock);
};
modes$1.gcm.prototype.decrypt = function(input, output, finish2) {
  var inputLength = input.length();
  if (inputLength < this.blockSize && !(finish2 && inputLength > 0)) {
    return true;
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  inc32$1(this._inBlock);
  this._hashBlock[0] = input.getInt32();
  this._hashBlock[1] = input.getInt32();
  this._hashBlock[2] = input.getInt32();
  this._hashBlock[3] = input.getInt32();
  this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
  for (var i2 = 0; i2 < this._ints; ++i2) {
    output.putInt32(this._outBlock[i2] ^ this._hashBlock[i2]);
  }
  if (inputLength < this.blockSize) {
    this._cipherLength += inputLength % this.blockSize;
  } else {
    this._cipherLength += this.blockSize;
  }
};
modes$1.gcm.prototype.afterFinish = function(output, options) {
  var rval = true;
  if (options.decrypt && options.overflow) {
    output.truncate(this.blockSize - options.overflow);
  }
  this.tag = forge$H.util.createBuffer();
  var lengths2 = this._aDataLength.concat(from64To32$1(this._cipherLength * 8));
  this._s = this.ghash(this._hashSubkey, this._s, lengths2);
  var tag = [];
  this.cipher.encrypt(this._j0, tag);
  for (var i2 = 0; i2 < this._ints; ++i2) {
    this.tag.putInt32(this._s[i2] ^ tag[i2]);
  }
  this.tag.truncate(this.tag.length() % (this._tagLength / 8));
  if (options.decrypt && this.tag.bytes() !== this._tag) {
    rval = false;
  }
  return rval;
};
modes$1.gcm.prototype.multiply = function(x2, y3) {
  var z_i = [0, 0, 0, 0];
  var v_i = y3.slice(0);
  for (var i2 = 0; i2 < 128; ++i2) {
    var x_i = x2[i2 / 32 | 0] & 1 << 31 - i2 % 32;
    if (x_i) {
      z_i[0] ^= v_i[0];
      z_i[1] ^= v_i[1];
      z_i[2] ^= v_i[2];
      z_i[3] ^= v_i[3];
    }
    this.pow(v_i, v_i);
  }
  return z_i;
};
modes$1.gcm.prototype.pow = function(x2, out) {
  var lsb = x2[3] & 1;
  for (var i2 = 3; i2 > 0; --i2) {
    out[i2] = x2[i2] >>> 1 | (x2[i2 - 1] & 1) << 31;
  }
  out[0] = x2[0] >>> 1;
  if (lsb) {
    out[0] ^= this._R;
  }
};
modes$1.gcm.prototype.tableMultiply = function(x2) {
  var z2 = [0, 0, 0, 0];
  for (var i2 = 0; i2 < 32; ++i2) {
    var idx = i2 / 8 | 0;
    var x_i = x2[idx] >>> (7 - i2 % 8) * 4 & 15;
    var ah = this._m[i2][x_i];
    z2[0] ^= ah[0];
    z2[1] ^= ah[1];
    z2[2] ^= ah[2];
    z2[3] ^= ah[3];
  }
  return z2;
};
modes$1.gcm.prototype.ghash = function(h2, y3, x2) {
  y3[0] ^= x2[0];
  y3[1] ^= x2[1];
  y3[2] ^= x2[2];
  y3[3] ^= x2[3];
  return this.tableMultiply(y3);
};
modes$1.gcm.prototype.generateHashTable = function(h2, bits) {
  var multiplier = 8 / bits;
  var perInt = 4 * multiplier;
  var size = 16 * multiplier;
  var m2 = new Array(size);
  for (var i2 = 0; i2 < size; ++i2) {
    var tmp = [0, 0, 0, 0];
    var idx = i2 / perInt | 0;
    var shft = (perInt - 1 - i2 % perInt) * bits;
    tmp[idx] = 1 << bits - 1 << shft;
    m2[i2] = this.generateSubHashTable(this.multiply(tmp, h2), bits);
  }
  return m2;
};
modes$1.gcm.prototype.generateSubHashTable = function(mid, bits) {
  var size = 1 << bits;
  var half = size >>> 1;
  var m2 = new Array(size);
  m2[half] = mid.slice(0);
  var i2 = half >>> 1;
  while (i2 > 0) {
    this.pow(m2[2 * i2], m2[i2] = []);
    i2 >>= 1;
  }
  i2 = 2;
  while (i2 < half) {
    for (var j3 = 1; j3 < i2; ++j3) {
      var m_i = m2[i2];
      var m_j = m2[j3];
      m2[i2 + j3] = [m_i[0] ^ m_j[0], m_i[1] ^ m_j[1], m_i[2] ^ m_j[2], m_i[3] ^ m_j[3]];
    }
    i2 *= 2;
  }
  m2[0] = [0, 0, 0, 0];
  for (i2 = half + 1; i2 < size; ++i2) {
    var c3 = m2[i2 ^ half];
    m2[i2] = [mid[0] ^ c3[0], mid[1] ^ c3[1], mid[2] ^ c3[2], mid[3] ^ c3[3]];
  }
  return m2;
};
function transformIV$1(iv) {
  if (typeof iv === "string") {
    iv = forge$H.util.createBuffer(iv);
  }
  if (forge$H.util.isArray(iv) && iv.length > 4) {
    var tmp = iv;
    iv = forge$H.util.createBuffer();
    for (var i2 = 0; i2 < tmp.length; ++i2) {
      iv.putByte(tmp[i2]);
    }
  }
  if (!forge$H.util.isArray(iv)) {
    iv = [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()];
  }
  return iv;
}
function inc32$1(block) {
  block[block.length - 1] = block[block.length - 1] + 1 & 4294967295;
}
function from64To32$1(num) {
  return [num / 4294967296 | 0, num & 4294967295];
}
var forge$G = forge$R;
var aes$2 = forge$G.aes = forge$G.aes || {};
forge$G.aes.startEncrypting = function(key3, iv, output, mode) {
  var cipher = _createCipher$3({ key: key3, output, decrypt: false, mode });
  cipher.start(iv);
  return cipher;
};
forge$G.aes.createEncryptionCipher = function(key3, mode) {
  return _createCipher$3({ key: key3, output: null, decrypt: false, mode });
};
forge$G.aes.startDecrypting = function(key3, iv, output, mode) {
  var cipher = _createCipher$3({ key: key3, output, decrypt: true, mode });
  cipher.start(iv);
  return cipher;
};
forge$G.aes.createDecryptionCipher = function(key3, mode) {
  return _createCipher$3({ key: key3, output: null, decrypt: true, mode });
};
forge$G.aes.Algorithm = function(name2, mode) {
  if (!init$1) {
    initialize$1();
  }
  var self2 = this;
  self2.name = name2;
  self2.mode = new mode({ blockSize: 16, cipher: { encrypt: function encrypt(inBlock, outBlock) {
    return _updateBlock$3(self2._w, inBlock, outBlock, false);
  }, decrypt: function decrypt(inBlock, outBlock) {
    return _updateBlock$3(self2._w, inBlock, outBlock, true);
  } } });
  self2._init = false;
};
forge$G.aes.Algorithm.prototype.initialize = function(options) {
  if (this._init) {
    return;
  }
  var key3 = options.key;
  var tmp;
  if (typeof key3 === "string" && (key3.length === 16 || key3.length === 24 || key3.length === 32)) {
    key3 = forge$G.util.createBuffer(key3);
  } else if (forge$G.util.isArray(key3) && (key3.length === 16 || key3.length === 24 || key3.length === 32)) {
    tmp = key3;
    key3 = forge$G.util.createBuffer();
    for (var i2 = 0; i2 < tmp.length; ++i2) {
      key3.putByte(tmp[i2]);
    }
  }
  if (!forge$G.util.isArray(key3)) {
    tmp = key3;
    key3 = [];
    var len2 = tmp.length();
    if (len2 === 16 || len2 === 24 || len2 === 32) {
      len2 = len2 >>> 2;
      for (var i2 = 0; i2 < len2; ++i2) {
        key3.push(tmp.getInt32());
      }
    }
  }
  if (!forge$G.util.isArray(key3) || !(key3.length === 4 || key3.length === 6 || key3.length === 8)) {
    throw new Error("Invalid key parameter.");
  }
  var mode = this.mode.name;
  var encryptOp = ["CFB", "OFB", "CTR", "GCM"].indexOf(mode) !== -1;
  this._w = _expandKey$1(key3, options.decrypt && !encryptOp);
  this._init = true;
};
forge$G.aes._expandKey = function(key3, decrypt) {
  if (!init$1) {
    initialize$1();
  }
  return _expandKey$1(key3, decrypt);
};
forge$G.aes._updateBlock = _updateBlock$3;
registerAlgorithm$3("AES-ECB", forge$G.cipher.modes.ecb);
registerAlgorithm$3("AES-CBC", forge$G.cipher.modes.cbc);
registerAlgorithm$3("AES-CFB", forge$G.cipher.modes.cfb);
registerAlgorithm$3("AES-OFB", forge$G.cipher.modes.ofb);
registerAlgorithm$3("AES-CTR", forge$G.cipher.modes.ctr);
registerAlgorithm$3("AES-GCM", forge$G.cipher.modes.gcm);
function registerAlgorithm$3(name2, mode) {
  var factory2 = function factory3() {
    return new forge$G.aes.Algorithm(name2, mode);
  };
  forge$G.cipher.registerAlgorithm(name2, factory2);
}
var init$1 = false;
var Nb$1 = 4;
var sbox$1;
var isbox$1;
var rcon$1;
var mix$1;
var imix$1;
function initialize$1() {
  init$1 = true;
  rcon$1 = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
  var xtime = new Array(256);
  for (var i2 = 0; i2 < 128; ++i2) {
    xtime[i2] = i2 << 1;
    xtime[i2 + 128] = i2 + 128 << 1 ^ 283;
  }
  sbox$1 = new Array(256);
  isbox$1 = new Array(256);
  mix$1 = new Array(4);
  imix$1 = new Array(4);
  for (var i2 = 0; i2 < 4; ++i2) {
    mix$1[i2] = new Array(256);
    imix$1[i2] = new Array(256);
  }
  var e2 = 0, ei = 0, e22, e4, e8, sx, sx2, me, ime;
  for (var i2 = 0; i2 < 256; ++i2) {
    sx = ei ^ ei << 1 ^ ei << 2 ^ ei << 3 ^ ei << 4;
    sx = sx >> 8 ^ sx & 255 ^ 99;
    sbox$1[e2] = sx;
    isbox$1[sx] = e2;
    sx2 = xtime[sx];
    e22 = xtime[e2];
    e4 = xtime[e22];
    e8 = xtime[e4];
    me = sx2 << 24 ^ // 2
    sx << 16 ^ // 1
    sx << 8 ^ // 1
    (sx ^ sx2);
    ime = (e22 ^ e4 ^ e8) << 24 ^ // E (14)
    (e2 ^ e8) << 16 ^ // 9
    (e2 ^ e4 ^ e8) << 8 ^ // D (13)
    (e2 ^ e22 ^ e8);
    for (var n2 = 0; n2 < 4; ++n2) {
      mix$1[n2][e2] = me;
      imix$1[n2][sx] = ime;
      me = me << 24 | me >>> 8;
      ime = ime << 24 | ime >>> 8;
    }
    if (e2 === 0) {
      e2 = ei = 1;
    } else {
      e2 = e22 ^ xtime[xtime[xtime[e22 ^ e8]]];
      ei ^= xtime[xtime[ei]];
    }
  }
}
function _expandKey$1(key3, decrypt) {
  var w2 = key3.slice(0);
  var temp, iNk = 1;
  var Nk = w2.length;
  var Nr1 = Nk + 6 + 1;
  var end2 = Nb$1 * Nr1;
  for (var i2 = Nk; i2 < end2; ++i2) {
    temp = w2[i2 - 1];
    if (i2 % Nk === 0) {
      temp = sbox$1[temp >>> 16 & 255] << 24 ^ sbox$1[temp >>> 8 & 255] << 16 ^ sbox$1[temp & 255] << 8 ^ sbox$1[temp >>> 24] ^ rcon$1[iNk] << 24;
      iNk++;
    } else if (Nk > 6 && i2 % Nk === 4) {
      temp = sbox$1[temp >>> 24] << 24 ^ sbox$1[temp >>> 16 & 255] << 16 ^ sbox$1[temp >>> 8 & 255] << 8 ^ sbox$1[temp & 255];
    }
    w2[i2] = w2[i2 - Nk] ^ temp;
  }
  if (decrypt) {
    var tmp;
    var m0 = imix$1[0];
    var m1 = imix$1[1];
    var m2 = imix$1[2];
    var m3 = imix$1[3];
    var wnew = w2.slice(0);
    end2 = w2.length;
    for (var i2 = 0, wi = end2 - Nb$1; i2 < end2; i2 += Nb$1, wi -= Nb$1) {
      if (i2 === 0 || i2 === end2 - Nb$1) {
        wnew[i2] = w2[wi];
        wnew[i2 + 1] = w2[wi + 3];
        wnew[i2 + 2] = w2[wi + 2];
        wnew[i2 + 3] = w2[wi + 1];
      } else {
        for (var n2 = 0; n2 < Nb$1; ++n2) {
          tmp = w2[wi + n2];
          wnew[i2 + (3 & -n2)] = m0[sbox$1[tmp >>> 24]] ^ m1[sbox$1[tmp >>> 16 & 255]] ^ m2[sbox$1[tmp >>> 8 & 255]] ^ m3[sbox$1[tmp & 255]];
        }
      }
    }
    w2 = wnew;
  }
  return w2;
}
function _updateBlock$3(w2, input, output, decrypt) {
  var Nr = w2.length / 4 - 1;
  var m0, m1, m2, m3, sub;
  if (decrypt) {
    m0 = imix$1[0];
    m1 = imix$1[1];
    m2 = imix$1[2];
    m3 = imix$1[3];
    sub = isbox$1;
  } else {
    m0 = mix$1[0];
    m1 = mix$1[1];
    m2 = mix$1[2];
    m3 = mix$1[3];
    sub = sbox$1;
  }
  var a2, b3, c3, d2, a22, b22, c22;
  a2 = input[0] ^ w2[0];
  b3 = input[decrypt ? 3 : 1] ^ w2[1];
  c3 = input[2] ^ w2[2];
  d2 = input[decrypt ? 1 : 3] ^ w2[3];
  var i2 = 3;
  for (var round = 1; round < Nr; ++round) {
    a22 = m0[a2 >>> 24] ^ m1[b3 >>> 16 & 255] ^ m2[c3 >>> 8 & 255] ^ m3[d2 & 255] ^ w2[++i2];
    b22 = m0[b3 >>> 24] ^ m1[c3 >>> 16 & 255] ^ m2[d2 >>> 8 & 255] ^ m3[a2 & 255] ^ w2[++i2];
    c22 = m0[c3 >>> 24] ^ m1[d2 >>> 16 & 255] ^ m2[a2 >>> 8 & 255] ^ m3[b3 & 255] ^ w2[++i2];
    d2 = m0[d2 >>> 24] ^ m1[a2 >>> 16 & 255] ^ m2[b3 >>> 8 & 255] ^ m3[c3 & 255] ^ w2[++i2];
    a2 = a22;
    b3 = b22;
    c3 = c22;
  }
  output[0] = sub[a2 >>> 24] << 24 ^ sub[b3 >>> 16 & 255] << 16 ^ sub[c3 >>> 8 & 255] << 8 ^ sub[d2 & 255] ^ w2[++i2];
  output[decrypt ? 3 : 1] = sub[b3 >>> 24] << 24 ^ sub[c3 >>> 16 & 255] << 16 ^ sub[d2 >>> 8 & 255] << 8 ^ sub[a2 & 255] ^ w2[++i2];
  output[2] = sub[c3 >>> 24] << 24 ^ sub[d2 >>> 16 & 255] << 16 ^ sub[a2 >>> 8 & 255] << 8 ^ sub[b3 & 255] ^ w2[++i2];
  output[decrypt ? 1 : 3] = sub[d2 >>> 24] << 24 ^ sub[a2 >>> 16 & 255] << 16 ^ sub[b3 >>> 8 & 255] << 8 ^ sub[c3 & 255] ^ w2[++i2];
}
function _createCipher$3(options) {
  options = options || {};
  var mode = (options.mode || "CBC").toUpperCase();
  var algorithm = "AES-" + mode;
  var cipher;
  if (options.decrypt) {
    cipher = forge$G.cipher.createDecipher(algorithm, options.key);
  } else {
    cipher = forge$G.cipher.createCipher(algorithm, options.key);
  }
  var start = cipher.start;
  cipher.start = function(iv, options2) {
    var output = null;
    if (options2 instanceof forge$G.util.ByteBuffer) {
      output = options2;
      options2 = {};
    }
    options2 = options2 || {};
    options2.output = output;
    options2.iv = iv;
    start.call(cipher, options2);
  };
  return cipher;
}
var aes$3 = getDefaultExportFromCjs(aes$2);
var forge$F = forge$R;
var des = forge$F.des = forge$F.des || {};
forge$F.des.startEncrypting = function(key3, iv, output, mode) {
  var cipher = _createCipher$2({ key: key3, output, decrypt: false, mode: mode || (iv === null ? "ECB" : "CBC") });
  cipher.start(iv);
  return cipher;
};
forge$F.des.createEncryptionCipher = function(key3, mode) {
  return _createCipher$2({ key: key3, output: null, decrypt: false, mode });
};
forge$F.des.startDecrypting = function(key3, iv, output, mode) {
  var cipher = _createCipher$2({ key: key3, output, decrypt: true, mode: mode || (iv === null ? "ECB" : "CBC") });
  cipher.start(iv);
  return cipher;
};
forge$F.des.createDecryptionCipher = function(key3, mode) {
  return _createCipher$2({ key: key3, output: null, decrypt: true, mode });
};
forge$F.des.Algorithm = function(name2, mode) {
  var self2 = this;
  self2.name = name2;
  self2.mode = new mode({ blockSize: 8, cipher: { encrypt: function encrypt(inBlock, outBlock) {
    return _updateBlock$2(self2._keys, inBlock, outBlock, false);
  }, decrypt: function decrypt(inBlock, outBlock) {
    return _updateBlock$2(self2._keys, inBlock, outBlock, true);
  } } });
  self2._init = false;
};
forge$F.des.Algorithm.prototype.initialize = function(options) {
  if (this._init) {
    return;
  }
  var key3 = forge$F.util.createBuffer(options.key);
  if (this.name.indexOf("3DES") === 0) {
    if (key3.length() !== 24) {
      throw new Error("Invalid Triple-DES key size: " + key3.length() * 8);
    }
  }
  this._keys = _createKeys$1(key3);
  this._init = true;
};
registerAlgorithm$2("DES-ECB", forge$F.cipher.modes.ecb);
registerAlgorithm$2("DES-CBC", forge$F.cipher.modes.cbc);
registerAlgorithm$2("DES-CFB", forge$F.cipher.modes.cfb);
registerAlgorithm$2("DES-OFB", forge$F.cipher.modes.ofb);
registerAlgorithm$2("DES-CTR", forge$F.cipher.modes.ctr);
registerAlgorithm$2("3DES-ECB", forge$F.cipher.modes.ecb);
registerAlgorithm$2("3DES-CBC", forge$F.cipher.modes.cbc);
registerAlgorithm$2("3DES-CFB", forge$F.cipher.modes.cfb);
registerAlgorithm$2("3DES-OFB", forge$F.cipher.modes.ofb);
registerAlgorithm$2("3DES-CTR", forge$F.cipher.modes.ctr);
function registerAlgorithm$2(name2, mode) {
  var factory2 = function factory3() {
    return new forge$F.des.Algorithm(name2, mode);
  };
  forge$F.cipher.registerAlgorithm(name2, factory2);
}
var spfunction1$1 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756];
var spfunction2$1 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344];
var spfunction3$1 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584];
var spfunction4$1 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928];
var spfunction5$1 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080];
var spfunction6$1 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312];
var spfunction7$1 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154];
var spfunction8$1 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
function _createKeys$1(key3) {
  var pc2bytes0 = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], pc2bytes1 = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], pc2bytes2 = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], pc2bytes3 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], pc2bytes4 = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], pc2bytes5 = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], pc2bytes6 = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], pc2bytes7 = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], pc2bytes8 = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], pc2bytes9 = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], pc2bytes10 = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], pc2bytes11 = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], pc2bytes12 = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], pc2bytes13 = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261];
  var iterations = key3.length() > 8 ? 3 : 1;
  var keys2 = [];
  var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];
  var n2 = 0, tmp;
  for (var j3 = 0; j3 < iterations; j3++) {
    var left = key3.getInt32();
    var right = key3.getInt32();
    tmp = (left >>> 4 ^ right) & 252645135;
    right ^= tmp;
    left ^= tmp << 4;
    tmp = (right >>> -16 ^ left) & 65535;
    left ^= tmp;
    right ^= tmp << -16;
    tmp = (left >>> 2 ^ right) & 858993459;
    right ^= tmp;
    left ^= tmp << 2;
    tmp = (right >>> -16 ^ left) & 65535;
    left ^= tmp;
    right ^= tmp << -16;
    tmp = (left >>> 1 ^ right) & 1431655765;
    right ^= tmp;
    left ^= tmp << 1;
    tmp = (right >>> 8 ^ left) & 16711935;
    left ^= tmp;
    right ^= tmp << 8;
    tmp = (left >>> 1 ^ right) & 1431655765;
    right ^= tmp;
    left ^= tmp << 1;
    tmp = left << 8 | right >>> 20 & 240;
    left = right << 24 | right << 8 & 16711680 | right >>> 8 & 65280 | right >>> 24 & 240;
    right = tmp;
    for (var i2 = 0; i2 < shifts.length; ++i2) {
      if (shifts[i2]) {
        left = left << 2 | left >>> 26;
        right = right << 2 | right >>> 26;
      } else {
        left = left << 1 | left >>> 27;
        right = right << 1 | right >>> 27;
      }
      left &= -15;
      right &= -15;
      var lefttmp = pc2bytes0[left >>> 28] | pc2bytes1[left >>> 24 & 15] | pc2bytes2[left >>> 20 & 15] | pc2bytes3[left >>> 16 & 15] | pc2bytes4[left >>> 12 & 15] | pc2bytes5[left >>> 8 & 15] | pc2bytes6[left >>> 4 & 15];
      var righttmp = pc2bytes7[right >>> 28] | pc2bytes8[right >>> 24 & 15] | pc2bytes9[right >>> 20 & 15] | pc2bytes10[right >>> 16 & 15] | pc2bytes11[right >>> 12 & 15] | pc2bytes12[right >>> 8 & 15] | pc2bytes13[right >>> 4 & 15];
      tmp = (righttmp >>> 16 ^ lefttmp) & 65535;
      keys2[n2++] = lefttmp ^ tmp;
      keys2[n2++] = righttmp ^ tmp << 16;
    }
  }
  return keys2;
}
function _updateBlock$2(keys2, input, output, decrypt) {
  var iterations = keys2.length === 32 ? 3 : 9;
  var looping;
  if (iterations === 3) {
    looping = decrypt ? [30, -2, -2] : [0, 32, 2];
  } else {
    looping = decrypt ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
  }
  var tmp;
  var left = input[0];
  var right = input[1];
  tmp = (left >>> 4 ^ right) & 252645135;
  right ^= tmp;
  left ^= tmp << 4;
  tmp = (left >>> 16 ^ right) & 65535;
  right ^= tmp;
  left ^= tmp << 16;
  tmp = (right >>> 2 ^ left) & 858993459;
  left ^= tmp;
  right ^= tmp << 2;
  tmp = (right >>> 8 ^ left) & 16711935;
  left ^= tmp;
  right ^= tmp << 8;
  tmp = (left >>> 1 ^ right) & 1431655765;
  right ^= tmp;
  left ^= tmp << 1;
  left = left << 1 | left >>> 31;
  right = right << 1 | right >>> 31;
  for (var j3 = 0; j3 < iterations; j3 += 3) {
    var endloop = looping[j3 + 1];
    var loopinc = looping[j3 + 2];
    for (var i2 = looping[j3]; i2 != endloop; i2 += loopinc) {
      var right1 = right ^ keys2[i2];
      var right2 = (right >>> 4 | right << 28) ^ keys2[i2 + 1];
      tmp = left;
      left = right;
      right = tmp ^ (spfunction2$1[right1 >>> 24 & 63] | spfunction4$1[right1 >>> 16 & 63] | spfunction6$1[right1 >>> 8 & 63] | spfunction8$1[right1 & 63] | spfunction1$1[right2 >>> 24 & 63] | spfunction3$1[right2 >>> 16 & 63] | spfunction5$1[right2 >>> 8 & 63] | spfunction7$1[right2 & 63]);
    }
    tmp = left;
    left = right;
    right = tmp;
  }
  left = left >>> 1 | left << 31;
  right = right >>> 1 | right << 31;
  tmp = (left >>> 1 ^ right) & 1431655765;
  right ^= tmp;
  left ^= tmp << 1;
  tmp = (right >>> 8 ^ left) & 16711935;
  left ^= tmp;
  right ^= tmp << 8;
  tmp = (right >>> 2 ^ left) & 858993459;
  left ^= tmp;
  right ^= tmp << 2;
  tmp = (left >>> 16 ^ right) & 65535;
  right ^= tmp;
  left ^= tmp << 16;
  tmp = (left >>> 4 ^ right) & 252645135;
  right ^= tmp;
  left ^= tmp << 4;
  output[0] = left;
  output[1] = right;
}
function _createCipher$2(options) {
  options = options || {};
  var mode = (options.mode || "CBC").toUpperCase();
  var algorithm = "DES-" + mode;
  var cipher;
  if (options.decrypt) {
    cipher = forge$F.cipher.createDecipher(algorithm, options.key);
  } else {
    cipher = forge$F.cipher.createCipher(algorithm, options.key);
  }
  var start = cipher.start;
  cipher.start = function(iv, options2) {
    var output = null;
    if (options2 instanceof forge$F.util.ByteBuffer) {
      output = options2;
      options2 = {};
    }
    options2 = options2 || {};
    options2.output = output;
    options2.iv = iv;
    start.call(cipher, options2);
  };
  return cipher;
}
var des$1 = getDefaultExportFromCjs(des);
var forge$E = forge$R;
var piTable$1 = [217, 120, 249, 196, 25, 221, 181, 237, 40, 233, 253, 121, 74, 160, 216, 157, 198, 126, 55, 131, 43, 118, 83, 142, 98, 76, 100, 136, 68, 139, 251, 162, 23, 154, 89, 245, 135, 179, 79, 19, 97, 69, 109, 141, 9, 129, 125, 50, 189, 143, 64, 235, 134, 183, 123, 11, 240, 149, 33, 34, 92, 107, 78, 130, 84, 214, 101, 147, 206, 96, 178, 28, 115, 86, 192, 20, 167, 140, 241, 220, 18, 117, 202, 31, 59, 190, 228, 209, 66, 61, 212, 48, 163, 60, 182, 38, 111, 191, 14, 218, 70, 105, 7, 87, 39, 242, 29, 155, 188, 148, 67, 3, 248, 17, 199, 246, 144, 239, 62, 231, 6, 195, 213, 47, 200, 102, 30, 215, 8, 232, 234, 222, 128, 82, 238, 247, 132, 170, 114, 172, 53, 77, 106, 42, 150, 26, 210, 113, 90, 21, 73, 116, 75, 159, 208, 94, 4, 24, 164, 236, 194, 224, 65, 110, 15, 81, 203, 204, 36, 145, 175, 80, 161, 244, 112, 57, 153, 124, 58, 133, 35, 184, 180, 122, 252, 2, 54, 91, 37, 85, 151, 49, 45, 93, 250, 152, 227, 138, 146, 174, 5, 223, 41, 16, 103, 108, 186, 201, 211, 0, 230, 207, 225, 158, 168, 44, 99, 22, 1, 63, 88, 226, 137, 169, 13, 56, 52, 27, 171, 51, 255, 176, 187, 72, 12, 95, 185, 177, 205, 46, 197, 243, 219, 71, 229, 165, 156, 119, 10, 166, 32, 104, 254, 127, 193, 173];
var s$2 = [1, 2, 3, 5];
var rol$1 = function rol$12(word, bits) {
  return word << bits & 65535 | (word & 65535) >> 16 - bits;
};
var ror$1 = function ror$12(word, bits) {
  return (word & 65535) >> bits | word << 16 - bits & 65535;
};
var rc2 = forge$E.rc2 = forge$E.rc2 || {};
forge$E.rc2.expandKey = function(key3, effKeyBits) {
  if (typeof key3 === "string") {
    key3 = forge$E.util.createBuffer(key3);
  }
  effKeyBits = effKeyBits || 128;
  var L2 = key3;
  var T3 = key3.length();
  var T1 = effKeyBits;
  var T8 = Math.ceil(T1 / 8);
  var TM = 255 >> (T1 & 7);
  var i2;
  for (i2 = T3; i2 < 128; i2++) {
    L2.putByte(piTable$1[L2.at(i2 - 1) + L2.at(i2 - T3) & 255]);
  }
  L2.setAt(128 - T8, piTable$1[L2.at(128 - T8) & TM]);
  for (i2 = 127 - T8; i2 >= 0; i2--) {
    L2.setAt(i2, piTable$1[L2.at(i2 + 1) ^ L2.at(i2 + T8)]);
  }
  return L2;
};
var createCipher$1 = function createCipher$12(key3, bits, encrypt) {
  var _finish = false, _input = null, _output = null, _iv = null;
  var mixRound, mashRound;
  var i2, j3, K2 = [];
  key3 = forge$E.rc2.expandKey(key3, bits);
  for (i2 = 0; i2 < 64; i2++) {
    K2.push(key3.getInt16Le());
  }
  if (encrypt) {
    mixRound = function mixRound2(R2) {
      for (i2 = 0; i2 < 4; i2++) {
        R2[i2] += K2[j3] + (R2[(i2 + 3) % 4] & R2[(i2 + 2) % 4]) + (~R2[(i2 + 3) % 4] & R2[(i2 + 1) % 4]);
        R2[i2] = rol$1(R2[i2], s$2[i2]);
        j3++;
      }
    };
    mashRound = function mashRound2(R2) {
      for (i2 = 0; i2 < 4; i2++) {
        R2[i2] += K2[R2[(i2 + 3) % 4] & 63];
      }
    };
  } else {
    mixRound = function mixRound2(R2) {
      for (i2 = 3; i2 >= 0; i2--) {
        R2[i2] = ror$1(R2[i2], s$2[i2]);
        R2[i2] -= K2[j3] + (R2[(i2 + 3) % 4] & R2[(i2 + 2) % 4]) + (~R2[(i2 + 3) % 4] & R2[(i2 + 1) % 4]);
        j3--;
      }
    };
    mashRound = function mashRound2(R2) {
      for (i2 = 3; i2 >= 0; i2--) {
        R2[i2] -= K2[R2[(i2 + 3) % 4] & 63];
      }
    };
  }
  var runPlan = function runPlan2(plan) {
    var R2 = [];
    for (i2 = 0; i2 < 4; i2++) {
      var val = _input.getInt16Le();
      if (_iv !== null) {
        if (encrypt) {
          val ^= _iv.getInt16Le();
        } else {
          _iv.putInt16Le(val);
        }
      }
      R2.push(val & 65535);
    }
    j3 = encrypt ? 0 : 63;
    for (var ptr = 0; ptr < plan.length; ptr++) {
      for (var ctr = 0; ctr < plan[ptr][0]; ctr++) {
        plan[ptr][1](R2);
      }
    }
    for (i2 = 0; i2 < 4; i2++) {
      if (_iv !== null) {
        if (encrypt) {
          _iv.putInt16Le(R2[i2]);
        } else {
          R2[i2] ^= _iv.getInt16Le();
        }
      }
      _output.putInt16Le(R2[i2]);
    }
  };
  var cipher = null;
  cipher = {
    /**
    * Starts or restarts the encryption or decryption process, whichever
    * was previously configured.
    *
    * To use the cipher in CBC mode, iv may be given either as a string
    * of bytes, or as a byte buffer.  For ECB mode, give null as iv.
    *
    * @param iv the initialization vector to use, null for ECB mode.
    * @param output the output the buffer to write to, null to create one.
    */
    start: function start(iv, output) {
      if (iv) {
        if (typeof iv === "string") {
          iv = forge$E.util.createBuffer(iv);
        }
      }
      _finish = false;
      _input = forge$E.util.createBuffer();
      _output = output || new forge$E.util.createBuffer();
      _iv = iv;
      cipher.output = _output;
    },
    /**
    * Updates the next block.
    *
    * @param input the buffer to read from.
    */
    update: function update5(input) {
      if (!_finish) {
        _input.putBuffer(input);
      }
      while (_input.length() >= 8) {
        runPlan([[5, mixRound], [1, mashRound], [6, mixRound], [1, mashRound], [5, mixRound]]);
      }
    },
    /**
    * Finishes encrypting or decrypting.
    *
    * @param pad a padding function to use, null for PKCS#7 padding,
    *           signature(blockSize, buffer, decrypt).
    *
    * @return true if successful, false on error.
    */
    finish: function finish2(pad2) {
      var rval = true;
      if (encrypt) {
        if (pad2) {
          rval = pad2(8, _input, !encrypt);
        } else {
          var padding = _input.length() === 8 ? 8 : 8 - _input.length();
          _input.fillWithByte(padding, padding);
        }
      }
      if (rval) {
        _finish = true;
        cipher.update();
      }
      if (!encrypt) {
        rval = _input.length() === 0;
        if (rval) {
          if (pad2) {
            rval = pad2(8, _output, !encrypt);
          } else {
            var len2 = _output.length();
            var count = _output.at(len2 - 1);
            if (count > len2) {
              rval = false;
            } else {
              _output.truncate(count);
            }
          }
        }
      }
      return rval;
    }
  };
  return cipher;
};
forge$E.rc2.startEncrypting = function(key3, iv, output) {
  var cipher = forge$E.rc2.createEncryptionCipher(key3, 128);
  cipher.start(iv, output);
  return cipher;
};
forge$E.rc2.createEncryptionCipher = function(key3, bits) {
  return createCipher$1(key3, bits, true);
};
forge$E.rc2.startDecrypting = function(key3, iv, output) {
  var cipher = forge$E.rc2.createDecryptionCipher(key3, 128);
  cipher.start(iv, output);
  return cipher;
};
forge$E.rc2.createDecryptionCipher = function(key3, bits) {
  return createCipher$1(key3, bits, false);
};
var rc2$1 = getDefaultExportFromCjs(rc2);
var random$1 = { exports: {} };
var forge$D = forge$R;
var _crypto$3 = null;
if (forge$D.util.isNodejs && !forge$D.options.usePureJavaScript && !process.versions["node-webkit"]) {
  _crypto$3 = require$$0$4;
}
var prng$1 = forge$D.prng = forge$D.prng || {};
prng$1.create = function(plugin) {
  var ctx = {
    plugin,
    key: null,
    seed: null,
    time: null,
    // number of reseeds so far
    reseeds: 0,
    // amount of data generated so far
    generated: 0,
    // no initial key bytes
    keyBytes: ""
  };
  var md = plugin.md;
  var pools = new Array(32);
  for (var i2 = 0; i2 < 32; ++i2) {
    pools[i2] = md.create();
  }
  ctx.pools = pools;
  ctx.pool = 0;
  ctx.generate = function(count, callback) {
    if (!callback) {
      return ctx.generateSync(count);
    }
    var cipher = ctx.plugin.cipher;
    var increment = ctx.plugin.increment;
    var formatKey = ctx.plugin.formatKey;
    var formatSeed = ctx.plugin.formatSeed;
    var b3 = forge$D.util.createBuffer();
    ctx.key = null;
    generate2();
    function generate2(err) {
      if (err) {
        return callback(err);
      }
      if (b3.length() >= count) {
        return callback(null, b3.getBytes(count));
      }
      if (ctx.generated > 1048575) {
        ctx.key = null;
      }
      if (ctx.key === null) {
        return forge$D.util.nextTick(function() {
          _reseed(generate2);
        });
      }
      var bytes = cipher(ctx.key, ctx.seed);
      ctx.generated += bytes.length;
      b3.putBytes(bytes);
      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
      forge$D.util.setImmediate(generate2);
    }
  };
  ctx.generateSync = function(count) {
    var cipher = ctx.plugin.cipher;
    var increment = ctx.plugin.increment;
    var formatKey = ctx.plugin.formatKey;
    var formatSeed = ctx.plugin.formatSeed;
    ctx.key = null;
    var b3 = forge$D.util.createBuffer();
    while (b3.length() < count) {
      if (ctx.generated > 1048575) {
        ctx.key = null;
      }
      if (ctx.key === null) {
        _reseedSync();
      }
      var bytes = cipher(ctx.key, ctx.seed);
      ctx.generated += bytes.length;
      b3.putBytes(bytes);
      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
    }
    return b3.getBytes(count);
  };
  function _reseed(callback) {
    if (ctx.pools[0].messageLength >= 32) {
      _seed();
      return callback();
    }
    var needed = 32 - ctx.pools[0].messageLength << 5;
    ctx.seedFile(needed, function(err, bytes) {
      if (err) {
        return callback(err);
      }
      ctx.collect(bytes);
      _seed();
      callback();
    });
  }
  function _reseedSync() {
    if (ctx.pools[0].messageLength >= 32) {
      return _seed();
    }
    var needed = 32 - ctx.pools[0].messageLength << 5;
    ctx.collect(ctx.seedFileSync(needed));
    _seed();
  }
  function _seed() {
    ctx.reseeds = ctx.reseeds === 4294967295 ? 0 : ctx.reseeds + 1;
    var md2 = ctx.plugin.md.create();
    md2.update(ctx.keyBytes);
    var _2powK = 1;
    for (var k3 = 0; k3 < 32; ++k3) {
      if (ctx.reseeds % _2powK === 0) {
        md2.update(ctx.pools[k3].digest().getBytes());
        ctx.pools[k3].start();
      }
      _2powK = _2powK << 1;
    }
    ctx.keyBytes = md2.digest().getBytes();
    md2.start();
    md2.update(ctx.keyBytes);
    var seedBytes = md2.digest().getBytes();
    ctx.key = ctx.plugin.formatKey(ctx.keyBytes);
    ctx.seed = ctx.plugin.formatSeed(seedBytes);
    ctx.generated = 0;
  }
  function defaultSeedFile(needed) {
    var getRandomValues = null;
    var globalScope = forge$D.util.globalScope;
    var _crypto2 = globalScope.crypto || globalScope.msCrypto;
    if (_crypto2 && _crypto2.getRandomValues) {
      getRandomValues = function getRandomValues2(arr) {
        return _crypto2.getRandomValues(arr);
      };
    }
    var b3 = forge$D.util.createBuffer();
    if (getRandomValues) {
      while (b3.length() < needed) {
        var count = Math.max(1, Math.min(needed - b3.length(), 65536) / 4);
        var entropy = new Uint32Array(Math.floor(count));
        try {
          getRandomValues(entropy);
          for (var i3 = 0; i3 < entropy.length; ++i3) {
            b3.putInt32(entropy[i3]);
          }
        } catch (e2) {
          if (!(typeof QuotaExceededError !== "undefined" && e2 instanceof QuotaExceededError)) {
            throw e2;
          }
        }
      }
    }
    if (b3.length() < needed) {
      var hi, lo, next;
      var seed = Math.floor(Math.random() * 65536);
      while (b3.length() < needed) {
        lo = 16807 * (seed & 65535);
        hi = 16807 * (seed >> 16);
        lo += (hi & 32767) << 16;
        lo += hi >> 15;
        lo = (lo & 2147483647) + (lo >> 31);
        seed = lo & 4294967295;
        for (var i3 = 0; i3 < 3; ++i3) {
          next = seed >>> (i3 << 3);
          next ^= Math.floor(Math.random() * 256);
          b3.putByte(String.fromCharCode(next & 255));
        }
      }
    }
    return b3.getBytes(needed);
  }
  if (_crypto$3) {
    ctx.seedFile = function(needed, callback) {
      _crypto$3.randomBytes(needed, function(err, bytes) {
        if (err) {
          return callback(err);
        }
        callback(null, bytes.toString());
      });
    };
    ctx.seedFileSync = function(needed) {
      return _crypto$3.randomBytes(needed).toString();
    };
  } else {
    ctx.seedFile = function(needed, callback) {
      try {
        callback(null, defaultSeedFile(needed));
      } catch (e2) {
        callback(e2);
      }
    };
    ctx.seedFileSync = defaultSeedFile;
  }
  ctx.collect = function(bytes) {
    var count = bytes.length;
    for (var i3 = 0; i3 < count; ++i3) {
      ctx.pools[ctx.pool].update(bytes.substr(i3, 1));
      ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;
    }
  };
  ctx.collectInt = function(i3, n2) {
    var bytes = "";
    for (var x2 = 0; x2 < n2; x2 += 8) {
      bytes += String.fromCharCode(i3 >> x2 & 255);
    }
    ctx.collect(bytes);
  };
  ctx.registerWorker = function(worker) {
    if (worker === self) {
      ctx.seedFile = function(needed, callback) {
        function listener2(e2) {
          var data = e2.data;
          if (data.forge && data.forge.prng) {
            self.removeEventListener("message", listener2);
            callback(data.forge.prng.err, data.forge.prng.bytes);
          }
        }
        self.addEventListener("message", listener2);
        self.postMessage({ forge: { prng: { needed } } });
      };
    } else {
      var listener = function listener2(e2) {
        var data = e2.data;
        if (data.forge && data.forge.prng) {
          ctx.seedFile(data.forge.prng.needed, function(err, bytes) {
            worker.postMessage({ forge: { prng: { err, bytes } } });
          });
        }
      };
      worker.addEventListener("message", listener);
    }
  };
  return ctx;
};
var forge$C = forge$R;
(function() {
  if (forge$C.random && forge$C.random.getBytes) {
    random$1.exports = forge$C.random;
    return;
  }
  (function(jQuery2) {
    var prng_aes = {};
    var _prng_aes_output = new Array(4);
    var _prng_aes_buffer = forge$C.util.createBuffer();
    prng_aes.formatKey = function(key4) {
      var tmp = forge$C.util.createBuffer(key4);
      key4 = new Array(4);
      key4[0] = tmp.getInt32();
      key4[1] = tmp.getInt32();
      key4[2] = tmp.getInt32();
      key4[3] = tmp.getInt32();
      return forge$C.aes._expandKey(key4, false);
    };
    prng_aes.formatSeed = function(seed) {
      var tmp = forge$C.util.createBuffer(seed);
      seed = new Array(4);
      seed[0] = tmp.getInt32();
      seed[1] = tmp.getInt32();
      seed[2] = tmp.getInt32();
      seed[3] = tmp.getInt32();
      return seed;
    };
    prng_aes.cipher = function(key4, seed) {
      forge$C.aes._updateBlock(key4, seed, _prng_aes_output, false);
      _prng_aes_buffer.putInt32(_prng_aes_output[0]);
      _prng_aes_buffer.putInt32(_prng_aes_output[1]);
      _prng_aes_buffer.putInt32(_prng_aes_output[2]);
      _prng_aes_buffer.putInt32(_prng_aes_output[3]);
      return _prng_aes_buffer.getBytes();
    };
    prng_aes.increment = function(seed) {
      ++seed[3];
      return seed;
    };
    prng_aes.md = forge$C.md.sha256;
    function spawnPrng() {
      var ctx = forge$C.prng.create(prng_aes);
      ctx.getBytes = function(count, callback) {
        return ctx.generate(count, callback);
      };
      ctx.getBytesSync = function(count) {
        return ctx.generate(count);
      };
      return ctx;
    }
    var _ctx = spawnPrng();
    var getRandomValues = null;
    var globalScope = forge$C.util.globalScope;
    var _crypto2 = globalScope.crypto || globalScope.msCrypto;
    if (_crypto2 && _crypto2.getRandomValues) {
      getRandomValues = function getRandomValues2(arr) {
        return _crypto2.getRandomValues(arr);
      };
    }
    if (forge$C.options.usePureJavaScript || !forge$C.util.isNodejs && !getRandomValues) {
      _ctx.collectInt(+/* @__PURE__ */ new Date(), 32);
      if (typeof navigator !== "undefined") {
        var _navBytes = "";
        for (var key3 in navigator) {
          try {
            if (typeof navigator[key3] == "string") {
              _navBytes += navigator[key3];
            }
          } catch (e2) {
          }
        }
        _ctx.collect(_navBytes);
        _navBytes = null;
      }
      if (jQuery2) {
        jQuery2().mousemove(function(e2) {
          _ctx.collectInt(e2.clientX, 16);
          _ctx.collectInt(e2.clientY, 16);
        });
        jQuery2().keypress(function(e2) {
          _ctx.collectInt(e2.charCode, 8);
        });
      }
    }
    if (!forge$C.random) {
      forge$C.random = _ctx;
    } else {
      for (var key3 in _ctx) {
        forge$C.random[key3] = _ctx[key3];
      }
    }
    forge$C.random.createInstance = spawnPrng;
    random$1.exports = forge$C.random;
  })(typeof jQuery !== "undefined" ? jQuery : null);
})();
var randomExports = random$1.exports;
var random = getDefaultExportFromCjs(randomExports);
var randomBytes$3 = function randomBytes$32(size) {
  return binaryStringToUint8Array(random.getBytesSync(size));
};
var deriveKeyWithPbkdf2 = function deriveKeyWithPbkdf22(password, params) {
  var salt2 = params.salt, iterationCount = params.iterationCount, keyLength = params.keyLength, prf = params.prf;
  var saltStr = uint8ArrayToBinaryString(salt2);
  var prfMd;
  switch (prf) {
    case "hmac-with-sha1":
      prfMd = sha1$2.create();
      break;
    case "hmac-with-sha256":
      prfMd = sha256$6.create();
      break;
    case "hmac-with-sha384":
      prfMd = sha512$5.sha384.create();
      break;
    case "hmac-with-sha512":
      prfMd = sha512$5.create();
      break;
    default:
      throw new UnsupportedAlgorithmError("Unsupported PBKDF2 prf id '".concat(prf, "'"));
  }
  var keyStr = pbkdf2$3(password, saltStr, iterationCount, keyLength, prfMd);
  return binaryStringToUint8Array(keyStr);
};
var deriveKeyWithOpensslDeriveBytes = function deriveKeyWithOpensslDeriveBytes2(password, params) {
  var salt2 = params.salt, keyLength = params.keyLength;
  var saltStr = uint8ArrayToBinaryString(salt2);
  var md = md5$1.create();
  var hash2 = function hash3(bytes) {
    return md.start().update(bytes).digest().getBytes();
  };
  var digests = [hash2(password + saltStr)];
  for (var _length = 16, _i54 = 1; _length < keyLength; _i54 += 1, _length += 16) {
    digests.push(hash2(digests[_i54 - 1] + password + saltStr));
  }
  var digestStr = digests.join("").substr(0, keyLength);
  return binaryStringToUint8Array(digestStr);
};
var decryptWithAes = function decryptWithAes2(key3, encryptedData, params) {
  var iv = params.iv, mode = params.mode;
  var ivStr = uint8ArrayToBinaryString(iv);
  var keyStr = uint8ArrayToBinaryString(key3);
  var cipher = aes$3.createDecryptionCipher(keyStr, mode);
  cipher.start(ivStr);
  cipher.update(utilExports$1.createBuffer(uint8ArrayToBinaryString(encryptedData)));
  if (!cipher.finish()) {
    throw new DecryptionFailedError("Decryption failed, mostly likely the password is wrong");
  }
  return binaryStringToUint8Array(cipher.output.getBytes());
};
var encryptWithAes = function encryptWithAes2(key3, data, params) {
  var iv = params.iv, mode = params.mode;
  var ivStr = uint8ArrayToBinaryString(iv);
  var keyStr = uint8ArrayToBinaryString(key3);
  var cipher = aes$3.createEncryptionCipher(keyStr, mode);
  cipher.start(ivStr);
  cipher.update(utilExports$1.createBuffer(uint8ArrayToBinaryString(data)));
  cipher.finish();
  return binaryStringToUint8Array(cipher.output.getBytes());
};
var decryptWithDes = function decryptWithDes2(key3, encryptedData, params) {
  var iv = params.iv, mode = params.mode;
  var ivStr = uint8ArrayToBinaryString(iv);
  var keyStr = uint8ArrayToBinaryString(key3);
  var cipher = des$1.createDecryptionCipher(keyStr, mode);
  cipher.start(ivStr);
  cipher.update(utilExports$1.createBuffer(uint8ArrayToBinaryString(encryptedData)));
  if (!cipher.finish()) {
    throw new DecryptionFailedError("Decryption failed, mostly likely the password is wrong");
  }
  return binaryStringToUint8Array(cipher.output.getBytes());
};
var encryptWithDes = function encryptWithDes2(key3, data, params) {
  var iv = params.iv, mode = params.mode;
  var ivStr = uint8ArrayToBinaryString(iv);
  var keyStr = uint8ArrayToBinaryString(key3);
  var cipher = des$1.createEncryptionCipher(keyStr, mode);
  cipher.start(ivStr);
  cipher.update(utilExports$1.createBuffer(uint8ArrayToBinaryString(data)));
  cipher.finish();
  return binaryStringToUint8Array(cipher.output.getBytes());
};
var decryptWithRc2 = function decryptWithRc22(key3, encryptedData, params) {
  var iv = params.iv, bits = params.bits;
  var ivStr = uint8ArrayToBinaryString(iv);
  var keyStr = uint8ArrayToBinaryString(key3);
  var cipher = rc2$1.createDecryptionCipher(keyStr, bits);
  cipher.start(ivStr);
  cipher.update(utilExports$1.createBuffer(uint8ArrayToBinaryString(encryptedData)));
  if (!cipher.finish()) {
    throw new DecryptionFailedError("Decryption failed, mostly likely the password is wrong");
  }
  return binaryStringToUint8Array(cipher.output.getBytes());
};
var encryptWithRc2 = function encryptWithRc22(key3, data, params) {
  var iv = params.iv, bits = params.bits;
  var ivStr = uint8ArrayToBinaryString(iv);
  var keyStr = uint8ArrayToBinaryString(key3);
  var cipher = rc2$1.createEncryptionCipher(keyStr, bits);
  cipher.start(ivStr);
  cipher.update(utilExports$1.createBuffer(uint8ArrayToBinaryString(data)));
  cipher.finish();
  return binaryStringToUint8Array(cipher.output.getBytes());
};
var getRc2KeyLength = function getRc2KeyLength2(bits) {
  switch (bits) {
    case 40:
      return 5;
    case 64:
      return 8;
    case 128:
      return 16;
    default:
      throw new UnsupportedAlgorithmError("Unsupported RC2 bits parameter with value '".concat(bits, "'"));
  }
};
var decryptWithPassword = function decryptWithPassword2(encryptedData, encryptionAlgorithm, password) {
  var keyDerivationFunc = encryptionAlgorithm.keyDerivationFunc, encryptionScheme = encryptionAlgorithm.encryptionScheme;
  var deriveKeyFn;
  var derivedKeyLength;
  var decryptFn;
  switch (encryptionScheme.id) {
    case "aes128-cbc":
    case "aes192-cbc":
    case "aes256-cbc":
      decryptFn = function decryptFn2(key3) {
        return decryptWithAes(key3, encryptedData, _objectSpread(_objectSpread({}, encryptionScheme), {}, { mode: "CBC" }));
      };
      derivedKeyLength = Number(encryptionScheme.id.match(/^aes(\d+)-/)[1]) / 8;
      break;
    case "rc2-cbc":
      decryptFn = function decryptFn2(key3) {
        return decryptWithRc2(key3, encryptedData, encryptionScheme);
      };
      derivedKeyLength = getRc2KeyLength(encryptionScheme.bits);
      break;
    case "des-ede3-cbc":
      decryptFn = function decryptFn2(key3) {
        return decryptWithDes(key3, encryptedData, _objectSpread(_objectSpread({}, encryptionScheme), {}, { mode: "CBC" }));
      };
      derivedKeyLength = 24;
      break;
    case "des-cbc":
      decryptFn = function decryptFn2(key3) {
        return decryptWithDes(key3, encryptedData, _objectSpread(_objectSpread({}, encryptionScheme), {}, { mode: "CBC" }));
      };
      derivedKeyLength = 8;
      break;
    default:
      throw new UnsupportedAlgorithmError("Unsupported encryption scheme id '".concat(encryptionScheme.id, "'"));
  }
  switch (keyDerivationFunc.id) {
    case "pbkdf2":
      deriveKeyFn = function deriveKeyFn2() {
        return deriveKeyWithPbkdf2(password, _objectSpread(_objectSpread({}, keyDerivationFunc), {}, { keyLength: keyDerivationFunc.keyLength || derivedKeyLength }));
      };
      break;
    case "openssl-derive-bytes":
      deriveKeyFn = function deriveKeyFn2() {
        return deriveKeyWithOpensslDeriveBytes(password, { keyLength: derivedKeyLength, salt: encryptionScheme.iv.slice(0, 8) });
      };
      break;
    default:
      throw new UnsupportedAlgorithmError("Unsupported key derivation function id '".concat(keyDerivationFunc.id, "'"));
  }
  var derivedKey = deriveKeyFn();
  var decryptedData = decryptFn(derivedKey);
  return decryptedData;
};
var encryptWithPassword = function encryptWithPassword2(data, encryptionAlgorithm, password) {
  var keyDerivationFunc = _objectSpread({}, encryptionAlgorithm.keyDerivationFunc);
  var encryptionScheme = _objectSpread({}, encryptionAlgorithm.encryptionScheme);
  var deriveKeyFn;
  var derivedKeyLength;
  var encryptFn;
  switch (encryptionScheme.id) {
    case "aes128-cbc":
    case "aes192-cbc":
    case "aes256-cbc":
      encryptionScheme.iv = encryptionScheme.iv || randomBytes$3(16);
      encryptFn = function encryptFn2(key3) {
        return encryptWithAes(key3, data, _objectSpread(_objectSpread({}, encryptionScheme), {}, { mode: "CBC" }));
      };
      derivedKeyLength = Number(encryptionScheme.id.match(/^aes(\d+)-/)[1]) / 8;
      break;
    case "rc2-cbc":
      encryptionScheme.bits = encryptionScheme.bits || 128;
      encryptionScheme.iv = encryptionScheme.iv || randomBytes$3(16);
      encryptFn = function encryptFn2(key3) {
        return encryptWithRc2(key3, data, encryptionScheme);
      };
      derivedKeyLength = getRc2KeyLength(encryptionScheme.bits);
      break;
    case "des-ede3-cbc":
      encryptionScheme.iv = encryptionScheme.iv || randomBytes$3(8);
      encryptFn = function encryptFn2(key3) {
        return encryptWithDes(key3, data, _objectSpread(_objectSpread({}, encryptionScheme), {}, { mode: "CBC" }));
      };
      derivedKeyLength = 24;
      break;
    case "des-cbc":
      encryptionScheme.iv = encryptionScheme.iv || randomBytes$3(8);
      encryptFn = function encryptFn2(key3) {
        return encryptWithDes(key3, data, _objectSpread(_objectSpread({}, encryptionScheme), {}, { mode: "CBC" }));
      };
      derivedKeyLength = 8;
      break;
    default:
      throw new UnsupportedAlgorithmError("Unsupported encryption scheme id '".concat(encryptionScheme.id, "'"));
  }
  switch (keyDerivationFunc.id) {
    case "pbkdf2":
      if (keyDerivationFunc.keyLength != null && derivedKeyLength !== keyDerivationFunc.keyLength) {
        throw new UnsupportedAlgorithmError("The specified key length must be equal to ".concat(derivedKeyLength, " (or omitted)"));
      }
      keyDerivationFunc.salt = keyDerivationFunc.salt || randomBytes$3(16);
      keyDerivationFunc.iterationCount = keyDerivationFunc.iterationCount || 1e4;
      keyDerivationFunc.keyLength = keyDerivationFunc.keyLength || derivedKeyLength;
      keyDerivationFunc.prf = keyDerivationFunc.prf || "hmac-with-sha512";
      deriveKeyFn = function deriveKeyFn2() {
        return deriveKeyWithPbkdf2(password, keyDerivationFunc);
      };
      break;
    case "openssl-derive-bytes":
      keyDerivationFunc.keyLength = derivedKeyLength;
      keyDerivationFunc.salt = encryptionScheme.iv.slice(0, 8);
      deriveKeyFn = function deriveKeyFn2() {
        return deriveKeyWithOpensslDeriveBytes(password, keyDerivationFunc);
      };
      break;
    default:
      throw new UnsupportedAlgorithmError("Unsupported key derivation function id '".concat(keyDerivationFunc.id, "'"));
  }
  var derivedKey = deriveKeyFn();
  var encryptedData = encryptFn(derivedKey);
  return { effectiveEncryptionAlgorithm: { keyDerivationFunc, encryptionScheme }, encryptedData };
};
var overArg = _overArg;
var getPrototype$1 = overArg(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype$1;
var baseGetTag = _baseGetTag;
var getPrototype = _getPrototype;
var isObjectLike = isObjectLike_1;
var objectTag = "[object Object]";
var funcProto = Function.prototype;
var objectProto = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty = objectProto.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
var isPlainObject_1 = isPlainObject;
var _isPlainObject = getDefaultExportFromCjs(isPlainObject_1);
var validateFormat = function validateFormat2(format, supportedFormats) {
  if (typeof format !== "string") {
    throw new UnexpectedTypeError("Expecting format to be a string");
  }
  if (!supportedFormats[format]) {
    throw new UnsupportedFormatError(format);
  }
  return format;
};
var validateAlgorithmIdentifier = function validateAlgorithmIdentifier2(algorithmIdentifier, errorContext) {
  if (typeof algorithmIdentifier === "string") {
    algorithmIdentifier = { id: algorithmIdentifier };
  }
  if (!_isPlainObject(algorithmIdentifier)) {
    throw new UnexpectedTypeError("Expecting ".concat(errorContext, " to be an object"));
  }
  if (typeof algorithmIdentifier.id !== "string") {
    throw new UnexpectedTypeError("Expecting ".concat(errorContext, " id to be a string"));
  }
  return algorithmIdentifier;
};
var validateDecomposedKey = function validateDecomposedKey2(decomposedKey, supportedFormats) {
  if (!decomposedKey || !_isPlainObject(decomposedKey)) {
    throw new UnexpectedTypeError("Expecting decomposed key to be an object");
  }
  decomposedKey = _objectSpread({}, decomposedKey);
  decomposedKey.format = validateFormat(decomposedKey.format, supportedFormats);
  decomposedKey.keyAlgorithm = validateAlgorithmIdentifier(decomposedKey.keyAlgorithm, "key algorithm");
  var aliasedKeyAlgorithm = KEY_ALIASES[decomposedKey.keyAlgorithm.id];
  if (aliasedKeyAlgorithm) {
    decomposedKey.keyAlgorithm = _objectSpread(_objectSpread(_objectSpread({}, aliasedKeyAlgorithm), decomposedKey.keyAlgorithm), {}, { id: aliasedKeyAlgorithm.id });
  }
  if (!_isPlainObject(decomposedKey.keyData)) {
    throw new UnexpectedTypeError("Expecting key data to be an object");
  }
  if (decomposedKey.encryptionAlgorithm && !_isPlainObject(decomposedKey.encryptionAlgorithm)) {
    throw new UnexpectedTypeError("Expecting encryption algorithm to be an object");
  }
  return decomposedKey;
};
var validateEncryptionAlgorithm = function validateEncryptionAlgorithm2(encryptionAlgorithm, defaultKeyDerivationFunc, defaultEncryptionScheme) {
  encryptionAlgorithm = encryptionAlgorithm || {};
  return { keyDerivationFunc: validateAlgorithmIdentifier(encryptionAlgorithm.keyDerivationFunc || defaultKeyDerivationFunc, "key derivation func"), encryptionScheme: validateAlgorithmIdentifier(encryptionAlgorithm.encryptionScheme || defaultEncryptionScheme, "encryption scheme") };
};
var decryptPemBody = function decryptPemBody2(pem2, password) {
  var keyDerivationFunc = { id: "openssl-derive-bytes" };
  var encryptionScheme = { iv: hexStringToUint8Array(pem2.dekInfo.parameters) };
  var dekInfoAlgorithm = pem2.dekInfo.algorithm;
  switch (dekInfoAlgorithm) {
    case "AES-128-CBC":
    case "AES-192-CBC":
    case "AES-256-CBC":
      encryptionScheme.id = dekInfoAlgorithm.replace("-", "").toLowerCase();
      break;
    case "RC2-40-CBC":
    case "RC2-64-CBC":
    case "RC2-128-CBC":
    case "RC2-CBC":
      encryptionScheme.id = "rc2-cbc";
      encryptionScheme.bits = Number((dekInfoAlgorithm.match(/-(\d+)-/) || [])[1]) || 128;
      break;
    case "DES-CBC":
    case "DES-EDE3-CBC":
      encryptionScheme.id = dekInfoAlgorithm.toLowerCase();
      break;
    default:
      throw new UnsupportedAlgorithmError("Unsupported DEK-INFO algorithm '".concat(dekInfoAlgorithm, "'"));
  }
  var encryptionAlgorithm = { keyDerivationFunc, encryptionScheme };
  var decryptedPemBody = decryptWithPassword(binaryStringToUint8Array(pem2.body), encryptionAlgorithm, password);
  return { encryptionAlgorithm, pemBody: decryptedPemBody };
};
var encryptPemBody = function encryptPemBody2(pemBody, encryptionAlgorithm, password) {
  encryptionAlgorithm = validateEncryptionAlgorithm(encryptionAlgorithm, "openssl-derive-bytes", "aes256-cbc");
  var _encryptionAlgorithm = encryptionAlgorithm, keyDerivationFunc = _encryptionAlgorithm.keyDerivationFunc, encryptionScheme = _encryptionAlgorithm.encryptionScheme;
  if (keyDerivationFunc.id !== "openssl-derive-bytes") {
    throw new UnsupportedAlgorithmError("PKCS1 PEM keys only support 'openssl-derive-bytes' as the key derivation func");
  }
  var dekInfoAlgorithm;
  switch (encryptionScheme.id) {
    case "aes128-cbc":
    case "aes192-cbc":
    case "aes256-cbc":
      dekInfoAlgorithm = encryptionScheme.id.replace("aes", "aes-").toUpperCase();
      break;
    case "rc2-cbc":
      encryptionScheme.bits = encryptionScheme.bits || 128;
      switch (encryptionScheme.bits) {
        case 40:
          dekInfoAlgorithm = "RC2-40-CBC";
          break;
        case 64:
          dekInfoAlgorithm = "RC2-64-CBC";
          break;
        case 128:
          dekInfoAlgorithm = "RC2-CBC";
          break;
        default:
          throw new UnsupportedAlgorithmError("Unsupported RC2 bits parameter with value '".concat(encryptionScheme.bits, "'"));
      }
      break;
    case "des-cbc":
    case "des-ede3-cbc":
      dekInfoAlgorithm = encryptionScheme.id.toUpperCase();
      break;
    default:
      throw new UnsupportedAlgorithmError("Unsupported encryption scheme id '".concat(encryptionScheme.id, "'"));
  }
  var _encryptWithPassword = encryptWithPassword(pemBody, encryptionAlgorithm, password), encryptedData = _encryptWithPassword.encryptedData, effectiveEncryptionAlgorithm = _encryptWithPassword.effectiveEncryptionAlgorithm;
  return { pemHeaders: { procType: { version: "4", type: "ENCRYPTED" }, dekInfo: { algorithm: dekInfoAlgorithm, parameters: uint8ArrayToHexString(effectiveEncryptionAlgorithm.encryptionScheme.iv).toUpperCase() } }, pemBody: encryptedData };
};
var maybeDecryptPemBody = function maybeDecryptPemBody2(pem2, password) {
  var encrypted = pem2.procType && pem2.procType.type === "ENCRYPTED" && pem2.dekInfo && pem2.dekInfo.algorithm;
  if (!encrypted) {
    return { pemBody: binaryStringToUint8Array(pem2.body), encryptionAlgorithm: null };
  }
  if (!password) {
    throw new MissingPasswordError("Please specify the password to decrypt the key");
  }
  return decryptPemBody(pem2, password);
};
var maybeEncryptPemBody = function maybeEncryptPemBody2(pemBody, encryptionAlgorithm, password) {
  if (!password && !encryptionAlgorithm) {
    return { pemHeaders: null, pemBody };
  }
  if (!password && encryptionAlgorithm) {
    throw new MissingPasswordError("An encryption algorithm was specified but no password was set");
  }
  return encryptPemBody(pemBody, encryptionAlgorithm, password);
};
var matcher$1 = { exports: {} };
var matchOperatorsRegex = /[|\\{}()[\]^$+*?.-]/g;
var escapeStringRegexp$1 = function escapeStringRegexp$12(string2) {
  if (typeof string2 !== "string") {
    throw new TypeError("Expected a string");
  }
  return string2.replace(matchOperatorsRegex, "\\$&");
};
var escapeStringRegexp = escapeStringRegexp$1;
var regexpCache = /* @__PURE__ */ new Map();
function makeRegexp(pattern, options) {
  options = _objectSpread({ caseSensitive: false }, options);
  var cacheKey = pattern + JSON.stringify(options);
  if (regexpCache.has(cacheKey)) {
    return regexpCache.get(cacheKey);
  }
  var negated = pattern[0] === "!";
  if (negated) {
    pattern = pattern.slice(1);
  }
  pattern = escapeStringRegexp(pattern).replace(/\\\*/g, ".*");
  var regexp = new RegExp("^".concat(pattern, "$"), options.caseSensitive ? "" : "i");
  regexp.negated = negated;
  regexpCache.set(cacheKey, regexp);
  return regexp;
}
matcher$1.exports = function(inputs, patterns, options) {
  if (!(Array.isArray(inputs) && Array.isArray(patterns))) {
    throw new TypeError("Expected two arrays, got ".concat(_typeof(inputs), " ").concat(_typeof(patterns)));
  }
  if (patterns.length === 0) {
    return inputs;
  }
  var firstNegated = patterns[0][0] === "!";
  patterns = patterns.map(function(pattern2) {
    return makeRegexp(pattern2, options);
  });
  var result = [];
  var _iterator3 = _createForOfIteratorHelper(inputs), _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
      var input = _step3.value;
      var matches = firstNegated;
      var _iterator4 = _createForOfIteratorHelper(patterns), _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
          var pattern = _step4.value;
          if (pattern.test(input)) {
            matches = !pattern.negated;
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      if (matches) {
        result.push(input);
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  return result;
};
matcher$1.exports.isMatch = function(input, pattern, options) {
  var inputArray = Array.isArray(input) ? input : [input];
  var patternArray = Array.isArray(pattern) ? pattern : [pattern];
  return inputArray.some(function(input2) {
    return patternArray.every(function(pattern2) {
      var regexp = makeRegexp(pattern2, options);
      var matches = regexp.test(input2);
      return regexp.negated ? !matches : matches;
    });
  });
};
var matcherExports = matcher$1.exports;
var matcher = getDefaultExportFromCjs(matcherExports);
var pem$2 = { exports: {} };
var forge$B = forge$R;
var pem$1 = pem$2.exports = forge$B.pem = forge$B.pem || {};
pem$1.encode = function(msg, options) {
  options = options || {};
  var rval = "-----BEGIN " + msg.type + "-----\r\n";
  var header;
  if (msg.procType) {
    header = { name: "Proc-Type", values: [String(msg.procType.version), msg.procType.type] };
    rval += foldHeader$1(header);
  }
  if (msg.contentDomain) {
    header = { name: "Content-Domain", values: [msg.contentDomain] };
    rval += foldHeader$1(header);
  }
  if (msg.dekInfo) {
    header = { name: "DEK-Info", values: [msg.dekInfo.algorithm] };
    if (msg.dekInfo.parameters) {
      header.values.push(msg.dekInfo.parameters);
    }
    rval += foldHeader$1(header);
  }
  if (msg.headers) {
    for (var i2 = 0; i2 < msg.headers.length; ++i2) {
      rval += foldHeader$1(msg.headers[i2]);
    }
  }
  if (msg.procType) {
    rval += "\r\n";
  }
  rval += forge$B.util.encode64(msg.body, options.maxline || 64) + "\r\n";
  rval += "-----END " + msg.type + "-----\r\n";
  return rval;
};
pem$1.decode = function(str) {
  var rval = [];
  var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
  var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
  var rCRLF = /\r?\n/;
  var match;
  while (true) {
    match = rMessage.exec(str);
    if (!match) {
      break;
    }
    var msg = { type: match[1], procType: null, contentDomain: null, dekInfo: null, headers: [], body: forge$B.util.decode64(match[3]) };
    rval.push(msg);
    if (!match[2]) {
      continue;
    }
    var lines = match[2].split(rCRLF);
    var li = 0;
    while (match && li < lines.length) {
      var line = lines[li].replace(/\s+$/, "");
      for (var nl = li + 1; nl < lines.length; ++nl) {
        var next = lines[nl];
        if (!/\s/.test(next[0])) {
          break;
        }
        line += next;
        li = nl;
      }
      match = line.match(rHeader);
      if (match) {
        var header = { name: match[1], values: [] };
        var values = match[2].split(",");
        for (var vi = 0; vi < values.length; ++vi) {
          header.values.push(ltrim$1(values[vi]));
        }
        if (!msg.procType) {
          if (header.name !== "Proc-Type") {
            throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
          } else if (header.values.length !== 2) {
            throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
          }
          msg.procType = { version: values[0], type: values[1] };
        } else if (!msg.contentDomain && header.name === "Content-Domain") {
          msg.contentDomain = values[0] || "";
        } else if (!msg.dekInfo && header.name === "DEK-Info") {
          if (header.values.length === 0) {
            throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
          }
          msg.dekInfo = { algorithm: values[0], parameters: values[1] || null };
        } else {
          msg.headers.push(header);
        }
      }
      ++li;
    }
    if (msg.procType === "ENCRYPTED" && !msg.dekInfo) {
      throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
    }
  }
  if (rval.length === 0) {
    throw new Error("Invalid PEM formatted message.");
  }
  return rval;
};
function foldHeader$1(header) {
  var rval = header.name + ": ";
  var values = [];
  var insertSpace = function insertSpace2(match, $1) {
    return " " + $1;
  };
  for (var i2 = 0; i2 < header.values.length; ++i2) {
    values.push(header.values[i2].replace(/^(\S+\r\n)/, insertSpace));
  }
  rval += values.join(",") + "\r\n";
  var length3 = 0;
  var candidate = -1;
  for (var i2 = 0; i2 < rval.length; ++i2, ++length3) {
    if (length3 > 65 && candidate !== -1) {
      var insert = rval[candidate];
      if (insert === ",") {
        ++candidate;
        rval = rval.substr(0, candidate) + "\r\n " + rval.substr(candidate);
      } else {
        rval = rval.substr(0, candidate) + "\r\n" + insert + rval.substr(candidate + 1);
      }
      length3 = i2 - candidate - 1;
      candidate = -1;
      ++i2;
    } else if (rval[i2] === " " || rval[i2] === "	" || rval[i2] === ",") {
      candidate = i2;
    }
  }
  return rval;
}
function ltrim$1(str) {
  return str.replace(/^\s+/, "");
}
var pemExports = pem$2.exports;
var decodePem = function decodePem2(pem2, patterns) {
  if (pem2 instanceof Uint8Array) {
    pem2 = uint8ArrayToBinaryString(pem2);
  }
  var decodedPem;
  try {
    decodedPem = pemExports.decode(pem2);
  } catch (err) {
    throw new DecodePemFailedError("Failed to decode PEM", { originalError: err });
  }
  if (!patterns) {
    return decodedPem[0];
  }
  patterns = Array.isArray(patterns) ? patterns : [patterns];
  var pemMessage = decodedPem.find(function(msg) {
    return matcher([msg.type], patterns, { caseSensitive: true }).length > 0;
  });
  if (!pemMessage) {
    throw new DecodePemFailedError("Could not find pem message matching patterns: '".concat(patterns.join("', '"), "'"));
  }
  return pemMessage;
};
var encodePem = function encodePem2(decodedPem) {
  var pem2;
  try {
    pem2 = pemExports.encode(decodedPem);
  } catch (err) {
    throw new EncodePemFailedError("Failed to encode PEM", { originalError: err });
  }
  pem2 = pem2.replace(/\r/g, "");
  return pem2;
};
var decomposePrivateKey$4 = function decomposePrivateKey$42(pem2, options) {
  var decodedPem;
  try {
    decodedPem = decodePem(pem2, "RSA PRIVATE KEY");
  } catch (err) {
    err.invalidInputKey = err instanceof DecodePemFailedError;
    throw err;
  }
  var _maybeDecryptPemBody = maybeDecryptPemBody(decodedPem, options.password), pkcs1Key = _maybeDecryptPemBody.pemBody, encryptionAlgorithm = _maybeDecryptPemBody.encryptionAlgorithm;
  var decomposedKey = decomposePrivateKey$5(pkcs1Key);
  decomposedKey.encryptionAlgorithm = encryptionAlgorithm;
  decomposedKey.format = "pkcs1-pem";
  return decomposedKey;
};
var composePrivateKey$5 = function composePrivateKey$52(_ref39, options) {
  var encryptionAlgorithm = _ref39.encryptionAlgorithm, decomposedKey = _objectWithoutProperties(_ref39, _excluded3);
  var pkcs1Key = composePrivateKey$6(decomposedKey);
  var _maybeEncryptPemBody = maybeEncryptPemBody(pkcs1Key, encryptionAlgorithm, options.password), pemBody = _maybeEncryptPemBody.pemBody, pemHeaders = _maybeEncryptPemBody.pemHeaders;
  return encodePem(_objectSpread({ type: "RSA PRIVATE KEY", body: uint8ArrayToBinaryString(pemBody) }, pemHeaders));
};
var pkcs1Pem = Object.freeze(Object.defineProperty({ __proto__: null, composePrivateKey: composePrivateKey$5, decomposePrivateKey: decomposePrivateKey$4 }, Symbol.toStringTag, { value: "Module" }));
var decomposeRsaPrivateKeyInfo = function decomposeRsaPrivateKeyInfo2(privateKeyInfo) {
  var privateKeyAlgorithm = privateKeyInfo.privateKeyAlgorithm, privateKeyAsn1 = privateKeyInfo.privateKey;
  var keyAlgorithm = { id: OIDS[privateKeyAlgorithm.id] };
  switch (keyAlgorithm.id) {
    case "rsa-encryption":
    case "md2-with-rsa-encryption":
    case "md4-with-rsa-encryption":
    case "md5-with-rsa-encryption":
    case "sha1-with-rsa-encryption":
    case "sha224-with-rsa-encryption":
    case "sha256-with-rsa-encryption":
    case "sha384-with-rsa-encryption":
    case "sha512-with-rsa-encryption":
    case "sha512-224-with-rsa-encryption":
    case "sha512-256-with-rsa-encryption":
      break;
    case "rsaes-oaep":
      throw new UnsupportedAlgorithmError("RSA-OAEP keys are not yet supported");
    case "rsassa-pss":
      throw new UnsupportedAlgorithmError("RSA-PSS keys are not yet supported");
    default:
      throw new UnsupportedAlgorithmError("Unsupported key algorithm OID '".concat(privateKeyAlgorithm.id, "'"));
  }
  var _decomposeRsaPrivateK = decomposeRsaPrivateKey(privateKeyAsn1), keyData = _decomposeRsaPrivateK.keyData;
  return { keyAlgorithm: { id: OIDS[privateKeyAlgorithm.id] }, keyData };
};
var composeRsaPrivateKeyInfo = function composeRsaPrivateKeyInfo2(keyAlgorithm, keyData) {
  var rsaPrivateKeyAsn1 = composeRsaPrivateKey(keyAlgorithm, keyData);
  return { version: 0, privateKeyAlgorithm: { id: FLIPPED_OIDS[keyAlgorithm.id], parameters: hexStringToUint8Array("0500") }, privateKey: rsaPrivateKeyAsn1 };
};
var decomposeEcPrivateKeyInfo = function decomposeEcPrivateKeyInfo2(privateKeyInfo) {
  var privateKeyAlgorithm = privateKeyInfo.privateKeyAlgorithm, privateKeyAsn1 = privateKeyInfo.privateKey;
  var ecParameters = decodeAsn1(privateKeyAlgorithm.parameters, EcParameters);
  var ecPrivateKey = decodeAsn1(privateKeyAsn1, EcPrivateKey);
  if (ecParameters.type !== "namedCurve") {
    throw new UnsupportedAlgorithmError("Only EC named curves are supported");
  }
  if (!ecPrivateKey.publicKey) {
    throw new UnsupportedAlgorithmError("Missing publicKey from ECPrivateKey");
  }
  var namedCurve = OIDS[ecParameters.value];
  if (!namedCurve) {
    throw new UnsupportedAlgorithmError("Unsupported named curve OID '".concat(ecParameters.value, "'"));
  }
  var _decodeEcPoint2 = decodeEcPoint(namedCurve, ecPrivateKey.publicKey.data), x2 = _decodeEcPoint2.x, y3 = _decodeEcPoint2.y;
  return { keyAlgorithm: { id: "ec-public-key", namedCurve }, keyData: { d: ecPrivateKey.privateKey, x: x2, y: y3 } };
};
var composeEcPrivateKeyInfo = function composeEcPrivateKeyInfo2(keyAlgorithm, keyData) {
  var namedCurveOid = FLIPPED_OIDS[keyAlgorithm.namedCurve];
  if (!namedCurveOid) {
    throw new UnsupportedAlgorithmError("Unsupported named curve '".concat(keyAlgorithm.namedCurve, "'"));
  }
  var privateKey = validateEcD(keyAlgorithm.namedCurve, keyData.d);
  var publicKey = encodeEcPoint(keyAlgorithm.namedCurve, keyData.x, keyData.y);
  var ecPrivateKey = { version: 1, privateKey, publicKey: { unused: 0, data: publicKey } };
  var ecPrivateKeyAsn1 = encodeAsn1(ecPrivateKey, EcPrivateKey);
  var ecParametersAsn1 = encodeAsn1({ type: "namedCurve", value: namedCurveOid }, EcParameters);
  return { version: 0, privateKeyAlgorithm: { id: FLIPPED_OIDS[keyAlgorithm.id], parameters: ecParametersAsn1 }, privateKey: ecPrivateKeyAsn1 };
};
var decomposeEd25519PrivateKeyInfo = function decomposeEd25519PrivateKeyInfo2(privateKeyInfo) {
  var privateKeyAlgorithm = privateKeyInfo.privateKeyAlgorithm, privateKey = privateKeyInfo.privateKey;
  var seed = decodeAsn1(privateKey, CurvePrivateKey);
  return { keyAlgorithm: { id: OIDS[privateKeyAlgorithm.id] }, keyData: { seed } };
};
var composeEd25519PrivateKeyInfo = function composeEd25519PrivateKeyInfo2(keyAlgorithm, keyData) {
  return { version: 0, privateKeyAlgorithm: { id: FLIPPED_OIDS[keyAlgorithm.id] }, privateKey: encodeAsn1(keyData.seed, CurvePrivateKey) };
};
var decomposePrivateKeyInfo = function decomposePrivateKeyInfo2(privateKeyInfo) {
  var keyType = KEY_TYPES[OIDS[privateKeyInfo.privateKeyAlgorithm.id]];
  switch (keyType) {
    case "rsa":
      return decomposeRsaPrivateKeyInfo(privateKeyInfo);
    case "ec":
      return decomposeEcPrivateKeyInfo(privateKeyInfo);
    case "ed25519":
      return decomposeEd25519PrivateKeyInfo(privateKeyInfo);
    default:
      throw new UnsupportedAlgorithmError("Unsupported key algorithm OID '".concat(privateKeyInfo.privateKeyAlgorithm.id, "'"));
  }
};
var composePrivateKeyInfo = function composePrivateKeyInfo2(keyAlgorithm, keyData) {
  var keyType = KEY_TYPES[keyAlgorithm.id];
  switch (keyType) {
    case "rsa":
      return composeRsaPrivateKeyInfo(keyAlgorithm, keyData);
    case "ec":
      return composeEcPrivateKeyInfo(keyAlgorithm, keyData);
    case "ed25519":
      return composeEd25519PrivateKeyInfo(keyAlgorithm, keyData);
    default:
      throw new UnsupportedAlgorithmError("Unsupported key algorithm id '".concat(keyAlgorithm.id, "'"));
  }
};
var decryptWithPBES2 = function decryptWithPBES22(encryptedData, encryptionAlgorithmParamsAsn1, password) {
  var _decodeAsn3 = decodeAsn1(encryptionAlgorithmParamsAsn1, Pbes2Algorithms), keyDerivationFunc = _decodeAsn3.keyDerivationFunc, encryptionScheme = _decodeAsn3.encryptionScheme;
  var keyDerivationFuncId = OIDS[keyDerivationFunc.id];
  var encryptionSchemeId = OIDS[encryptionScheme.id];
  var effectiveKeyDerivationFunc = { id: keyDerivationFuncId };
  var effectiveEncryptionScheme = { id: encryptionSchemeId };
  switch (encryptionSchemeId) {
    case "aes128-cbc":
    case "aes192-cbc":
    case "aes256-cbc":
    case "des-ede3-cbc":
    case "des-cbc":
      effectiveEncryptionScheme.iv = decodeAsn1(encryptionScheme.parameters, Pbes2EsParams[encryptionSchemeId]);
      break;
    case "rc2-cbc": {
      var rc2CBCParameter = decodeAsn1(encryptionScheme.parameters, Rc2CbcParameter);
      var rc2ParameterVersion = uint8ArrayToInteger(rc2CBCParameter.rc2ParameterVersion);
      effectiveEncryptionScheme.iv = rc2CBCParameter.iv;
      switch (rc2ParameterVersion) {
        case 160:
          effectiveEncryptionScheme.bits = 40;
          break;
        case 120:
          effectiveEncryptionScheme.bits = 64;
          break;
        case 58:
          effectiveEncryptionScheme.bits = 128;
          break;
        default:
          throw new UnsupportedAlgorithmError("Unsupported RC2 version parameter with value '".concat(rc2ParameterVersion, "'"));
      }
      break;
    }
    default:
      throw new UnsupportedAlgorithmError("Unsupported encryption scheme algorithm OID '".concat(encryptionScheme.id, "'"));
  }
  switch (keyDerivationFuncId) {
    case "pbkdf2": {
      var pbkdf2Params = decodeAsn1(keyDerivationFunc.parameters, Pbkdf2Params);
      var prfId = OIDS[pbkdf2Params.prf.id];
      if (pbkdf2Params.salt.type !== "specified") {
        throw new UnsupportedAlgorithmError("Only 'specified' salts are supported in PBKDF2");
      }
      if (!prfId) {
        throw new UnsupportedAlgorithmError("Unsupported prf algorithm OID '".concat(pbkdf2Params.prf.id, "'"));
      }
      effectiveKeyDerivationFunc.salt = pbkdf2Params.salt.value;
      effectiveKeyDerivationFunc.iterationCount = uint8ArrayToInteger(pbkdf2Params.iterationCount);
      effectiveKeyDerivationFunc.prf = prfId;
      if (pbkdf2Params.keyLength) {
        effectiveKeyDerivationFunc.keyLength = uint8ArrayToInteger(pbkdf2Params.keyLength);
      }
      break;
    }
    default:
      throw new UnsupportedAlgorithmError("Unsupported key derivation function algorithm OID '".concat(keyDerivationFunc.id, "'"));
  }
  var encryptionAlgorithm = { keyDerivationFunc: effectiveKeyDerivationFunc, encryptionScheme: effectiveEncryptionScheme };
  var decryptedData = decryptWithPassword(encryptedData, encryptionAlgorithm, password);
  return { encryptionAlgorithm, decryptedData };
};
var encryptWithPBES2 = function encryptWithPBES22(data, encryptionAlgorithm, password) {
  encryptionAlgorithm = validateEncryptionAlgorithm(encryptionAlgorithm, "pbkdf2", "aes256-cbc");
  var _encryptionAlgorithm2 = encryptionAlgorithm, keyDerivationFunc = _encryptionAlgorithm2.keyDerivationFunc, encryptionScheme = _encryptionAlgorithm2.encryptionScheme;
  var encodeEncryptionSchemeAsn1ParamsFn;
  var encodeKeyDerivationFuncAsn1ParamsFn;
  switch (encryptionScheme.id) {
    case "aes128-cbc":
    case "aes192-cbc":
    case "aes256-cbc":
    case "des-ede3-cbc":
    case "des-cbc":
      encodeEncryptionSchemeAsn1ParamsFn = function encodeEncryptionSchemeAsn1ParamsFn2(_ref40) {
        var iv = _ref40.iv;
        return encodeAsn1(iv, Pbes2EsParams[encryptionScheme.id]);
      };
      break;
    case "rc2-cbc":
      encodeEncryptionSchemeAsn1ParamsFn = function encodeEncryptionSchemeAsn1ParamsFn2(_ref41) {
        var iv = _ref41.iv, bits = _ref41.bits;
        var rc2ParameterVersion;
        switch (bits) {
          case 40:
            rc2ParameterVersion = 160;
            break;
          case 64:
            rc2ParameterVersion = 120;
            break;
          case 128:
            rc2ParameterVersion = 58;
            break;
          default:
            throw new UnsupportedAlgorithmError("Unsupported RC2 bits parameter with value '".concat(rc2ParameterVersion, "'"));
        }
        return encodeAsn1({ iv, rc2ParameterVersion }, Rc2CbcParameter);
      };
      break;
    default:
      throw new UnsupportedAlgorithmError("Unsupported encryption scheme id '".concat(encryptionScheme.id, "'"));
  }
  switch (keyDerivationFunc.id) {
    case "pbkdf2":
      encodeKeyDerivationFuncAsn1ParamsFn = function encodeKeyDerivationFuncAsn1ParamsFn2(_ref42) {
        var salt2 = _ref42.salt, iterationCount = _ref42.iterationCount, prf = _ref42.prf;
        return encodeAsn1({ salt: { type: "specified", value: salt2 }, iterationCount, keyLength: keyDerivationFunc.keyLength, prf: { id: FLIPPED_OIDS[prf], parameters: hexStringToUint8Array("0500") } }, Pbkdf2Params);
      };
      break;
    default:
      throw new UnsupportedAlgorithmError("Unsupported key derivation function id '".concat(keyDerivationFunc.id, "'"));
  }
  var _encryptWithPassword2 = encryptWithPassword(data, encryptionAlgorithm, password), encryptedData = _encryptWithPassword2.encryptedData, effectiveEncryptionAlgorithm = _encryptWithPassword2.effectiveEncryptionAlgorithm;
  var encryptionAlgorithmParamsAsn1 = encodeAsn1({ keyDerivationFunc: { id: FLIPPED_OIDS[keyDerivationFunc.id], parameters: encodeKeyDerivationFuncAsn1ParamsFn(effectiveEncryptionAlgorithm.keyDerivationFunc) }, encryptionScheme: { id: FLIPPED_OIDS[encryptionScheme.id], parameters: encodeEncryptionSchemeAsn1ParamsFn(effectiveEncryptionAlgorithm.encryptionScheme) } }, Pbes2Algorithms);
  return { encryptionAlgorithmParamsAsn1, encryptedData };
};
var maybeDecryptPrivateKeyInfo = function maybeDecryptPrivateKeyInfo2(encryptedPrivateKeyInfoAsn1, password) {
  var encryptedPrivateKeyInfo;
  try {
    encryptedPrivateKeyInfo = decodeAsn1(encryptedPrivateKeyInfoAsn1, EncryptedPrivateKeyInfo);
  } catch (err) {
    if (err instanceof DecodeAsn1FailedError) {
      return { encryptionAlgorithm: null, privateKeyInfoAsn1: encryptedPrivateKeyInfoAsn1 };
    }
    throw err;
  }
  if (!password) {
    throw new MissingPasswordError("Please specify the password to decrypt the key");
  }
  var _encryptedPrivateKeyI = encryptedPrivateKeyInfo, encryptionAlgorithm = _encryptedPrivateKeyI.encryptionAlgorithm, encryptedData = _encryptedPrivateKeyI.encryptedData;
  var encryptionAlgorithmId = OIDS[encryptionAlgorithm.id];
  var encryptionAlgorithmParamsAsn1 = encryptionAlgorithm.parameters;
  var decryptionResult;
  switch (encryptionAlgorithmId) {
    case "pbes2":
      decryptionResult = decryptWithPBES2(encryptedData, encryptionAlgorithmParamsAsn1, password);
      break;
    default:
      throw new UnsupportedAlgorithmError("Unsupported encryption algorithm OID '".concat(encryptionAlgorithm.id, "'"));
  }
  return { encryptionAlgorithm: decryptionResult.encryptionAlgorithm, privateKeyInfoAsn1: decryptionResult.decryptedData };
};
var maybeEncryptPrivateKeyInfo = function maybeEncryptPrivateKeyInfo2(privateKeyInfoAsn1, encryptionAlgorithm, password) {
  if (!password && !encryptionAlgorithm) {
    return privateKeyInfoAsn1;
  }
  if (!password && encryptionAlgorithm) {
    throw new MissingPasswordError("An encryption algorithm was specified but no password was set");
  }
  var _encryptWithPBES = encryptWithPBES2(privateKeyInfoAsn1, encryptionAlgorithm, password), encryptedData = _encryptWithPBES.encryptedData, encryptionAlgorithmParamsAsn1 = _encryptWithPBES.encryptionAlgorithmParamsAsn1;
  var encryptedPrivateKeyInfoAsn1 = encodeAsn1({ encryptionAlgorithm: { id: FLIPPED_OIDS.pbes2, parameters: encryptionAlgorithmParamsAsn1 }, encryptedData }, EncryptedPrivateKeyInfo);
  return encryptedPrivateKeyInfoAsn1;
};
var decomposePrivateKey$3 = function decomposePrivateKey$32(encryptedPrivateKeyInfoAsn1, options) {
  var _maybeDecryptPrivateK = maybeDecryptPrivateKeyInfo(encryptedPrivateKeyInfoAsn1, options.password), privateKeyInfoAsn1 = _maybeDecryptPrivateK.privateKeyInfoAsn1, encryptionAlgorithm = _maybeDecryptPrivateK.encryptionAlgorithm;
  var privateKeyInfo;
  try {
    privateKeyInfo = decodeAsn1(privateKeyInfoAsn1, PrivateKeyInfo);
  } catch (err) {
    err.invalidInputKey = err instanceof DecodeAsn1FailedError;
    throw err;
  }
  var _decomposePrivateKeyI = decomposePrivateKeyInfo(privateKeyInfo), keyAlgorithm = _decomposePrivateKeyI.keyAlgorithm, keyData = _decomposePrivateKeyI.keyData;
  return { format: "pkcs8-der", keyAlgorithm, keyData, encryptionAlgorithm };
};
var composePrivateKey$4 = function composePrivateKey$42(_ref43, options) {
  var keyAlgorithm = _ref43.keyAlgorithm, keyData = _ref43.keyData, encryptionAlgorithm = _ref43.encryptionAlgorithm;
  var privateKeyInfo = composePrivateKeyInfo(keyAlgorithm, keyData);
  var privateKeyInfoAsn1 = encodeAsn1(privateKeyInfo, PrivateKeyInfo);
  var encryptedPrivateKeyInfoAsn1 = maybeEncryptPrivateKeyInfo(privateKeyInfoAsn1, encryptionAlgorithm, options.password);
  return encryptedPrivateKeyInfoAsn1;
};
var pkcs8Der = Object.freeze(Object.defineProperty({ __proto__: null, composePrivateKey: composePrivateKey$4, decomposePrivateKey: decomposePrivateKey$3 }, Symbol.toStringTag, { value: "Module" }));
var decomposePrivateKey$2 = function decomposePrivateKey$22(pem2, options) {
  var decodedPem;
  try {
    decodedPem = decodePem(pem2, ["PRIVATE KEY", "ENCRYPTED PRIVATE KEY"]);
  } catch (err) {
    err.invalidInputKey = err instanceof DecodePemFailedError;
    throw err;
  }
  var pkcs8Key = binaryStringToUint8Array(decodedPem.body);
  var decomposedKey = decomposePrivateKey$3(pkcs8Key, options);
  decomposedKey.format = "pkcs8-pem";
  return decomposedKey;
};
var composePrivateKey$3 = function composePrivateKey$32(decomposedKey, options) {
  var pkcs8Key = composePrivateKey$4(decomposedKey, options);
  return encodePem({ type: options.password ? "ENCRYPTED PRIVATE KEY" : "PRIVATE KEY", body: uint8ArrayToBinaryString(pkcs8Key) });
};
var pkcs8Pem = Object.freeze(Object.defineProperty({ __proto__: null, composePrivateKey: composePrivateKey$3, decomposePrivateKey: decomposePrivateKey$2 }, Symbol.toStringTag, { value: "Module" }));
var decomposePrivateKey$1 = function decomposePrivateKey$12(privateKeyAsn1) {
  var decomposedKey;
  var errors = {};
  var _iterator5 = _createForOfIteratorHelper(SUPPORTED_KEY_TYPES.private), _step5;
  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
      var keyType = _step5.value;
      try {
        decomposedKey = decomposeRawPrivateKey(keyType, privateKeyAsn1);
        break;
      } catch (err) {
        if (err instanceof DecodeAsn1FailedError) {
          errors[keyType] = err;
        } else {
          throw err;
        }
      }
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }
  if (!decomposedKey) {
    throw new AggregatedError("The input key is not one of: ".concat(SUPPORTED_KEY_TYPES.private.join(", ")), errors, { invalidInputKey: true });
  }
  var _decomposedKey = decomposedKey, keyAlgorithm = _decomposedKey.keyAlgorithm, keyData = _decomposedKey.keyData;
  return { format: "raw-der", encryptionAlgorithm: null, keyAlgorithm, keyData };
};
var composePrivateKey$2 = function composePrivateKey$22(_ref44) {
  var keyAlgorithm = _ref44.keyAlgorithm, keyData = _ref44.keyData, encryptionAlgorithm = _ref44.encryptionAlgorithm;
  if (encryptionAlgorithm) {
    throw new UnsupportedAlgorithmError("The RAW DER format does not support encryption");
  }
  return composeRawPrivateKey(keyAlgorithm, keyData);
};
var decomposePublicKey$3 = function decomposePublicKey$32(publicKeyAsn1) {
  var decomposedKey;
  var errors = {};
  var _iterator6 = _createForOfIteratorHelper(SUPPORTED_KEY_TYPES.public), _step6;
  try {
    for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
      var keyType = _step6.value;
      try {
        decomposedKey = decomposeRawPublicKey(keyType, publicKeyAsn1);
        break;
      } catch (err) {
        if (err instanceof DecodeAsn1FailedError) {
          errors[keyType] = err;
        } else {
          throw err;
        }
      }
    }
  } catch (err) {
    _iterator6.e(err);
  } finally {
    _iterator6.f();
  }
  if (!decomposedKey) {
    throw new AggregatedError("The input key is not one of: ".concat(SUPPORTED_KEY_TYPES.public.join(", ")), errors, { invalidInputKey: true });
  }
  var _decomposedKey2 = decomposedKey, keyAlgorithm = _decomposedKey2.keyAlgorithm, keyData = _decomposedKey2.keyData;
  return { format: "raw-der", keyAlgorithm, keyData };
};
var composePublicKey$4 = function composePublicKey$42(_ref45) {
  var keyAlgorithm = _ref45.keyAlgorithm, keyData = _ref45.keyData;
  return composeRawPublicKey(keyAlgorithm, keyData);
};
var rawDer = Object.freeze(Object.defineProperty({ __proto__: null, composePrivateKey: composePrivateKey$2, composePublicKey: composePublicKey$4, decomposePrivateKey: decomposePrivateKey$1, decomposePublicKey: decomposePublicKey$3 }, Symbol.toStringTag, { value: "Module" }));
var getKeyType = function getKeyType2(pemType) {
  var match = /^(\S+?) (PUBLIC|PRIVATE) KEY$/.exec(pemType);
  return match && match[1].toLocaleLowerCase();
};
var getPemType = function getPemType2(keyAlgorithm) {
  var keyType = KEY_TYPES[keyAlgorithm.id];
  return keyType && keyType.toUpperCase();
};
var decomposePrivateKey = function decomposePrivateKey2(pem2, options) {
  var decodedPem;
  try {
    decodedPem = decodePem(pem2, "* PRIVATE KEY");
  } catch (err) {
    err.invalidInputKey = err instanceof DecodePemFailedError;
    throw err;
  }
  var _maybeDecryptPemBody2 = maybeDecryptPemBody(decodedPem, options.password), pemBody = _maybeDecryptPemBody2.pemBody, encryptionAlgorithm = _maybeDecryptPemBody2.encryptionAlgorithm;
  var keyType = getKeyType(decodedPem.type);
  if (!keyType) {
    throw new DecodePemFailedError("Unable to extract key type from PEM", { invalidInputKey: true });
  }
  var _decomposeRawPrivateK = decomposeRawPrivateKey(keyType, pemBody), keyAlgorithm = _decomposeRawPrivateK.keyAlgorithm, keyData = _decomposeRawPrivateK.keyData;
  return { format: "raw-pem", keyAlgorithm, keyData, encryptionAlgorithm };
};
var composePrivateKey$1 = function composePrivateKey$12(_ref46, options) {
  var keyAlgorithm = _ref46.keyAlgorithm, keyData = _ref46.keyData, encryptionAlgorithm = _ref46.encryptionAlgorithm;
  var rawKey = composeRawPrivateKey(keyAlgorithm, keyData);
  var pemKeyType = getPemType(keyAlgorithm);
  if (!pemKeyType) {
    throw new UnsupportedAlgorithmError("Unable to extract pem type from key algorithm");
  }
  var _maybeEncryptPemBody2 = maybeEncryptPemBody(rawKey, encryptionAlgorithm, options.password), pemBody = _maybeEncryptPemBody2.pemBody, pemHeaders = _maybeEncryptPemBody2.pemHeaders;
  return encodePem(_objectSpread({ type: "".concat(pemKeyType, " PRIVATE KEY"), body: uint8ArrayToBinaryString(pemBody) }, pemHeaders));
};
var decomposePublicKey$2 = function decomposePublicKey$22(pem2) {
  var decodedPem;
  try {
    decodedPem = decodePem(pem2);
  } catch (err) {
    err.invalidInputKey = err instanceof DecodePemFailedError;
    throw err;
  }
  var keyType = getKeyType(decodedPem.type);
  if (!keyType) {
    throw new DecodePemFailedError("Unable to extract key type from PEM", { invalidInputKey: true });
  }
  var pemBody = binaryStringToUint8Array(decodedPem.body);
  var _decomposeRawPublicKe = decomposeRawPublicKey(keyType, pemBody), keyAlgorithm = _decomposeRawPublicKe.keyAlgorithm, keyData = _decomposeRawPublicKe.keyData;
  return { format: "raw-pem", keyAlgorithm, keyData };
};
var composePublicKey$3 = function composePublicKey$32(_ref47) {
  var keyAlgorithm = _ref47.keyAlgorithm, keyData = _ref47.keyData;
  var rawKey = composeRawPublicKey(keyAlgorithm, keyData);
  var pemKeyType = getPemType(keyAlgorithm);
  if (!pemKeyType) {
    throw new UnsupportedAlgorithmError("Unable to extract pem type from key algorithm");
  }
  return encodePem({ type: "".concat(pemKeyType, " PUBLIC KEY"), body: uint8ArrayToBinaryString(rawKey) });
};
var rawPem = Object.freeze(Object.defineProperty({ __proto__: null, composePrivateKey: composePrivateKey$1, composePublicKey: composePublicKey$3, decomposePrivateKey, decomposePublicKey: decomposePublicKey$2 }, Symbol.toStringTag, { value: "Module" }));
var decomposeRsaSubjectPublicKeyInfo = function decomposeRsaSubjectPublicKeyInfo2(subjectPublicKeyInfo) {
  var algorithm = subjectPublicKeyInfo.algorithm, publicKeyAsn1 = subjectPublicKeyInfo.publicKey;
  var keyAlgorithm = { id: OIDS[algorithm.id] };
  switch (keyAlgorithm.id) {
    case "rsa-encryption":
    case "md2-with-rsa-encryption":
    case "md4-with-rsa-encryption":
    case "md5-with-rsa-encryption":
    case "sha1-with-rsa-encryption":
    case "sha224-with-rsa-encryption":
    case "sha256-with-rsa-encryption":
    case "sha384-with-rsa-encryption":
    case "sha512-with-rsa-encryption":
    case "sha512-224-with-rsa-encryption":
    case "sha512-256-with-rsa-encryption":
      break;
    case "rsaes-oaep":
      throw new UnsupportedAlgorithmError("RSA-OAEP keys are not yet supported");
    case "rsassa-pss":
      throw new UnsupportedAlgorithmError("RSA-PSS keys are not yet supported");
    default:
      throw new UnsupportedAlgorithmError("Unsupported key algorithm OID '".concat(algorithm.id, "'"));
  }
  var _decomposeRsaPublicKe = decomposeRsaPublicKey(publicKeyAsn1.data), keyData = _decomposeRsaPublicKe.keyData;
  return { keyAlgorithm: { id: OIDS[algorithm.id] }, keyData };
};
var composeRsaSubjectPublicKeyInfo = function composeRsaSubjectPublicKeyInfo2(keyAlgorithm, keyData) {
  var rsaPublicKeyAsn1 = composeRsaPublicKey(keyAlgorithm, keyData);
  return { algorithm: { id: FLIPPED_OIDS[keyAlgorithm.id], parameters: hexStringToUint8Array("0500") }, publicKey: { unused: 0, data: rsaPublicKeyAsn1 } };
};
var decomposeEcSubjectPublicKeyInfo = function decomposeEcSubjectPublicKeyInfo2(subjectPublicKeyInfo) {
  var algorithm = subjectPublicKeyInfo.algorithm, publicKey = subjectPublicKeyInfo.publicKey;
  var ecParameters = decodeAsn1(algorithm.parameters, EcParameters);
  if (ecParameters.type !== "namedCurve") {
    throw new UnsupportedAlgorithmError("Only EC named curves are supported");
  }
  var namedCurve = OIDS[ecParameters.value];
  if (!namedCurve) {
    throw new UnsupportedAlgorithmError("Unsupported named curve OID '".concat(ecParameters.value, "'"));
  }
  var _decodeEcPoint3 = decodeEcPoint(namedCurve, publicKey.data), x2 = _decodeEcPoint3.x, y3 = _decodeEcPoint3.y;
  return { keyAlgorithm: { id: "ec-public-key", namedCurve }, keyData: { x: x2, y: y3 } };
};
var composeEcSubjectPublicKeyInfo = function composeEcSubjectPublicKeyInfo2(keyAlgorithm, keyData) {
  var namedCurveOid = FLIPPED_OIDS[keyAlgorithm.namedCurve];
  if (!namedCurveOid) {
    throw new UnsupportedAlgorithmError("Unsupported named curve '".concat(keyAlgorithm.namedCurve, "'"));
  }
  var encodedPoint = encodeEcPoint(keyAlgorithm.namedCurve, keyData.x, keyData.y);
  var ecParametersAsn1 = encodeAsn1({ type: "namedCurve", value: namedCurveOid }, EcParameters);
  return { algorithm: { id: FLIPPED_OIDS[keyAlgorithm.id], parameters: ecParametersAsn1 }, publicKey: { unused: 0, data: encodedPoint } };
};
var decomposeEd25519SubjectPublicKeyInfo = function decomposeEd25519SubjectPublicKeyInfo2(subjectPublicKeyInfo) {
  var algorithm = subjectPublicKeyInfo.algorithm, publicKey = subjectPublicKeyInfo.publicKey;
  return { keyAlgorithm: { id: OIDS[algorithm.id] }, keyData: { bytes: publicKey.data } };
};
var composeEd25519SubjectPublicKeyInfo = function composeEd25519SubjectPublicKeyInfo2(keyAlgorithm, keyData) {
  return { algorithm: { id: FLIPPED_OIDS[keyAlgorithm.id] }, publicKey: { unused: 0, data: keyData.bytes } };
};
var decomposeSubjectPublicKeyInfo = function decomposeSubjectPublicKeyInfo2(subjectPublicKeyInfo) {
  var keyType = KEY_TYPES[OIDS[subjectPublicKeyInfo.algorithm.id]];
  switch (keyType) {
    case "rsa":
      return decomposeRsaSubjectPublicKeyInfo(subjectPublicKeyInfo);
    case "ec":
      return decomposeEcSubjectPublicKeyInfo(subjectPublicKeyInfo);
    case "ed25519":
      return decomposeEd25519SubjectPublicKeyInfo(subjectPublicKeyInfo);
    default:
      throw new UnsupportedAlgorithmError("Unsupported key algorithm OID '".concat(subjectPublicKeyInfo.algorithm.id, "'"));
  }
};
var composeSubjectPublicKeyInfo = function composeSubjectPublicKeyInfo2(keyAlgorithm, keyData) {
  var keyType = KEY_TYPES[keyAlgorithm.id];
  switch (keyType) {
    case "rsa":
      return composeRsaSubjectPublicKeyInfo(keyAlgorithm, keyData);
    case "ec":
      return composeEcSubjectPublicKeyInfo(keyAlgorithm, keyData);
    case "ed25519":
      return composeEd25519SubjectPublicKeyInfo(keyAlgorithm, keyData);
    default:
      throw new UnsupportedAlgorithmError("Unsupported key algorithm id '".concat(keyAlgorithm.id, "'"));
  }
};
var decomposePublicKey$1 = function decomposePublicKey$12(subjectPublicKeyInfoAsn1) {
  var subjectPublicKeyInfo;
  try {
    subjectPublicKeyInfo = decodeAsn1(subjectPublicKeyInfoAsn1, SubjectPublicKeyInfo);
  } catch (err) {
    err.invalidInputKey = err instanceof DecodeAsn1FailedError;
    throw err;
  }
  var _decomposeSubjectPubl = decomposeSubjectPublicKeyInfo(subjectPublicKeyInfo), keyAlgorithm = _decomposeSubjectPubl.keyAlgorithm, keyData = _decomposeSubjectPubl.keyData;
  return { format: "spki-der", keyAlgorithm, keyData };
};
var composePublicKey$2 = function composePublicKey$22(_ref48) {
  var keyAlgorithm = _ref48.keyAlgorithm, keyData = _ref48.keyData;
  var subjectPublicKeyInfo = composeSubjectPublicKeyInfo(keyAlgorithm, keyData);
  var subjectPublicKeyInfoAsn1 = encodeAsn1(subjectPublicKeyInfo, SubjectPublicKeyInfo);
  return subjectPublicKeyInfoAsn1;
};
var spkiDer = Object.freeze(Object.defineProperty({ __proto__: null, composePublicKey: composePublicKey$2, decomposePublicKey: decomposePublicKey$1 }, Symbol.toStringTag, { value: "Module" }));
var decomposePublicKey = function decomposePublicKey2(pem2, options) {
  var decodedPem;
  try {
    decodedPem = decodePem(pem2, "PUBLIC KEY");
  } catch (err) {
    err.invalidInputKey = err instanceof DecodePemFailedError;
    throw err;
  }
  var spkiKey = binaryStringToUint8Array(decodedPem.body);
  var decomposedKey = decomposePublicKey$1(spkiKey);
  decomposedKey.format = "spki-pem";
  return decomposedKey;
};
var composePublicKey$1 = function composePublicKey$12(decomposedKey) {
  var spkiKey = composePublicKey$2(decomposedKey);
  return encodePem({ type: "PUBLIC KEY", body: uint8ArrayToBinaryString(spkiKey) });
};
var spkiPem = Object.freeze(Object.defineProperty({ __proto__: null, composePublicKey: composePublicKey$1, decomposePublicKey }, Symbol.toStringTag, { value: "Module" }));
var mapPrivate = function mapPrivate2(format) {
  return { decomposeKey: format.decomposePrivateKey, composeKey: format.composePrivateKey };
};
var mapPublic = function mapPublic2(format) {
  return { decomposeKey: format.decomposePublicKey, composeKey: format.composePublicKey };
};
var PRIVATE_FORMATS = { "pkcs1-der": mapPrivate(pkcs1Der), "pkcs1-pem": mapPrivate(pkcs1Pem), "pkcs8-der": mapPrivate(pkcs8Der), "pkcs8-pem": mapPrivate(pkcs8Pem), "raw-der": mapPrivate(rawDer), "raw-pem": mapPrivate(rawPem) };
var PUBLIC_FORMATS = { "raw-der": mapPublic(rawDer), "raw-pem": mapPublic(rawPem), "spki-der": mapPublic(spkiDer), "spki-pem": mapPublic(spkiPem) };
var composeKey = function composeKey2(supportedFormats, decomposedKey, options) {
  decomposedKey = validateDecomposedKey(decomposedKey, supportedFormats);
  return supportedFormats[decomposedKey.format].composeKey(decomposedKey, options);
};
var composePrivateKey = function composePrivateKey2(decomposedKey, options) {
  return composeKey(PRIVATE_FORMATS, decomposedKey, _objectSpread({ password: null }, options));
};
var composePublicKey = function composePublicKey2(decomposedKey) {
  return composeKey(PUBLIC_FORMATS, decomposedKey, {});
};
var getKeyTypeFromAlgorithm = function getKeyTypeFromAlgorithm2(keyAlgorithm) {
  var keyAlgorithmId = typeof keyAlgorithm === "string" ? keyAlgorithm : keyAlgorithm && keyAlgorithm.id;
  return KEY_TYPES[keyAlgorithmId];
};
var forge$A = forge$R;
forge$A.pki = forge$A.pki || {};
var oids$2 = forge$A.pki.oids = forge$A.oids = forge$A.oids || {};
function _IN$1(id, name2) {
  oids$2[id] = name2;
  oids$2[name2] = id;
}
function _I_$1(id, name2) {
  oids$2[id] = name2;
}
_IN$1("1.2.840.113549.1.1.1", "rsaEncryption");
_IN$1("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
_IN$1("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
_IN$1("1.2.840.113549.1.1.7", "RSAES-OAEP");
_IN$1("1.2.840.113549.1.1.8", "mgf1");
_IN$1("1.2.840.113549.1.1.9", "pSpecified");
_IN$1("1.2.840.113549.1.1.10", "RSASSA-PSS");
_IN$1("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
_IN$1("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
_IN$1("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
_IN$1("1.2.840.10040.4.3", "dsa-with-sha1");
_IN$1("1.3.14.3.2.7", "desCBC");
_IN$1("1.3.14.3.2.26", "sha1");
_IN$1("2.16.840.1.101.3.4.2.1", "sha256");
_IN$1("2.16.840.1.101.3.4.2.2", "sha384");
_IN$1("2.16.840.1.101.3.4.2.3", "sha512");
_IN$1("1.2.840.113549.2.5", "md5");
_IN$1("1.2.840.113549.1.7.1", "data");
_IN$1("1.2.840.113549.1.7.2", "signedData");
_IN$1("1.2.840.113549.1.7.3", "envelopedData");
_IN$1("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
_IN$1("1.2.840.113549.1.7.5", "digestedData");
_IN$1("1.2.840.113549.1.7.6", "encryptedData");
_IN$1("1.2.840.113549.1.9.1", "emailAddress");
_IN$1("1.2.840.113549.1.9.2", "unstructuredName");
_IN$1("1.2.840.113549.1.9.3", "contentType");
_IN$1("1.2.840.113549.1.9.4", "messageDigest");
_IN$1("1.2.840.113549.1.9.5", "signingTime");
_IN$1("1.2.840.113549.1.9.6", "counterSignature");
_IN$1("1.2.840.113549.1.9.7", "challengePassword");
_IN$1("1.2.840.113549.1.9.8", "unstructuredAddress");
_IN$1("1.2.840.113549.1.9.14", "extensionRequest");
_IN$1("1.2.840.113549.1.9.20", "friendlyName");
_IN$1("1.2.840.113549.1.9.21", "localKeyId");
_IN$1("1.2.840.113549.1.9.22.1", "x509Certificate");
_IN$1("1.2.840.113549.1.12.10.1.1", "keyBag");
_IN$1("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
_IN$1("1.2.840.113549.1.12.10.1.3", "certBag");
_IN$1("1.2.840.113549.1.12.10.1.4", "crlBag");
_IN$1("1.2.840.113549.1.12.10.1.5", "secretBag");
_IN$1("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
_IN$1("1.2.840.113549.1.5.13", "pkcs5PBES2");
_IN$1("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
_IN$1("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
_IN$1("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
_IN$1("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
_IN$1("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
_IN$1("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
_IN$1("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
_IN$1("1.2.840.113549.2.7", "hmacWithSHA1");
_IN$1("1.2.840.113549.2.8", "hmacWithSHA224");
_IN$1("1.2.840.113549.2.9", "hmacWithSHA256");
_IN$1("1.2.840.113549.2.10", "hmacWithSHA384");
_IN$1("1.2.840.113549.2.11", "hmacWithSHA512");
_IN$1("1.2.840.113549.3.7", "des-EDE3-CBC");
_IN$1("2.16.840.1.101.3.4.1.2", "aes128-CBC");
_IN$1("2.16.840.1.101.3.4.1.22", "aes192-CBC");
_IN$1("2.16.840.1.101.3.4.1.42", "aes256-CBC");
_IN$1("2.5.4.3", "commonName");
_IN$1("2.5.4.5", "serialName");
_IN$1("2.5.4.6", "countryName");
_IN$1("2.5.4.7", "localityName");
_IN$1("2.5.4.8", "stateOrProvinceName");
_IN$1("2.5.4.10", "organizationName");
_IN$1("2.5.4.11", "organizationalUnitName");
_IN$1("2.5.4.13", "description");
_IN$1("2.16.840.1.113730.1.1", "nsCertType");
_IN$1("2.16.840.1.113730.1.13", "nsComment");
_I_$1("2.5.29.1", "authorityKeyIdentifier");
_I_$1("2.5.29.2", "keyAttributes");
_I_$1("2.5.29.3", "certificatePolicies");
_I_$1("2.5.29.4", "keyUsageRestriction");
_I_$1("2.5.29.5", "policyMapping");
_I_$1("2.5.29.6", "subtreesConstraint");
_I_$1("2.5.29.7", "subjectAltName");
_I_$1("2.5.29.8", "issuerAltName");
_I_$1("2.5.29.9", "subjectDirectoryAttributes");
_I_$1("2.5.29.10", "basicConstraints");
_I_$1("2.5.29.11", "nameConstraints");
_I_$1("2.5.29.12", "policyConstraints");
_I_$1("2.5.29.13", "basicConstraints");
_IN$1("2.5.29.14", "subjectKeyIdentifier");
_IN$1("2.5.29.15", "keyUsage");
_I_$1("2.5.29.16", "privateKeyUsagePeriod");
_IN$1("2.5.29.17", "subjectAltName");
_IN$1("2.5.29.18", "issuerAltName");
_IN$1("2.5.29.19", "basicConstraints");
_I_$1("2.5.29.20", "cRLNumber");
_I_$1("2.5.29.21", "cRLReason");
_I_$1("2.5.29.22", "expirationDate");
_I_$1("2.5.29.23", "instructionCode");
_I_$1("2.5.29.24", "invalidityDate");
_I_$1("2.5.29.25", "cRLDistributionPoints");
_I_$1("2.5.29.26", "issuingDistributionPoint");
_I_$1("2.5.29.27", "deltaCRLIndicator");
_I_$1("2.5.29.28", "issuingDistributionPoint");
_I_$1("2.5.29.29", "certificateIssuer");
_I_$1("2.5.29.30", "nameConstraints");
_IN$1("2.5.29.31", "cRLDistributionPoints");
_IN$1("2.5.29.32", "certificatePolicies");
_I_$1("2.5.29.33", "policyMappings");
_I_$1("2.5.29.34", "policyConstraints");
_IN$1("2.5.29.35", "authorityKeyIdentifier");
_I_$1("2.5.29.36", "policyConstraints");
_IN$1("2.5.29.37", "extKeyUsage");
_I_$1("2.5.29.46", "freshestCRL");
_I_$1("2.5.29.54", "inhibitAnyPolicy");
_IN$1("1.3.6.1.4.1.11129.2.4.2", "timestampList");
_IN$1("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
_IN$1("1.3.6.1.5.5.7.3.1", "serverAuth");
_IN$1("1.3.6.1.5.5.7.3.2", "clientAuth");
_IN$1("1.3.6.1.5.5.7.3.3", "codeSigning");
_IN$1("1.3.6.1.5.5.7.3.4", "emailProtection");
_IN$1("1.3.6.1.5.5.7.3.8", "timeStamping");
var forge$z = forge$R;
var asn1$5 = forge$z.asn1 = forge$z.asn1 || {};
asn1$5.Class = { UNIVERSAL: 0, APPLICATION: 64, CONTEXT_SPECIFIC: 128, PRIVATE: 192 };
asn1$5.Type = { NONE: 0, BOOLEAN: 1, INTEGER: 2, BITSTRING: 3, OCTETSTRING: 4, NULL: 5, OID: 6, ODESC: 7, EXTERNAL: 8, REAL: 9, ENUMERATED: 10, EMBEDDED: 11, UTF8: 12, ROID: 13, SEQUENCE: 16, SET: 17, PRINTABLESTRING: 19, IA5STRING: 22, UTCTIME: 23, GENERALIZEDTIME: 24, BMPSTRING: 30 };
asn1$5.create = function(tagClass, type, constructed, value, options) {
  if (forge$z.util.isArray(value)) {
    var tmp = [];
    for (var i2 = 0; i2 < value.length; ++i2) {
      if (value[i2] !== void 0) {
        tmp.push(value[i2]);
      }
    }
    value = tmp;
  }
  var obj2 = { tagClass, type, constructed, composed: constructed || forge$z.util.isArray(value), value };
  if (options && "bitStringContents" in options) {
    obj2.bitStringContents = options.bitStringContents;
    obj2.original = asn1$5.copy(obj2);
  }
  return obj2;
};
asn1$5.copy = function(obj2, options) {
  var copy;
  if (forge$z.util.isArray(obj2)) {
    copy = [];
    for (var i2 = 0; i2 < obj2.length; ++i2) {
      copy.push(asn1$5.copy(obj2[i2], options));
    }
    return copy;
  }
  if (typeof obj2 === "string") {
    return obj2;
  }
  copy = { tagClass: obj2.tagClass, type: obj2.type, constructed: obj2.constructed, composed: obj2.composed, value: asn1$5.copy(obj2.value, options) };
  if (options && !options.excludeBitStringContents) {
    copy.bitStringContents = obj2.bitStringContents;
  }
  return copy;
};
asn1$5.equals = function(obj1, obj2, options) {
  if (forge$z.util.isArray(obj1)) {
    if (!forge$z.util.isArray(obj2)) {
      return false;
    }
    if (obj1.length !== obj2.length) {
      return false;
    }
    for (var i2 = 0; i2 < obj1.length; ++i2) {
      if (!asn1$5.equals(obj1[i2], obj2[i2])) {
        return false;
      }
    }
    return true;
  }
  if (_typeof(obj1) !== _typeof(obj2)) {
    return false;
  }
  if (typeof obj1 === "string") {
    return obj1 === obj2;
  }
  var equal = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn1$5.equals(obj1.value, obj2.value);
  if (options && options.includeBitStringContents) {
    equal = equal && obj1.bitStringContents === obj2.bitStringContents;
  }
  return equal;
};
asn1$5.getBerValueLength = function(b3) {
  var b22 = b3.getByte();
  if (b22 === 128) {
    return void 0;
  }
  var length3;
  var longForm = b22 & 128;
  if (!longForm) {
    length3 = b22;
  } else {
    length3 = b3.getInt((b22 & 127) << 3);
  }
  return length3;
};
function _checkBufferLength$1(bytes, remaining, n2) {
  if (n2 > remaining) {
    var error3 = new Error("Too few bytes to parse DER.");
    error3.available = bytes.length();
    error3.remaining = remaining;
    error3.requested = n2;
    throw error3;
  }
}
var _getValueLength$1 = function _getValueLength$12(bytes, remaining) {
  var b22 = bytes.getByte();
  remaining--;
  if (b22 === 128) {
    return void 0;
  }
  var length3;
  var longForm = b22 & 128;
  if (!longForm) {
    length3 = b22;
  } else {
    var longFormBytes = b22 & 127;
    _checkBufferLength$1(bytes, remaining, longFormBytes);
    length3 = bytes.getInt(longFormBytes << 3);
  }
  if (length3 < 0) {
    throw new Error("Negative length: " + length3);
  }
  return length3;
};
asn1$5.fromDer = function(bytes, options) {
  if (options === void 0) {
    options = { strict: true, decodeBitStrings: true };
  }
  if (typeof options === "boolean") {
    options = { strict: options, decodeBitStrings: true };
  }
  if (!("strict" in options)) {
    options.strict = true;
  }
  if (!("decodeBitStrings" in options)) {
    options.decodeBitStrings = true;
  }
  if (typeof bytes === "string") {
    bytes = forge$z.util.createBuffer(bytes);
  }
  return _fromDer$1(bytes, bytes.length(), 0, options);
};
function _fromDer$1(bytes, remaining, depth, options) {
  var start;
  _checkBufferLength$1(bytes, remaining, 2);
  var b1 = bytes.getByte();
  remaining--;
  var tagClass = b1 & 192;
  var type = b1 & 31;
  start = bytes.length();
  var length3 = _getValueLength$1(bytes, remaining);
  remaining -= start - bytes.length();
  if (length3 !== void 0 && length3 > remaining) {
    if (options.strict) {
      var error3 = new Error("Too few bytes to read ASN.1 value.");
      error3.available = bytes.length();
      error3.remaining = remaining;
      error3.requested = length3;
      throw error3;
    }
    length3 = remaining;
  }
  var value;
  var bitStringContents;
  var constructed = (b1 & 32) === 32;
  if (constructed) {
    value = [];
    if (length3 === void 0) {
      for (; ; ) {
        _checkBufferLength$1(bytes, remaining, 2);
        if (bytes.bytes(2) === String.fromCharCode(0, 0)) {
          bytes.getBytes(2);
          remaining -= 2;
          break;
        }
        start = bytes.length();
        value.push(_fromDer$1(bytes, remaining, depth + 1, options));
        remaining -= start - bytes.length();
      }
    } else {
      while (length3 > 0) {
        start = bytes.length();
        value.push(_fromDer$1(bytes, length3, depth + 1, options));
        remaining -= start - bytes.length();
        length3 -= start - bytes.length();
      }
    }
  }
  if (value === void 0 && tagClass === asn1$5.Class.UNIVERSAL && type === asn1$5.Type.BITSTRING) {
    bitStringContents = bytes.bytes(length3);
  }
  if (value === void 0 && options.decodeBitStrings && tagClass === asn1$5.Class.UNIVERSAL && // FIXME: OCTET STRINGs not yet supported here
  // .. other parts of forge expect to decode OCTET STRINGs manually
  type === asn1$5.Type.BITSTRING && length3 > 1) {
    var savedRead = bytes.read;
    var savedRemaining = remaining;
    var unused = 0;
    if (type === asn1$5.Type.BITSTRING) {
      _checkBufferLength$1(bytes, remaining, 1);
      unused = bytes.getByte();
      remaining--;
    }
    if (unused === 0) {
      try {
        start = bytes.length();
        var subOptions = {
          // enforce strict mode to avoid parsing ASN.1 from plain data
          verbose: options.verbose,
          strict: true,
          decodeBitStrings: true
        };
        var composed = _fromDer$1(bytes, remaining, depth + 1, subOptions);
        var used = start - bytes.length();
        remaining -= used;
        if (type == asn1$5.Type.BITSTRING) {
          used++;
        }
        var tc = composed.tagClass;
        if (used === length3 && (tc === asn1$5.Class.UNIVERSAL || tc === asn1$5.Class.CONTEXT_SPECIFIC)) {
          value = [composed];
        }
      } catch (ex) {
      }
    }
    if (value === void 0) {
      bytes.read = savedRead;
      remaining = savedRemaining;
    }
  }
  if (value === void 0) {
    if (length3 === void 0) {
      if (options.strict) {
        throw new Error("Non-constructed ASN.1 object of indefinite length.");
      }
      length3 = remaining;
    }
    if (type === asn1$5.Type.BMPSTRING) {
      value = "";
      for (; length3 > 0; length3 -= 2) {
        _checkBufferLength$1(bytes, remaining, 2);
        value += String.fromCharCode(bytes.getInt16());
        remaining -= 2;
      }
    } else {
      value = bytes.getBytes(length3);
    }
  }
  var asn1Options = bitStringContents === void 0 ? null : { bitStringContents };
  return asn1$5.create(tagClass, type, constructed, value, asn1Options);
}
asn1$5.toDer = function(obj2) {
  var bytes = forge$z.util.createBuffer();
  var b1 = obj2.tagClass | obj2.type;
  var value = forge$z.util.createBuffer();
  var useBitStringContents = false;
  if ("bitStringContents" in obj2) {
    useBitStringContents = true;
    if (obj2.original) {
      useBitStringContents = asn1$5.equals(obj2, obj2.original);
    }
  }
  if (useBitStringContents) {
    value.putBytes(obj2.bitStringContents);
  } else if (obj2.composed) {
    if (obj2.constructed) {
      b1 |= 32;
    } else {
      value.putByte(0);
    }
    for (var i2 = 0; i2 < obj2.value.length; ++i2) {
      if (obj2.value[i2] !== void 0) {
        value.putBuffer(asn1$5.toDer(obj2.value[i2]));
      }
    }
  } else {
    if (obj2.type === asn1$5.Type.BMPSTRING) {
      for (var i2 = 0; i2 < obj2.value.length; ++i2) {
        value.putInt16(obj2.value.charCodeAt(i2));
      }
    } else {
      if (obj2.type === asn1$5.Type.INTEGER && obj2.value.length > 1 && // leading 0x00 for positive integer
      (obj2.value.charCodeAt(0) === 0 && (obj2.value.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer
      obj2.value.charCodeAt(0) === 255 && (obj2.value.charCodeAt(1) & 128) === 128)) {
        value.putBytes(obj2.value.substr(1));
      } else {
        value.putBytes(obj2.value);
      }
    }
  }
  bytes.putByte(b1);
  if (value.length() <= 127) {
    bytes.putByte(value.length() & 127);
  } else {
    var len2 = value.length();
    var lenBytes = "";
    do {
      lenBytes += String.fromCharCode(len2 & 255);
      len2 = len2 >>> 8;
    } while (len2 > 0);
    bytes.putByte(lenBytes.length | 128);
    for (var i2 = lenBytes.length - 1; i2 >= 0; --i2) {
      bytes.putByte(lenBytes.charCodeAt(i2));
    }
  }
  bytes.putBuffer(value);
  return bytes;
};
asn1$5.oidToDer = function(oid) {
  var values = oid.split(".");
  var bytes = forge$z.util.createBuffer();
  bytes.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));
  var last, valueBytes, value, b3;
  for (var i2 = 2; i2 < values.length; ++i2) {
    last = true;
    valueBytes = [];
    value = parseInt(values[i2], 10);
    do {
      b3 = value & 127;
      value = value >>> 7;
      if (!last) {
        b3 |= 128;
      }
      valueBytes.push(b3);
      last = false;
    } while (value > 0);
    for (var n2 = valueBytes.length - 1; n2 >= 0; --n2) {
      bytes.putByte(valueBytes[n2]);
    }
  }
  return bytes;
};
asn1$5.derToOid = function(bytes) {
  var oid;
  if (typeof bytes === "string") {
    bytes = forge$z.util.createBuffer(bytes);
  }
  var b3 = bytes.getByte();
  oid = Math.floor(b3 / 40) + "." + b3 % 40;
  var value = 0;
  while (bytes.length() > 0) {
    b3 = bytes.getByte();
    value = value << 7;
    if (b3 & 128) {
      value += b3 & 127;
    } else {
      oid += "." + (value + b3);
      value = 0;
    }
  }
  return oid;
};
asn1$5.utcTimeToDate = function(utc) {
  var date = /* @__PURE__ */ new Date();
  var year = parseInt(utc.substr(0, 2), 10);
  year = year >= 50 ? 1900 + year : 2e3 + year;
  var MM = parseInt(utc.substr(2, 2), 10) - 1;
  var DD = parseInt(utc.substr(4, 2), 10);
  var hh = parseInt(utc.substr(6, 2), 10);
  var mm = parseInt(utc.substr(8, 2), 10);
  var ss = 0;
  if (utc.length > 11) {
    var c3 = utc.charAt(10);
    var end2 = 10;
    if (c3 !== "+" && c3 !== "-") {
      ss = parseInt(utc.substr(10, 2), 10);
      end2 += 2;
    }
  }
  date.setUTCFullYear(year, MM, DD);
  date.setUTCHours(hh, mm, ss, 0);
  if (end2) {
    c3 = utc.charAt(end2);
    if (c3 === "+" || c3 === "-") {
      var hhoffset = parseInt(utc.substr(end2 + 1, 2), 10);
      var mmoffset = parseInt(utc.substr(end2 + 4, 2), 10);
      var offset = hhoffset * 60 + mmoffset;
      offset *= 6e4;
      if (c3 === "+") {
        date.setTime(+date - offset);
      } else {
        date.setTime(+date + offset);
      }
    }
  }
  return date;
};
asn1$5.generalizedTimeToDate = function(gentime) {
  var date = /* @__PURE__ */ new Date();
  var YYYY = parseInt(gentime.substr(0, 4), 10);
  var MM = parseInt(gentime.substr(4, 2), 10) - 1;
  var DD = parseInt(gentime.substr(6, 2), 10);
  var hh = parseInt(gentime.substr(8, 2), 10);
  var mm = parseInt(gentime.substr(10, 2), 10);
  var ss = parseInt(gentime.substr(12, 2), 10);
  var fff = 0;
  var offset = 0;
  var isUTC = false;
  if (gentime.charAt(gentime.length - 1) === "Z") {
    isUTC = true;
  }
  var end2 = gentime.length - 5, c3 = gentime.charAt(end2);
  if (c3 === "+" || c3 === "-") {
    var hhoffset = parseInt(gentime.substr(end2 + 1, 2), 10);
    var mmoffset = parseInt(gentime.substr(end2 + 4, 2), 10);
    offset = hhoffset * 60 + mmoffset;
    offset *= 6e4;
    if (c3 === "+") {
      offset *= -1;
    }
    isUTC = true;
  }
  if (gentime.charAt(14) === ".") {
    fff = parseFloat(gentime.substr(14), 10) * 1e3;
  }
  if (isUTC) {
    date.setUTCFullYear(YYYY, MM, DD);
    date.setUTCHours(hh, mm, ss, fff);
    date.setTime(+date + offset);
  } else {
    date.setFullYear(YYYY, MM, DD);
    date.setHours(hh, mm, ss, fff);
  }
  return date;
};
asn1$5.dateToUtcTime = function(date) {
  if (typeof date === "string") {
    return date;
  }
  var rval = "";
  var format = [];
  format.push(("" + date.getUTCFullYear()).substr(2));
  format.push("" + (date.getUTCMonth() + 1));
  format.push("" + date.getUTCDate());
  format.push("" + date.getUTCHours());
  format.push("" + date.getUTCMinutes());
  format.push("" + date.getUTCSeconds());
  for (var i2 = 0; i2 < format.length; ++i2) {
    if (format[i2].length < 2) {
      rval += "0";
    }
    rval += format[i2];
  }
  rval += "Z";
  return rval;
};
asn1$5.dateToGeneralizedTime = function(date) {
  if (typeof date === "string") {
    return date;
  }
  var rval = "";
  var format = [];
  format.push("" + date.getUTCFullYear());
  format.push("" + (date.getUTCMonth() + 1));
  format.push("" + date.getUTCDate());
  format.push("" + date.getUTCHours());
  format.push("" + date.getUTCMinutes());
  format.push("" + date.getUTCSeconds());
  for (var i2 = 0; i2 < format.length; ++i2) {
    if (format[i2].length < 2) {
      rval += "0";
    }
    rval += format[i2];
  }
  rval += "Z";
  return rval;
};
asn1$5.integerToDer = function(x2) {
  var rval = forge$z.util.createBuffer();
  if (x2 >= -128 && x2 < 128) {
    return rval.putSignedInt(x2, 8);
  }
  if (x2 >= -32768 && x2 < 32768) {
    return rval.putSignedInt(x2, 16);
  }
  if (x2 >= -8388608 && x2 < 8388608) {
    return rval.putSignedInt(x2, 24);
  }
  if (x2 >= -2147483648 && x2 < 2147483648) {
    return rval.putSignedInt(x2, 32);
  }
  var error3 = new Error("Integer too large; max is 32-bits.");
  error3.integer = x2;
  throw error3;
};
asn1$5.derToInteger = function(bytes) {
  if (typeof bytes === "string") {
    bytes = forge$z.util.createBuffer(bytes);
  }
  var n2 = bytes.length() * 8;
  if (n2 > 32) {
    throw new Error("Integer too large; max is 32-bits.");
  }
  return bytes.getSignedInt(n2);
};
asn1$5.validate = function(obj2, v2, capture, errors) {
  var rval = false;
  if ((obj2.tagClass === v2.tagClass || typeof v2.tagClass === "undefined") && (obj2.type === v2.type || typeof v2.type === "undefined")) {
    if (obj2.constructed === v2.constructed || typeof v2.constructed === "undefined") {
      rval = true;
      if (v2.value && forge$z.util.isArray(v2.value)) {
        var j3 = 0;
        for (var i2 = 0; rval && i2 < v2.value.length; ++i2) {
          rval = v2.value[i2].optional || false;
          if (obj2.value[j3]) {
            rval = asn1$5.validate(obj2.value[j3], v2.value[i2], capture, errors);
            if (rval) {
              ++j3;
            } else if (v2.value[i2].optional) {
              rval = true;
            }
          }
          if (!rval && errors) {
            errors.push("[" + v2.name + '] Tag class "' + v2.tagClass + '", type "' + v2.type + '" expected value length "' + v2.value.length + '", got "' + obj2.value.length + '"');
          }
        }
      }
      if (rval && capture) {
        if (v2.capture) {
          capture[v2.capture] = obj2.value;
        }
        if (v2.captureAsn1) {
          capture[v2.captureAsn1] = obj2;
        }
        if (v2.captureBitStringContents && "bitStringContents" in obj2) {
          capture[v2.captureBitStringContents] = obj2.bitStringContents;
        }
        if (v2.captureBitStringValue && "bitStringContents" in obj2) {
          if (obj2.bitStringContents.length < 2) {
            capture[v2.captureBitStringValue] = "";
          } else {
            var unused = obj2.bitStringContents.charCodeAt(0);
            if (unused !== 0) {
              throw new Error("captureBitStringValue only supported for zero unused bits");
            }
            capture[v2.captureBitStringValue] = obj2.bitStringContents.slice(1);
          }
        }
      }
    } else if (errors) {
      errors.push("[" + v2.name + '] Expected constructed "' + v2.constructed + '", got "' + obj2.constructed + '"');
    }
  } else if (errors) {
    if (obj2.tagClass !== v2.tagClass) {
      errors.push("[" + v2.name + '] Expected tag class "' + v2.tagClass + '", got "' + obj2.tagClass + '"');
    }
    if (obj2.type !== v2.type) {
      errors.push("[" + v2.name + '] Expected type "' + v2.type + '", got "' + obj2.type + '"');
    }
  }
  return rval;
};
var _nonLatinRegex$1 = /[^\\u0000-\\u00ff]/;
asn1$5.prettyPrint = function(obj2, level, indentation) {
  var rval = "";
  level = level || 0;
  indentation = indentation || 2;
  if (level > 0) {
    rval += "\n";
  }
  var indent = "";
  for (var i2 = 0; i2 < level * indentation; ++i2) {
    indent += " ";
  }
  rval += indent + "Tag: ";
  switch (obj2.tagClass) {
    case asn1$5.Class.UNIVERSAL:
      rval += "Universal:";
      break;
    case asn1$5.Class.APPLICATION:
      rval += "Application:";
      break;
    case asn1$5.Class.CONTEXT_SPECIFIC:
      rval += "Context-Specific:";
      break;
    case asn1$5.Class.PRIVATE:
      rval += "Private:";
      break;
  }
  if (obj2.tagClass === asn1$5.Class.UNIVERSAL) {
    rval += obj2.type;
    switch (obj2.type) {
      case asn1$5.Type.NONE:
        rval += " (None)";
        break;
      case asn1$5.Type.BOOLEAN:
        rval += " (Boolean)";
        break;
      case asn1$5.Type.INTEGER:
        rval += " (Integer)";
        break;
      case asn1$5.Type.BITSTRING:
        rval += " (Bit string)";
        break;
      case asn1$5.Type.OCTETSTRING:
        rval += " (Octet string)";
        break;
      case asn1$5.Type.NULL:
        rval += " (Null)";
        break;
      case asn1$5.Type.OID:
        rval += " (Object Identifier)";
        break;
      case asn1$5.Type.ODESC:
        rval += " (Object Descriptor)";
        break;
      case asn1$5.Type.EXTERNAL:
        rval += " (External or Instance of)";
        break;
      case asn1$5.Type.REAL:
        rval += " (Real)";
        break;
      case asn1$5.Type.ENUMERATED:
        rval += " (Enumerated)";
        break;
      case asn1$5.Type.EMBEDDED:
        rval += " (Embedded PDV)";
        break;
      case asn1$5.Type.UTF8:
        rval += " (UTF8)";
        break;
      case asn1$5.Type.ROID:
        rval += " (Relative Object Identifier)";
        break;
      case asn1$5.Type.SEQUENCE:
        rval += " (Sequence)";
        break;
      case asn1$5.Type.SET:
        rval += " (Set)";
        break;
      case asn1$5.Type.PRINTABLESTRING:
        rval += " (Printable String)";
        break;
      case asn1$5.Type.IA5String:
        rval += " (IA5String (ASCII))";
        break;
      case asn1$5.Type.UTCTIME:
        rval += " (UTC time)";
        break;
      case asn1$5.Type.GENERALIZEDTIME:
        rval += " (Generalized time)";
        break;
      case asn1$5.Type.BMPSTRING:
        rval += " (BMP String)";
        break;
    }
  } else {
    rval += obj2.type;
  }
  rval += "\n";
  rval += indent + "Constructed: " + obj2.constructed + "\n";
  if (obj2.composed) {
    var subvalues = 0;
    var sub = "";
    for (var i2 = 0; i2 < obj2.value.length; ++i2) {
      if (obj2.value[i2] !== void 0) {
        subvalues += 1;
        sub += asn1$5.prettyPrint(obj2.value[i2], level + 1, indentation);
        if (i2 + 1 < obj2.value.length) {
          sub += ",";
        }
      }
    }
    rval += indent + "Sub values: " + subvalues + sub;
  } else {
    rval += indent + "Value: ";
    if (obj2.type === asn1$5.Type.OID) {
      var oid = asn1$5.derToOid(obj2.value);
      rval += oid;
      if (forge$z.pki && forge$z.pki.oids) {
        if (oid in forge$z.pki.oids) {
          rval += " (" + forge$z.pki.oids[oid] + ") ";
        }
      }
    }
    if (obj2.type === asn1$5.Type.INTEGER) {
      try {
        rval += asn1$5.derToInteger(obj2.value);
      } catch (ex) {
        rval += "0x" + forge$z.util.bytesToHex(obj2.value);
      }
    } else if (obj2.type === asn1$5.Type.BITSTRING) {
      if (obj2.value.length > 1) {
        rval += "0x" + forge$z.util.bytesToHex(obj2.value.slice(1));
      } else {
        rval += "(none)";
      }
      if (obj2.value.length > 0) {
        var unused = obj2.value.charCodeAt(0);
        if (unused == 1) {
          rval += " (1 unused bit shown)";
        } else if (unused > 1) {
          rval += " (" + unused + " unused bits shown)";
        }
      }
    } else if (obj2.type === asn1$5.Type.OCTETSTRING) {
      if (!_nonLatinRegex$1.test(obj2.value)) {
        rval += "(" + obj2.value + ") ";
      }
      rval += "0x" + forge$z.util.bytesToHex(obj2.value);
    } else if (obj2.type === asn1$5.Type.UTF8) {
      rval += forge$z.util.decodeUtf8(obj2.value);
    } else if (obj2.type === asn1$5.Type.PRINTABLESTRING || obj2.type === asn1$5.Type.IA5String) {
      rval += obj2.value;
    } else if (_nonLatinRegex$1.test(obj2.value)) {
      rval += "0x" + forge$z.util.bytesToHex(obj2.value);
    } else if (obj2.value.length === 0) {
      rval += "[null]";
    } else {
      rval += obj2.value;
    }
  }
  return rval;
};
var forge$y = forge$R;
forge$y.jsbn = forge$y.jsbn || {};
var dbits$1;
function BigInteger$6(a2, b3, c3) {
  this.data = [];
  if (a2 != null)
    if ("number" == typeof a2)
      this.fromNumber(a2, b3, c3);
    else if (b3 == null && "string" != typeof a2)
      this.fromString(a2, 256);
    else
      this.fromString(a2, b3);
}
forge$y.jsbn.BigInteger = BigInteger$6;
function nbi$1() {
  return new BigInteger$6(null);
}
function am1$1(i2, x2, w2, j3, c3, n2) {
  while (--n2 >= 0) {
    var v2 = x2 * this.data[i2++] + w2.data[j3] + c3;
    c3 = Math.floor(v2 / 67108864);
    w2.data[j3++] = v2 & 67108863;
  }
  return c3;
}
function am2$1(i2, x2, w2, j3, c3, n2) {
  var xl = x2 & 32767, xh = x2 >> 15;
  while (--n2 >= 0) {
    var l2 = this.data[i2] & 32767;
    var h2 = this.data[i2++] >> 15;
    var m2 = xh * l2 + h2 * xl;
    l2 = xl * l2 + ((m2 & 32767) << 15) + w2.data[j3] + (c3 & 1073741823);
    c3 = (l2 >>> 30) + (m2 >>> 15) + xh * h2 + (c3 >>> 30);
    w2.data[j3++] = l2 & 1073741823;
  }
  return c3;
}
function am3$1(i2, x2, w2, j3, c3, n2) {
  var xl = x2 & 16383, xh = x2 >> 14;
  while (--n2 >= 0) {
    var l2 = this.data[i2] & 16383;
    var h2 = this.data[i2++] >> 14;
    var m2 = xh * l2 + h2 * xl;
    l2 = xl * l2 + ((m2 & 16383) << 14) + w2.data[j3] + c3;
    c3 = (l2 >> 28) + (m2 >> 14) + xh * h2;
    w2.data[j3++] = l2 & 268435455;
  }
  return c3;
}
if (typeof navigator === "undefined") {
  BigInteger$6.prototype.am = am3$1;
  dbits$1 = 28;
} else if (navigator.appName == "Microsoft Internet Explorer") {
  BigInteger$6.prototype.am = am2$1;
  dbits$1 = 30;
} else if (navigator.appName != "Netscape") {
  BigInteger$6.prototype.am = am1$1;
  dbits$1 = 26;
} else {
  BigInteger$6.prototype.am = am3$1;
  dbits$1 = 28;
}
BigInteger$6.prototype.DB = dbits$1;
BigInteger$6.prototype.DM = (1 << dbits$1) - 1;
BigInteger$6.prototype.DV = 1 << dbits$1;
var BI_FP$1 = 52;
BigInteger$6.prototype.FV = Math.pow(2, BI_FP$1);
BigInteger$6.prototype.F1 = BI_FP$1 - dbits$1;
BigInteger$6.prototype.F2 = 2 * dbits$1 - BI_FP$1;
var BI_RM$1 = "0123456789abcdefghijklmnopqrstuvwxyz";
var BI_RC$1 = new Array();
var rr$1;
var vv$1;
rr$1 = "0".charCodeAt(0);
for (vv$1 = 0; vv$1 <= 9; ++vv$1)
  BI_RC$1[rr$1++] = vv$1;
rr$1 = "a".charCodeAt(0);
for (vv$1 = 10; vv$1 < 36; ++vv$1)
  BI_RC$1[rr$1++] = vv$1;
rr$1 = "A".charCodeAt(0);
for (vv$1 = 10; vv$1 < 36; ++vv$1)
  BI_RC$1[rr$1++] = vv$1;
function int2char$1(n2) {
  return BI_RM$1.charAt(n2);
}
function intAt$1(s2, i2) {
  var c3 = BI_RC$1[s2.charCodeAt(i2)];
  return c3 == null ? -1 : c3;
}
function bnpCopyTo$1(r2) {
  for (var i2 = this.t - 1; i2 >= 0; --i2)
    r2.data[i2] = this.data[i2];
  r2.t = this.t;
  r2.s = this.s;
}
function bnpFromInt$1(x2) {
  this.t = 1;
  this.s = x2 < 0 ? -1 : 0;
  if (x2 > 0)
    this.data[0] = x2;
  else if (x2 < -1)
    this.data[0] = x2 + this.DV;
  else
    this.t = 0;
}
function nbv$1(i2) {
  var r2 = nbi$1();
  r2.fromInt(i2);
  return r2;
}
function bnpFromString$1(s2, b3) {
  var k3;
  if (b3 == 16)
    k3 = 4;
  else if (b3 == 8)
    k3 = 3;
  else if (b3 == 256)
    k3 = 8;
  else if (b3 == 2)
    k3 = 1;
  else if (b3 == 32)
    k3 = 5;
  else if (b3 == 4)
    k3 = 2;
  else {
    this.fromRadix(s2, b3);
    return;
  }
  this.t = 0;
  this.s = 0;
  var i2 = s2.length, mi = false, sh2 = 0;
  while (--i2 >= 0) {
    var x2 = k3 == 8 ? s2[i2] & 255 : intAt$1(s2, i2);
    if (x2 < 0) {
      if (s2.charAt(i2) == "-")
        mi = true;
      continue;
    }
    mi = false;
    if (sh2 == 0)
      this.data[this.t++] = x2;
    else if (sh2 + k3 > this.DB) {
      this.data[this.t - 1] |= (x2 & (1 << this.DB - sh2) - 1) << sh2;
      this.data[this.t++] = x2 >> this.DB - sh2;
    } else
      this.data[this.t - 1] |= x2 << sh2;
    sh2 += k3;
    if (sh2 >= this.DB)
      sh2 -= this.DB;
  }
  if (k3 == 8 && (s2[0] & 128) != 0) {
    this.s = -1;
    if (sh2 > 0)
      this.data[this.t - 1] |= (1 << this.DB - sh2) - 1 << sh2;
  }
  this.clamp();
  if (mi)
    BigInteger$6.ZERO.subTo(this, this);
}
function bnpClamp$1() {
  var c3 = this.s & this.DM;
  while (this.t > 0 && this.data[this.t - 1] == c3)
    --this.t;
}
function bnToString$1(b3) {
  if (this.s < 0)
    return "-" + this.negate().toString(b3);
  var k3;
  if (b3 == 16)
    k3 = 4;
  else if (b3 == 8)
    k3 = 3;
  else if (b3 == 2)
    k3 = 1;
  else if (b3 == 32)
    k3 = 5;
  else if (b3 == 4)
    k3 = 2;
  else
    return this.toRadix(b3);
  var km = (1 << k3) - 1, d2, m2 = false, r2 = "", i2 = this.t;
  var p2 = this.DB - i2 * this.DB % k3;
  if (i2-- > 0) {
    if (p2 < this.DB && (d2 = this.data[i2] >> p2) > 0) {
      m2 = true;
      r2 = int2char$1(d2);
    }
    while (i2 >= 0) {
      if (p2 < k3) {
        d2 = (this.data[i2] & (1 << p2) - 1) << k3 - p2;
        d2 |= this.data[--i2] >> (p2 += this.DB - k3);
      } else {
        d2 = this.data[i2] >> (p2 -= k3) & km;
        if (p2 <= 0) {
          p2 += this.DB;
          --i2;
        }
      }
      if (d2 > 0)
        m2 = true;
      if (m2)
        r2 += int2char$1(d2);
    }
  }
  return m2 ? r2 : "0";
}
function bnNegate$1() {
  var r2 = nbi$1();
  BigInteger$6.ZERO.subTo(this, r2);
  return r2;
}
function bnAbs$1() {
  return this.s < 0 ? this.negate() : this;
}
function bnCompareTo$1(a2) {
  var r2 = this.s - a2.s;
  if (r2 != 0)
    return r2;
  var i2 = this.t;
  r2 = i2 - a2.t;
  if (r2 != 0)
    return this.s < 0 ? -r2 : r2;
  while (--i2 >= 0)
    if ((r2 = this.data[i2] - a2.data[i2]) != 0)
      return r2;
  return 0;
}
function nbits$1(x2) {
  var r2 = 1, t2;
  if ((t2 = x2 >>> 16) != 0) {
    x2 = t2;
    r2 += 16;
  }
  if ((t2 = x2 >> 8) != 0) {
    x2 = t2;
    r2 += 8;
  }
  if ((t2 = x2 >> 4) != 0) {
    x2 = t2;
    r2 += 4;
  }
  if ((t2 = x2 >> 2) != 0) {
    x2 = t2;
    r2 += 2;
  }
  if ((t2 = x2 >> 1) != 0) {
    x2 = t2;
    r2 += 1;
  }
  return r2;
}
function bnBitLength$1() {
  if (this.t <= 0)
    return 0;
  return this.DB * (this.t - 1) + nbits$1(this.data[this.t - 1] ^ this.s & this.DM);
}
function bnpDLShiftTo$1(n2, r2) {
  var i2;
  for (i2 = this.t - 1; i2 >= 0; --i2)
    r2.data[i2 + n2] = this.data[i2];
  for (i2 = n2 - 1; i2 >= 0; --i2)
    r2.data[i2] = 0;
  r2.t = this.t + n2;
  r2.s = this.s;
}
function bnpDRShiftTo$1(n2, r2) {
  for (var i2 = n2; i2 < this.t; ++i2)
    r2.data[i2 - n2] = this.data[i2];
  r2.t = Math.max(this.t - n2, 0);
  r2.s = this.s;
}
function bnpLShiftTo$1(n2, r2) {
  var bs = n2 % this.DB;
  var cbs = this.DB - bs;
  var bm = (1 << cbs) - 1;
  var ds = Math.floor(n2 / this.DB), c3 = this.s << bs & this.DM, i2;
  for (i2 = this.t - 1; i2 >= 0; --i2) {
    r2.data[i2 + ds + 1] = this.data[i2] >> cbs | c3;
    c3 = (this.data[i2] & bm) << bs;
  }
  for (i2 = ds - 1; i2 >= 0; --i2)
    r2.data[i2] = 0;
  r2.data[ds] = c3;
  r2.t = this.t + ds + 1;
  r2.s = this.s;
  r2.clamp();
}
function bnpRShiftTo$1(n2, r2) {
  r2.s = this.s;
  var ds = Math.floor(n2 / this.DB);
  if (ds >= this.t) {
    r2.t = 0;
    return;
  }
  var bs = n2 % this.DB;
  var cbs = this.DB - bs;
  var bm = (1 << bs) - 1;
  r2.data[0] = this.data[ds] >> bs;
  for (var i2 = ds + 1; i2 < this.t; ++i2) {
    r2.data[i2 - ds - 1] |= (this.data[i2] & bm) << cbs;
    r2.data[i2 - ds] = this.data[i2] >> bs;
  }
  if (bs > 0)
    r2.data[this.t - ds - 1] |= (this.s & bm) << cbs;
  r2.t = this.t - ds;
  r2.clamp();
}
function bnpSubTo$1(a2, r2) {
  var i2 = 0, c3 = 0, m2 = Math.min(a2.t, this.t);
  while (i2 < m2) {
    c3 += this.data[i2] - a2.data[i2];
    r2.data[i2++] = c3 & this.DM;
    c3 >>= this.DB;
  }
  if (a2.t < this.t) {
    c3 -= a2.s;
    while (i2 < this.t) {
      c3 += this.data[i2];
      r2.data[i2++] = c3 & this.DM;
      c3 >>= this.DB;
    }
    c3 += this.s;
  } else {
    c3 += this.s;
    while (i2 < a2.t) {
      c3 -= a2.data[i2];
      r2.data[i2++] = c3 & this.DM;
      c3 >>= this.DB;
    }
    c3 -= a2.s;
  }
  r2.s = c3 < 0 ? -1 : 0;
  if (c3 < -1)
    r2.data[i2++] = this.DV + c3;
  else if (c3 > 0)
    r2.data[i2++] = c3;
  r2.t = i2;
  r2.clamp();
}
function bnpMultiplyTo$1(a2, r2) {
  var x2 = this.abs(), y3 = a2.abs();
  var i2 = x2.t;
  r2.t = i2 + y3.t;
  while (--i2 >= 0)
    r2.data[i2] = 0;
  for (i2 = 0; i2 < y3.t; ++i2)
    r2.data[i2 + x2.t] = x2.am(0, y3.data[i2], r2, i2, 0, x2.t);
  r2.s = 0;
  r2.clamp();
  if (this.s != a2.s)
    BigInteger$6.ZERO.subTo(r2, r2);
}
function bnpSquareTo$1(r2) {
  var x2 = this.abs();
  var i2 = r2.t = 2 * x2.t;
  while (--i2 >= 0)
    r2.data[i2] = 0;
  for (i2 = 0; i2 < x2.t - 1; ++i2) {
    var c3 = x2.am(i2, x2.data[i2], r2, 2 * i2, 0, 1);
    if ((r2.data[i2 + x2.t] += x2.am(i2 + 1, 2 * x2.data[i2], r2, 2 * i2 + 1, c3, x2.t - i2 - 1)) >= x2.DV) {
      r2.data[i2 + x2.t] -= x2.DV;
      r2.data[i2 + x2.t + 1] = 1;
    }
  }
  if (r2.t > 0)
    r2.data[r2.t - 1] += x2.am(i2, x2.data[i2], r2, 2 * i2, 0, 1);
  r2.s = 0;
  r2.clamp();
}
function bnpDivRemTo$1(m2, q3, r2) {
  var pm = m2.abs();
  if (pm.t <= 0)
    return;
  var pt2 = this.abs();
  if (pt2.t < pm.t) {
    if (q3 != null)
      q3.fromInt(0);
    if (r2 != null)
      this.copyTo(r2);
    return;
  }
  if (r2 == null)
    r2 = nbi$1();
  var y3 = nbi$1(), ts = this.s, ms = m2.s;
  var nsh = this.DB - nbits$1(pm.data[pm.t - 1]);
  if (nsh > 0) {
    pm.lShiftTo(nsh, y3);
    pt2.lShiftTo(nsh, r2);
  } else {
    pm.copyTo(y3);
    pt2.copyTo(r2);
  }
  var ys = y3.t;
  var y0 = y3.data[ys - 1];
  if (y0 == 0)
    return;
  var yt2 = y0 * (1 << this.F1) + (ys > 1 ? y3.data[ys - 2] >> this.F2 : 0);
  var d1 = this.FV / yt2, d2 = (1 << this.F1) / yt2, e2 = 1 << this.F2;
  var i2 = r2.t, j3 = i2 - ys, t2 = q3 == null ? nbi$1() : q3;
  y3.dlShiftTo(j3, t2);
  if (r2.compareTo(t2) >= 0) {
    r2.data[r2.t++] = 1;
    r2.subTo(t2, r2);
  }
  BigInteger$6.ONE.dlShiftTo(ys, t2);
  t2.subTo(y3, y3);
  while (y3.t < ys)
    y3.data[y3.t++] = 0;
  while (--j3 >= 0) {
    var qd = r2.data[--i2] == y0 ? this.DM : Math.floor(r2.data[i2] * d1 + (r2.data[i2 - 1] + e2) * d2);
    if ((r2.data[i2] += y3.am(0, qd, r2, j3, 0, ys)) < qd) {
      y3.dlShiftTo(j3, t2);
      r2.subTo(t2, r2);
      while (r2.data[i2] < --qd)
        r2.subTo(t2, r2);
    }
  }
  if (q3 != null) {
    r2.drShiftTo(ys, q3);
    if (ts != ms)
      BigInteger$6.ZERO.subTo(q3, q3);
  }
  r2.t = ys;
  r2.clamp();
  if (nsh > 0)
    r2.rShiftTo(nsh, r2);
  if (ts < 0)
    BigInteger$6.ZERO.subTo(r2, r2);
}
function bnMod$1(a2) {
  var r2 = nbi$1();
  this.abs().divRemTo(a2, null, r2);
  if (this.s < 0 && r2.compareTo(BigInteger$6.ZERO) > 0)
    a2.subTo(r2, r2);
  return r2;
}
function Classic$1(m2) {
  this.m = m2;
}
function cConvert$1(x2) {
  if (x2.s < 0 || x2.compareTo(this.m) >= 0)
    return x2.mod(this.m);
  else
    return x2;
}
function cRevert$1(x2) {
  return x2;
}
function cReduce$1(x2) {
  x2.divRemTo(this.m, null, x2);
}
function cMulTo$1(x2, y3, r2) {
  x2.multiplyTo(y3, r2);
  this.reduce(r2);
}
function cSqrTo$1(x2, r2) {
  x2.squareTo(r2);
  this.reduce(r2);
}
Classic$1.prototype.convert = cConvert$1;
Classic$1.prototype.revert = cRevert$1;
Classic$1.prototype.reduce = cReduce$1;
Classic$1.prototype.mulTo = cMulTo$1;
Classic$1.prototype.sqrTo = cSqrTo$1;
function bnpInvDigit$1() {
  if (this.t < 1)
    return 0;
  var x2 = this.data[0];
  if ((x2 & 1) == 0)
    return 0;
  var y3 = x2 & 3;
  y3 = y3 * (2 - (x2 & 15) * y3) & 15;
  y3 = y3 * (2 - (x2 & 255) * y3) & 255;
  y3 = y3 * (2 - ((x2 & 65535) * y3 & 65535)) & 65535;
  y3 = y3 * (2 - x2 * y3 % this.DV) % this.DV;
  return y3 > 0 ? this.DV - y3 : -y3;
}
function Montgomery$1(m2) {
  this.m = m2;
  this.mp = m2.invDigit();
  this.mpl = this.mp & 32767;
  this.mph = this.mp >> 15;
  this.um = (1 << m2.DB - 15) - 1;
  this.mt2 = 2 * m2.t;
}
function montConvert$1(x2) {
  var r2 = nbi$1();
  x2.abs().dlShiftTo(this.m.t, r2);
  r2.divRemTo(this.m, null, r2);
  if (x2.s < 0 && r2.compareTo(BigInteger$6.ZERO) > 0)
    this.m.subTo(r2, r2);
  return r2;
}
function montRevert$1(x2) {
  var r2 = nbi$1();
  x2.copyTo(r2);
  this.reduce(r2);
  return r2;
}
function montReduce$1(x2) {
  while (x2.t <= this.mt2)
    x2.data[x2.t++] = 0;
  for (var i2 = 0; i2 < this.m.t; ++i2) {
    var j3 = x2.data[i2] & 32767;
    var u0 = j3 * this.mpl + ((j3 * this.mph + (x2.data[i2] >> 15) * this.mpl & this.um) << 15) & x2.DM;
    j3 = i2 + this.m.t;
    x2.data[j3] += this.m.am(0, u0, x2, i2, 0, this.m.t);
    while (x2.data[j3] >= x2.DV) {
      x2.data[j3] -= x2.DV;
      x2.data[++j3]++;
    }
  }
  x2.clamp();
  x2.drShiftTo(this.m.t, x2);
  if (x2.compareTo(this.m) >= 0)
    x2.subTo(this.m, x2);
}
function montSqrTo$1(x2, r2) {
  x2.squareTo(r2);
  this.reduce(r2);
}
function montMulTo$1(x2, y3, r2) {
  x2.multiplyTo(y3, r2);
  this.reduce(r2);
}
Montgomery$1.prototype.convert = montConvert$1;
Montgomery$1.prototype.revert = montRevert$1;
Montgomery$1.prototype.reduce = montReduce$1;
Montgomery$1.prototype.mulTo = montMulTo$1;
Montgomery$1.prototype.sqrTo = montSqrTo$1;
function bnpIsEven$1() {
  return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
}
function bnpExp$1(e2, z2) {
  if (e2 > 4294967295 || e2 < 1)
    return BigInteger$6.ONE;
  var r2 = nbi$1(), r22 = nbi$1(), g2 = z2.convert(this), i2 = nbits$1(e2) - 1;
  g2.copyTo(r2);
  while (--i2 >= 0) {
    z2.sqrTo(r2, r22);
    if ((e2 & 1 << i2) > 0)
      z2.mulTo(r22, g2, r2);
    else {
      var t2 = r2;
      r2 = r22;
      r22 = t2;
    }
  }
  return z2.revert(r2);
}
function bnModPowInt$1(e2, m2) {
  var z2;
  if (e2 < 256 || m2.isEven())
    z2 = new Classic$1(m2);
  else
    z2 = new Montgomery$1(m2);
  return this.exp(e2, z2);
}
BigInteger$6.prototype.copyTo = bnpCopyTo$1;
BigInteger$6.prototype.fromInt = bnpFromInt$1;
BigInteger$6.prototype.fromString = bnpFromString$1;
BigInteger$6.prototype.clamp = bnpClamp$1;
BigInteger$6.prototype.dlShiftTo = bnpDLShiftTo$1;
BigInteger$6.prototype.drShiftTo = bnpDRShiftTo$1;
BigInteger$6.prototype.lShiftTo = bnpLShiftTo$1;
BigInteger$6.prototype.rShiftTo = bnpRShiftTo$1;
BigInteger$6.prototype.subTo = bnpSubTo$1;
BigInteger$6.prototype.multiplyTo = bnpMultiplyTo$1;
BigInteger$6.prototype.squareTo = bnpSquareTo$1;
BigInteger$6.prototype.divRemTo = bnpDivRemTo$1;
BigInteger$6.prototype.invDigit = bnpInvDigit$1;
BigInteger$6.prototype.isEven = bnpIsEven$1;
BigInteger$6.prototype.exp = bnpExp$1;
BigInteger$6.prototype.toString = bnToString$1;
BigInteger$6.prototype.negate = bnNegate$1;
BigInteger$6.prototype.abs = bnAbs$1;
BigInteger$6.prototype.compareTo = bnCompareTo$1;
BigInteger$6.prototype.bitLength = bnBitLength$1;
BigInteger$6.prototype.mod = bnMod$1;
BigInteger$6.prototype.modPowInt = bnModPowInt$1;
BigInteger$6.ZERO = nbv$1(0);
BigInteger$6.ONE = nbv$1(1);
function bnClone$1() {
  var r2 = nbi$1();
  this.copyTo(r2);
  return r2;
}
function bnIntValue$1() {
  if (this.s < 0) {
    if (this.t == 1)
      return this.data[0] - this.DV;
    else if (this.t == 0)
      return -1;
  } else if (this.t == 1)
    return this.data[0];
  else if (this.t == 0)
    return 0;
  return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
}
function bnByteValue$1() {
  return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
}
function bnShortValue$1() {
  return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
}
function bnpChunkSize$1(r2) {
  return Math.floor(Math.LN2 * this.DB / Math.log(r2));
}
function bnSigNum$1() {
  if (this.s < 0)
    return -1;
  else if (this.t <= 0 || this.t == 1 && this.data[0] <= 0)
    return 0;
  else
    return 1;
}
function bnpToRadix$1(b3) {
  if (b3 == null)
    b3 = 10;
  if (this.signum() == 0 || b3 < 2 || b3 > 36)
    return "0";
  var cs = this.chunkSize(b3);
  var a2 = Math.pow(b3, cs);
  var d2 = nbv$1(a2), y3 = nbi$1(), z2 = nbi$1(), r2 = "";
  this.divRemTo(d2, y3, z2);
  while (y3.signum() > 0) {
    r2 = (a2 + z2.intValue()).toString(b3).substr(1) + r2;
    y3.divRemTo(d2, y3, z2);
  }
  return z2.intValue().toString(b3) + r2;
}
function bnpFromRadix$1(s2, b3) {
  this.fromInt(0);
  if (b3 == null)
    b3 = 10;
  var cs = this.chunkSize(b3);
  var d2 = Math.pow(b3, cs), mi = false, j3 = 0, w2 = 0;
  for (var i2 = 0; i2 < s2.length; ++i2) {
    var x2 = intAt$1(s2, i2);
    if (x2 < 0) {
      if (s2.charAt(i2) == "-" && this.signum() == 0)
        mi = true;
      continue;
    }
    w2 = b3 * w2 + x2;
    if (++j3 >= cs) {
      this.dMultiply(d2);
      this.dAddOffset(w2, 0);
      j3 = 0;
      w2 = 0;
    }
  }
  if (j3 > 0) {
    this.dMultiply(Math.pow(b3, j3));
    this.dAddOffset(w2, 0);
  }
  if (mi)
    BigInteger$6.ZERO.subTo(this, this);
}
function bnpFromNumber$1(a2, b3, c3) {
  if ("number" == typeof b3) {
    if (a2 < 2)
      this.fromInt(1);
    else {
      this.fromNumber(a2, c3);
      if (!this.testBit(a2 - 1))
        this.bitwiseTo(BigInteger$6.ONE.shiftLeft(a2 - 1), op_or$1, this);
      if (this.isEven())
        this.dAddOffset(1, 0);
      while (!this.isProbablePrime(b3)) {
        this.dAddOffset(2, 0);
        if (this.bitLength() > a2)
          this.subTo(BigInteger$6.ONE.shiftLeft(a2 - 1), this);
      }
    }
  } else {
    var x2 = new Array(), t2 = a2 & 7;
    x2.length = (a2 >> 3) + 1;
    b3.nextBytes(x2);
    if (t2 > 0)
      x2[0] &= (1 << t2) - 1;
    else
      x2[0] = 0;
    this.fromString(x2, 256);
  }
}
function bnToByteArray$1() {
  var i2 = this.t, r2 = new Array();
  r2[0] = this.s;
  var p2 = this.DB - i2 * this.DB % 8, d2, k3 = 0;
  if (i2-- > 0) {
    if (p2 < this.DB && (d2 = this.data[i2] >> p2) != (this.s & this.DM) >> p2)
      r2[k3++] = d2 | this.s << this.DB - p2;
    while (i2 >= 0) {
      if (p2 < 8) {
        d2 = (this.data[i2] & (1 << p2) - 1) << 8 - p2;
        d2 |= this.data[--i2] >> (p2 += this.DB - 8);
      } else {
        d2 = this.data[i2] >> (p2 -= 8) & 255;
        if (p2 <= 0) {
          p2 += this.DB;
          --i2;
        }
      }
      if ((d2 & 128) != 0)
        d2 |= -256;
      if (k3 == 0 && (this.s & 128) != (d2 & 128))
        ++k3;
      if (k3 > 0 || d2 != this.s)
        r2[k3++] = d2;
    }
  }
  return r2;
}
function bnEquals$1(a2) {
  return this.compareTo(a2) == 0;
}
function bnMin$1(a2) {
  return this.compareTo(a2) < 0 ? this : a2;
}
function bnMax$1(a2) {
  return this.compareTo(a2) > 0 ? this : a2;
}
function bnpBitwiseTo$1(a2, op, r2) {
  var i2, f2, m2 = Math.min(a2.t, this.t);
  for (i2 = 0; i2 < m2; ++i2)
    r2.data[i2] = op(this.data[i2], a2.data[i2]);
  if (a2.t < this.t) {
    f2 = a2.s & this.DM;
    for (i2 = m2; i2 < this.t; ++i2)
      r2.data[i2] = op(this.data[i2], f2);
    r2.t = this.t;
  } else {
    f2 = this.s & this.DM;
    for (i2 = m2; i2 < a2.t; ++i2)
      r2.data[i2] = op(f2, a2.data[i2]);
    r2.t = a2.t;
  }
  r2.s = op(this.s, a2.s);
  r2.clamp();
}
function op_and$1(x2, y3) {
  return x2 & y3;
}
function bnAnd$1(a2) {
  var r2 = nbi$1();
  this.bitwiseTo(a2, op_and$1, r2);
  return r2;
}
function op_or$1(x2, y3) {
  return x2 | y3;
}
function bnOr$1(a2) {
  var r2 = nbi$1();
  this.bitwiseTo(a2, op_or$1, r2);
  return r2;
}
function op_xor$1(x2, y3) {
  return x2 ^ y3;
}
function bnXor$1(a2) {
  var r2 = nbi$1();
  this.bitwiseTo(a2, op_xor$1, r2);
  return r2;
}
function op_andnot$1(x2, y3) {
  return x2 & ~y3;
}
function bnAndNot$1(a2) {
  var r2 = nbi$1();
  this.bitwiseTo(a2, op_andnot$1, r2);
  return r2;
}
function bnNot$1() {
  var r2 = nbi$1();
  for (var i2 = 0; i2 < this.t; ++i2)
    r2.data[i2] = this.DM & ~this.data[i2];
  r2.t = this.t;
  r2.s = ~this.s;
  return r2;
}
function bnShiftLeft$1(n2) {
  var r2 = nbi$1();
  if (n2 < 0)
    this.rShiftTo(-n2, r2);
  else
    this.lShiftTo(n2, r2);
  return r2;
}
function bnShiftRight$1(n2) {
  var r2 = nbi$1();
  if (n2 < 0)
    this.lShiftTo(-n2, r2);
  else
    this.rShiftTo(n2, r2);
  return r2;
}
function lbit$1(x2) {
  if (x2 == 0)
    return -1;
  var r2 = 0;
  if ((x2 & 65535) == 0) {
    x2 >>= 16;
    r2 += 16;
  }
  if ((x2 & 255) == 0) {
    x2 >>= 8;
    r2 += 8;
  }
  if ((x2 & 15) == 0) {
    x2 >>= 4;
    r2 += 4;
  }
  if ((x2 & 3) == 0) {
    x2 >>= 2;
    r2 += 2;
  }
  if ((x2 & 1) == 0)
    ++r2;
  return r2;
}
function bnGetLowestSetBit$1() {
  for (var i2 = 0; i2 < this.t; ++i2)
    if (this.data[i2] != 0)
      return i2 * this.DB + lbit$1(this.data[i2]);
  if (this.s < 0)
    return this.t * this.DB;
  return -1;
}
function cbit$1(x2) {
  var r2 = 0;
  while (x2 != 0) {
    x2 &= x2 - 1;
    ++r2;
  }
  return r2;
}
function bnBitCount$1() {
  var r2 = 0, x2 = this.s & this.DM;
  for (var i2 = 0; i2 < this.t; ++i2)
    r2 += cbit$1(this.data[i2] ^ x2);
  return r2;
}
function bnTestBit$1(n2) {
  var j3 = Math.floor(n2 / this.DB);
  if (j3 >= this.t)
    return this.s != 0;
  return (this.data[j3] & 1 << n2 % this.DB) != 0;
}
function bnpChangeBit$1(n2, op) {
  var r2 = BigInteger$6.ONE.shiftLeft(n2);
  this.bitwiseTo(r2, op, r2);
  return r2;
}
function bnSetBit$1(n2) {
  return this.changeBit(n2, op_or$1);
}
function bnClearBit$1(n2) {
  return this.changeBit(n2, op_andnot$1);
}
function bnFlipBit$1(n2) {
  return this.changeBit(n2, op_xor$1);
}
function bnpAddTo$1(a2, r2) {
  var i2 = 0, c3 = 0, m2 = Math.min(a2.t, this.t);
  while (i2 < m2) {
    c3 += this.data[i2] + a2.data[i2];
    r2.data[i2++] = c3 & this.DM;
    c3 >>= this.DB;
  }
  if (a2.t < this.t) {
    c3 += a2.s;
    while (i2 < this.t) {
      c3 += this.data[i2];
      r2.data[i2++] = c3 & this.DM;
      c3 >>= this.DB;
    }
    c3 += this.s;
  } else {
    c3 += this.s;
    while (i2 < a2.t) {
      c3 += a2.data[i2];
      r2.data[i2++] = c3 & this.DM;
      c3 >>= this.DB;
    }
    c3 += a2.s;
  }
  r2.s = c3 < 0 ? -1 : 0;
  if (c3 > 0)
    r2.data[i2++] = c3;
  else if (c3 < -1)
    r2.data[i2++] = this.DV + c3;
  r2.t = i2;
  r2.clamp();
}
function bnAdd$1(a2) {
  var r2 = nbi$1();
  this.addTo(a2, r2);
  return r2;
}
function bnSubtract$1(a2) {
  var r2 = nbi$1();
  this.subTo(a2, r2);
  return r2;
}
function bnMultiply$1(a2) {
  var r2 = nbi$1();
  this.multiplyTo(a2, r2);
  return r2;
}
function bnDivide$1(a2) {
  var r2 = nbi$1();
  this.divRemTo(a2, r2, null);
  return r2;
}
function bnRemainder$1(a2) {
  var r2 = nbi$1();
  this.divRemTo(a2, null, r2);
  return r2;
}
function bnDivideAndRemainder$1(a2) {
  var q3 = nbi$1(), r2 = nbi$1();
  this.divRemTo(a2, q3, r2);
  return new Array(q3, r2);
}
function bnpDMultiply$1(n2) {
  this.data[this.t] = this.am(0, n2 - 1, this, 0, 0, this.t);
  ++this.t;
  this.clamp();
}
function bnpDAddOffset$1(n2, w2) {
  if (n2 == 0)
    return;
  while (this.t <= w2)
    this.data[this.t++] = 0;
  this.data[w2] += n2;
  while (this.data[w2] >= this.DV) {
    this.data[w2] -= this.DV;
    if (++w2 >= this.t)
      this.data[this.t++] = 0;
    ++this.data[w2];
  }
}
function NullExp$1() {
}
function nNop$1(x2) {
  return x2;
}
function nMulTo$1(x2, y3, r2) {
  x2.multiplyTo(y3, r2);
}
function nSqrTo$1(x2, r2) {
  x2.squareTo(r2);
}
NullExp$1.prototype.convert = nNop$1;
NullExp$1.prototype.revert = nNop$1;
NullExp$1.prototype.mulTo = nMulTo$1;
NullExp$1.prototype.sqrTo = nSqrTo$1;
function bnPow$1(e2) {
  return this.exp(e2, new NullExp$1());
}
function bnpMultiplyLowerTo$1(a2, n2, r2) {
  var i2 = Math.min(this.t + a2.t, n2);
  r2.s = 0;
  r2.t = i2;
  while (i2 > 0)
    r2.data[--i2] = 0;
  var j3;
  for (j3 = r2.t - this.t; i2 < j3; ++i2)
    r2.data[i2 + this.t] = this.am(0, a2.data[i2], r2, i2, 0, this.t);
  for (j3 = Math.min(a2.t, n2); i2 < j3; ++i2)
    this.am(0, a2.data[i2], r2, i2, 0, n2 - i2);
  r2.clamp();
}
function bnpMultiplyUpperTo$1(a2, n2, r2) {
  --n2;
  var i2 = r2.t = this.t + a2.t - n2;
  r2.s = 0;
  while (--i2 >= 0)
    r2.data[i2] = 0;
  for (i2 = Math.max(n2 - this.t, 0); i2 < a2.t; ++i2)
    r2.data[this.t + i2 - n2] = this.am(n2 - i2, a2.data[i2], r2, 0, 0, this.t + i2 - n2);
  r2.clamp();
  r2.drShiftTo(1, r2);
}
function Barrett$1(m2) {
  this.r2 = nbi$1();
  this.q3 = nbi$1();
  BigInteger$6.ONE.dlShiftTo(2 * m2.t, this.r2);
  this.mu = this.r2.divide(m2);
  this.m = m2;
}
function barrettConvert$1(x2) {
  if (x2.s < 0 || x2.t > 2 * this.m.t)
    return x2.mod(this.m);
  else if (x2.compareTo(this.m) < 0)
    return x2;
  else {
    var r2 = nbi$1();
    x2.copyTo(r2);
    this.reduce(r2);
    return r2;
  }
}
function barrettRevert$1(x2) {
  return x2;
}
function barrettReduce$1(x2) {
  x2.drShiftTo(this.m.t - 1, this.r2);
  if (x2.t > this.m.t + 1) {
    x2.t = this.m.t + 1;
    x2.clamp();
  }
  this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
  this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
  while (x2.compareTo(this.r2) < 0)
    x2.dAddOffset(1, this.m.t + 1);
  x2.subTo(this.r2, x2);
  while (x2.compareTo(this.m) >= 0)
    x2.subTo(this.m, x2);
}
function barrettSqrTo$1(x2, r2) {
  x2.squareTo(r2);
  this.reduce(r2);
}
function barrettMulTo$1(x2, y3, r2) {
  x2.multiplyTo(y3, r2);
  this.reduce(r2);
}
Barrett$1.prototype.convert = barrettConvert$1;
Barrett$1.prototype.revert = barrettRevert$1;
Barrett$1.prototype.reduce = barrettReduce$1;
Barrett$1.prototype.mulTo = barrettMulTo$1;
Barrett$1.prototype.sqrTo = barrettSqrTo$1;
function bnModPow$1(e2, m2) {
  var i2 = e2.bitLength(), k3, r2 = nbv$1(1), z2;
  if (i2 <= 0)
    return r2;
  else if (i2 < 18)
    k3 = 1;
  else if (i2 < 48)
    k3 = 3;
  else if (i2 < 144)
    k3 = 4;
  else if (i2 < 768)
    k3 = 5;
  else
    k3 = 6;
  if (i2 < 8)
    z2 = new Classic$1(m2);
  else if (m2.isEven())
    z2 = new Barrett$1(m2);
  else
    z2 = new Montgomery$1(m2);
  var g2 = new Array(), n2 = 3, k1 = k3 - 1, km = (1 << k3) - 1;
  g2[1] = z2.convert(this);
  if (k3 > 1) {
    var g22 = nbi$1();
    z2.sqrTo(g2[1], g22);
    while (n2 <= km) {
      g2[n2] = nbi$1();
      z2.mulTo(g22, g2[n2 - 2], g2[n2]);
      n2 += 2;
    }
  }
  var j3 = e2.t - 1, w2, is1 = true, r22 = nbi$1(), t2;
  i2 = nbits$1(e2.data[j3]) - 1;
  while (j3 >= 0) {
    if (i2 >= k1)
      w2 = e2.data[j3] >> i2 - k1 & km;
    else {
      w2 = (e2.data[j3] & (1 << i2 + 1) - 1) << k1 - i2;
      if (j3 > 0)
        w2 |= e2.data[j3 - 1] >> this.DB + i2 - k1;
    }
    n2 = k3;
    while ((w2 & 1) == 0) {
      w2 >>= 1;
      --n2;
    }
    if ((i2 -= n2) < 0) {
      i2 += this.DB;
      --j3;
    }
    if (is1) {
      g2[w2].copyTo(r2);
      is1 = false;
    } else {
      while (n2 > 1) {
        z2.sqrTo(r2, r22);
        z2.sqrTo(r22, r2);
        n2 -= 2;
      }
      if (n2 > 0)
        z2.sqrTo(r2, r22);
      else {
        t2 = r2;
        r2 = r22;
        r22 = t2;
      }
      z2.mulTo(r22, g2[w2], r2);
    }
    while (j3 >= 0 && (e2.data[j3] & 1 << i2) == 0) {
      z2.sqrTo(r2, r22);
      t2 = r2;
      r2 = r22;
      r22 = t2;
      if (--i2 < 0) {
        i2 = this.DB - 1;
        --j3;
      }
    }
  }
  return z2.revert(r2);
}
function bnGCD$1(a2) {
  var x2 = this.s < 0 ? this.negate() : this.clone();
  var y3 = a2.s < 0 ? a2.negate() : a2.clone();
  if (x2.compareTo(y3) < 0) {
    var t2 = x2;
    x2 = y3;
    y3 = t2;
  }
  var i2 = x2.getLowestSetBit(), g2 = y3.getLowestSetBit();
  if (g2 < 0)
    return x2;
  if (i2 < g2)
    g2 = i2;
  if (g2 > 0) {
    x2.rShiftTo(g2, x2);
    y3.rShiftTo(g2, y3);
  }
  while (x2.signum() > 0) {
    if ((i2 = x2.getLowestSetBit()) > 0)
      x2.rShiftTo(i2, x2);
    if ((i2 = y3.getLowestSetBit()) > 0)
      y3.rShiftTo(i2, y3);
    if (x2.compareTo(y3) >= 0) {
      x2.subTo(y3, x2);
      x2.rShiftTo(1, x2);
    } else {
      y3.subTo(x2, y3);
      y3.rShiftTo(1, y3);
    }
  }
  if (g2 > 0)
    y3.lShiftTo(g2, y3);
  return y3;
}
function bnpModInt$1(n2) {
  if (n2 <= 0)
    return 0;
  var d2 = this.DV % n2, r2 = this.s < 0 ? n2 - 1 : 0;
  if (this.t > 0)
    if (d2 == 0)
      r2 = this.data[0] % n2;
    else
      for (var i2 = this.t - 1; i2 >= 0; --i2)
        r2 = (d2 * r2 + this.data[i2]) % n2;
  return r2;
}
function bnModInverse$1(m2) {
  var ac = m2.isEven();
  if (this.isEven() && ac || m2.signum() == 0)
    return BigInteger$6.ZERO;
  var u2 = m2.clone(), v2 = this.clone();
  var a2 = nbv$1(1), b3 = nbv$1(0), c3 = nbv$1(0), d2 = nbv$1(1);
  while (u2.signum() != 0) {
    while (u2.isEven()) {
      u2.rShiftTo(1, u2);
      if (ac) {
        if (!a2.isEven() || !b3.isEven()) {
          a2.addTo(this, a2);
          b3.subTo(m2, b3);
        }
        a2.rShiftTo(1, a2);
      } else if (!b3.isEven())
        b3.subTo(m2, b3);
      b3.rShiftTo(1, b3);
    }
    while (v2.isEven()) {
      v2.rShiftTo(1, v2);
      if (ac) {
        if (!c3.isEven() || !d2.isEven()) {
          c3.addTo(this, c3);
          d2.subTo(m2, d2);
        }
        c3.rShiftTo(1, c3);
      } else if (!d2.isEven())
        d2.subTo(m2, d2);
      d2.rShiftTo(1, d2);
    }
    if (u2.compareTo(v2) >= 0) {
      u2.subTo(v2, u2);
      if (ac)
        a2.subTo(c3, a2);
      b3.subTo(d2, b3);
    } else {
      v2.subTo(u2, v2);
      if (ac)
        c3.subTo(a2, c3);
      d2.subTo(b3, d2);
    }
  }
  if (v2.compareTo(BigInteger$6.ONE) != 0)
    return BigInteger$6.ZERO;
  if (d2.compareTo(m2) >= 0)
    return d2.subtract(m2);
  if (d2.signum() < 0)
    d2.addTo(m2, d2);
  else
    return d2;
  if (d2.signum() < 0)
    return d2.add(m2);
  else
    return d2;
}
var lowprimes$1 = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];
var lplim$1 = (1 << 26) / lowprimes$1[lowprimes$1.length - 1];
function bnIsProbablePrime$1(t2) {
  var i2, x2 = this.abs();
  if (x2.t == 1 && x2.data[0] <= lowprimes$1[lowprimes$1.length - 1]) {
    for (i2 = 0; i2 < lowprimes$1.length; ++i2)
      if (x2.data[0] == lowprimes$1[i2])
        return true;
    return false;
  }
  if (x2.isEven())
    return false;
  i2 = 1;
  while (i2 < lowprimes$1.length) {
    var m2 = lowprimes$1[i2], j3 = i2 + 1;
    while (j3 < lowprimes$1.length && m2 < lplim$1)
      m2 *= lowprimes$1[j3++];
    m2 = x2.modInt(m2);
    while (i2 < j3)
      if (m2 % lowprimes$1[i2++] == 0)
        return false;
  }
  return x2.millerRabin(t2);
}
function bnpMillerRabin$1(t2) {
  var n1 = this.subtract(BigInteger$6.ONE);
  var k3 = n1.getLowestSetBit();
  if (k3 <= 0)
    return false;
  var r2 = n1.shiftRight(k3);
  var prng2 = bnGetPrng$1();
  var a2;
  for (var i2 = 0; i2 < t2; ++i2) {
    do {
      a2 = new BigInteger$6(this.bitLength(), prng2);
    } while (a2.compareTo(BigInteger$6.ONE) <= 0 || a2.compareTo(n1) >= 0);
    var y3 = a2.modPow(r2, this);
    if (y3.compareTo(BigInteger$6.ONE) != 0 && y3.compareTo(n1) != 0) {
      var j3 = 1;
      while (j3++ < k3 && y3.compareTo(n1) != 0) {
        y3 = y3.modPowInt(2, this);
        if (y3.compareTo(BigInteger$6.ONE) == 0)
          return false;
      }
      if (y3.compareTo(n1) != 0)
        return false;
    }
  }
  return true;
}
function bnGetPrng$1() {
  return {
    // x is an array to fill with bytes
    nextBytes: function nextBytes(x2) {
      for (var i2 = 0; i2 < x2.length; ++i2) {
        x2[i2] = Math.floor(Math.random() * 256);
      }
    }
  };
}
BigInteger$6.prototype.chunkSize = bnpChunkSize$1;
BigInteger$6.prototype.toRadix = bnpToRadix$1;
BigInteger$6.prototype.fromRadix = bnpFromRadix$1;
BigInteger$6.prototype.fromNumber = bnpFromNumber$1;
BigInteger$6.prototype.bitwiseTo = bnpBitwiseTo$1;
BigInteger$6.prototype.changeBit = bnpChangeBit$1;
BigInteger$6.prototype.addTo = bnpAddTo$1;
BigInteger$6.prototype.dMultiply = bnpDMultiply$1;
BigInteger$6.prototype.dAddOffset = bnpDAddOffset$1;
BigInteger$6.prototype.multiplyLowerTo = bnpMultiplyLowerTo$1;
BigInteger$6.prototype.multiplyUpperTo = bnpMultiplyUpperTo$1;
BigInteger$6.prototype.modInt = bnpModInt$1;
BigInteger$6.prototype.millerRabin = bnpMillerRabin$1;
BigInteger$6.prototype.clone = bnClone$1;
BigInteger$6.prototype.intValue = bnIntValue$1;
BigInteger$6.prototype.byteValue = bnByteValue$1;
BigInteger$6.prototype.shortValue = bnShortValue$1;
BigInteger$6.prototype.signum = bnSigNum$1;
BigInteger$6.prototype.toByteArray = bnToByteArray$1;
BigInteger$6.prototype.equals = bnEquals$1;
BigInteger$6.prototype.min = bnMin$1;
BigInteger$6.prototype.max = bnMax$1;
BigInteger$6.prototype.and = bnAnd$1;
BigInteger$6.prototype.or = bnOr$1;
BigInteger$6.prototype.xor = bnXor$1;
BigInteger$6.prototype.andNot = bnAndNot$1;
BigInteger$6.prototype.not = bnNot$1;
BigInteger$6.prototype.shiftLeft = bnShiftLeft$1;
BigInteger$6.prototype.shiftRight = bnShiftRight$1;
BigInteger$6.prototype.getLowestSetBit = bnGetLowestSetBit$1;
BigInteger$6.prototype.bitCount = bnBitCount$1;
BigInteger$6.prototype.testBit = bnTestBit$1;
BigInteger$6.prototype.setBit = bnSetBit$1;
BigInteger$6.prototype.clearBit = bnClearBit$1;
BigInteger$6.prototype.flipBit = bnFlipBit$1;
BigInteger$6.prototype.add = bnAdd$1;
BigInteger$6.prototype.subtract = bnSubtract$1;
BigInteger$6.prototype.multiply = bnMultiply$1;
BigInteger$6.prototype.divide = bnDivide$1;
BigInteger$6.prototype.remainder = bnRemainder$1;
BigInteger$6.prototype.divideAndRemainder = bnDivideAndRemainder$1;
BigInteger$6.prototype.modPow = bnModPow$1;
BigInteger$6.prototype.modInverse = bnModInverse$1;
BigInteger$6.prototype.pow = bnPow$1;
BigInteger$6.prototype.gcd = bnGCD$1;
BigInteger$6.prototype.isProbablePrime = bnIsProbablePrime$1;
var forge$x = forge$R;
var pkcs1$1 = forge$x.pkcs1 = forge$x.pkcs1 || {};
pkcs1$1.encode_rsa_oaep = function(key3, message, options) {
  var label;
  var seed;
  var md;
  var mgf1Md;
  if (typeof options === "string") {
    label = options;
    seed = arguments[3] || void 0;
    md = arguments[4] || void 0;
  } else if (options) {
    label = options.label || void 0;
    seed = options.seed || void 0;
    md = options.md || void 0;
    if (options.mgf1 && options.mgf1.md) {
      mgf1Md = options.mgf1.md;
    }
  }
  if (!md) {
    md = forge$x.md.sha1.create();
  } else {
    md.start();
  }
  if (!mgf1Md) {
    mgf1Md = md;
  }
  var keyLength = Math.ceil(key3.n.bitLength() / 8);
  var maxLength = keyLength - 2 * md.digestLength - 2;
  if (message.length > maxLength) {
    var error3 = new Error("RSAES-OAEP input message length is too long.");
    error3.length = message.length;
    error3.maxLength = maxLength;
    throw error3;
  }
  if (!label) {
    label = "";
  }
  md.update(label, "raw");
  var lHash = md.digest();
  var PS = "";
  var PS_length = maxLength - message.length;
  for (var i2 = 0; i2 < PS_length; i2++) {
    PS += "\0";
  }
  var DB = lHash.getBytes() + PS + "" + message;
  if (!seed) {
    seed = forge$x.random.getBytes(md.digestLength);
  } else if (seed.length !== md.digestLength) {
    var error3 = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
    error3.seedLength = seed.length;
    error3.digestLength = md.digestLength;
    throw error3;
  }
  var dbMask = rsa_mgf1$1(seed, keyLength - md.digestLength - 1, mgf1Md);
  var maskedDB = forge$x.util.xorBytes(DB, dbMask, DB.length);
  var seedMask = rsa_mgf1$1(maskedDB, md.digestLength, mgf1Md);
  var maskedSeed = forge$x.util.xorBytes(seed, seedMask, seed.length);
  return "\0" + maskedSeed + maskedDB;
};
pkcs1$1.decode_rsa_oaep = function(key3, em, options) {
  var label;
  var md;
  var mgf1Md;
  if (typeof options === "string") {
    label = options;
    md = arguments[3] || void 0;
  } else if (options) {
    label = options.label || void 0;
    md = options.md || void 0;
    if (options.mgf1 && options.mgf1.md) {
      mgf1Md = options.mgf1.md;
    }
  }
  var keyLength = Math.ceil(key3.n.bitLength() / 8);
  if (em.length !== keyLength) {
    var error3 = new Error("RSAES-OAEP encoded message length is invalid.");
    error3.length = em.length;
    error3.expectedLength = keyLength;
    throw error3;
  }
  if (md === void 0) {
    md = forge$x.md.sha1.create();
  } else {
    md.start();
  }
  if (!mgf1Md) {
    mgf1Md = md;
  }
  if (keyLength < 2 * md.digestLength + 2) {
    throw new Error("RSAES-OAEP key is too short for the hash function.");
  }
  if (!label) {
    label = "";
  }
  md.update(label, "raw");
  var lHash = md.digest().getBytes();
  var y3 = em.charAt(0);
  var maskedSeed = em.substring(1, md.digestLength + 1);
  var maskedDB = em.substring(1 + md.digestLength);
  var seedMask = rsa_mgf1$1(maskedDB, md.digestLength, mgf1Md);
  var seed = forge$x.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);
  var dbMask = rsa_mgf1$1(seed, keyLength - md.digestLength - 1, mgf1Md);
  var db = forge$x.util.xorBytes(maskedDB, dbMask, maskedDB.length);
  var lHashPrime = db.substring(0, md.digestLength);
  var error3 = y3 !== "\0";
  for (var i2 = 0; i2 < md.digestLength; ++i2) {
    error3 |= lHash.charAt(i2) !== lHashPrime.charAt(i2);
  }
  var in_ps = 1;
  var index = md.digestLength;
  for (var j3 = md.digestLength; j3 < db.length; j3++) {
    var code2 = db.charCodeAt(j3);
    var is_0 = code2 & 1 ^ 1;
    var error_mask = in_ps ? 65534 : 0;
    error3 |= code2 & error_mask;
    in_ps = in_ps & is_0;
    index += in_ps;
  }
  if (error3 || db.charCodeAt(index) !== 1) {
    throw new Error("Invalid RSAES-OAEP padding.");
  }
  return db.substring(index + 1);
};
function rsa_mgf1$1(seed, maskLength, hash2) {
  if (!hash2) {
    hash2 = forge$x.md.sha1.create();
  }
  var t2 = "";
  var count = Math.ceil(maskLength / hash2.digestLength);
  for (var i2 = 0; i2 < count; ++i2) {
    var c3 = String.fromCharCode(i2 >> 24 & 255, i2 >> 16 & 255, i2 >> 8 & 255, i2 & 255);
    hash2.start();
    hash2.update(seed + c3);
    t2 += hash2.digest().getBytes();
  }
  return t2.substring(0, maskLength);
}
var forge$w = forge$R;
(function() {
  if (forge$w.prime) {
    forge$w.prime;
    return;
  }
  var prime = forge$w.prime = forge$w.prime || {};
  var BigInteger2 = forge$w.jsbn.BigInteger;
  var GCD_30_DELTA2 = [6, 4, 2, 4, 2, 4, 6, 2];
  var THIRTY = new BigInteger2(null);
  THIRTY.fromInt(30);
  var op_or2 = function op_or3(x2, y3) {
    return x2 | y3;
  };
  prime.generateProbablePrime = function(bits, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    options = options || {};
    var algorithm = options.algorithm || "PRIMEINC";
    if (typeof algorithm === "string") {
      algorithm = { name: algorithm };
    }
    algorithm.options = algorithm.options || {};
    var prng2 = options.prng || forge$w.random;
    var rng = {
      // x is an array to fill with bytes
      nextBytes: function nextBytes(x2) {
        var b3 = prng2.getBytesSync(x2.length);
        for (var i2 = 0; i2 < x2.length; ++i2) {
          x2[i2] = b3.charCodeAt(i2);
        }
      }
    };
    if (algorithm.name === "PRIMEINC") {
      return primeincFindPrime(bits, rng, algorithm.options, callback);
    }
    throw new Error("Invalid prime generation algorithm: " + algorithm.name);
  };
  function primeincFindPrime(bits, rng, options, callback) {
    if ("workers" in options) {
      return primeincFindPrimeWithWorkers(bits, rng, options, callback);
    }
    return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
  }
  function primeincFindPrimeWithoutWorkers(bits, rng, options, callback) {
    var num = generateRandom(bits, rng);
    var deltaIdx = 0;
    var mrTests = getMillerRabinTests(num.bitLength());
    if ("millerRabinTests" in options) {
      mrTests = options.millerRabinTests;
    }
    var maxBlockTime = 10;
    if ("maxBlockTime" in options) {
      maxBlockTime = options.maxBlockTime;
    }
    _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
  }
  function _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback) {
    var start = +/* @__PURE__ */ new Date();
    do {
      if (num.bitLength() > bits) {
        num = generateRandom(bits, rng);
      }
      if (num.isProbablePrime(mrTests)) {
        return callback(null, num);
      }
      num.dAddOffset(GCD_30_DELTA2[deltaIdx++ % 8], 0);
    } while (maxBlockTime < 0 || +/* @__PURE__ */ new Date() - start < maxBlockTime);
    forge$w.util.setImmediate(function() {
      _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
    });
  }
  function primeincFindPrimeWithWorkers(bits, rng, options, callback) {
    if (typeof Worker === "undefined") {
      return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
    }
    var num = generateRandom(bits, rng);
    var numWorkers = options.workers;
    var workLoad = options.workLoad || 100;
    var range = workLoad * 30 / 8;
    var workerScript = options.workerScript || "forge/prime.worker.js";
    if (numWorkers === -1) {
      return forge$w.util.estimateCores(function(err, cores) {
        if (err) {
          cores = 2;
        }
        numWorkers = cores - 1;
        generate2();
      });
    }
    generate2();
    function generate2() {
      numWorkers = Math.max(1, numWorkers);
      var workers = [];
      for (var i2 = 0; i2 < numWorkers; ++i2) {
        workers[i2] = new Worker(workerScript);
      }
      for (var i2 = 0; i2 < numWorkers; ++i2) {
        workers[i2].addEventListener("message", workerMessage);
      }
      var found = false;
      function workerMessage(e2) {
        if (found) {
          return;
        }
        var data = e2.data;
        if (data.found) {
          for (var i3 = 0; i3 < workers.length; ++i3) {
            workers[i3].terminate();
          }
          found = true;
          return callback(null, new BigInteger2(data.prime, 16));
        }
        if (num.bitLength() > bits) {
          num = generateRandom(bits, rng);
        }
        var hex = num.toString(16);
        e2.target.postMessage({ hex, workLoad });
        num.dAddOffset(range, 0);
      }
    }
  }
  function generateRandom(bits, rng) {
    var num = new BigInteger2(bits, rng);
    var bits1 = bits - 1;
    if (!num.testBit(bits1)) {
      num.bitwiseTo(BigInteger2.ONE.shiftLeft(bits1), op_or2, num);
    }
    num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);
    return num;
  }
  function getMillerRabinTests(bits) {
    if (bits <= 100)
      return 27;
    if (bits <= 150)
      return 18;
    if (bits <= 200)
      return 15;
    if (bits <= 250)
      return 12;
    if (bits <= 300)
      return 9;
    if (bits <= 350)
      return 8;
    if (bits <= 400)
      return 7;
    if (bits <= 500)
      return 6;
    if (bits <= 600)
      return 5;
    if (bits <= 800)
      return 4;
    if (bits <= 1250)
      return 3;
    return 2;
  }
})();
var forge$v = forge$R;
if (typeof BigInteger$5 === "undefined") {
  BigInteger$5 = forge$v.jsbn.BigInteger;
}
var BigInteger$5;
var _crypto$2 = forge$v.util.isNodejs ? require$$0$4 : null;
var asn1$4 = forge$v.asn1;
var util$9 = forge$v.util;
forge$v.pki = forge$v.pki || {};
var rsa$1 = forge$v.pki.rsa = forge$v.rsa = forge$v.rsa || {};
var pki$2 = forge$v.pki;
var GCD_30_DELTA$1 = [6, 4, 2, 4, 2, 4, 6, 2];
var privateKeyValidator$2 = {
  // PrivateKeyInfo
  name: "PrivateKeyInfo",
  tagClass: asn1$4.Class.UNIVERSAL,
  type: asn1$4.Type.SEQUENCE,
  constructed: true,
  value: [{
    // Version (INTEGER)
    name: "PrivateKeyInfo.version",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.INTEGER,
    constructed: false,
    capture: "privateKeyVersion"
  }, {
    // privateKeyAlgorithm
    name: "PrivateKeyInfo.privateKeyAlgorithm",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.SEQUENCE,
    constructed: true,
    value: [{ name: "AlgorithmIdentifier.algorithm", tagClass: asn1$4.Class.UNIVERSAL, type: asn1$4.Type.OID, constructed: false, capture: "privateKeyOid" }]
  }, {
    // PrivateKey
    name: "PrivateKeyInfo",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.OCTETSTRING,
    constructed: false,
    capture: "privateKey"
  }]
};
var rsaPrivateKeyValidator$1 = {
  // RSAPrivateKey
  name: "RSAPrivateKey",
  tagClass: asn1$4.Class.UNIVERSAL,
  type: asn1$4.Type.SEQUENCE,
  constructed: true,
  value: [{
    // Version (INTEGER)
    name: "RSAPrivateKey.version",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.INTEGER,
    constructed: false,
    capture: "privateKeyVersion"
  }, {
    // modulus (n)
    name: "RSAPrivateKey.modulus",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.INTEGER,
    constructed: false,
    capture: "privateKeyModulus"
  }, {
    // publicExponent (e)
    name: "RSAPrivateKey.publicExponent",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.INTEGER,
    constructed: false,
    capture: "privateKeyPublicExponent"
  }, {
    // privateExponent (d)
    name: "RSAPrivateKey.privateExponent",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.INTEGER,
    constructed: false,
    capture: "privateKeyPrivateExponent"
  }, {
    // prime1 (p)
    name: "RSAPrivateKey.prime1",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.INTEGER,
    constructed: false,
    capture: "privateKeyPrime1"
  }, {
    // prime2 (q)
    name: "RSAPrivateKey.prime2",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.INTEGER,
    constructed: false,
    capture: "privateKeyPrime2"
  }, {
    // exponent1 (d mod (p-1))
    name: "RSAPrivateKey.exponent1",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.INTEGER,
    constructed: false,
    capture: "privateKeyExponent1"
  }, {
    // exponent2 (d mod (q-1))
    name: "RSAPrivateKey.exponent2",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.INTEGER,
    constructed: false,
    capture: "privateKeyExponent2"
  }, {
    // coefficient ((inverse of q) mod p)
    name: "RSAPrivateKey.coefficient",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.INTEGER,
    constructed: false,
    capture: "privateKeyCoefficient"
  }]
};
var rsaPublicKeyValidator$1 = {
  // RSAPublicKey
  name: "RSAPublicKey",
  tagClass: asn1$4.Class.UNIVERSAL,
  type: asn1$4.Type.SEQUENCE,
  constructed: true,
  value: [{
    // modulus (n)
    name: "RSAPublicKey.modulus",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.INTEGER,
    constructed: false,
    capture: "publicKeyModulus"
  }, {
    // publicExponent (e)
    name: "RSAPublicKey.exponent",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.INTEGER,
    constructed: false,
    capture: "publicKeyExponent"
  }]
};
var publicKeyValidator$2 = forge$v.pki.rsa.publicKeyValidator = { name: "SubjectPublicKeyInfo", tagClass: asn1$4.Class.UNIVERSAL, type: asn1$4.Type.SEQUENCE, constructed: true, captureAsn1: "subjectPublicKeyInfo", value: [{ name: "SubjectPublicKeyInfo.AlgorithmIdentifier", tagClass: asn1$4.Class.UNIVERSAL, type: asn1$4.Type.SEQUENCE, constructed: true, value: [{ name: "AlgorithmIdentifier.algorithm", tagClass: asn1$4.Class.UNIVERSAL, type: asn1$4.Type.OID, constructed: false, capture: "publicKeyOid" }] }, {
  // subjectPublicKey
  name: "SubjectPublicKeyInfo.subjectPublicKey",
  tagClass: asn1$4.Class.UNIVERSAL,
  type: asn1$4.Type.BITSTRING,
  constructed: false,
  value: [{
    // RSAPublicKey
    name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.SEQUENCE,
    constructed: true,
    optional: true,
    captureAsn1: "rsaPublicKey"
  }]
}] };
var emsaPkcs1v15encode$1 = function emsaPkcs1v15encode$12(md) {
  var oid;
  if (md.algorithm in pki$2.oids) {
    oid = pki$2.oids[md.algorithm];
  } else {
    var error3 = new Error("Unknown message digest algorithm.");
    error3.algorithm = md.algorithm;
    throw error3;
  }
  var oidBytes = asn1$4.oidToDer(oid).getBytes();
  var digestInfo = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, []);
  var digestAlgorithm = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, []);
  digestAlgorithm.value.push(asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.OID, false, oidBytes));
  digestAlgorithm.value.push(asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.NULL, false, ""));
  var digest11 = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.OCTETSTRING, false, md.digest().getBytes());
  digestInfo.value.push(digestAlgorithm);
  digestInfo.value.push(digest11);
  return asn1$4.toDer(digestInfo).getBytes();
};
var _modPow$1 = function _modPow$12(x2, key3, pub) {
  if (pub) {
    return x2.modPow(key3.e, key3.n);
  }
  if (!key3.p || !key3.q) {
    return x2.modPow(key3.d, key3.n);
  }
  if (!key3.dP) {
    key3.dP = key3.d.mod(key3.p.subtract(BigInteger$5.ONE));
  }
  if (!key3.dQ) {
    key3.dQ = key3.d.mod(key3.q.subtract(BigInteger$5.ONE));
  }
  if (!key3.qInv) {
    key3.qInv = key3.q.modInverse(key3.p);
  }
  var r2;
  do {
    r2 = new BigInteger$5(forge$v.util.bytesToHex(forge$v.random.getBytes(key3.n.bitLength() / 8)), 16);
  } while (r2.compareTo(key3.n) >= 0 || !r2.gcd(key3.n).equals(BigInteger$5.ONE));
  x2 = x2.multiply(r2.modPow(key3.e, key3.n)).mod(key3.n);
  var xp = x2.mod(key3.p).modPow(key3.dP, key3.p);
  var xq = x2.mod(key3.q).modPow(key3.dQ, key3.q);
  while (xp.compareTo(xq) < 0) {
    xp = xp.add(key3.p);
  }
  var y3 = xp.subtract(xq).multiply(key3.qInv).mod(key3.p).multiply(key3.q).add(xq);
  y3 = y3.multiply(r2.modInverse(key3.n)).mod(key3.n);
  return y3;
};
pki$2.rsa.encrypt = function(m2, key3, bt) {
  var pub = bt;
  var eb;
  var k3 = Math.ceil(key3.n.bitLength() / 8);
  if (bt !== false && bt !== true) {
    pub = bt === 2;
    eb = _encodePkcs1_v1_5$1(m2, key3, bt);
  } else {
    eb = forge$v.util.createBuffer();
    eb.putBytes(m2);
  }
  var x2 = new BigInteger$5(eb.toHex(), 16);
  var y3 = _modPow$1(x2, key3, pub);
  var yhex = y3.toString(16);
  var ed = forge$v.util.createBuffer();
  var zeros = k3 - Math.ceil(yhex.length / 2);
  while (zeros > 0) {
    ed.putByte(0);
    --zeros;
  }
  ed.putBytes(forge$v.util.hexToBytes(yhex));
  return ed.getBytes();
};
pki$2.rsa.decrypt = function(ed, key3, pub, ml) {
  var k3 = Math.ceil(key3.n.bitLength() / 8);
  if (ed.length !== k3) {
    var error3 = new Error("Encrypted message length is invalid.");
    error3.length = ed.length;
    error3.expected = k3;
    throw error3;
  }
  var y3 = new BigInteger$5(forge$v.util.createBuffer(ed).toHex(), 16);
  if (y3.compareTo(key3.n) >= 0) {
    throw new Error("Encrypted message is invalid.");
  }
  var x2 = _modPow$1(y3, key3, pub);
  var xhex = x2.toString(16);
  var eb = forge$v.util.createBuffer();
  var zeros = k3 - Math.ceil(xhex.length / 2);
  while (zeros > 0) {
    eb.putByte(0);
    --zeros;
  }
  eb.putBytes(forge$v.util.hexToBytes(xhex));
  if (ml !== false) {
    return _decodePkcs1_v1_5$1(eb.getBytes(), key3, pub);
  }
  return eb.getBytes();
};
pki$2.rsa.createKeyPairGenerationState = function(bits, e2, options) {
  if (typeof bits === "string") {
    bits = parseInt(bits, 10);
  }
  bits = bits || 2048;
  options = options || {};
  var prng2 = options.prng || forge$v.random;
  var rng = {
    // x is an array to fill with bytes
    nextBytes: function nextBytes(x2) {
      var b3 = prng2.getBytesSync(x2.length);
      for (var i2 = 0; i2 < x2.length; ++i2) {
        x2[i2] = b3.charCodeAt(i2);
      }
    }
  };
  var algorithm = options.algorithm || "PRIMEINC";
  var rval;
  if (algorithm === "PRIMEINC") {
    rval = { algorithm, state: 0, bits, rng, eInt: e2 || 65537, e: new BigInteger$5(null), p: null, q: null, qBits: bits >> 1, pBits: bits - (bits >> 1), pqState: 0, num: null, keys: null };
    rval.e.fromInt(rval.eInt);
  } else {
    throw new Error("Invalid key generation algorithm: " + algorithm);
  }
  return rval;
};
pki$2.rsa.stepKeyPairGenerationState = function(state, n2) {
  if (!("algorithm" in state)) {
    state.algorithm = "PRIMEINC";
  }
  var THIRTY = new BigInteger$5(null);
  THIRTY.fromInt(30);
  var deltaIdx = 0;
  var op_or2 = function op_or3(x2, y3) {
    return x2 | y3;
  };
  var t1 = +/* @__PURE__ */ new Date();
  var t2;
  var total = 0;
  while (state.keys === null && (n2 <= 0 || total < n2)) {
    if (state.state === 0) {
      var bits = state.p === null ? state.pBits : state.qBits;
      var bits1 = bits - 1;
      if (state.pqState === 0) {
        state.num = new BigInteger$5(bits, state.rng);
        if (!state.num.testBit(bits1)) {
          state.num.bitwiseTo(BigInteger$5.ONE.shiftLeft(bits1), op_or2, state.num);
        }
        state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);
        deltaIdx = 0;
        ++state.pqState;
      } else if (state.pqState === 1) {
        if (state.num.bitLength() > bits) {
          state.pqState = 0;
        } else if (state.num.isProbablePrime(_getMillerRabinTests$1(state.num.bitLength()))) {
          ++state.pqState;
        } else {
          state.num.dAddOffset(GCD_30_DELTA$1[deltaIdx++ % 8], 0);
        }
      } else if (state.pqState === 2) {
        state.pqState = state.num.subtract(BigInteger$5.ONE).gcd(state.e).compareTo(BigInteger$5.ONE) === 0 ? 3 : 0;
      } else if (state.pqState === 3) {
        state.pqState = 0;
        if (state.p === null) {
          state.p = state.num;
        } else {
          state.q = state.num;
        }
        if (state.p !== null && state.q !== null) {
          ++state.state;
        }
        state.num = null;
      }
    } else if (state.state === 1) {
      if (state.p.compareTo(state.q) < 0) {
        state.num = state.p;
        state.p = state.q;
        state.q = state.num;
      }
      ++state.state;
    } else if (state.state === 2) {
      state.p1 = state.p.subtract(BigInteger$5.ONE);
      state.q1 = state.q.subtract(BigInteger$5.ONE);
      state.phi = state.p1.multiply(state.q1);
      ++state.state;
    } else if (state.state === 3) {
      if (state.phi.gcd(state.e).compareTo(BigInteger$5.ONE) === 0) {
        ++state.state;
      } else {
        state.p = null;
        state.q = null;
        state.state = 0;
      }
    } else if (state.state === 4) {
      state.n = state.p.multiply(state.q);
      if (state.n.bitLength() === state.bits) {
        ++state.state;
      } else {
        state.q = null;
        state.state = 0;
      }
    } else if (state.state === 5) {
      var d2 = state.e.modInverse(state.phi);
      state.keys = { privateKey: pki$2.rsa.setPrivateKey(state.n, state.e, d2, state.p, state.q, d2.mod(state.p1), d2.mod(state.q1), state.q.modInverse(state.p)), publicKey: pki$2.rsa.setPublicKey(state.n, state.e) };
    }
    t2 = +/* @__PURE__ */ new Date();
    total += t2 - t1;
    t1 = t2;
  }
  return state.keys !== null;
};
pki$2.rsa.generateKeyPair = function(bits, e2, options, callback) {
  if (arguments.length === 1) {
    if (_typeof(bits) === "object") {
      options = bits;
      bits = void 0;
    } else if (typeof bits === "function") {
      callback = bits;
      bits = void 0;
    }
  } else if (arguments.length === 2) {
    if (typeof bits === "number") {
      if (typeof e2 === "function") {
        callback = e2;
        e2 = void 0;
      } else if (typeof e2 !== "number") {
        options = e2;
        e2 = void 0;
      }
    } else {
      options = bits;
      callback = e2;
      bits = void 0;
      e2 = void 0;
    }
  } else if (arguments.length === 3) {
    if (typeof e2 === "number") {
      if (typeof options === "function") {
        callback = options;
        options = void 0;
      }
    } else {
      callback = options;
      options = e2;
      e2 = void 0;
    }
  }
  options = options || {};
  if (bits === void 0) {
    bits = options.bits || 2048;
  }
  if (e2 === void 0) {
    e2 = options.e || 65537;
  }
  if (!forge$v.options.usePureJavaScript && !options.prng && bits >= 256 && bits <= 16384 && (e2 === 65537 || e2 === 3)) {
    if (callback) {
      if (_detectNodeCrypto$1("generateKeyPair")) {
        return _crypto$2.generateKeyPair("rsa", { modulusLength: bits, publicExponent: e2, publicKeyEncoding: { type: "spki", format: "pem" }, privateKeyEncoding: { type: "pkcs8", format: "pem" } }, function(err, pub, priv) {
          if (err) {
            return callback(err);
          }
          callback(null, { privateKey: pki$2.privateKeyFromPem(priv), publicKey: pki$2.publicKeyFromPem(pub) });
        });
      }
      if (_detectSubtleCrypto$1("generateKey") && _detectSubtleCrypto$1("exportKey")) {
        return util$9.globalScope.crypto.subtle.generateKey({ name: "RSASSA-PKCS1-v1_5", modulusLength: bits, publicExponent: _intToUint8Array$1(e2), hash: { name: "SHA-256" } }, true, ["sign", "verify"]).then(function(pair) {
          return util$9.globalScope.crypto.subtle.exportKey("pkcs8", pair.privateKey);
        }).then(void 0, function(err) {
          callback(err);
        }).then(function(pkcs8) {
          if (pkcs8) {
            var privateKey = pki$2.privateKeyFromAsn1(asn1$4.fromDer(forge$v.util.createBuffer(pkcs8)));
            callback(null, { privateKey, publicKey: pki$2.setRsaPublicKey(privateKey.n, privateKey.e) });
          }
        });
      }
      if (_detectSubtleMsCrypto$1("generateKey") && _detectSubtleMsCrypto$1("exportKey")) {
        var genOp = util$9.globalScope.msCrypto.subtle.generateKey({ name: "RSASSA-PKCS1-v1_5", modulusLength: bits, publicExponent: _intToUint8Array$1(e2), hash: { name: "SHA-256" } }, true, ["sign", "verify"]);
        genOp.oncomplete = function(e3) {
          var pair = e3.target.result;
          var exportOp = util$9.globalScope.msCrypto.subtle.exportKey("pkcs8", pair.privateKey);
          exportOp.oncomplete = function(e4) {
            var pkcs8 = e4.target.result;
            var privateKey = pki$2.privateKeyFromAsn1(asn1$4.fromDer(forge$v.util.createBuffer(pkcs8)));
            callback(null, { privateKey, publicKey: pki$2.setRsaPublicKey(privateKey.n, privateKey.e) });
          };
          exportOp.onerror = function(err) {
            callback(err);
          };
        };
        genOp.onerror = function(err) {
          callback(err);
        };
        return;
      }
    } else {
      if (_detectNodeCrypto$1("generateKeyPairSync")) {
        var keypair = _crypto$2.generateKeyPairSync("rsa", { modulusLength: bits, publicExponent: e2, publicKeyEncoding: { type: "spki", format: "pem" }, privateKeyEncoding: { type: "pkcs8", format: "pem" } });
        return { privateKey: pki$2.privateKeyFromPem(keypair.privateKey), publicKey: pki$2.publicKeyFromPem(keypair.publicKey) };
      }
    }
  }
  var state = pki$2.rsa.createKeyPairGenerationState(bits, e2, options);
  if (!callback) {
    pki$2.rsa.stepKeyPairGenerationState(state, 0);
    return state.keys;
  }
  _generateKeyPair$1(state, options, callback);
};
pki$2.setRsaPublicKey = pki$2.rsa.setPublicKey = function(n2, e2) {
  var key3 = { n: n2, e: e2 };
  key3.encrypt = function(data, scheme, schemeOptions) {
    if (typeof scheme === "string") {
      scheme = scheme.toUpperCase();
    } else if (scheme === void 0) {
      scheme = "RSAES-PKCS1-V1_5";
    }
    if (scheme === "RSAES-PKCS1-V1_5") {
      scheme = { encode: function encode7(m2, key4, pub) {
        return _encodePkcs1_v1_5$1(m2, key4, 2).getBytes();
      } };
    } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
      scheme = { encode: function encode7(m2, key4) {
        return forge$v.pkcs1.encode_rsa_oaep(key4, m2, schemeOptions);
      } };
    } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
      scheme = { encode: function encode7(e4) {
        return e4;
      } };
    } else if (typeof scheme === "string") {
      throw new Error('Unsupported encryption scheme: "' + scheme + '".');
    }
    var e3 = scheme.encode(data, key3, true);
    return pki$2.rsa.encrypt(e3, key3, true);
  };
  key3.verify = function(digest11, signature2, scheme) {
    if (typeof scheme === "string") {
      scheme = scheme.toUpperCase();
    } else if (scheme === void 0) {
      scheme = "RSASSA-PKCS1-V1_5";
    }
    if (scheme === "RSASSA-PKCS1-V1_5") {
      scheme = { verify: function verify(digest12, d3) {
        d3 = _decodePkcs1_v1_5$1(d3, key3, true);
        var obj2 = asn1$4.fromDer(d3);
        return digest12 === obj2.value[1].value;
      } };
    } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
      scheme = { verify: function verify(digest12, d3) {
        d3 = _decodePkcs1_v1_5$1(d3, key3, true);
        return digest12 === d3;
      } };
    }
    var d2 = pki$2.rsa.decrypt(signature2, key3, true, false);
    return scheme.verify(digest11, d2, key3.n.bitLength());
  };
  return key3;
};
pki$2.setRsaPrivateKey = pki$2.rsa.setPrivateKey = function(n2, e2, d2, p2, q3, dP, dQ, qInv) {
  var key3 = { n: n2, e: e2, d: d2, p: p2, q: q3, dP, dQ, qInv };
  key3.decrypt = function(data, scheme, schemeOptions) {
    if (typeof scheme === "string") {
      scheme = scheme.toUpperCase();
    } else if (scheme === void 0) {
      scheme = "RSAES-PKCS1-V1_5";
    }
    var d3 = pki$2.rsa.decrypt(data, key3, false, false);
    if (scheme === "RSAES-PKCS1-V1_5") {
      scheme = { decode: _decodePkcs1_v1_5$1 };
    } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
      scheme = { decode: function decode6(d4, key4) {
        return forge$v.pkcs1.decode_rsa_oaep(key4, d4, schemeOptions);
      } };
    } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
      scheme = { decode: function decode6(d4) {
        return d4;
      } };
    } else {
      throw new Error('Unsupported encryption scheme: "' + scheme + '".');
    }
    return scheme.decode(d3, key3, false);
  };
  key3.sign = function(md, scheme) {
    var bt = false;
    if (typeof scheme === "string") {
      scheme = scheme.toUpperCase();
    }
    if (scheme === void 0 || scheme === "RSASSA-PKCS1-V1_5") {
      scheme = { encode: emsaPkcs1v15encode$1 };
      bt = 1;
    } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
      scheme = { encode: function encode7() {
        return md;
      } };
      bt = 1;
    }
    var d3 = scheme.encode(md, key3.n.bitLength());
    return pki$2.rsa.encrypt(d3, key3, bt);
  };
  return key3;
};
pki$2.wrapRsaPrivateKey = function(rsaKey) {
  return asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
    // version (0)
    asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.INTEGER, false, asn1$4.integerToDer(0).getBytes()),
    // privateKeyAlgorithm
    asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.OID, false, asn1$4.oidToDer(pki$2.oids.rsaEncryption).getBytes()), asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.NULL, false, "")]),
    // PrivateKey
    asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.OCTETSTRING, false, asn1$4.toDer(rsaKey).getBytes())
  ]);
};
pki$2.privateKeyFromAsn1 = function(obj2) {
  var capture = {};
  var errors = [];
  if (asn1$4.validate(obj2, privateKeyValidator$2, capture, errors)) {
    obj2 = asn1$4.fromDer(forge$v.util.createBuffer(capture.privateKey));
  }
  capture = {};
  errors = [];
  if (!asn1$4.validate(obj2, rsaPrivateKeyValidator$1, capture, errors)) {
    var error3 = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
    error3.errors = errors;
    throw error3;
  }
  var n2, e2, d2, p2, q3, dP, dQ, qInv;
  n2 = forge$v.util.createBuffer(capture.privateKeyModulus).toHex();
  e2 = forge$v.util.createBuffer(capture.privateKeyPublicExponent).toHex();
  d2 = forge$v.util.createBuffer(capture.privateKeyPrivateExponent).toHex();
  p2 = forge$v.util.createBuffer(capture.privateKeyPrime1).toHex();
  q3 = forge$v.util.createBuffer(capture.privateKeyPrime2).toHex();
  dP = forge$v.util.createBuffer(capture.privateKeyExponent1).toHex();
  dQ = forge$v.util.createBuffer(capture.privateKeyExponent2).toHex();
  qInv = forge$v.util.createBuffer(capture.privateKeyCoefficient).toHex();
  return pki$2.setRsaPrivateKey(new BigInteger$5(n2, 16), new BigInteger$5(e2, 16), new BigInteger$5(d2, 16), new BigInteger$5(p2, 16), new BigInteger$5(q3, 16), new BigInteger$5(dP, 16), new BigInteger$5(dQ, 16), new BigInteger$5(qInv, 16));
};
pki$2.privateKeyToAsn1 = pki$2.privateKeyToRSAPrivateKey = function(key3) {
  return asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
    // version (0 = only 2 primes, 1 multiple primes)
    asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.INTEGER, false, asn1$4.integerToDer(0).getBytes()),
    // modulus (n)
    asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.INTEGER, false, _bnToBytes$1(key3.n)),
    // publicExponent (e)
    asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.INTEGER, false, _bnToBytes$1(key3.e)),
    // privateExponent (d)
    asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.INTEGER, false, _bnToBytes$1(key3.d)),
    // privateKeyPrime1 (p)
    asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.INTEGER, false, _bnToBytes$1(key3.p)),
    // privateKeyPrime2 (q)
    asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.INTEGER, false, _bnToBytes$1(key3.q)),
    // privateKeyExponent1 (dP)
    asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.INTEGER, false, _bnToBytes$1(key3.dP)),
    // privateKeyExponent2 (dQ)
    asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.INTEGER, false, _bnToBytes$1(key3.dQ)),
    // coefficient (qInv)
    asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.INTEGER, false, _bnToBytes$1(key3.qInv))
  ]);
};
pki$2.publicKeyFromAsn1 = function(obj2) {
  var capture = {};
  var errors = [];
  if (asn1$4.validate(obj2, publicKeyValidator$2, capture, errors)) {
    var oid = asn1$4.derToOid(capture.publicKeyOid);
    if (oid !== pki$2.oids.rsaEncryption) {
      var error3 = new Error("Cannot read public key. Unknown OID.");
      error3.oid = oid;
      throw error3;
    }
    obj2 = capture.rsaPublicKey;
  }
  errors = [];
  if (!asn1$4.validate(obj2, rsaPublicKeyValidator$1, capture, errors)) {
    var error3 = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
    error3.errors = errors;
    throw error3;
  }
  var n2 = forge$v.util.createBuffer(capture.publicKeyModulus).toHex();
  var e2 = forge$v.util.createBuffer(capture.publicKeyExponent).toHex();
  return pki$2.setRsaPublicKey(new BigInteger$5(n2, 16), new BigInteger$5(e2, 16));
};
pki$2.publicKeyToAsn1 = pki$2.publicKeyToSubjectPublicKeyInfo = function(key3) {
  return asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
    // AlgorithmIdentifier
    asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
      // algorithm
      asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.OID, false, asn1$4.oidToDer(pki$2.oids.rsaEncryption).getBytes()),
      // parameters (null)
      asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.NULL, false, "")
    ]),
    // subjectPublicKey
    asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.BITSTRING, false, [pki$2.publicKeyToRSAPublicKey(key3)])
  ]);
};
pki$2.publicKeyToRSAPublicKey = function(key3) {
  return asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
    // modulus (n)
    asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.INTEGER, false, _bnToBytes$1(key3.n)),
    // publicExponent (e)
    asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.INTEGER, false, _bnToBytes$1(key3.e))
  ]);
};
function _encodePkcs1_v1_5$1(m2, key3, bt) {
  var eb = forge$v.util.createBuffer();
  var k3 = Math.ceil(key3.n.bitLength() / 8);
  if (m2.length > k3 - 11) {
    var error3 = new Error("Message is too long for PKCS#1 v1.5 padding.");
    error3.length = m2.length;
    error3.max = k3 - 11;
    throw error3;
  }
  eb.putByte(0);
  eb.putByte(bt);
  var padNum = k3 - 3 - m2.length;
  var padByte;
  if (bt === 0 || bt === 1) {
    padByte = bt === 0 ? 0 : 255;
    for (var i2 = 0; i2 < padNum; ++i2) {
      eb.putByte(padByte);
    }
  } else {
    while (padNum > 0) {
      var numZeros = 0;
      var padBytes = forge$v.random.getBytes(padNum);
      for (var i2 = 0; i2 < padNum; ++i2) {
        padByte = padBytes.charCodeAt(i2);
        if (padByte === 0) {
          ++numZeros;
        } else {
          eb.putByte(padByte);
        }
      }
      padNum = numZeros;
    }
  }
  eb.putByte(0);
  eb.putBytes(m2);
  return eb;
}
function _decodePkcs1_v1_5$1(em, key3, pub, ml) {
  var k3 = Math.ceil(key3.n.bitLength() / 8);
  var eb = forge$v.util.createBuffer(em);
  var first = eb.getByte();
  var bt = eb.getByte();
  if (first !== 0 || pub && bt !== 0 && bt !== 1 || !pub && bt != 2 || pub && bt === 0 && typeof ml === "undefined") {
    throw new Error("Encryption block is invalid.");
  }
  var padNum = 0;
  if (bt === 0) {
    padNum = k3 - 3 - ml;
    for (var i2 = 0; i2 < padNum; ++i2) {
      if (eb.getByte() !== 0) {
        throw new Error("Encryption block is invalid.");
      }
    }
  } else if (bt === 1) {
    padNum = 0;
    while (eb.length() > 1) {
      if (eb.getByte() !== 255) {
        --eb.read;
        break;
      }
      ++padNum;
    }
  } else if (bt === 2) {
    padNum = 0;
    while (eb.length() > 1) {
      if (eb.getByte() === 0) {
        --eb.read;
        break;
      }
      ++padNum;
    }
  }
  var zero = eb.getByte();
  if (zero !== 0 || padNum !== k3 - 3 - eb.length()) {
    throw new Error("Encryption block is invalid.");
  }
  return eb.getBytes();
}
function _generateKeyPair$1(state, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = {};
  }
  options = options || {};
  var opts = { algorithm: { name: options.algorithm || "PRIMEINC", options: { workers: options.workers || 2, workLoad: options.workLoad || 100, workerScript: options.workerScript } } };
  if ("prng" in options) {
    opts.prng = options.prng;
  }
  generate2();
  function generate2() {
    getPrime(state.pBits, function(err, num) {
      if (err) {
        return callback(err);
      }
      state.p = num;
      if (state.q !== null) {
        return finish2(err, state.q);
      }
      getPrime(state.qBits, finish2);
    });
  }
  function getPrime(bits, callback2) {
    forge$v.prime.generateProbablePrime(bits, opts, callback2);
  }
  function finish2(err, num) {
    if (err) {
      return callback(err);
    }
    state.q = num;
    if (state.p.compareTo(state.q) < 0) {
      var tmp = state.p;
      state.p = state.q;
      state.q = tmp;
    }
    if (state.p.subtract(BigInteger$5.ONE).gcd(state.e).compareTo(BigInteger$5.ONE) !== 0) {
      state.p = null;
      generate2();
      return;
    }
    if (state.q.subtract(BigInteger$5.ONE).gcd(state.e).compareTo(BigInteger$5.ONE) !== 0) {
      state.q = null;
      getPrime(state.qBits, finish2);
      return;
    }
    state.p1 = state.p.subtract(BigInteger$5.ONE);
    state.q1 = state.q.subtract(BigInteger$5.ONE);
    state.phi = state.p1.multiply(state.q1);
    if (state.phi.gcd(state.e).compareTo(BigInteger$5.ONE) !== 0) {
      state.p = state.q = null;
      generate2();
      return;
    }
    state.n = state.p.multiply(state.q);
    if (state.n.bitLength() !== state.bits) {
      state.q = null;
      getPrime(state.qBits, finish2);
      return;
    }
    var d2 = state.e.modInverse(state.phi);
    state.keys = { privateKey: pki$2.rsa.setPrivateKey(state.n, state.e, d2, state.p, state.q, d2.mod(state.p1), d2.mod(state.q1), state.q.modInverse(state.p)), publicKey: pki$2.rsa.setPublicKey(state.n, state.e) };
    callback(null, state.keys);
  }
}
function _bnToBytes$1(b3) {
  var hex = b3.toString(16);
  if (hex[0] >= "8") {
    hex = "00" + hex;
  }
  var bytes = forge$v.util.hexToBytes(hex);
  if (bytes.length > 1 && // leading 0x00 for positive integer
  (bytes.charCodeAt(0) === 0 && (bytes.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer
  bytes.charCodeAt(0) === 255 && (bytes.charCodeAt(1) & 128) === 128)) {
    return bytes.substr(1);
  }
  return bytes;
}
function _getMillerRabinTests$1(bits) {
  if (bits <= 100)
    return 27;
  if (bits <= 150)
    return 18;
  if (bits <= 200)
    return 15;
  if (bits <= 250)
    return 12;
  if (bits <= 300)
    return 9;
  if (bits <= 350)
    return 8;
  if (bits <= 400)
    return 7;
  if (bits <= 500)
    return 6;
  if (bits <= 600)
    return 5;
  if (bits <= 800)
    return 4;
  if (bits <= 1250)
    return 3;
  return 2;
}
function _detectNodeCrypto$1(fn) {
  return forge$v.util.isNodejs && typeof _crypto$2[fn] === "function";
}
function _detectSubtleCrypto$1(fn) {
  return typeof util$9.globalScope !== "undefined" && _typeof(util$9.globalScope.crypto) === "object" && _typeof(util$9.globalScope.crypto.subtle) === "object" && typeof util$9.globalScope.crypto.subtle[fn] === "function";
}
function _detectSubtleMsCrypto$1(fn) {
  return typeof util$9.globalScope !== "undefined" && _typeof(util$9.globalScope.msCrypto) === "object" && _typeof(util$9.globalScope.msCrypto.subtle) === "object" && typeof util$9.globalScope.msCrypto.subtle[fn] === "function";
}
function _intToUint8Array$1(x2) {
  var bytes = forge$v.util.hexToBytes(x2.toString(16));
  var buffer2 = new Uint8Array(bytes.length);
  for (var i2 = 0; i2 < bytes.length; ++i2) {
    buffer2[i2] = bytes.charCodeAt(i2);
  }
  return buffer2;
}
var rsa$2 = getDefaultExportFromCjs(rsa$1);
var processFn = function processFn2(fn, options) {
  return function() {
    var _this24 = this;
    for (var _len14 = arguments.length, args = new Array(_len14), _key17 = 0; _key17 < _len14; _key17++) {
      args[_key17] = arguments[_key17];
    }
    var P3 = options.promiseModule;
    return new P3(function(resolve, reject) {
      if (options.multiArgs) {
        args.push(function() {
          for (var _len15 = arguments.length, result = new Array(_len15), _key18 = 0; _key18 < _len15; _key18++) {
            result[_key18] = arguments[_key18];
          }
          if (options.errorFirst) {
            if (result[0]) {
              reject(result);
            } else {
              result.shift();
              resolve(result);
            }
          } else {
            resolve(result);
          }
        });
      } else if (options.errorFirst) {
        args.push(function(error3, result) {
          if (error3) {
            reject(error3);
          } else {
            resolve(result);
          }
        });
      } else {
        args.push(resolve);
      }
      fn.apply(_this24, args);
    });
  };
};
var pify = function pify2(input, options) {
  options = Object.assign({ exclude: [/.+(Sync|Stream)$/], errorFirst: true, promiseModule: Promise }, options);
  var objType = _typeof(input);
  if (!(input !== null && (objType === "object" || objType === "function"))) {
    throw new TypeError("Expected `input` to be a `Function` or `Object`, got `".concat(input === null ? "null" : objType, "`"));
  }
  var filter2 = function filter3(key3) {
    var match = function match2(pattern) {
      return typeof pattern === "string" ? key3 === pattern : pattern.test(key3);
    };
    return options.include ? options.include.some(match) : !options.exclude.some(match);
  };
  var ret;
  if (objType === "function") {
    ret = function ret2() {
      for (var _len16 = arguments.length, args = new Array(_len16), _key19 = 0; _key19 < _len16; _key19++) {
        args[_key19] = arguments[_key19];
      }
      return options.excludeMain ? input.apply(void 0, args) : processFn(input, options).apply(this, args);
    };
  } else {
    ret = Object.create(Object.getPrototypeOf(input));
  }
  for (var _key20 in input) {
    var property = input[_key20];
    ret[_key20] = typeof property === "function" && filter2(_key20) ? processFn(property, options) : property;
  }
  return ret;
};
var pify$1 = getDefaultExportFromCjs(pify);
var hash$4 = {};
var utils$d = {};
var assert$5 = minimalisticAssert;
var inherits = inherits_browserExports;
utils$d.inherits = inherits;
function isSurrogatePair(msg, i2) {
  if ((msg.charCodeAt(i2) & 64512) !== 55296) {
    return false;
  }
  if (i2 < 0 || i2 + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i2 + 1) & 64512) === 56320;
}
function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === "string") {
    if (!enc) {
      var p2 = 0;
      for (var i2 = 0; i2 < msg.length; i2++) {
        var c3 = msg.charCodeAt(i2);
        if (c3 < 128) {
          res[p2++] = c3;
        } else if (c3 < 2048) {
          res[p2++] = c3 >> 6 | 192;
          res[p2++] = c3 & 63 | 128;
        } else if (isSurrogatePair(msg, i2)) {
          c3 = 65536 + ((c3 & 1023) << 10) + (msg.charCodeAt(++i2) & 1023);
          res[p2++] = c3 >> 18 | 240;
          res[p2++] = c3 >> 12 & 63 | 128;
          res[p2++] = c3 >> 6 & 63 | 128;
          res[p2++] = c3 & 63 | 128;
        } else {
          res[p2++] = c3 >> 12 | 224;
          res[p2++] = c3 >> 6 & 63 | 128;
          res[p2++] = c3 & 63 | 128;
        }
      }
    } else if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (i2 = 0; i2 < msg.length; i2 += 2)
        res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
    }
  } else {
    for (i2 = 0; i2 < msg.length; i2++)
      res[i2] = msg[i2] | 0;
  }
  return res;
}
utils$d.toArray = toArray;
function toHex(msg) {
  var res = "";
  for (var i2 = 0; i2 < msg.length; i2++)
    res += zero2(msg[i2].toString(16));
  return res;
}
utils$d.toHex = toHex;
function htonl(w2) {
  var res = w2 >>> 24 | w2 >>> 8 & 65280 | w2 << 8 & 16711680 | (w2 & 255) << 24;
  return res >>> 0;
}
utils$d.htonl = htonl;
function toHex32(msg, endian) {
  var res = "";
  for (var i2 = 0; i2 < msg.length; i2++) {
    var w2 = msg[i2];
    if (endian === "little")
      w2 = htonl(w2);
    res += zero8(w2.toString(16));
  }
  return res;
}
utils$d.toHex32 = toHex32;
function zero2(word) {
  if (word.length === 1)
    return "0" + word;
  else
    return word;
}
utils$d.zero2 = zero2;
function zero8(word) {
  if (word.length === 7)
    return "0" + word;
  else if (word.length === 6)
    return "00" + word;
  else if (word.length === 5)
    return "000" + word;
  else if (word.length === 4)
    return "0000" + word;
  else if (word.length === 3)
    return "00000" + word;
  else if (word.length === 2)
    return "000000" + word;
  else if (word.length === 1)
    return "0000000" + word;
  else
    return word;
}
utils$d.zero8 = zero8;
function join32(msg, start, end2, endian) {
  var len2 = end2 - start;
  assert$5(len2 % 4 === 0);
  var res = new Array(len2 / 4);
  for (var i2 = 0, k3 = start; i2 < res.length; i2++, k3 += 4) {
    var w2;
    if (endian === "big")
      w2 = msg[k3] << 24 | msg[k3 + 1] << 16 | msg[k3 + 2] << 8 | msg[k3 + 3];
    else
      w2 = msg[k3 + 3] << 24 | msg[k3 + 2] << 16 | msg[k3 + 1] << 8 | msg[k3];
    res[i2] = w2 >>> 0;
  }
  return res;
}
utils$d.join32 = join32;
function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i2 = 0, k3 = 0; i2 < msg.length; i2++, k3 += 4) {
    var m2 = msg[i2];
    if (endian === "big") {
      res[k3] = m2 >>> 24;
      res[k3 + 1] = m2 >>> 16 & 255;
      res[k3 + 2] = m2 >>> 8 & 255;
      res[k3 + 3] = m2 & 255;
    } else {
      res[k3 + 3] = m2 >>> 24;
      res[k3 + 2] = m2 >>> 16 & 255;
      res[k3 + 1] = m2 >>> 8 & 255;
      res[k3] = m2 & 255;
    }
  }
  return res;
}
utils$d.split32 = split32;
function rotr32$1(w2, b3) {
  return w2 >>> b3 | w2 << 32 - b3;
}
utils$d.rotr32 = rotr32$1;
function rotl32$2(w2, b3) {
  return w2 << b3 | w2 >>> 32 - b3;
}
utils$d.rotl32 = rotl32$2;
function sum32$3(a2, b3) {
  return a2 + b3 >>> 0;
}
utils$d.sum32 = sum32$3;
function sum32_3$1(a2, b3, c3) {
  return a2 + b3 + c3 >>> 0;
}
utils$d.sum32_3 = sum32_3$1;
function sum32_4$2(a2, b3, c3, d2) {
  return a2 + b3 + c3 + d2 >>> 0;
}
utils$d.sum32_4 = sum32_4$2;
function sum32_5$2(a2, b3, c3, d2, e2) {
  return a2 + b3 + c3 + d2 + e2 >>> 0;
}
utils$d.sum32_5 = sum32_5$2;
function sum64$1(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];
  var lo = al + bl >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
utils$d.sum64 = sum64$1;
function sum64_hi$1(ah, al, bh, bl) {
  var lo = al + bl >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
utils$d.sum64_hi = sum64_hi$1;
function sum64_lo$1(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
utils$d.sum64_lo = sum64_lo$1;
function sum64_4_hi$1(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = lo + bl >>> 0;
  carry += lo < al ? 1 : 0;
  lo = lo + cl >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = lo + dl >>> 0;
  carry += lo < dl ? 1 : 0;
  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
utils$d.sum64_4_hi = sum64_4_hi$1;
function sum64_4_lo$1(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
utils$d.sum64_4_lo = sum64_4_lo$1;
function sum64_5_hi$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = lo + bl >>> 0;
  carry += lo < al ? 1 : 0;
  lo = lo + cl >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = lo + dl >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = lo + el >>> 0;
  carry += lo < el ? 1 : 0;
  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
utils$d.sum64_5_hi = sum64_5_hi$1;
function sum64_5_lo$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;
  return lo >>> 0;
}
utils$d.sum64_5_lo = sum64_5_lo$1;
function rotr64_hi$1(ah, al, num) {
  var r2 = al << 32 - num | ah >>> num;
  return r2 >>> 0;
}
utils$d.rotr64_hi = rotr64_hi$1;
function rotr64_lo$1(ah, al, num) {
  var r2 = ah << 32 - num | al >>> num;
  return r2 >>> 0;
}
utils$d.rotr64_lo = rotr64_lo$1;
function shr64_hi$1(ah, al, num) {
  return ah >>> num;
}
utils$d.shr64_hi = shr64_hi$1;
function shr64_lo$1(ah, al, num) {
  var r2 = ah << 32 - num | al >>> num;
  return r2 >>> 0;
}
utils$d.shr64_lo = shr64_lo$1;
var common$6 = {};
var utils$c = utils$d;
var assert$4 = minimalisticAssert;
function BlockHash$4() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = "big";
  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
common$6.BlockHash = BlockHash$4;
BlockHash$4.prototype.update = function update(msg, enc) {
  msg = utils$c.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;
  if (this.pending.length >= this._delta8) {
    msg = this.pending;
    var r2 = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r2, msg.length);
    if (this.pending.length === 0)
      this.pending = null;
    msg = utils$c.join32(msg, 0, msg.length - r2, this.endian);
    for (var i2 = 0; i2 < msg.length; i2 += this._delta32)
      this._update(msg, i2, i2 + this._delta32);
  }
  return this;
};
BlockHash$4.prototype.digest = function digest2(enc) {
  this.update(this._pad());
  assert$4(this.pending === null);
  return this._digest(enc);
};
BlockHash$4.prototype._pad = function pad() {
  var len2 = this.pendingTotal;
  var bytes = this._delta8;
  var k3 = bytes - (len2 + this.padLength) % bytes;
  var res = new Array(k3 + this.padLength);
  res[0] = 128;
  for (var i2 = 1; i2 < k3; i2++)
    res[i2] = 0;
  len2 <<= 3;
  if (this.endian === "big") {
    for (var t2 = 8; t2 < this.padLength; t2++)
      res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = len2 >>> 24 & 255;
    res[i2++] = len2 >>> 16 & 255;
    res[i2++] = len2 >>> 8 & 255;
    res[i2++] = len2 & 255;
  } else {
    res[i2++] = len2 & 255;
    res[i2++] = len2 >>> 8 & 255;
    res[i2++] = len2 >>> 16 & 255;
    res[i2++] = len2 >>> 24 & 255;
    res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = 0;
    for (t2 = 8; t2 < this.padLength; t2++)
      res[i2++] = 0;
  }
  return res;
};
var sha$1 = {};
var common$5 = {};
var utils$b = utils$d;
var rotr32 = utils$b.rotr32;
function ft_1$1(s2, x2, y3, z2) {
  if (s2 === 0)
    return ch32$1(x2, y3, z2);
  if (s2 === 1 || s2 === 3)
    return p32(x2, y3, z2);
  if (s2 === 2)
    return maj32$1(x2, y3, z2);
}
common$5.ft_1 = ft_1$1;
function ch32$1(x2, y3, z2) {
  return x2 & y3 ^ ~x2 & z2;
}
common$5.ch32 = ch32$1;
function maj32$1(x2, y3, z2) {
  return x2 & y3 ^ x2 & z2 ^ y3 & z2;
}
common$5.maj32 = maj32$1;
function p32(x2, y3, z2) {
  return x2 ^ y3 ^ z2;
}
common$5.p32 = p32;
function s0_256$1(x2) {
  return rotr32(x2, 2) ^ rotr32(x2, 13) ^ rotr32(x2, 22);
}
common$5.s0_256 = s0_256$1;
function s1_256$1(x2) {
  return rotr32(x2, 6) ^ rotr32(x2, 11) ^ rotr32(x2, 25);
}
common$5.s1_256 = s1_256$1;
function g0_256$1(x2) {
  return rotr32(x2, 7) ^ rotr32(x2, 18) ^ x2 >>> 3;
}
common$5.g0_256 = g0_256$1;
function g1_256$1(x2) {
  return rotr32(x2, 17) ^ rotr32(x2, 19) ^ x2 >>> 10;
}
common$5.g1_256 = g1_256$1;
var utils$a = utils$d;
var common$4 = common$6;
var shaCommon$1 = common$5;
var rotl32$1 = utils$a.rotl32;
var sum32$2 = utils$a.sum32;
var sum32_5$1 = utils$a.sum32_5;
var ft_1 = shaCommon$1.ft_1;
var BlockHash$3 = common$4.BlockHash;
var sha1_K = [1518500249, 1859775393, 2400959708, 3395469782];
function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();
  BlockHash$3.call(this);
  this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  this.W = new Array(80);
}
utils$a.inherits(SHA1, BlockHash$3);
var _1 = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function _update2(msg, start) {
  var W2 = this.W;
  for (var i2 = 0; i2 < 16; i2++)
    W2[i2] = msg[start + i2];
  for (; i2 < W2.length; i2++)
    W2[i2] = rotl32$1(W2[i2 - 3] ^ W2[i2 - 8] ^ W2[i2 - 14] ^ W2[i2 - 16], 1);
  var a2 = this.h[0];
  var b3 = this.h[1];
  var c3 = this.h[2];
  var d2 = this.h[3];
  var e2 = this.h[4];
  for (i2 = 0; i2 < W2.length; i2++) {
    var s2 = ~~(i2 / 20);
    var t2 = sum32_5$1(rotl32$1(a2, 5), ft_1(s2, b3, c3, d2), e2, W2[i2], sha1_K[s2]);
    e2 = d2;
    d2 = c3;
    c3 = rotl32$1(b3, 30);
    b3 = a2;
    a2 = t2;
  }
  this.h[0] = sum32$2(this.h[0], a2);
  this.h[1] = sum32$2(this.h[1], b3);
  this.h[2] = sum32$2(this.h[2], c3);
  this.h[3] = sum32$2(this.h[3], d2);
  this.h[4] = sum32$2(this.h[4], e2);
};
SHA1.prototype._digest = function digest3(enc) {
  if (enc === "hex")
    return utils$a.toHex32(this.h, "big");
  else
    return utils$a.split32(this.h, "big");
};
var utils$9 = utils$d;
var common$3 = common$6;
var shaCommon = common$5;
var assert$3 = minimalisticAssert;
var sum32$1 = utils$9.sum32;
var sum32_4$1 = utils$9.sum32_4;
var sum32_5 = utils$9.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;
var BlockHash$2 = common$3.BlockHash;
var sha256_K = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
function SHA256$1() {
  if (!(this instanceof SHA256$1))
    return new SHA256$1();
  BlockHash$2.call(this);
  this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils$9.inherits(SHA256$1, BlockHash$2);
var _256 = SHA256$1;
SHA256$1.blockSize = 512;
SHA256$1.outSize = 256;
SHA256$1.hmacStrength = 192;
SHA256$1.padLength = 64;
SHA256$1.prototype._update = function _update3(msg, start) {
  var W2 = this.W;
  for (var i2 = 0; i2 < 16; i2++)
    W2[i2] = msg[start + i2];
  for (; i2 < W2.length; i2++)
    W2[i2] = sum32_4$1(g1_256(W2[i2 - 2]), W2[i2 - 7], g0_256(W2[i2 - 15]), W2[i2 - 16]);
  var a2 = this.h[0];
  var b3 = this.h[1];
  var c3 = this.h[2];
  var d2 = this.h[3];
  var e2 = this.h[4];
  var f2 = this.h[5];
  var g2 = this.h[6];
  var h2 = this.h[7];
  assert$3(this.k.length === W2.length);
  for (i2 = 0; i2 < W2.length; i2++) {
    var T1 = sum32_5(h2, s1_256(e2), ch32(e2, f2, g2), this.k[i2], W2[i2]);
    var T22 = sum32$1(s0_256(a2), maj32(a2, b3, c3));
    h2 = g2;
    g2 = f2;
    f2 = e2;
    e2 = sum32$1(d2, T1);
    d2 = c3;
    c3 = b3;
    b3 = a2;
    a2 = sum32$1(T1, T22);
  }
  this.h[0] = sum32$1(this.h[0], a2);
  this.h[1] = sum32$1(this.h[1], b3);
  this.h[2] = sum32$1(this.h[2], c3);
  this.h[3] = sum32$1(this.h[3], d2);
  this.h[4] = sum32$1(this.h[4], e2);
  this.h[5] = sum32$1(this.h[5], f2);
  this.h[6] = sum32$1(this.h[6], g2);
  this.h[7] = sum32$1(this.h[7], h2);
};
SHA256$1.prototype._digest = function digest4(enc) {
  if (enc === "hex")
    return utils$9.toHex32(this.h, "big");
  else
    return utils$9.split32(this.h, "big");
};
var utils$8 = utils$d;
var SHA256 = _256;
function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();
  SHA256.call(this);
  this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
}
utils$8.inherits(SHA224, SHA256);
var _224 = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function digest5(enc) {
  if (enc === "hex")
    return utils$8.toHex32(this.h.slice(0, 7), "big");
  else
    return utils$8.split32(this.h.slice(0, 7), "big");
};
var utils$7 = utils$d;
var common$2 = common$6;
var assert$2 = minimalisticAssert;
var rotr64_hi = utils$7.rotr64_hi;
var rotr64_lo = utils$7.rotr64_lo;
var shr64_hi = utils$7.shr64_hi;
var shr64_lo = utils$7.shr64_lo;
var sum64 = utils$7.sum64;
var sum64_hi = utils$7.sum64_hi;
var sum64_lo = utils$7.sum64_lo;
var sum64_4_hi = utils$7.sum64_4_hi;
var sum64_4_lo = utils$7.sum64_4_lo;
var sum64_5_hi = utils$7.sum64_5_hi;
var sum64_5_lo = utils$7.sum64_5_lo;
var BlockHash$1 = common$2.BlockHash;
var sha512_K = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
function SHA512$1() {
  if (!(this instanceof SHA512$1))
    return new SHA512$1();
  BlockHash$1.call(this);
  this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils$7.inherits(SHA512$1, BlockHash$1);
var _512 = SHA512$1;
SHA512$1.blockSize = 1024;
SHA512$1.outSize = 512;
SHA512$1.hmacStrength = 192;
SHA512$1.padLength = 128;
SHA512$1.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W2 = this.W;
  for (var i2 = 0; i2 < 32; i2++)
    W2[i2] = msg[start + i2];
  for (; i2 < W2.length; i2 += 2) {
    var c0_hi = g1_512_hi(W2[i2 - 4], W2[i2 - 3]);
    var c0_lo = g1_512_lo(W2[i2 - 4], W2[i2 - 3]);
    var c1_hi = W2[i2 - 14];
    var c1_lo = W2[i2 - 13];
    var c2_hi = g0_512_hi(W2[i2 - 30], W2[i2 - 29]);
    var c2_lo = g0_512_lo(W2[i2 - 30], W2[i2 - 29]);
    var c3_hi = W2[i2 - 32];
    var c3_lo = W2[i2 - 31];
    W2[i2] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
    W2[i2 + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
  }
};
SHA512$1.prototype._update = function _update4(msg, start) {
  this._prepareBlock(msg, start);
  var W2 = this.W;
  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];
  assert$2(this.k.length === W2.length);
  for (var i2 = 0; i2 < W2.length; i2 += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i2];
    var c3_lo = this.k[i2 + 1];
    var c4_hi = W2[i2];
    var c4_lo = W2[i2 + 1];
    var T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
    hh = gh;
    hl = gl;
    gh = fh;
    gl = fl;
    fh = eh;
    fl = el;
    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);
    dh = ch;
    dl = cl;
    ch = bh;
    cl = bl;
    bh = ah;
    bl = al;
    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }
  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};
SHA512$1.prototype._digest = function digest6(enc) {
  if (enc === "hex")
    return utils$7.toHex32(this.h, "big");
  else
    return utils$7.split32(this.h, "big");
};
function ch64_hi(xh, xl, yh, yl, zh) {
  var r2 = xh & yh ^ ~xh & zh;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r2 = xl & yl ^ ~xl & zl;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function maj64_hi(xh, xl, yh, yl, zh) {
  var r2 = xh & yh ^ xh & zh ^ yh & zh;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r2 = xl & yl ^ xl & zl ^ yl & zl;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);
  var c2_hi = rotr64_hi(xl, xh, 7);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);
  var c2_lo = rotr64_lo(xl, xh, 7);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);
  var c2_hi = shr64_hi(xh, xl, 6);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);
  var c2_lo = shr64_lo(xh, xl, 6);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
var utils$6 = utils$d;
var SHA512 = _512;
function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();
  SHA512.call(this);
  this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
}
utils$6.inherits(SHA384, SHA512);
var _384 = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function digest7(enc) {
  if (enc === "hex")
    return utils$6.toHex32(this.h.slice(0, 12), "big");
  else
    return utils$6.split32(this.h.slice(0, 12), "big");
};
sha$1.sha1 = _1;
sha$1.sha224 = _224;
sha$1.sha256 = _256;
sha$1.sha384 = _384;
sha$1.sha512 = _512;
var ripemd = {};
var utils$5 = utils$d;
var common$1 = common$6;
var rotl32 = utils$5.rotl32;
var sum32 = utils$5.sum32;
var sum32_3 = utils$5.sum32_3;
var sum32_4 = utils$5.sum32_4;
var BlockHash = common$1.BlockHash;
function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();
  BlockHash.call(this);
  this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  this.endian = "little";
}
utils$5.inherits(RIPEMD160, BlockHash);
ripemd.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;
RIPEMD160.prototype._update = function update2(msg, start) {
  var A2 = this.h[0];
  var B2 = this.h[1];
  var C3 = this.h[2];
  var D3 = this.h[3];
  var E2 = this.h[4];
  var Ah = A2;
  var Bh = B2;
  var Ch = C3;
  var Dh = D3;
  var Eh = E2;
  for (var j3 = 0; j3 < 80; j3++) {
    var T3 = sum32(rotl32(sum32_4(A2, f(j3, B2, C3, D3), msg[r[j3] + start], K(j3)), s$1[j3]), E2);
    A2 = E2;
    E2 = D3;
    D3 = rotl32(C3, 10);
    C3 = B2;
    B2 = T3;
    T3 = sum32(rotl32(sum32_4(Ah, f(79 - j3, Bh, Ch, Dh), msg[rh[j3] + start], Kh(j3)), sh[j3]), Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T3;
  }
  T3 = sum32_3(this.h[1], C3, Dh);
  this.h[1] = sum32_3(this.h[2], D3, Eh);
  this.h[2] = sum32_3(this.h[3], E2, Ah);
  this.h[3] = sum32_3(this.h[4], A2, Bh);
  this.h[4] = sum32_3(this.h[0], B2, Ch);
  this.h[0] = T3;
};
RIPEMD160.prototype._digest = function digest8(enc) {
  if (enc === "hex")
    return utils$5.toHex32(this.h, "little");
  else
    return utils$5.split32(this.h, "little");
};
function f(j3, x2, y3, z2) {
  if (j3 <= 15)
    return x2 ^ y3 ^ z2;
  else if (j3 <= 31)
    return x2 & y3 | ~x2 & z2;
  else if (j3 <= 47)
    return (x2 | ~y3) ^ z2;
  else if (j3 <= 63)
    return x2 & z2 | y3 & ~z2;
  else
    return x2 ^ (y3 | ~z2);
}
function K(j3) {
  if (j3 <= 15)
    return 0;
  else if (j3 <= 31)
    return 1518500249;
  else if (j3 <= 47)
    return 1859775393;
  else if (j3 <= 63)
    return 2400959708;
  else
    return 2840853838;
}
function Kh(j3) {
  if (j3 <= 15)
    return 1352829926;
  else if (j3 <= 31)
    return 1548603684;
  else if (j3 <= 47)
    return 1836072691;
  else if (j3 <= 63)
    return 2053994217;
  else
    return 0;
}
var r = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
var rh = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
var s$1 = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
var sh = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
var utils$4 = utils$d;
var assert$1 = minimalisticAssert;
function Hmac(hash2, key3, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash2, key3, enc);
  this.Hash = hash2;
  this.blockSize = hash2.blockSize / 8;
  this.outSize = hash2.outSize / 8;
  this.inner = null;
  this.outer = null;
  this._init(utils$4.toArray(key3, enc));
}
var hmac$2 = Hmac;
Hmac.prototype._init = function init3(key3) {
  if (key3.length > this.blockSize)
    key3 = new this.Hash().update(key3).digest();
  assert$1(key3.length <= this.blockSize);
  for (var i2 = key3.length; i2 < this.blockSize; i2++)
    key3.push(0);
  for (i2 = 0; i2 < key3.length; i2++)
    key3[i2] ^= 54;
  this.inner = new this.Hash().update(key3);
  for (i2 = 0; i2 < key3.length; i2++)
    key3[i2] ^= 106;
  this.outer = new this.Hash().update(key3);
};
Hmac.prototype.update = function update3(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};
Hmac.prototype.digest = function digest9(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};
(function(exports) {
  var hash2 = exports;
  hash2.utils = utils$d;
  hash2.common = common$6;
  hash2.sha = sha$1;
  hash2.ripemd = ripemd;
  hash2.hmac = hmac$2;
  hash2.sha1 = hash2.sha.sha1;
  hash2.sha256 = hash2.sha.sha256;
  hash2.sha224 = hash2.sha.sha224;
  hash2.sha384 = hash2.sha.sha384;
  hash2.sha512 = hash2.sha.sha512;
  hash2.ripemd160 = hash2.ripemd.ripemd160;
})(hash$4);
var hash$3 = getDefaultExportFromCjs(hash$4);
var utils$3 = {};
(function(exports) {
  var utils2 = exports;
  function toArray2(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== "string") {
      for (var i2 = 0; i2 < msg.length; i2++)
        res[i2] = msg[i2] | 0;
      return res;
    }
    if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (var i2 = 0; i2 < msg.length; i2 += 2)
        res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
    } else {
      for (var i2 = 0; i2 < msg.length; i2++) {
        var c3 = msg.charCodeAt(i2);
        var hi = c3 >> 8;
        var lo = c3 & 255;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    }
    return res;
  }
  utils2.toArray = toArray2;
  function zero22(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  utils2.zero2 = zero22;
  function toHex2(msg) {
    var res = "";
    for (var i2 = 0; i2 < msg.length; i2++)
      res += zero22(msg[i2].toString(16));
    return res;
  }
  utils2.toHex = toHex2;
  utils2.encode = function encode7(arr, enc) {
    if (enc === "hex")
      return toHex2(arr);
    else
      return arr;
  };
})(utils$3);
var hash$2 = hash$4;
var utils$2 = utils$3;
var assert = minimalisticAssert;
function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils$2.toArray(options.entropy, options.entropyEnc || "hex");
  var nonce = utils$2.toArray(options.nonce, options.nonceEnc || "hex");
  var pers = utils$2.toArray(options.pers, options.persEnc || "hex");
  assert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
  this._init(entropy, nonce, pers);
}
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init = function init4(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i2 = 0; i2 < this.V.length; i2++) {
    this.K[i2] = 0;
    this.V[i2] = 1;
  }
  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 281474976710656;
};
HmacDRBG.prototype._hmac = function hmac2() {
  return new hash$2.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function update4(seed) {
  var kmac = this._hmac().update(this.V).update([0]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;
  this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
};
HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add2, addEnc) {
  if (typeof entropyEnc !== "string") {
    addEnc = add2;
    add2 = entropyEnc;
    entropyEnc = null;
  }
  entropy = utils$2.toArray(entropy, entropyEnc);
  add2 = utils$2.toArray(add2, addEnc);
  assert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
  this._update(entropy.concat(add2 || []));
  this._reseed = 1;
};
HmacDRBG.prototype.generate = function generate(len2, enc, add2, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  if (typeof enc !== "string") {
    addEnc = add2;
    add2 = enc;
    enc = null;
  }
  if (add2) {
    add2 = utils$2.toArray(add2, addEnc || "hex");
    this._update(add2);
  }
  var temp = [];
  while (temp.length < len2) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }
  var res = temp.slice(0, len2);
  this._update(add2);
  this._reseed++;
  return utils$2.encode(res, enc);
};
var HmacDrgb = getDefaultExportFromCjs(hmacDrbg);
var createPrng = function createPrng2(seed) {
  var hmacDrgb = new HmacDrgb({ hash: hash$3.sha256, entropy: util$b.binary.hex.encode(seed), nonce: null, pers: null });
  return { getBytesSync: function getBytesSync(size) {
    var bytesArray = hmacDrgb.generate(size);
    var bytes = new Uint8Array(bytesArray);
    return util$b.binary.raw.encode(bytes);
  } };
};
var refCount = 0;
var globalWorker;
var restore = function restore4() {
  refCount -= 1;
  if (refCount <= 0 && globalWorker) {
    Worker = globalWorker;
  }
};
var disableWorker = function disableWorker2() {
  refCount += 1;
  if (typeof Worker === "undefined") {
    return restore;
  }
  globalWorker = Worker;
  Worker = void 0;
  return restore;
};
var forgeGenerateKeyPair = pify$1(rsa$2.generateKeyPair);
var defaultParams$1 = { modulusLength: 2048, publicExponent: 65537, method: "PRIMEINC" };
var parseForgePrivateKey = function parseForgePrivateKey2(privateKey) {
  var n2 = privateKey.n, e2 = privateKey.e, d2 = privateKey.d, p2 = privateKey.p, q3 = privateKey.q, dP = privateKey.dP, dQ = privateKey.dQ, qInv = privateKey.qInv;
  return { modulus: new Uint8Array(n2.toByteArray()), publicExponent: e2.intValue(), privateExponent: new Uint8Array(d2.toByteArray()), prime1: new Uint8Array(p2.toByteArray()), prime2: new Uint8Array(q3.toByteArray()), exponent1: new Uint8Array(dP.toByteArray()), exponent2: new Uint8Array(dQ.toByteArray()), coefficient: new Uint8Array(qInv.toByteArray()) };
};
var parseForgePublicKey = function parseForgePublicKey2(publicKey) {
  var n2 = publicKey.n, e2 = publicKey.e;
  return { modulus: new Uint8Array(n2.toByteArray()), publicExponent: e2.intValue() };
};
var generateKeyPair$5 = function() {
  var _ref49 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee47(params, seed) {
    var modulusLength, publicExponent, method, restoreWorker, _yield$forgeGenerateK, privateKey, publicKey;
    return _regeneratorRuntime().wrap(function _callee47$(_context48) {
      while (1)
        switch (_context48.prev = _context48.next) {
          case 0:
            modulusLength = params.modulusLength, publicExponent = params.publicExponent, method = params.method;
            restoreWorker = disableWorker();
            _context48.next = 4;
            return forgeGenerateKeyPair(modulusLength, publicExponent, { prng: createPrng(seed), algorithm: method });
          case 4:
            _yield$forgeGenerateK = _context48.sent;
            privateKey = _yield$forgeGenerateK.privateKey;
            publicKey = _yield$forgeGenerateK.publicKey;
            restoreWorker();
            return _context48.abrupt("return", { privateKey: parseForgePrivateKey(privateKey), publicKey: parseForgePublicKey(publicKey) });
          case 9:
          case "end":
            return _context48.stop();
        }
    }, _callee47);
  }));
  return function generateKeyPair$52(_x69, _x70) {
    return _ref49.apply(this, arguments);
  };
}();
var rsa = Object.freeze(Object.defineProperty({ __proto__: null, defaultParams: defaultParams$1, generateKeyPair: generateKeyPair$5 }, Symbol.toStringTag, { value: "Module" }));
var forge$u = forge$R;
if (typeof BigInteger$4 === "undefined") {
  BigInteger$4 = forge$u.jsbn.BigInteger;
}
var BigInteger$4;
var ByteBuffer$1 = forge$u.util.ByteBuffer;
var NativeBuffer$1 = typeof Buffer === "undefined" ? Uint8Array : Buffer;
forge$u.pki = forge$u.pki || {};
var ed25519_1 = forge$u.pki.ed25519 = forge$u.ed25519 = forge$u.ed25519 || {};
var ed25519$3 = forge$u.ed25519;
ed25519$3.constants = {};
ed25519$3.constants.PUBLIC_KEY_BYTE_LENGTH = 32;
ed25519$3.constants.PRIVATE_KEY_BYTE_LENGTH = 64;
ed25519$3.constants.SEED_BYTE_LENGTH = 32;
ed25519$3.constants.SIGN_BYTE_LENGTH = 64;
ed25519$3.constants.HASH_BYTE_LENGTH = 64;
ed25519$3.generateKeyPair = function(options) {
  options = options || {};
  var seed = options.seed;
  if (seed === void 0) {
    seed = forge$u.random.getBytesSync(ed25519$3.constants.SEED_BYTE_LENGTH);
  } else if (typeof seed === "string") {
    if (seed.length !== ed25519$3.constants.SEED_BYTE_LENGTH) {
      throw new TypeError('"seed" must be ' + ed25519$3.constants.SEED_BYTE_LENGTH + " bytes in length.");
    }
  } else if (!(seed instanceof Uint8Array)) {
    throw new TypeError('"seed" must be a node.js Buffer, Uint8Array, or a binary string.');
  }
  seed = messageToNativeBuffer$1({ message: seed, encoding: "binary" });
  var pk = new NativeBuffer$1(ed25519$3.constants.PUBLIC_KEY_BYTE_LENGTH);
  var sk = new NativeBuffer$1(ed25519$3.constants.PRIVATE_KEY_BYTE_LENGTH);
  for (var i2 = 0; i2 < 32; ++i2) {
    sk[i2] = seed[i2];
  }
  crypto_sign_keypair$1(pk, sk);
  return { publicKey: pk, privateKey: sk };
};
ed25519$3.publicKeyFromPrivateKey = function(options) {
  options = options || {};
  var privateKey = messageToNativeBuffer$1({ message: options.privateKey, encoding: "binary" });
  if (privateKey.length !== ed25519$3.constants.PRIVATE_KEY_BYTE_LENGTH) {
    throw new TypeError('"options.privateKey" must have a byte length of ' + ed25519$3.constants.PRIVATE_KEY_BYTE_LENGTH);
  }
  var pk = new NativeBuffer$1(ed25519$3.constants.PUBLIC_KEY_BYTE_LENGTH);
  for (var i2 = 0; i2 < pk.length; ++i2) {
    pk[i2] = privateKey[32 + i2];
  }
  return pk;
};
ed25519$3.sign = function(options) {
  options = options || {};
  var msg = messageToNativeBuffer$1(options);
  var privateKey = messageToNativeBuffer$1({ message: options.privateKey, encoding: "binary" });
  if (privateKey.length !== ed25519$3.constants.PRIVATE_KEY_BYTE_LENGTH) {
    throw new TypeError('"options.privateKey" must have a byte length of ' + ed25519$3.constants.PRIVATE_KEY_BYTE_LENGTH);
  }
  var signedMsg = new NativeBuffer$1(ed25519$3.constants.SIGN_BYTE_LENGTH + msg.length);
  crypto_sign$1(signedMsg, msg, msg.length, privateKey);
  var sig = new NativeBuffer$1(ed25519$3.constants.SIGN_BYTE_LENGTH);
  for (var i2 = 0; i2 < sig.length; ++i2) {
    sig[i2] = signedMsg[i2];
  }
  return sig;
};
ed25519$3.verify = function(options) {
  options = options || {};
  var msg = messageToNativeBuffer$1(options);
  if (options.signature === void 0) {
    throw new TypeError('"options.signature" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.');
  }
  var sig = messageToNativeBuffer$1({ message: options.signature, encoding: "binary" });
  if (sig.length !== ed25519$3.constants.SIGN_BYTE_LENGTH) {
    throw new TypeError('"options.signature" must have a byte length of ' + ed25519$3.constants.SIGN_BYTE_LENGTH);
  }
  var publicKey = messageToNativeBuffer$1({ message: options.publicKey, encoding: "binary" });
  if (publicKey.length !== ed25519$3.constants.PUBLIC_KEY_BYTE_LENGTH) {
    throw new TypeError('"options.publicKey" must have a byte length of ' + ed25519$3.constants.PUBLIC_KEY_BYTE_LENGTH);
  }
  var sm = new NativeBuffer$1(ed25519$3.constants.SIGN_BYTE_LENGTH + msg.length);
  var m2 = new NativeBuffer$1(ed25519$3.constants.SIGN_BYTE_LENGTH + msg.length);
  var i2;
  for (i2 = 0; i2 < ed25519$3.constants.SIGN_BYTE_LENGTH; ++i2) {
    sm[i2] = sig[i2];
  }
  for (i2 = 0; i2 < msg.length; ++i2) {
    sm[i2 + ed25519$3.constants.SIGN_BYTE_LENGTH] = msg[i2];
  }
  return crypto_sign_open$1(m2, sm, sm.length, publicKey) >= 0;
};
function messageToNativeBuffer$1(options) {
  var message = options.message;
  if (message instanceof Uint8Array) {
    return message;
  }
  var encoding = options.encoding;
  if (message === void 0) {
    if (options.md) {
      message = options.md.digest().getBytes();
      encoding = "binary";
    } else {
      throw new TypeError('"options.message" or "options.md" not specified.');
    }
  }
  if (typeof message === "string" && !encoding) {
    throw new TypeError('"options.encoding" must be "binary" or "utf8".');
  }
  if (typeof message === "string") {
    if (typeof Buffer !== "undefined") {
      return Buffer.from(message, encoding);
    }
    message = new ByteBuffer$1(message, encoding);
  } else if (!(message instanceof ByteBuffer$1)) {
    throw new TypeError('"options.message" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with "options.encoding" specifying its encoding.');
  }
  var buffer2 = new NativeBuffer$1(message.length());
  for (var i2 = 0; i2 < buffer2.length; ++i2) {
    buffer2[i2] = message.at(i2);
  }
  return buffer2;
}
var gf0$1 = gf$1();
var gf1$1 = gf$1([1]);
var D$1 = gf$1([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]);
var D2$1 = gf$1([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]);
var X$2 = gf$1([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]);
var Y$1 = gf$1([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]);
var L$1 = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
var I$2 = gf$1([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
function sha512$3(msg, msgLen) {
  var md = forge$u.md.sha512.create();
  var buffer2 = new ByteBuffer$1(msg);
  md.update(buffer2.getBytes(msgLen), "binary");
  var hash2 = md.digest().getBytes();
  if (typeof Buffer !== "undefined") {
    return Buffer.from(hash2, "binary");
  }
  var out = new NativeBuffer$1(ed25519$3.constants.HASH_BYTE_LENGTH);
  for (var i2 = 0; i2 < 64; ++i2) {
    out[i2] = hash2.charCodeAt(i2);
  }
  return out;
}
function crypto_sign_keypair$1(pk, sk) {
  var p2 = [gf$1(), gf$1(), gf$1(), gf$1()];
  var i2;
  var d2 = sha512$3(sk, 32);
  d2[0] &= 248;
  d2[31] &= 127;
  d2[31] |= 64;
  scalarbase$1(p2, d2);
  pack$1(pk, p2);
  for (i2 = 0; i2 < 32; ++i2) {
    sk[i2 + 32] = pk[i2];
  }
  return 0;
}
function crypto_sign$1(sm, m2, n2, sk) {
  var i2, j3, x2 = new Float64Array(64);
  var p2 = [gf$1(), gf$1(), gf$1(), gf$1()];
  var d2 = sha512$3(sk, 32);
  d2[0] &= 248;
  d2[31] &= 127;
  d2[31] |= 64;
  var smlen = n2 + 64;
  for (i2 = 0; i2 < n2; ++i2) {
    sm[64 + i2] = m2[i2];
  }
  for (i2 = 0; i2 < 32; ++i2) {
    sm[32 + i2] = d2[32 + i2];
  }
  var r2 = sha512$3(sm.subarray(32), n2 + 32);
  reduce$1(r2);
  scalarbase$1(p2, r2);
  pack$1(sm, p2);
  for (i2 = 32; i2 < 64; ++i2) {
    sm[i2] = sk[i2];
  }
  var h2 = sha512$3(sm, n2 + 64);
  reduce$1(h2);
  for (i2 = 32; i2 < 64; ++i2) {
    x2[i2] = 0;
  }
  for (i2 = 0; i2 < 32; ++i2) {
    x2[i2] = r2[i2];
  }
  for (i2 = 0; i2 < 32; ++i2) {
    for (j3 = 0; j3 < 32; j3++) {
      x2[i2 + j3] += h2[i2] * d2[j3];
    }
  }
  modL$1(sm.subarray(32), x2);
  return smlen;
}
function crypto_sign_open$1(m2, sm, n2, pk) {
  var i2, mlen;
  var t2 = new NativeBuffer$1(32);
  var p2 = [gf$1(), gf$1(), gf$1(), gf$1()], q3 = [gf$1(), gf$1(), gf$1(), gf$1()];
  mlen = -1;
  if (n2 < 64) {
    return -1;
  }
  if (unpackneg$1(q3, pk)) {
    return -1;
  }
  for (i2 = 0; i2 < n2; ++i2) {
    m2[i2] = sm[i2];
  }
  for (i2 = 0; i2 < 32; ++i2) {
    m2[i2 + 32] = pk[i2];
  }
  var h2 = sha512$3(m2, n2);
  reduce$1(h2);
  scalarmult$1(p2, q3, h2);
  scalarbase$1(q3, sm.subarray(32));
  add$1(p2, q3);
  pack$1(t2, p2);
  n2 -= 64;
  if (crypto_verify_32$1(sm, 0, t2, 0)) {
    for (i2 = 0; i2 < n2; ++i2) {
      m2[i2] = 0;
    }
    return -1;
  }
  for (i2 = 0; i2 < n2; ++i2) {
    m2[i2] = sm[i2 + 64];
  }
  mlen = n2;
  return mlen;
}
function modL$1(r2, x2) {
  var carry, i2, j3, k3;
  for (i2 = 63; i2 >= 32; --i2) {
    carry = 0;
    for (j3 = i2 - 32, k3 = i2 - 12; j3 < k3; ++j3) {
      x2[j3] += carry - 16 * x2[i2] * L$1[j3 - (i2 - 32)];
      carry = x2[j3] + 128 >> 8;
      x2[j3] -= carry * 256;
    }
    x2[j3] += carry;
    x2[i2] = 0;
  }
  carry = 0;
  for (j3 = 0; j3 < 32; ++j3) {
    x2[j3] += carry - (x2[31] >> 4) * L$1[j3];
    carry = x2[j3] >> 8;
    x2[j3] &= 255;
  }
  for (j3 = 0; j3 < 32; ++j3) {
    x2[j3] -= carry * L$1[j3];
  }
  for (i2 = 0; i2 < 32; ++i2) {
    x2[i2 + 1] += x2[i2] >> 8;
    r2[i2] = x2[i2] & 255;
  }
}
function reduce$1(r2) {
  var x2 = new Float64Array(64);
  for (var i2 = 0; i2 < 64; ++i2) {
    x2[i2] = r2[i2];
    r2[i2] = 0;
  }
  modL$1(r2, x2);
}
function add$1(p2, q3) {
  var a2 = gf$1(), b3 = gf$1(), c3 = gf$1(), d2 = gf$1(), e2 = gf$1(), f2 = gf$1(), g2 = gf$1(), h2 = gf$1(), t2 = gf$1();
  Z$2(a2, p2[1], p2[0]);
  Z$2(t2, q3[1], q3[0]);
  M$2(a2, a2, t2);
  A$1(b3, p2[0], p2[1]);
  A$1(t2, q3[0], q3[1]);
  M$2(b3, b3, t2);
  M$2(c3, p2[3], q3[3]);
  M$2(c3, c3, D2$1);
  M$2(d2, p2[2], q3[2]);
  A$1(d2, d2, d2);
  Z$2(e2, b3, a2);
  Z$2(f2, d2, c3);
  A$1(g2, d2, c3);
  A$1(h2, b3, a2);
  M$2(p2[0], e2, f2);
  M$2(p2[1], h2, g2);
  M$2(p2[2], g2, f2);
  M$2(p2[3], e2, h2);
}
function cswap$1(p2, q3, b3) {
  for (var i2 = 0; i2 < 4; ++i2) {
    sel25519$1(p2[i2], q3[i2], b3);
  }
}
function pack$1(r2, p2) {
  var tx = gf$1(), ty = gf$1(), zi = gf$1();
  inv25519$1(zi, p2[2]);
  M$2(tx, p2[0], zi);
  M$2(ty, p2[1], zi);
  pack25519$1(r2, ty);
  r2[31] ^= par25519$1(tx) << 7;
}
function pack25519$1(o2, n2) {
  var i2, j3, b3;
  var m2 = gf$1(), t2 = gf$1();
  for (i2 = 0; i2 < 16; ++i2) {
    t2[i2] = n2[i2];
  }
  car25519$1(t2);
  car25519$1(t2);
  car25519$1(t2);
  for (j3 = 0; j3 < 2; ++j3) {
    m2[0] = t2[0] - 65517;
    for (i2 = 1; i2 < 15; ++i2) {
      m2[i2] = t2[i2] - 65535 - (m2[i2 - 1] >> 16 & 1);
      m2[i2 - 1] &= 65535;
    }
    m2[15] = t2[15] - 32767 - (m2[14] >> 16 & 1);
    b3 = m2[15] >> 16 & 1;
    m2[14] &= 65535;
    sel25519$1(t2, m2, 1 - b3);
  }
  for (i2 = 0; i2 < 16; i2++) {
    o2[2 * i2] = t2[i2] & 255;
    o2[2 * i2 + 1] = t2[i2] >> 8;
  }
}
function unpackneg$1(r2, p2) {
  var t2 = gf$1(), chk = gf$1(), num = gf$1(), den = gf$1(), den2 = gf$1(), den4 = gf$1(), den6 = gf$1();
  set25519$1(r2[2], gf1$1);
  unpack25519$1(r2[1], p2);
  S$1(num, r2[1]);
  M$2(den, num, D$1);
  Z$2(num, num, r2[2]);
  A$1(den, r2[2], den);
  S$1(den2, den);
  S$1(den4, den2);
  M$2(den6, den4, den2);
  M$2(t2, den6, num);
  M$2(t2, t2, den);
  pow2523$1(t2, t2);
  M$2(t2, t2, num);
  M$2(t2, t2, den);
  M$2(t2, t2, den);
  M$2(r2[0], t2, den);
  S$1(chk, r2[0]);
  M$2(chk, chk, den);
  if (neq25519$1(chk, num)) {
    M$2(r2[0], r2[0], I$2);
  }
  S$1(chk, r2[0]);
  M$2(chk, chk, den);
  if (neq25519$1(chk, num)) {
    return -1;
  }
  if (par25519$1(r2[0]) === p2[31] >> 7) {
    Z$2(r2[0], gf0$1, r2[0]);
  }
  M$2(r2[3], r2[0], r2[1]);
  return 0;
}
function unpack25519$1(o2, n2) {
  var i2;
  for (i2 = 0; i2 < 16; ++i2) {
    o2[i2] = n2[2 * i2] + (n2[2 * i2 + 1] << 8);
  }
  o2[15] &= 32767;
}
function pow2523$1(o2, i2) {
  var c3 = gf$1();
  var a2;
  for (a2 = 0; a2 < 16; ++a2) {
    c3[a2] = i2[a2];
  }
  for (a2 = 250; a2 >= 0; --a2) {
    S$1(c3, c3);
    if (a2 !== 1) {
      M$2(c3, c3, i2);
    }
  }
  for (a2 = 0; a2 < 16; ++a2) {
    o2[a2] = c3[a2];
  }
}
function neq25519$1(a2, b3) {
  var c3 = new NativeBuffer$1(32);
  var d2 = new NativeBuffer$1(32);
  pack25519$1(c3, a2);
  pack25519$1(d2, b3);
  return crypto_verify_32$1(c3, 0, d2, 0);
}
function crypto_verify_32$1(x2, xi, y3, yi) {
  return vn$1(x2, xi, y3, yi, 32);
}
function vn$1(x2, xi, y3, yi, n2) {
  var i2, d2 = 0;
  for (i2 = 0; i2 < n2; ++i2) {
    d2 |= x2[xi + i2] ^ y3[yi + i2];
  }
  return (1 & d2 - 1 >>> 8) - 1;
}
function par25519$1(a2) {
  var d2 = new NativeBuffer$1(32);
  pack25519$1(d2, a2);
  return d2[0] & 1;
}
function scalarmult$1(p2, q3, s2) {
  var b3, i2;
  set25519$1(p2[0], gf0$1);
  set25519$1(p2[1], gf1$1);
  set25519$1(p2[2], gf1$1);
  set25519$1(p2[3], gf0$1);
  for (i2 = 255; i2 >= 0; --i2) {
    b3 = s2[i2 / 8 | 0] >> (i2 & 7) & 1;
    cswap$1(p2, q3, b3);
    add$1(q3, p2);
    add$1(p2, p2);
    cswap$1(p2, q3, b3);
  }
}
function scalarbase$1(p2, s2) {
  var q3 = [gf$1(), gf$1(), gf$1(), gf$1()];
  set25519$1(q3[0], X$2);
  set25519$1(q3[1], Y$1);
  set25519$1(q3[2], gf1$1);
  M$2(q3[3], X$2, Y$1);
  scalarmult$1(p2, q3, s2);
}
function set25519$1(r2, a2) {
  var i2;
  for (i2 = 0; i2 < 16; i2++) {
    r2[i2] = a2[i2] | 0;
  }
}
function inv25519$1(o2, i2) {
  var c3 = gf$1();
  var a2;
  for (a2 = 0; a2 < 16; ++a2) {
    c3[a2] = i2[a2];
  }
  for (a2 = 253; a2 >= 0; --a2) {
    S$1(c3, c3);
    if (a2 !== 2 && a2 !== 4) {
      M$2(c3, c3, i2);
    }
  }
  for (a2 = 0; a2 < 16; ++a2) {
    o2[a2] = c3[a2];
  }
}
function car25519$1(o2) {
  var i2, v2, c3 = 1;
  for (i2 = 0; i2 < 16; ++i2) {
    v2 = o2[i2] + c3 + 65535;
    c3 = Math.floor(v2 / 65536);
    o2[i2] = v2 - c3 * 65536;
  }
  o2[0] += c3 - 1 + 37 * (c3 - 1);
}
function sel25519$1(p2, q3, b3) {
  var t2, c3 = ~(b3 - 1);
  for (var i2 = 0; i2 < 16; ++i2) {
    t2 = c3 & (p2[i2] ^ q3[i2]);
    p2[i2] ^= t2;
    q3[i2] ^= t2;
  }
}
function gf$1(init5) {
  var i2, r2 = new Float64Array(16);
  if (init5) {
    for (i2 = 0; i2 < init5.length; ++i2) {
      r2[i2] = init5[i2];
    }
  }
  return r2;
}
function A$1(o2, a2, b3) {
  for (var i2 = 0; i2 < 16; ++i2) {
    o2[i2] = a2[i2] + b3[i2];
  }
}
function Z$2(o2, a2, b3) {
  for (var i2 = 0; i2 < 16; ++i2) {
    o2[i2] = a2[i2] - b3[i2];
  }
}
function S$1(o2, a2) {
  M$2(o2, a2, a2);
}
function M$2(o2, a2, b3) {
  var v2, c3, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b3[0], b1 = b3[1], b22 = b3[2], b32 = b3[3], b4 = b3[4], b5 = b3[5], b6 = b3[6], b7 = b3[7], b8 = b3[8], b9 = b3[9], b10 = b3[10], b11 = b3[11], b12 = b3[12], b13 = b3[13], b14 = b3[14], b15 = b3[15];
  v2 = a2[0];
  t0 += v2 * b0;
  t1 += v2 * b1;
  t2 += v2 * b22;
  t3 += v2 * b32;
  t4 += v2 * b4;
  t5 += v2 * b5;
  t6 += v2 * b6;
  t7 += v2 * b7;
  t8 += v2 * b8;
  t9 += v2 * b9;
  t10 += v2 * b10;
  t11 += v2 * b11;
  t12 += v2 * b12;
  t13 += v2 * b13;
  t14 += v2 * b14;
  t15 += v2 * b15;
  v2 = a2[1];
  t1 += v2 * b0;
  t2 += v2 * b1;
  t3 += v2 * b22;
  t4 += v2 * b32;
  t5 += v2 * b4;
  t6 += v2 * b5;
  t7 += v2 * b6;
  t8 += v2 * b7;
  t9 += v2 * b8;
  t10 += v2 * b9;
  t11 += v2 * b10;
  t12 += v2 * b11;
  t13 += v2 * b12;
  t14 += v2 * b13;
  t15 += v2 * b14;
  t16 += v2 * b15;
  v2 = a2[2];
  t2 += v2 * b0;
  t3 += v2 * b1;
  t4 += v2 * b22;
  t5 += v2 * b32;
  t6 += v2 * b4;
  t7 += v2 * b5;
  t8 += v2 * b6;
  t9 += v2 * b7;
  t10 += v2 * b8;
  t11 += v2 * b9;
  t12 += v2 * b10;
  t13 += v2 * b11;
  t14 += v2 * b12;
  t15 += v2 * b13;
  t16 += v2 * b14;
  t17 += v2 * b15;
  v2 = a2[3];
  t3 += v2 * b0;
  t4 += v2 * b1;
  t5 += v2 * b22;
  t6 += v2 * b32;
  t7 += v2 * b4;
  t8 += v2 * b5;
  t9 += v2 * b6;
  t10 += v2 * b7;
  t11 += v2 * b8;
  t12 += v2 * b9;
  t13 += v2 * b10;
  t14 += v2 * b11;
  t15 += v2 * b12;
  t16 += v2 * b13;
  t17 += v2 * b14;
  t18 += v2 * b15;
  v2 = a2[4];
  t4 += v2 * b0;
  t5 += v2 * b1;
  t6 += v2 * b22;
  t7 += v2 * b32;
  t8 += v2 * b4;
  t9 += v2 * b5;
  t10 += v2 * b6;
  t11 += v2 * b7;
  t12 += v2 * b8;
  t13 += v2 * b9;
  t14 += v2 * b10;
  t15 += v2 * b11;
  t16 += v2 * b12;
  t17 += v2 * b13;
  t18 += v2 * b14;
  t19 += v2 * b15;
  v2 = a2[5];
  t5 += v2 * b0;
  t6 += v2 * b1;
  t7 += v2 * b22;
  t8 += v2 * b32;
  t9 += v2 * b4;
  t10 += v2 * b5;
  t11 += v2 * b6;
  t12 += v2 * b7;
  t13 += v2 * b8;
  t14 += v2 * b9;
  t15 += v2 * b10;
  t16 += v2 * b11;
  t17 += v2 * b12;
  t18 += v2 * b13;
  t19 += v2 * b14;
  t20 += v2 * b15;
  v2 = a2[6];
  t6 += v2 * b0;
  t7 += v2 * b1;
  t8 += v2 * b22;
  t9 += v2 * b32;
  t10 += v2 * b4;
  t11 += v2 * b5;
  t12 += v2 * b6;
  t13 += v2 * b7;
  t14 += v2 * b8;
  t15 += v2 * b9;
  t16 += v2 * b10;
  t17 += v2 * b11;
  t18 += v2 * b12;
  t19 += v2 * b13;
  t20 += v2 * b14;
  t21 += v2 * b15;
  v2 = a2[7];
  t7 += v2 * b0;
  t8 += v2 * b1;
  t9 += v2 * b22;
  t10 += v2 * b32;
  t11 += v2 * b4;
  t12 += v2 * b5;
  t13 += v2 * b6;
  t14 += v2 * b7;
  t15 += v2 * b8;
  t16 += v2 * b9;
  t17 += v2 * b10;
  t18 += v2 * b11;
  t19 += v2 * b12;
  t20 += v2 * b13;
  t21 += v2 * b14;
  t22 += v2 * b15;
  v2 = a2[8];
  t8 += v2 * b0;
  t9 += v2 * b1;
  t10 += v2 * b22;
  t11 += v2 * b32;
  t12 += v2 * b4;
  t13 += v2 * b5;
  t14 += v2 * b6;
  t15 += v2 * b7;
  t16 += v2 * b8;
  t17 += v2 * b9;
  t18 += v2 * b10;
  t19 += v2 * b11;
  t20 += v2 * b12;
  t21 += v2 * b13;
  t22 += v2 * b14;
  t23 += v2 * b15;
  v2 = a2[9];
  t9 += v2 * b0;
  t10 += v2 * b1;
  t11 += v2 * b22;
  t12 += v2 * b32;
  t13 += v2 * b4;
  t14 += v2 * b5;
  t15 += v2 * b6;
  t16 += v2 * b7;
  t17 += v2 * b8;
  t18 += v2 * b9;
  t19 += v2 * b10;
  t20 += v2 * b11;
  t21 += v2 * b12;
  t22 += v2 * b13;
  t23 += v2 * b14;
  t24 += v2 * b15;
  v2 = a2[10];
  t10 += v2 * b0;
  t11 += v2 * b1;
  t12 += v2 * b22;
  t13 += v2 * b32;
  t14 += v2 * b4;
  t15 += v2 * b5;
  t16 += v2 * b6;
  t17 += v2 * b7;
  t18 += v2 * b8;
  t19 += v2 * b9;
  t20 += v2 * b10;
  t21 += v2 * b11;
  t22 += v2 * b12;
  t23 += v2 * b13;
  t24 += v2 * b14;
  t25 += v2 * b15;
  v2 = a2[11];
  t11 += v2 * b0;
  t12 += v2 * b1;
  t13 += v2 * b22;
  t14 += v2 * b32;
  t15 += v2 * b4;
  t16 += v2 * b5;
  t17 += v2 * b6;
  t18 += v2 * b7;
  t19 += v2 * b8;
  t20 += v2 * b9;
  t21 += v2 * b10;
  t22 += v2 * b11;
  t23 += v2 * b12;
  t24 += v2 * b13;
  t25 += v2 * b14;
  t26 += v2 * b15;
  v2 = a2[12];
  t12 += v2 * b0;
  t13 += v2 * b1;
  t14 += v2 * b22;
  t15 += v2 * b32;
  t16 += v2 * b4;
  t17 += v2 * b5;
  t18 += v2 * b6;
  t19 += v2 * b7;
  t20 += v2 * b8;
  t21 += v2 * b9;
  t22 += v2 * b10;
  t23 += v2 * b11;
  t24 += v2 * b12;
  t25 += v2 * b13;
  t26 += v2 * b14;
  t27 += v2 * b15;
  v2 = a2[13];
  t13 += v2 * b0;
  t14 += v2 * b1;
  t15 += v2 * b22;
  t16 += v2 * b32;
  t17 += v2 * b4;
  t18 += v2 * b5;
  t19 += v2 * b6;
  t20 += v2 * b7;
  t21 += v2 * b8;
  t22 += v2 * b9;
  t23 += v2 * b10;
  t24 += v2 * b11;
  t25 += v2 * b12;
  t26 += v2 * b13;
  t27 += v2 * b14;
  t28 += v2 * b15;
  v2 = a2[14];
  t14 += v2 * b0;
  t15 += v2 * b1;
  t16 += v2 * b22;
  t17 += v2 * b32;
  t18 += v2 * b4;
  t19 += v2 * b5;
  t20 += v2 * b6;
  t21 += v2 * b7;
  t22 += v2 * b8;
  t23 += v2 * b9;
  t24 += v2 * b10;
  t25 += v2 * b11;
  t26 += v2 * b12;
  t27 += v2 * b13;
  t28 += v2 * b14;
  t29 += v2 * b15;
  v2 = a2[15];
  t15 += v2 * b0;
  t16 += v2 * b1;
  t17 += v2 * b22;
  t18 += v2 * b32;
  t19 += v2 * b4;
  t20 += v2 * b5;
  t21 += v2 * b6;
  t22 += v2 * b7;
  t23 += v2 * b8;
  t24 += v2 * b9;
  t25 += v2 * b10;
  t26 += v2 * b11;
  t27 += v2 * b12;
  t28 += v2 * b13;
  t29 += v2 * b14;
  t30 += v2 * b15;
  t0 += 38 * t16;
  t1 += 38 * t17;
  t2 += 38 * t18;
  t3 += 38 * t19;
  t4 += 38 * t20;
  t5 += 38 * t21;
  t6 += 38 * t22;
  t7 += 38 * t23;
  t8 += 38 * t24;
  t9 += 38 * t25;
  t10 += 38 * t26;
  t11 += 38 * t27;
  t12 += 38 * t28;
  t13 += 38 * t29;
  t14 += 38 * t30;
  c3 = 1;
  v2 = t0 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t0 = v2 - c3 * 65536;
  v2 = t1 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t1 = v2 - c3 * 65536;
  v2 = t2 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t2 = v2 - c3 * 65536;
  v2 = t3 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t3 = v2 - c3 * 65536;
  v2 = t4 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t4 = v2 - c3 * 65536;
  v2 = t5 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t5 = v2 - c3 * 65536;
  v2 = t6 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t6 = v2 - c3 * 65536;
  v2 = t7 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t7 = v2 - c3 * 65536;
  v2 = t8 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t8 = v2 - c3 * 65536;
  v2 = t9 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t9 = v2 - c3 * 65536;
  v2 = t10 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t10 = v2 - c3 * 65536;
  v2 = t11 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t11 = v2 - c3 * 65536;
  v2 = t12 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t12 = v2 - c3 * 65536;
  v2 = t13 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t13 = v2 - c3 * 65536;
  v2 = t14 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t14 = v2 - c3 * 65536;
  v2 = t15 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t15 = v2 - c3 * 65536;
  t0 += c3 - 1 + 37 * (c3 - 1);
  c3 = 1;
  v2 = t0 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t0 = v2 - c3 * 65536;
  v2 = t1 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t1 = v2 - c3 * 65536;
  v2 = t2 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t2 = v2 - c3 * 65536;
  v2 = t3 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t3 = v2 - c3 * 65536;
  v2 = t4 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t4 = v2 - c3 * 65536;
  v2 = t5 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t5 = v2 - c3 * 65536;
  v2 = t6 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t6 = v2 - c3 * 65536;
  v2 = t7 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t7 = v2 - c3 * 65536;
  v2 = t8 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t8 = v2 - c3 * 65536;
  v2 = t9 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t9 = v2 - c3 * 65536;
  v2 = t10 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t10 = v2 - c3 * 65536;
  v2 = t11 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t11 = v2 - c3 * 65536;
  v2 = t12 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t12 = v2 - c3 * 65536;
  v2 = t13 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t13 = v2 - c3 * 65536;
  v2 = t14 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t14 = v2 - c3 * 65536;
  v2 = t15 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t15 = v2 - c3 * 65536;
  t0 += c3 - 1 + 37 * (c3 - 1);
  o2[0] = t0;
  o2[1] = t1;
  o2[2] = t2;
  o2[3] = t3;
  o2[4] = t4;
  o2[5] = t5;
  o2[6] = t6;
  o2[7] = t7;
  o2[8] = t8;
  o2[9] = t9;
  o2[10] = t10;
  o2[11] = t11;
  o2[12] = t12;
  o2[13] = t13;
  o2[14] = t14;
  o2[15] = t15;
}
var ed25519$4 = getDefaultExportFromCjs(ed25519_1);
var typedArrayToUint8Array = function typedArrayToUint8Array2(typedArray) {
  return new Uint8Array(typedArray.buffer.slice(typedArray.byteOffset, typedArray.byteOffset + typedArray.byteLength));
};
var defaultParams = {};
var generateKeyPair$4 = function generateKeyPair$42(params, seed) {
  seed = seed.slice(0, 32);
  var _ed25519$4$generateKe = ed25519$4.generateKeyPair({ seed }), publicKey = _ed25519$4$generateKe.publicKey;
  return { privateKey: { seed }, publicKey: { bytes: typedArrayToUint8Array(publicKey) } };
};
var ed25519$2 = Object.freeze(Object.defineProperty({ __proto__: null, defaultParams, generateKeyPair: generateKeyPair$4 }, Symbol.toStringTag, { value: "Module" }));
var BaseError = function(_Error2) {
  function BaseError2(message, code2, props) {
    var _this25;
    _classCallCheck2(this, BaseError2);
    _this25 = _callSuper(this, BaseError2, [message]);
    Object.assign(_this25, _objectSpread(_objectSpread({}, props), {}, { code: code2, name: _this25.constructor.name }));
    if (Error.captureStackTrace) {
      Error.captureStackTrace(_this25, _this25.constructor);
      return _possibleConstructorReturn2(_this25);
    }
    _this25.stack = new Error(message).stack;
    return _this25;
  }
  _inherits2(BaseError2, _Error2);
  return _createClass(BaseError2);
}(_wrapNativeSuper(Error));
var UnknownAlgorithmError = function(_BaseError) {
  function UnknownAlgorithmError2(algorithm) {
    _classCallCheck2(this, UnknownAlgorithmError2);
    return _callSuper(this, UnknownAlgorithmError2, ["Unknown algorithm `".concat(algorithm, "`"), "UNKNOWN_ALGORITHM"]);
  }
  _inherits2(UnknownAlgorithmError2, _BaseError);
  return _createClass(UnknownAlgorithmError2);
}(BaseError);
var UnknownAlgorithmParamError = function(_BaseError2) {
  function UnknownAlgorithmParamError2(param) {
    _classCallCheck2(this, UnknownAlgorithmParamError2);
    return _callSuper(this, UnknownAlgorithmParamError2, ["Unknown algorithm param `".concat(param, "`"), "UNKNOWN_ALGORITHM_PARAM"]);
  }
  _inherits2(UnknownAlgorithmParamError2, _BaseError2);
  return _createClass(UnknownAlgorithmParamError2);
}(BaseError);
var NilAlgorithmParamError = function(_BaseError3) {
  function NilAlgorithmParamError2(param) {
    _classCallCheck2(this, NilAlgorithmParamError2);
    return _callSuper(this, NilAlgorithmParamError2, ["Algorithm param `".concat(param, "` can't be null or undefined"), "NIL_ALGORITHM_PARAM"]);
  }
  _inherits2(NilAlgorithmParamError2, _BaseError3);
  return _createClass(NilAlgorithmParamError2);
}(BaseError);
var TypeMismatchAlgorithmParamError = function(_BaseError4) {
  function TypeMismatchAlgorithmParamError2(param, type) {
    _classCallCheck2(this, TypeMismatchAlgorithmParamError2);
    return _callSuper(this, TypeMismatchAlgorithmParamError2, ["Expected algorithm param `".concat(param, "` to be of type `").concat(type, "`"), "TYPE_ALGORITHM_PARAM"]);
  }
  _inherits2(TypeMismatchAlgorithmParamError2, _BaseError4);
  return _createClass(TypeMismatchAlgorithmParamError2);
}(BaseError);
var supportedAlgorithms = { rsa, ed25519: ed25519$2 };
var buildParams = function buildParams2(defaultParams2, customParams) {
  return Object.keys(customParams).reduce(function(params, key3) {
    if (defaultParams2[key3] == null) {
      throw new UnknownAlgorithmParamError(key3);
    }
    if (customParams[key3] == null) {
      throw new NilAlgorithmParamError(key3);
    }
    if (_typeof(customParams[key3]) !== _typeof(defaultParams2[key3])) {
      throw new TypeMismatchAlgorithmParamError(key3, _typeof(defaultParams2[key3]));
    }
    params[key3] = customParams[key3];
    return params;
  }, _objectSpread({}, defaultParams2));
};
var parseAlgorithm = function parseAlgorithm2(keyAlgorithm) {
  var algorithm = typeof keyAlgorithm === "string" ? { id: keyAlgorithm } : keyAlgorithm;
  var type = supportedAlgorithms[algorithm.id] ? algorithm.id : getKeyTypeFromAlgorithm(algorithm.id);
  if (!type) {
    throw new UnknownAlgorithmError(algorithm.id);
  }
  var _supportedAlgorithms$ = supportedAlgorithms[type], generateKeyPair2 = _supportedAlgorithms$.generateKeyPair, defaultParams2 = _supportedAlgorithms$.defaultParams;
  var id = algorithm.id, customParams = _objectWithoutProperties(algorithm, _excluded4);
  var params = buildParams(defaultParams2, customParams);
  return { id, type, params, generate: generateKeyPair2 };
};
var composeKeys = function composeKeys2(_ref50, keyAlgorithm, options) {
  var privateKey = _ref50.privateKey, publicKey = _ref50.publicKey;
  options = _objectSpread({ privateKeyFormat: "pkcs8-pem", publicKeyFormat: "spki-pem" }, options);
  var _options = options, privateKeyFormat = _options.privateKeyFormat, publicKeyFormat = _options.publicKeyFormat, encryptionAlgorithm = _options.encryptionAlgorithm, password = _options.password;
  return { privateKey: composePrivateKey({ format: privateKeyFormat, keyAlgorithm, keyData: privateKey, encryptionAlgorithm }, { password }), publicKey: composePublicKey({ format: publicKeyFormat, keyAlgorithm, keyData: publicKey }) };
};
var generateKeys = function() {
  var _ref51 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee48(seed, algorithm, options) {
    var _parseAlgorithm, id, params, generate2, keyPair, keyAlgorithm, composedKeyPair;
    return _regeneratorRuntime().wrap(function _callee48$(_context49) {
      while (1)
        switch (_context49.prev = _context49.next) {
          case 0:
            _parseAlgorithm = parseAlgorithm(algorithm), id = _parseAlgorithm.id, params = _parseAlgorithm.params, generate2 = _parseAlgorithm.generate;
            _context49.next = 3;
            return generate2(params, seed);
          case 3:
            keyPair = _context49.sent;
            keyAlgorithm = _objectSpread({ id }, params);
            composedKeyPair = composeKeys(keyPair, keyAlgorithm, options);
            return _context49.abrupt("return", { keyAlgorithm, composedKeyPair });
          case 7:
          case "end":
            return _context49.stop();
        }
    }, _callee48);
  }));
  return function generateKeys2(_x71, _x72, _x73) {
    return _ref51.apply(this, arguments);
  };
}();
var generateKeyPair$3 = function() {
  var _ref52 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee49(algorithm, options) {
    var mnemonic, seedBuffer, seed, _yield$generateKeys, keyAlgorithm, composedKeyPair;
    return _regeneratorRuntime().wrap(function _callee49$(_context50) {
      while (1)
        switch (_context50.prev = _context50.next) {
          case 0:
            mnemonic = generateMnemonic_1();
            _context50.next = 3;
            return mnemonicToSeed_1(mnemonic);
          case 3:
            seedBuffer = _context50.sent;
            seed = new Uint8Array(seedBuffer.buffer);
            _context50.next = 7;
            return generateKeys(seed, algorithm, options);
          case 7:
            _yield$generateKeys = _context50.sent;
            keyAlgorithm = _yield$generateKeys.keyAlgorithm;
            composedKeyPair = _yield$generateKeys.composedKeyPair;
            return _context50.abrupt("return", _objectSpread({ algorithm: keyAlgorithm, mnemonic, seed }, composedKeyPair));
          case 11:
          case "end":
            return _context50.stop();
        }
    }, _callee49);
  }));
  return function generateKeyPair$32(_x74, _x75) {
    return _ref52.apply(this, arguments);
  };
}();
var getKeyPairFromMnemonic = function() {
  var _ref53 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee50(mnemonic, algorithm, options) {
    var seedBuffer, seed;
    return _regeneratorRuntime().wrap(function _callee50$(_context51) {
      while (1)
        switch (_context51.prev = _context51.next) {
          case 0:
            _context51.next = 2;
            return mnemonicToSeed_1(mnemonic);
          case 2:
            seedBuffer = _context51.sent;
            seed = new Uint8Array(seedBuffer.buffer);
            return _context51.abrupt("return", getKeyPairFromSeed(seed, algorithm, options));
          case 5:
          case "end":
            return _context51.stop();
        }
    }, _callee50);
  }));
  return function getKeyPairFromMnemonic2(_x76, _x77, _x78) {
    return _ref53.apply(this, arguments);
  };
}();
var getKeyPairFromSeed = function() {
  var _ref54 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee51(seed, algorithm, options) {
    var _yield$generateKeys2, composedKeyPair;
    return _regeneratorRuntime().wrap(function _callee51$(_context52) {
      while (1)
        switch (_context52.prev = _context52.next) {
          case 0:
            _context52.next = 2;
            return generateKeys(seed, algorithm, options);
          case 2:
            _yield$generateKeys2 = _context52.sent;
            composedKeyPair = _yield$generateKeys2.composedKeyPair;
            return _context52.abrupt("return", composedKeyPair);
          case 5:
          case "end":
            return _context52.stop();
        }
    }, _callee51);
  }));
  return function getKeyPairFromSeed2(_x79, _x80, _x81) {
    return _ref54.apply(this, arguments);
  };
}();
var es = Object.freeze(Object.defineProperty({ __proto__: null, generateKeyPair: generateKeyPair$3, getKeyPairFromMnemonic, getKeyPairFromSeed }, Symbol.toStringTag, { value: "Module" }));
var require$$0$3 = getAugmentedNamespace(es);
var src$1 = {};
var indexBrowser = {};
var webcrypto$3 = {};
webcrypto$3.get = function() {
  var win = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : self;
  var nativeCrypto = win.crypto || win.msCrypto;
  if (!nativeCrypto || !nativeCrypto.subtle) {
    throw Object.assign(new Error("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p-crypto/blob/master/README.md#web-crypto-api"), { code: "ERR_MISSING_WEB_CRYPTO" });
  }
  return nativeCrypto;
};
var lengths$1 = { SHA1: 20, SHA256: 32, SHA512: 64 };
var webcrypto$2 = webcrypto$3;
var lengths = lengths$1;
var hashTypes = { SHA1: "SHA-1", SHA256: "SHA-256", SHA512: "SHA-512" };
var sign$1 = function() {
  var _ref55 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee52(key3, data) {
    var buf;
    return _regeneratorRuntime().wrap(function _callee52$(_context53) {
      while (1)
        switch (_context53.prev = _context53.next) {
          case 0:
            _context53.next = 2;
            return webcrypto$2.get().subtle.sign({ name: "HMAC" }, key3, data);
          case 2:
            buf = _context53.sent;
            return _context53.abrupt("return", new Uint8Array(buf, buf.byteOffset, buf.byteLength));
          case 4:
          case "end":
            return _context53.stop();
        }
    }, _callee52);
  }));
  return function sign$12(_x82, _x83) {
    return _ref55.apply(this, arguments);
  };
}();
indexBrowser.create = function() {
  var _ref56 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee54(hashType, secret) {
    var hash2, key3;
    return _regeneratorRuntime().wrap(function _callee54$(_context55) {
      while (1)
        switch (_context55.prev = _context55.next) {
          case 0:
            hash2 = hashTypes[hashType];
            _context55.next = 3;
            return webcrypto$2.get().subtle.importKey("raw", secret, { name: "HMAC", hash: { name: hash2 } }, false, ["sign"]);
          case 3:
            key3 = _context55.sent;
            return _context55.abrupt("return", { digest: function digest11(data) {
              return _asyncToGenerator(_regeneratorRuntime().mark(function _callee53() {
                return _regeneratorRuntime().wrap(function _callee53$(_context54) {
                  while (1)
                    switch (_context54.prev = _context54.next) {
                      case 0:
                        return _context54.abrupt("return", sign$1(key3, data));
                      case 1:
                      case "end":
                        return _context54.stop();
                    }
                }, _callee53);
              }))();
            }, length: lengths[hashType] });
          case 5:
          case "end":
            return _context55.stop();
        }
    }, _callee54);
  }));
  return function(_x84, _x85) {
    return _ref56.apply(this, arguments);
  };
}();
var aes$1 = {};
var forge$t = {
  // default options
  options: { usePureJavaScript: false }
};
var util$8 = { exports: {} };
var api$1 = {};
var baseN$1 = api$1;
var _reverseAlphabets = {};
api$1.encode = function(input, alphabet2, maxline) {
  if (typeof alphabet2 !== "string") {
    throw new TypeError('"alphabet" must be a string.');
  }
  if (maxline !== void 0 && typeof maxline !== "number") {
    throw new TypeError('"maxline" must be a number.');
  }
  var output = "";
  if (!(input instanceof Uint8Array)) {
    output = _encodeWithByteBuffer(input, alphabet2);
  } else {
    var i2 = 0;
    var base3 = alphabet2.length;
    var first = alphabet2.charAt(0);
    var digits = [0];
    for (i2 = 0; i2 < input.length; ++i2) {
      for (var j3 = 0, carry = input[i2]; j3 < digits.length; ++j3) {
        carry += digits[j3] << 8;
        digits[j3] = carry % base3;
        carry = carry / base3 | 0;
      }
      while (carry > 0) {
        digits.push(carry % base3);
        carry = carry / base3 | 0;
      }
    }
    for (i2 = 0; input[i2] === 0 && i2 < input.length - 1; ++i2) {
      output += first;
    }
    for (i2 = digits.length - 1; i2 >= 0; --i2) {
      output += alphabet2[digits[i2]];
    }
  }
  if (maxline) {
    var regex = new RegExp(".{1," + maxline + "}", "g");
    output = output.match(regex).join("\r\n");
  }
  return output;
};
api$1.decode = function(input, alphabet2) {
  if (typeof input !== "string") {
    throw new TypeError('"input" must be a string.');
  }
  if (typeof alphabet2 !== "string") {
    throw new TypeError('"alphabet" must be a string.');
  }
  var table = _reverseAlphabets[alphabet2];
  if (!table) {
    table = _reverseAlphabets[alphabet2] = [];
    for (var i2 = 0; i2 < alphabet2.length; ++i2) {
      table[alphabet2.charCodeAt(i2)] = i2;
    }
  }
  input = input.replace(/\s/g, "");
  var base3 = alphabet2.length;
  var first = alphabet2.charAt(0);
  var bytes = [0];
  for (var i2 = 0; i2 < input.length; i2++) {
    var value = table[input.charCodeAt(i2)];
    if (value === void 0) {
      return;
    }
    for (var j3 = 0, carry = value; j3 < bytes.length; ++j3) {
      carry += bytes[j3] * base3;
      bytes[j3] = carry & 255;
      carry >>= 8;
    }
    while (carry > 0) {
      bytes.push(carry & 255);
      carry >>= 8;
    }
  }
  for (var k3 = 0; input[k3] === first && k3 < input.length - 1; ++k3) {
    bytes.push(0);
  }
  if (typeof Buffer !== "undefined") {
    return Buffer.from(bytes.reverse());
  }
  return new Uint8Array(bytes.reverse());
};
function _encodeWithByteBuffer(input, alphabet2) {
  var i2 = 0;
  var base3 = alphabet2.length;
  var first = alphabet2.charAt(0);
  var digits = [0];
  for (i2 = 0; i2 < input.length(); ++i2) {
    for (var j3 = 0, carry = input.at(i2); j3 < digits.length; ++j3) {
      carry += digits[j3] << 8;
      digits[j3] = carry % base3;
      carry = carry / base3 | 0;
    }
    while (carry > 0) {
      digits.push(carry % base3);
      carry = carry / base3 | 0;
    }
  }
  var output = "";
  for (i2 = 0; input.at(i2) === 0 && i2 < input.length() - 1; ++i2) {
    output += first;
  }
  for (i2 = digits.length - 1; i2 >= 0; --i2) {
    output += alphabet2[digits[i2]];
  }
  return output;
}
var forge$s = forge$t;
var baseN = baseN$1;
var util$7 = util$8.exports = forge$s.util = forge$s.util || {};
(function() {
  if (typeof process !== "undefined" && process.nextTick && !process.browser) {
    util$7.nextTick = process.nextTick;
    if (typeof setImmediate === "function") {
      util$7.setImmediate = setImmediate;
    } else {
      util$7.setImmediate = util$7.nextTick;
    }
    return;
  }
  if (typeof setImmediate === "function") {
    util$7.setImmediate = function() {
      return setImmediate.apply(void 0, arguments);
    };
    util$7.nextTick = function(callback) {
      return setImmediate(callback);
    };
    return;
  }
  util$7.setImmediate = function(callback) {
    setTimeout(callback, 0);
  };
  if (typeof window !== "undefined" && typeof window.postMessage === "function") {
    let handler = function(event) {
      if (event.source === window && event.data === msg) {
        event.stopPropagation();
        var copy = callbacks.slice();
        callbacks.length = 0;
        copy.forEach(function(callback) {
          callback();
        });
      }
    };
    var msg = "forge.setImmediate";
    var callbacks = [];
    util$7.setImmediate = function(callback) {
      callbacks.push(callback);
      if (callbacks.length === 1) {
        window.postMessage(msg, "*");
      }
    };
    window.addEventListener("message", handler, true);
  }
  if (typeof MutationObserver !== "undefined") {
    var now = Date.now();
    var attr = true;
    var div = document.createElement("div");
    var callbacks = [];
    new MutationObserver(function() {
      var copy = callbacks.slice();
      callbacks.length = 0;
      copy.forEach(function(callback) {
        callback();
      });
    }).observe(div, { attributes: true });
    var oldSetImmediate = util$7.setImmediate;
    util$7.setImmediate = function(callback) {
      if (Date.now() - now > 15) {
        now = Date.now();
        oldSetImmediate(callback);
      } else {
        callbacks.push(callback);
        if (callbacks.length === 1) {
          div.setAttribute("a", attr = !attr);
        }
      }
    };
  }
  util$7.nextTick = util$7.setImmediate;
})();
util$7.isNodejs = typeof process !== "undefined" && process.versions && process.versions.node;
util$7.globalScope = function() {
  if (util$7.isNodejs) {
    return commonjsGlobal;
  }
  return typeof self === "undefined" ? window : self;
}();
util$7.isArray = Array.isArray || function(x2) {
  return Object.prototype.toString.call(x2) === "[object Array]";
};
util$7.isArrayBuffer = function(x2) {
  return typeof ArrayBuffer !== "undefined" && x2 instanceof ArrayBuffer;
};
util$7.isArrayBufferView = function(x2) {
  return x2 && util$7.isArrayBuffer(x2.buffer) && x2.byteLength !== void 0;
};
function _checkBitsParam(n2) {
  if (!(n2 === 8 || n2 === 16 || n2 === 24 || n2 === 32)) {
    throw new Error("Only 8, 16, 24, or 32 bits supported: " + n2);
  }
}
util$7.ByteBuffer = ByteStringBuffer;
function ByteStringBuffer(b3) {
  this.data = "";
  this.read = 0;
  if (typeof b3 === "string") {
    this.data = b3;
  } else if (util$7.isArrayBuffer(b3) || util$7.isArrayBufferView(b3)) {
    if (typeof Buffer !== "undefined" && b3 instanceof Buffer) {
      this.data = b3.toString("binary");
    } else {
      var arr = new Uint8Array(b3);
      try {
        this.data = String.fromCharCode.apply(null, arr);
      } catch (e2) {
        for (var i2 = 0; i2 < arr.length; ++i2) {
          this.putByte(arr[i2]);
        }
      }
    }
  } else if (b3 instanceof ByteStringBuffer || _typeof(b3) === "object" && typeof b3.data === "string" && typeof b3.read === "number") {
    this.data = b3.data;
    this.read = b3.read;
  }
  this._constructedStringLength = 0;
}
util$7.ByteStringBuffer = ByteStringBuffer;
var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
util$7.ByteStringBuffer.prototype._optimizeConstructedString = function(x2) {
  this._constructedStringLength += x2;
  if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
    this.data.substr(0, 1);
    this._constructedStringLength = 0;
  }
};
util$7.ByteStringBuffer.prototype.length = function() {
  return this.data.length - this.read;
};
util$7.ByteStringBuffer.prototype.isEmpty = function() {
  return this.length() <= 0;
};
util$7.ByteStringBuffer.prototype.putByte = function(b3) {
  return this.putBytes(String.fromCharCode(b3));
};
util$7.ByteStringBuffer.prototype.fillWithByte = function(b3, n2) {
  b3 = String.fromCharCode(b3);
  var d2 = this.data;
  while (n2 > 0) {
    if (n2 & 1) {
      d2 += b3;
    }
    n2 >>>= 1;
    if (n2 > 0) {
      b3 += b3;
    }
  }
  this.data = d2;
  this._optimizeConstructedString(n2);
  return this;
};
util$7.ByteStringBuffer.prototype.putBytes = function(bytes) {
  this.data += bytes;
  this._optimizeConstructedString(bytes.length);
  return this;
};
util$7.ByteStringBuffer.prototype.putString = function(str) {
  return this.putBytes(util$7.encodeUtf8(str));
};
util$7.ByteStringBuffer.prototype.putInt16 = function(i2) {
  return this.putBytes(String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255));
};
util$7.ByteStringBuffer.prototype.putInt24 = function(i2) {
  return this.putBytes(String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255));
};
util$7.ByteStringBuffer.prototype.putInt32 = function(i2) {
  return this.putBytes(String.fromCharCode(i2 >> 24 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255));
};
util$7.ByteStringBuffer.prototype.putInt16Le = function(i2) {
  return this.putBytes(String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255));
};
util$7.ByteStringBuffer.prototype.putInt24Le = function(i2) {
  return this.putBytes(String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 >> 16 & 255));
};
util$7.ByteStringBuffer.prototype.putInt32Le = function(i2) {
  return this.putBytes(String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 24 & 255));
};
util$7.ByteStringBuffer.prototype.putInt = function(i2, n2) {
  _checkBitsParam(n2);
  var bytes = "";
  do {
    n2 -= 8;
    bytes += String.fromCharCode(i2 >> n2 & 255);
  } while (n2 > 0);
  return this.putBytes(bytes);
};
util$7.ByteStringBuffer.prototype.putSignedInt = function(i2, n2) {
  if (i2 < 0) {
    i2 += 2 << n2 - 1;
  }
  return this.putInt(i2, n2);
};
util$7.ByteStringBuffer.prototype.putBuffer = function(buffer2) {
  return this.putBytes(buffer2.getBytes());
};
util$7.ByteStringBuffer.prototype.getByte = function() {
  return this.data.charCodeAt(this.read++);
};
util$7.ByteStringBuffer.prototype.getInt16 = function() {
  var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
  this.read += 2;
  return rval;
};
util$7.ByteStringBuffer.prototype.getInt24 = function() {
  var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
  this.read += 3;
  return rval;
};
util$7.ByteStringBuffer.prototype.getInt32 = function() {
  var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
  this.read += 4;
  return rval;
};
util$7.ByteStringBuffer.prototype.getInt16Le = function() {
  var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
  this.read += 2;
  return rval;
};
util$7.ByteStringBuffer.prototype.getInt24Le = function() {
  var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
  this.read += 3;
  return rval;
};
util$7.ByteStringBuffer.prototype.getInt32Le = function() {
  var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
  this.read += 4;
  return rval;
};
util$7.ByteStringBuffer.prototype.getInt = function(n2) {
  _checkBitsParam(n2);
  var rval = 0;
  do {
    rval = (rval << 8) + this.data.charCodeAt(this.read++);
    n2 -= 8;
  } while (n2 > 0);
  return rval;
};
util$7.ByteStringBuffer.prototype.getSignedInt = function(n2) {
  var x2 = this.getInt(n2);
  var max = 2 << n2 - 2;
  if (x2 >= max) {
    x2 -= max << 1;
  }
  return x2;
};
util$7.ByteStringBuffer.prototype.getBytes = function(count) {
  var rval;
  if (count) {
    count = Math.min(this.length(), count);
    rval = this.data.slice(this.read, this.read + count);
    this.read += count;
  } else if (count === 0) {
    rval = "";
  } else {
    rval = this.read === 0 ? this.data : this.data.slice(this.read);
    this.clear();
  }
  return rval;
};
util$7.ByteStringBuffer.prototype.bytes = function(count) {
  return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
};
util$7.ByteStringBuffer.prototype.at = function(i2) {
  return this.data.charCodeAt(this.read + i2);
};
util$7.ByteStringBuffer.prototype.setAt = function(i2, b3) {
  this.data = this.data.substr(0, this.read + i2) + String.fromCharCode(b3) + this.data.substr(this.read + i2 + 1);
  return this;
};
util$7.ByteStringBuffer.prototype.last = function() {
  return this.data.charCodeAt(this.data.length - 1);
};
util$7.ByteStringBuffer.prototype.copy = function() {
  var c3 = util$7.createBuffer(this.data);
  c3.read = this.read;
  return c3;
};
util$7.ByteStringBuffer.prototype.compact = function() {
  if (this.read > 0) {
    this.data = this.data.slice(this.read);
    this.read = 0;
  }
  return this;
};
util$7.ByteStringBuffer.prototype.clear = function() {
  this.data = "";
  this.read = 0;
  return this;
};
util$7.ByteStringBuffer.prototype.truncate = function(count) {
  var len2 = Math.max(0, this.length() - count);
  this.data = this.data.substr(this.read, len2);
  this.read = 0;
  return this;
};
util$7.ByteStringBuffer.prototype.toHex = function() {
  var rval = "";
  for (var i2 = this.read; i2 < this.data.length; ++i2) {
    var b3 = this.data.charCodeAt(i2);
    if (b3 < 16) {
      rval += "0";
    }
    rval += b3.toString(16);
  }
  return rval;
};
util$7.ByteStringBuffer.prototype.toString = function() {
  return util$7.decodeUtf8(this.bytes());
};
function DataBuffer(b3, options) {
  options = options || {};
  this.read = options.readOffset || 0;
  this.growSize = options.growSize || 1024;
  var isArrayBuffer2 = util$7.isArrayBuffer(b3);
  var isArrayBufferView2 = util$7.isArrayBufferView(b3);
  if (isArrayBuffer2 || isArrayBufferView2) {
    if (isArrayBuffer2) {
      this.data = new DataView(b3);
    } else {
      this.data = new DataView(b3.buffer, b3.byteOffset, b3.byteLength);
    }
    this.write = "writeOffset" in options ? options.writeOffset : this.data.byteLength;
    return;
  }
  this.data = new DataView(new ArrayBuffer(0));
  this.write = 0;
  if (b3 !== null && b3 !== void 0) {
    this.putBytes(b3);
  }
  if ("writeOffset" in options) {
    this.write = options.writeOffset;
  }
}
util$7.DataBuffer = DataBuffer;
util$7.DataBuffer.prototype.length = function() {
  return this.write - this.read;
};
util$7.DataBuffer.prototype.isEmpty = function() {
  return this.length() <= 0;
};
util$7.DataBuffer.prototype.accommodate = function(amount, growSize) {
  if (this.length() >= amount) {
    return this;
  }
  growSize = Math.max(growSize || this.growSize, amount);
  var src2 = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength);
  var dst = new Uint8Array(this.length() + growSize);
  dst.set(src2);
  this.data = new DataView(dst.buffer);
  return this;
};
util$7.DataBuffer.prototype.putByte = function(b3) {
  this.accommodate(1);
  this.data.setUint8(this.write++, b3);
  return this;
};
util$7.DataBuffer.prototype.fillWithByte = function(b3, n2) {
  this.accommodate(n2);
  for (var i2 = 0; i2 < n2; ++i2) {
    this.data.setUint8(b3);
  }
  return this;
};
util$7.DataBuffer.prototype.putBytes = function(bytes, encoding) {
  if (util$7.isArrayBufferView(bytes)) {
    var src2 = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    var len2 = src2.byteLength - src2.byteOffset;
    this.accommodate(len2);
    var dst = new Uint8Array(this.data.buffer, this.write);
    dst.set(src2);
    this.write += len2;
    return this;
  }
  if (util$7.isArrayBuffer(bytes)) {
    var src2 = new Uint8Array(bytes);
    this.accommodate(src2.byteLength);
    var dst = new Uint8Array(this.data.buffer);
    dst.set(src2, this.write);
    this.write += src2.byteLength;
    return this;
  }
  if (bytes instanceof util$7.DataBuffer || _typeof(bytes) === "object" && typeof bytes.read === "number" && typeof bytes.write === "number" && util$7.isArrayBufferView(bytes.data)) {
    var src2 = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());
    this.accommodate(src2.byteLength);
    var dst = new Uint8Array(bytes.data.byteLength, this.write);
    dst.set(src2);
    this.write += src2.byteLength;
    return this;
  }
  if (bytes instanceof util$7.ByteStringBuffer) {
    bytes = bytes.data;
    encoding = "binary";
  }
  encoding = encoding || "binary";
  if (typeof bytes === "string") {
    var view;
    if (encoding === "hex") {
      this.accommodate(Math.ceil(bytes.length / 2));
      view = new Uint8Array(this.data.buffer, this.write);
      this.write += util$7.binary.hex.decode(bytes, view, this.write);
      return this;
    }
    if (encoding === "base64") {
      this.accommodate(Math.ceil(bytes.length / 4) * 3);
      view = new Uint8Array(this.data.buffer, this.write);
      this.write += util$7.binary.base64.decode(bytes, view, this.write);
      return this;
    }
    if (encoding === "utf8") {
      bytes = util$7.encodeUtf8(bytes);
      encoding = "binary";
    }
    if (encoding === "binary" || encoding === "raw") {
      this.accommodate(bytes.length);
      view = new Uint8Array(this.data.buffer, this.write);
      this.write += util$7.binary.raw.decode(view);
      return this;
    }
    if (encoding === "utf16") {
      this.accommodate(bytes.length * 2);
      view = new Uint16Array(this.data.buffer, this.write);
      this.write += util$7.text.utf16.encode(view);
      return this;
    }
    throw new Error("Invalid encoding: " + encoding);
  }
  throw Error("Invalid parameter: " + bytes);
};
util$7.DataBuffer.prototype.putBuffer = function(buffer2) {
  this.putBytes(buffer2);
  buffer2.clear();
  return this;
};
util$7.DataBuffer.prototype.putString = function(str) {
  return this.putBytes(str, "utf16");
};
util$7.DataBuffer.prototype.putInt16 = function(i2) {
  this.accommodate(2);
  this.data.setInt16(this.write, i2);
  this.write += 2;
  return this;
};
util$7.DataBuffer.prototype.putInt24 = function(i2) {
  this.accommodate(3);
  this.data.setInt16(this.write, i2 >> 8 & 65535);
  this.data.setInt8(this.write, i2 >> 16 & 255);
  this.write += 3;
  return this;
};
util$7.DataBuffer.prototype.putInt32 = function(i2) {
  this.accommodate(4);
  this.data.setInt32(this.write, i2);
  this.write += 4;
  return this;
};
util$7.DataBuffer.prototype.putInt16Le = function(i2) {
  this.accommodate(2);
  this.data.setInt16(this.write, i2, true);
  this.write += 2;
  return this;
};
util$7.DataBuffer.prototype.putInt24Le = function(i2) {
  this.accommodate(3);
  this.data.setInt8(this.write, i2 >> 16 & 255);
  this.data.setInt16(this.write, i2 >> 8 & 65535, true);
  this.write += 3;
  return this;
};
util$7.DataBuffer.prototype.putInt32Le = function(i2) {
  this.accommodate(4);
  this.data.setInt32(this.write, i2, true);
  this.write += 4;
  return this;
};
util$7.DataBuffer.prototype.putInt = function(i2, n2) {
  _checkBitsParam(n2);
  this.accommodate(n2 / 8);
  do {
    n2 -= 8;
    this.data.setInt8(this.write++, i2 >> n2 & 255);
  } while (n2 > 0);
  return this;
};
util$7.DataBuffer.prototype.putSignedInt = function(i2, n2) {
  _checkBitsParam(n2);
  this.accommodate(n2 / 8);
  if (i2 < 0) {
    i2 += 2 << n2 - 1;
  }
  return this.putInt(i2, n2);
};
util$7.DataBuffer.prototype.getByte = function() {
  return this.data.getInt8(this.read++);
};
util$7.DataBuffer.prototype.getInt16 = function() {
  var rval = this.data.getInt16(this.read);
  this.read += 2;
  return rval;
};
util$7.DataBuffer.prototype.getInt24 = function() {
  var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
  this.read += 3;
  return rval;
};
util$7.DataBuffer.prototype.getInt32 = function() {
  var rval = this.data.getInt32(this.read);
  this.read += 4;
  return rval;
};
util$7.DataBuffer.prototype.getInt16Le = function() {
  var rval = this.data.getInt16(this.read, true);
  this.read += 2;
  return rval;
};
util$7.DataBuffer.prototype.getInt24Le = function() {
  var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
  this.read += 3;
  return rval;
};
util$7.DataBuffer.prototype.getInt32Le = function() {
  var rval = this.data.getInt32(this.read, true);
  this.read += 4;
  return rval;
};
util$7.DataBuffer.prototype.getInt = function(n2) {
  _checkBitsParam(n2);
  var rval = 0;
  do {
    rval = (rval << 8) + this.data.getInt8(this.read++);
    n2 -= 8;
  } while (n2 > 0);
  return rval;
};
util$7.DataBuffer.prototype.getSignedInt = function(n2) {
  var x2 = this.getInt(n2);
  var max = 2 << n2 - 2;
  if (x2 >= max) {
    x2 -= max << 1;
  }
  return x2;
};
util$7.DataBuffer.prototype.getBytes = function(count) {
  var rval;
  if (count) {
    count = Math.min(this.length(), count);
    rval = this.data.slice(this.read, this.read + count);
    this.read += count;
  } else if (count === 0) {
    rval = "";
  } else {
    rval = this.read === 0 ? this.data : this.data.slice(this.read);
    this.clear();
  }
  return rval;
};
util$7.DataBuffer.prototype.bytes = function(count) {
  return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
};
util$7.DataBuffer.prototype.at = function(i2) {
  return this.data.getUint8(this.read + i2);
};
util$7.DataBuffer.prototype.setAt = function(i2, b3) {
  this.data.setUint8(i2, b3);
  return this;
};
util$7.DataBuffer.prototype.last = function() {
  return this.data.getUint8(this.write - 1);
};
util$7.DataBuffer.prototype.copy = function() {
  return new util$7.DataBuffer(this);
};
util$7.DataBuffer.prototype.compact = function() {
  if (this.read > 0) {
    var src2 = new Uint8Array(this.data.buffer, this.read);
    var dst = new Uint8Array(src2.byteLength);
    dst.set(src2);
    this.data = new DataView(dst);
    this.write -= this.read;
    this.read = 0;
  }
  return this;
};
util$7.DataBuffer.prototype.clear = function() {
  this.data = new DataView(new ArrayBuffer(0));
  this.read = this.write = 0;
  return this;
};
util$7.DataBuffer.prototype.truncate = function(count) {
  this.write = Math.max(0, this.length() - count);
  this.read = Math.min(this.read, this.write);
  return this;
};
util$7.DataBuffer.prototype.toHex = function() {
  var rval = "";
  for (var i2 = this.read; i2 < this.data.byteLength; ++i2) {
    var b3 = this.data.getUint8(i2);
    if (b3 < 16) {
      rval += "0";
    }
    rval += b3.toString(16);
  }
  return rval;
};
util$7.DataBuffer.prototype.toString = function(encoding) {
  var view = new Uint8Array(this.data, this.read, this.length());
  encoding = encoding || "utf8";
  if (encoding === "binary" || encoding === "raw") {
    return util$7.binary.raw.encode(view);
  }
  if (encoding === "hex") {
    return util$7.binary.hex.encode(view);
  }
  if (encoding === "base64") {
    return util$7.binary.base64.encode(view);
  }
  if (encoding === "utf8") {
    return util$7.text.utf8.decode(view);
  }
  if (encoding === "utf16") {
    return util$7.text.utf16.decode(view);
  }
  throw new Error("Invalid encoding: " + encoding);
};
util$7.createBuffer = function(input, encoding) {
  encoding = encoding || "raw";
  if (input !== void 0 && encoding === "utf8") {
    input = util$7.encodeUtf8(input);
  }
  return new util$7.ByteBuffer(input);
};
util$7.fillString = function(c3, n2) {
  var s2 = "";
  while (n2 > 0) {
    if (n2 & 1) {
      s2 += c3;
    }
    n2 >>>= 1;
    if (n2 > 0) {
      c3 += c3;
    }
  }
  return s2;
};
util$7.xorBytes = function(s1, s2, n2) {
  var s3 = "";
  var b3 = "";
  var t2 = "";
  var i2 = 0;
  var c3 = 0;
  for (; n2 > 0; --n2, ++i2) {
    b3 = s1.charCodeAt(i2) ^ s2.charCodeAt(i2);
    if (c3 >= 10) {
      s3 += t2;
      t2 = "";
      c3 = 0;
    }
    t2 += String.fromCharCode(b3);
    ++c3;
  }
  s3 += t2;
  return s3;
};
util$7.hexToBytes = function(hex) {
  var rval = "";
  var i2 = 0;
  if (hex.length & true) {
    i2 = 1;
    rval += String.fromCharCode(parseInt(hex[0], 16));
  }
  for (; i2 < hex.length; i2 += 2) {
    rval += String.fromCharCode(parseInt(hex.substr(i2, 2), 16));
  }
  return rval;
};
util$7.bytesToHex = function(bytes) {
  return util$7.createBuffer(bytes).toHex();
};
util$7.int32ToBytes = function(i2) {
  return String.fromCharCode(i2 >> 24 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255);
};
var _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var _base64Idx = [
  /*43 -43 = 0*/
  /*'+',  1,  2,  3,'/' */
  62,
  -1,
  -1,
  -1,
  63,
  /*'0','1','2','3','4','5','6','7','8','9' */
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  /*15, 16, 17,'=', 19, 20, 21 */
  -1,
  -1,
  -1,
  64,
  -1,
  -1,
  -1,
  /*65 - 43 = 22*/
  /*'A','B','C','D','E','F','G','H','I','J','K','L','M', */
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  /*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  /*91 - 43 = 48 */
  /*48, 49, 50, 51, 52, 53 */
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  /*97 - 43 = 54*/
  /*'a','b','c','d','e','f','g','h','i','j','k','l','m' */
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  /*'n','o','p','q','r','s','t','u','v','w','x','y','z' */
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51
];
var _base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
util$7.encode64 = function(input, maxline) {
  var line = "";
  var output = "";
  var chr1, chr2, chr3;
  var i2 = 0;
  while (i2 < input.length) {
    chr1 = input.charCodeAt(i2++);
    chr2 = input.charCodeAt(i2++);
    chr3 = input.charCodeAt(i2++);
    line += _base64.charAt(chr1 >> 2);
    line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
    if (isNaN(chr2)) {
      line += "==";
    } else {
      line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
      line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
    }
    if (maxline && line.length > maxline) {
      output += line.substr(0, maxline) + "\r\n";
      line = line.substr(maxline);
    }
  }
  output += line;
  return output;
};
util$7.decode64 = function(input) {
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
  var output = "";
  var enc1, enc2, enc3, enc4;
  var i2 = 0;
  while (i2 < input.length) {
    enc1 = _base64Idx[input.charCodeAt(i2++) - 43];
    enc2 = _base64Idx[input.charCodeAt(i2++) - 43];
    enc3 = _base64Idx[input.charCodeAt(i2++) - 43];
    enc4 = _base64Idx[input.charCodeAt(i2++) - 43];
    output += String.fromCharCode(enc1 << 2 | enc2 >> 4);
    if (enc3 !== 64) {
      output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);
      if (enc4 !== 64) {
        output += String.fromCharCode((enc3 & 3) << 6 | enc4);
      }
    }
  }
  return output;
};
util$7.encodeUtf8 = function(str) {
  return unescape(encodeURIComponent(str));
};
util$7.decodeUtf8 = function(str) {
  return decodeURIComponent(escape(str));
};
util$7.binary = { raw: {}, hex: {}, base64: {}, base58: {}, baseN: { encode: baseN.encode, decode: baseN.decode } };
util$7.binary.raw.encode = function(bytes) {
  return String.fromCharCode.apply(null, bytes);
};
util$7.binary.raw.decode = function(str, output, offset) {
  var out = output;
  if (!out) {
    out = new Uint8Array(str.length);
  }
  offset = offset || 0;
  var j3 = offset;
  for (var i2 = 0; i2 < str.length; ++i2) {
    out[j3++] = str.charCodeAt(i2);
  }
  return output ? j3 - offset : out;
};
util$7.binary.hex.encode = util$7.bytesToHex;
util$7.binary.hex.decode = function(hex, output, offset) {
  var out = output;
  if (!out) {
    out = new Uint8Array(Math.ceil(hex.length / 2));
  }
  offset = offset || 0;
  var i2 = 0, j3 = offset;
  if (hex.length & 1) {
    i2 = 1;
    out[j3++] = parseInt(hex[0], 16);
  }
  for (; i2 < hex.length; i2 += 2) {
    out[j3++] = parseInt(hex.substr(i2, 2), 16);
  }
  return output ? j3 - offset : out;
};
util$7.binary.base64.encode = function(input, maxline) {
  var line = "";
  var output = "";
  var chr1, chr2, chr3;
  var i2 = 0;
  while (i2 < input.byteLength) {
    chr1 = input[i2++];
    chr2 = input[i2++];
    chr3 = input[i2++];
    line += _base64.charAt(chr1 >> 2);
    line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
    if (isNaN(chr2)) {
      line += "==";
    } else {
      line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
      line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
    }
    if (maxline && line.length > maxline) {
      output += line.substr(0, maxline) + "\r\n";
      line = line.substr(maxline);
    }
  }
  output += line;
  return output;
};
util$7.binary.base64.decode = function(input, output, offset) {
  var out = output;
  if (!out) {
    out = new Uint8Array(Math.ceil(input.length / 4) * 3);
  }
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
  offset = offset || 0;
  var enc1, enc2, enc3, enc4;
  var i2 = 0, j3 = offset;
  while (i2 < input.length) {
    enc1 = _base64Idx[input.charCodeAt(i2++) - 43];
    enc2 = _base64Idx[input.charCodeAt(i2++) - 43];
    enc3 = _base64Idx[input.charCodeAt(i2++) - 43];
    enc4 = _base64Idx[input.charCodeAt(i2++) - 43];
    out[j3++] = enc1 << 2 | enc2 >> 4;
    if (enc3 !== 64) {
      out[j3++] = (enc2 & 15) << 4 | enc3 >> 2;
      if (enc4 !== 64) {
        out[j3++] = (enc3 & 3) << 6 | enc4;
      }
    }
  }
  return output ? j3 - offset : out.subarray(0, j3);
};
util$7.binary.base58.encode = function(input, maxline) {
  return util$7.binary.baseN.encode(input, _base58, maxline);
};
util$7.binary.base58.decode = function(input, maxline) {
  return util$7.binary.baseN.decode(input, _base58, maxline);
};
util$7.text = { utf8: {}, utf16: {} };
util$7.text.utf8.encode = function(str, output, offset) {
  str = util$7.encodeUtf8(str);
  var out = output;
  if (!out) {
    out = new Uint8Array(str.length);
  }
  offset = offset || 0;
  var j3 = offset;
  for (var i2 = 0; i2 < str.length; ++i2) {
    out[j3++] = str.charCodeAt(i2);
  }
  return output ? j3 - offset : out;
};
util$7.text.utf8.decode = function(bytes) {
  return util$7.decodeUtf8(String.fromCharCode.apply(null, bytes));
};
util$7.text.utf16.encode = function(str, output, offset) {
  var out = output;
  if (!out) {
    out = new Uint8Array(str.length * 2);
  }
  var view = new Uint16Array(out.buffer);
  offset = offset || 0;
  var j3 = offset;
  var k3 = offset;
  for (var i2 = 0; i2 < str.length; ++i2) {
    view[k3++] = str.charCodeAt(i2);
    j3 += 2;
  }
  return output ? j3 - offset : out;
};
util$7.text.utf16.decode = function(bytes) {
  return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));
};
util$7.deflate = function(api2, bytes, raw2) {
  bytes = util$7.decode64(api2.deflate(util$7.encode64(bytes)).rval);
  if (raw2) {
    var start = 2;
    var flg = bytes.charCodeAt(1);
    if (flg & 32) {
      start = 6;
    }
    bytes = bytes.substring(start, bytes.length - 4);
  }
  return bytes;
};
util$7.inflate = function(api2, bytes, raw2) {
  var rval = api2.inflate(util$7.encode64(bytes)).rval;
  return rval === null ? null : util$7.decode64(rval);
};
var _setStorageObject = function _setStorageObject2(api2, id, obj2) {
  if (!api2) {
    throw new Error("WebStorage not available.");
  }
  var rval;
  if (obj2 === null) {
    rval = api2.removeItem(id);
  } else {
    obj2 = util$7.encode64(JSON.stringify(obj2));
    rval = api2.setItem(id, obj2);
  }
  if (typeof rval !== "undefined" && rval.rval !== true) {
    var error3 = new Error(rval.error.message);
    error3.id = rval.error.id;
    error3.name = rval.error.name;
    throw error3;
  }
};
var _getStorageObject = function _getStorageObject2(api2, id) {
  if (!api2) {
    throw new Error("WebStorage not available.");
  }
  var rval = api2.getItem(id);
  if (api2.init) {
    if (rval.rval === null) {
      if (rval.error) {
        var error3 = new Error(rval.error.message);
        error3.id = rval.error.id;
        error3.name = rval.error.name;
        throw error3;
      }
      rval = null;
    } else {
      rval = rval.rval;
    }
  }
  if (rval !== null) {
    rval = JSON.parse(util$7.decode64(rval));
  }
  return rval;
};
var _setItem = function _setItem2(api2, id, key3, data) {
  var obj2 = _getStorageObject(api2, id);
  if (obj2 === null) {
    obj2 = {};
  }
  obj2[key3] = data;
  _setStorageObject(api2, id, obj2);
};
var _getItem = function _getItem2(api2, id, key3) {
  var rval = _getStorageObject(api2, id);
  if (rval !== null) {
    rval = key3 in rval ? rval[key3] : null;
  }
  return rval;
};
var _removeItem = function _removeItem2(api2, id, key3) {
  var obj2 = _getStorageObject(api2, id);
  if (obj2 !== null && key3 in obj2) {
    delete obj2[key3];
    var empty = true;
    for (var prop in obj2) {
      empty = false;
      break;
    }
    if (empty) {
      obj2 = null;
    }
    _setStorageObject(api2, id, obj2);
  }
};
var _clearItems = function _clearItems2(api2, id) {
  _setStorageObject(api2, id, null);
};
var _callStorageFunction = function _callStorageFunction2(func, args, location2) {
  var rval = null;
  if (typeof location2 === "undefined") {
    location2 = ["web", "flash"];
  }
  var type;
  var done = false;
  var exception = null;
  for (var idx in location2) {
    type = location2[idx];
    try {
      if (type === "flash" || type === "both") {
        if (args[0] === null) {
          throw new Error("Flash local storage not available.");
        }
        rval = func.apply(this, args);
        done = type === "flash";
      }
      if (type === "web" || type === "both") {
        args[0] = localStorage;
        rval = func.apply(this, args);
        done = true;
      }
    } catch (ex) {
      exception = ex;
    }
    if (done) {
      break;
    }
  }
  if (!done) {
    throw exception;
  }
  return rval;
};
util$7.setItem = function(api2, id, key3, data, location2) {
  _callStorageFunction(_setItem, arguments, location2);
};
util$7.getItem = function(api2, id, key3, location2) {
  return _callStorageFunction(_getItem, arguments, location2);
};
util$7.removeItem = function(api2, id, key3, location2) {
  _callStorageFunction(_removeItem, arguments, location2);
};
util$7.clearItems = function(api2, id, location2) {
  _callStorageFunction(_clearItems, arguments, location2);
};
util$7.parseUrl = function(str) {
  var regex = /^(https?):\/\/([^:&^\/]*):?(\d*)(.*)$/g;
  regex.lastIndex = 0;
  var m2 = regex.exec(str);
  var url = m2 === null ? null : { full: str, scheme: m2[1], host: m2[2], port: m2[3], path: m2[4] };
  if (url) {
    url.fullHost = url.host;
    if (url.port) {
      if (url.port !== 80 && url.scheme === "http") {
        url.fullHost += ":" + url.port;
      } else if (url.port !== 443 && url.scheme === "https") {
        url.fullHost += ":" + url.port;
      }
    } else if (url.scheme === "http") {
      url.port = 80;
    } else if (url.scheme === "https") {
      url.port = 443;
    }
    url.full = url.scheme + "://" + url.fullHost;
  }
  return url;
};
var _queryVariables = null;
util$7.getQueryVariables = function(query) {
  var parse = function parse2(q3) {
    var rval2 = {};
    var kvpairs = q3.split("&");
    for (var i2 = 0; i2 < kvpairs.length; i2++) {
      var pos = kvpairs[i2].indexOf("=");
      var key3;
      var val;
      if (pos > 0) {
        key3 = kvpairs[i2].substring(0, pos);
        val = kvpairs[i2].substring(pos + 1);
      } else {
        key3 = kvpairs[i2];
        val = null;
      }
      if (!(key3 in rval2)) {
        rval2[key3] = [];
      }
      if (!(key3 in Object.prototype) && val !== null) {
        rval2[key3].push(unescape(val));
      }
    }
    return rval2;
  };
  var rval;
  if (typeof query === "undefined") {
    if (_queryVariables === null) {
      if (typeof window !== "undefined" && window.location && window.location.search) {
        _queryVariables = parse(window.location.search.substring(1));
      } else {
        _queryVariables = {};
      }
    }
    rval = _queryVariables;
  } else {
    rval = parse(query);
  }
  return rval;
};
util$7.parseFragment = function(fragment) {
  var fp = fragment;
  var fq = "";
  var pos = fragment.indexOf("?");
  if (pos > 0) {
    fp = fragment.substring(0, pos);
    fq = fragment.substring(pos + 1);
  }
  var path2 = fp.split("/");
  if (path2.length > 0 && path2[0] === "") {
    path2.shift();
  }
  var query = fq === "" ? {} : util$7.getQueryVariables(fq);
  return { pathString: fp, queryString: fq, path: path2, query };
};
util$7.makeRequest = function(reqString) {
  var frag = util$7.parseFragment(reqString);
  var req = {
    // full path string
    path: frag.pathString,
    // full query string
    query: frag.queryString,
    /**
    * Get path or element in path.
    *
    * @param i optional path index.
    *
    * @return path or part of path if i provided.
    */
    getPath: function getPath(i2) {
      return typeof i2 === "undefined" ? frag.path : frag.path[i2];
    },
    /**
    * Get query, values for a key, or value for a key index.
    *
    * @param k optional query key.
    * @param i optional query key index.
    *
    * @return query, values for a key, or value for a key index.
    */
    getQuery: function getQuery(k3, i2) {
      var rval;
      if (typeof k3 === "undefined") {
        rval = frag.query;
      } else {
        rval = frag.query[k3];
        if (rval && typeof i2 !== "undefined") {
          rval = rval[i2];
        }
      }
      return rval;
    },
    getQueryLast: function getQueryLast(k3, _default2) {
      var rval;
      var vals = req.getQuery(k3);
      if (vals) {
        rval = vals[vals.length - 1];
      } else {
        rval = _default2;
      }
      return rval;
    }
  };
  return req;
};
util$7.makeLink = function(path2, query, fragment) {
  path2 = jQuery.isArray(path2) ? path2.join("/") : path2;
  var qstr = jQuery.param(query || {});
  fragment = fragment || "";
  return path2 + (qstr.length > 0 ? "?" + qstr : "") + (fragment.length > 0 ? "#" + fragment : "");
};
util$7.isEmpty = function(obj2) {
  for (var prop in obj2) {
    if (obj2.hasOwnProperty(prop)) {
      return false;
    }
  }
  return true;
};
util$7.format = function(format) {
  var re = /%./g;
  var match;
  var part;
  var argi = 0;
  var parts = [];
  var last = 0;
  while (match = re.exec(format)) {
    part = format.substring(last, re.lastIndex - 2);
    if (part.length > 0) {
      parts.push(part);
    }
    last = re.lastIndex;
    var code2 = match[0][1];
    switch (code2) {
      case "s":
      case "o":
        if (argi < arguments.length) {
          parts.push(arguments[argi++ + 1]);
        } else {
          parts.push("<?>");
        }
        break;
      case "%":
        parts.push("%");
        break;
      default:
        parts.push("<%" + code2 + "?>");
    }
  }
  parts.push(format.substring(last));
  return parts.join("");
};
util$7.formatNumber = function(number, decimals, dec_point, thousands_sep) {
  var n2 = number, c3 = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
  var d2 = dec_point === void 0 ? "," : dec_point;
  var t2 = thousands_sep === void 0 ? "." : thousands_sep, s2 = n2 < 0 ? "-" : "";
  var i2 = parseInt(n2 = Math.abs(+n2 || 0).toFixed(c3), 10) + "";
  var j3 = i2.length > 3 ? i2.length % 3 : 0;
  return s2 + (j3 ? i2.substr(0, j3) + t2 : "") + i2.substr(j3).replace(/(\d{3})(?=\d)/g, "$1" + t2) + (c3 ? d2 + Math.abs(n2 - i2).toFixed(c3).slice(2) : "");
};
util$7.formatSize = function(size) {
  if (size >= 1073741824) {
    size = util$7.formatNumber(size / 1073741824, 2, ".", "") + " GiB";
  } else if (size >= 1048576) {
    size = util$7.formatNumber(size / 1048576, 2, ".", "") + " MiB";
  } else if (size >= 1024) {
    size = util$7.formatNumber(size / 1024, 0) + " KiB";
  } else {
    size = util$7.formatNumber(size, 0) + " bytes";
  }
  return size;
};
util$7.bytesFromIP = function(ip) {
  if (ip.indexOf(".") !== -1) {
    return util$7.bytesFromIPv4(ip);
  }
  if (ip.indexOf(":") !== -1) {
    return util$7.bytesFromIPv6(ip);
  }
  return null;
};
util$7.bytesFromIPv4 = function(ip) {
  ip = ip.split(".");
  if (ip.length !== 4) {
    return null;
  }
  var b3 = util$7.createBuffer();
  for (var i2 = 0; i2 < ip.length; ++i2) {
    var num = parseInt(ip[i2], 10);
    if (isNaN(num)) {
      return null;
    }
    b3.putByte(num);
  }
  return b3.getBytes();
};
util$7.bytesFromIPv6 = function(ip) {
  var blanks = 0;
  ip = ip.split(":").filter(function(e2) {
    if (e2.length === 0)
      ++blanks;
    return true;
  });
  var zeros = (8 - ip.length + blanks) * 2;
  var b3 = util$7.createBuffer();
  for (var i2 = 0; i2 < 8; ++i2) {
    if (!ip[i2] || ip[i2].length === 0) {
      b3.fillWithByte(0, zeros);
      zeros = 0;
      continue;
    }
    var bytes = util$7.hexToBytes(ip[i2]);
    if (bytes.length < 2) {
      b3.putByte(0);
    }
    b3.putBytes(bytes);
  }
  return b3.getBytes();
};
util$7.bytesToIP = function(bytes) {
  if (bytes.length === 4) {
    return util$7.bytesToIPv4(bytes);
  }
  if (bytes.length === 16) {
    return util$7.bytesToIPv6(bytes);
  }
  return null;
};
util$7.bytesToIPv4 = function(bytes) {
  if (bytes.length !== 4) {
    return null;
  }
  var ip = [];
  for (var i2 = 0; i2 < bytes.length; ++i2) {
    ip.push(bytes.charCodeAt(i2));
  }
  return ip.join(".");
};
util$7.bytesToIPv6 = function(bytes) {
  if (bytes.length !== 16) {
    return null;
  }
  var ip = [];
  var zeroGroups = [];
  var zeroMaxGroup = 0;
  for (var i2 = 0; i2 < bytes.length; i2 += 2) {
    var hex = util$7.bytesToHex(bytes[i2] + bytes[i2 + 1]);
    while (hex[0] === "0" && hex !== "0") {
      hex = hex.substr(1);
    }
    if (hex === "0") {
      var last = zeroGroups[zeroGroups.length - 1];
      var idx = ip.length;
      if (!last || idx !== last.end + 1) {
        zeroGroups.push({ start: idx, end: idx });
      } else {
        last.end = idx;
        if (last.end - last.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) {
          zeroMaxGroup = zeroGroups.length - 1;
        }
      }
    }
    ip.push(hex);
  }
  if (zeroGroups.length > 0) {
    var group = zeroGroups[zeroMaxGroup];
    if (group.end - group.start > 0) {
      ip.splice(group.start, group.end - group.start + 1, "");
      if (group.start === 0) {
        ip.unshift("");
      }
      if (group.end === 7) {
        ip.push("");
      }
    }
  }
  return ip.join(":");
};
util$7.estimateCores = function(options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = {};
  }
  options = options || {};
  if ("cores" in util$7 && !options.update) {
    return callback(null, util$7.cores);
  }
  if (typeof navigator !== "undefined" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) {
    util$7.cores = navigator.hardwareConcurrency;
    return callback(null, util$7.cores);
  }
  if (typeof Worker === "undefined") {
    util$7.cores = 1;
    return callback(null, util$7.cores);
  }
  if (typeof Blob === "undefined") {
    util$7.cores = 2;
    return callback(null, util$7.cores);
  }
  var blobUrl = URL.createObjectURL(new Blob(["(", (function() {
    self.addEventListener("message", function(e2) {
      var st = Date.now();
      var et = st + 4;
      self.postMessage({ st, et });
    });
  }).toString(), ")()"], { type: "application/javascript" }));
  sample([], 5, 16);
  function sample(max, samples, numWorkers) {
    if (samples === 0) {
      var avg = Math.floor(max.reduce(function(avg2, x2) {
        return avg2 + x2;
      }, 0) / max.length);
      util$7.cores = Math.max(1, avg);
      URL.revokeObjectURL(blobUrl);
      return callback(null, util$7.cores);
    }
    map(numWorkers, function(err, results) {
      max.push(reduce2(numWorkers, results));
      sample(max, samples - 1, numWorkers);
    });
  }
  function map(numWorkers, callback2) {
    var workers = [];
    var results = [];
    for (var i2 = 0; i2 < numWorkers; ++i2) {
      var worker = new Worker(blobUrl);
      worker.addEventListener("message", function(e2) {
        results.push(e2.data);
        if (results.length === numWorkers) {
          for (var i3 = 0; i3 < numWorkers; ++i3) {
            workers[i3].terminate();
          }
          callback2(null, results);
        }
      });
      workers.push(worker);
    }
    for (var i2 = 0; i2 < numWorkers; ++i2) {
      workers[i2].postMessage(i2);
    }
  }
  function reduce2(numWorkers, results) {
    var overlaps = [];
    for (var n2 = 0; n2 < numWorkers; ++n2) {
      var r1 = results[n2];
      var overlap = overlaps[n2] = [];
      for (var i2 = 0; i2 < numWorkers; ++i2) {
        if (n2 === i2) {
          continue;
        }
        var r2 = results[i2];
        if (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) {
          overlap.push(i2);
        }
      }
    }
    return overlaps.reduce(function(max, overlap2) {
      return Math.max(max, overlap2.length);
    }, 0);
  }
};
var utilExports = util$8.exports;
var forge$r = forge$t;
forge$r.cipher = forge$r.cipher || {};
forge$r.cipher.algorithms = forge$r.cipher.algorithms || {};
forge$r.cipher.createCipher = function(algorithm, key3) {
  var api2 = algorithm;
  if (typeof api2 === "string") {
    api2 = forge$r.cipher.getAlgorithm(api2);
    if (api2) {
      api2 = api2();
    }
  }
  if (!api2) {
    throw new Error("Unsupported algorithm: " + algorithm);
  }
  return new forge$r.cipher.BlockCipher({ algorithm: api2, key: key3, decrypt: false });
};
forge$r.cipher.createDecipher = function(algorithm, key3) {
  var api2 = algorithm;
  if (typeof api2 === "string") {
    api2 = forge$r.cipher.getAlgorithm(api2);
    if (api2) {
      api2 = api2();
    }
  }
  if (!api2) {
    throw new Error("Unsupported algorithm: " + algorithm);
  }
  return new forge$r.cipher.BlockCipher({ algorithm: api2, key: key3, decrypt: true });
};
forge$r.cipher.registerAlgorithm = function(name2, algorithm) {
  name2 = name2.toUpperCase();
  forge$r.cipher.algorithms[name2] = algorithm;
};
forge$r.cipher.getAlgorithm = function(name2) {
  name2 = name2.toUpperCase();
  if (name2 in forge$r.cipher.algorithms) {
    return forge$r.cipher.algorithms[name2];
  }
  return null;
};
var BlockCipher = forge$r.cipher.BlockCipher = function(options) {
  this.algorithm = options.algorithm;
  this.mode = this.algorithm.mode;
  this.blockSize = this.mode.blockSize;
  this._finish = false;
  this._input = null;
  this.output = null;
  this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
  this._decrypt = options.decrypt;
  this.algorithm.initialize(options);
};
BlockCipher.prototype.start = function(options) {
  options = options || {};
  var opts = {};
  for (var key3 in options) {
    opts[key3] = options[key3];
  }
  opts.decrypt = this._decrypt;
  this._finish = false;
  this._input = forge$r.util.createBuffer();
  this.output = options.output || forge$r.util.createBuffer();
  this.mode.start(opts);
};
BlockCipher.prototype.update = function(input) {
  if (input) {
    this._input.putBuffer(input);
  }
  while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {
  }
  this._input.compact();
};
BlockCipher.prototype.finish = function(pad2) {
  if (pad2 && (this.mode.name === "ECB" || this.mode.name === "CBC")) {
    this.mode.pad = function(input) {
      return pad2(this.blockSize, input, false);
    };
    this.mode.unpad = function(output) {
      return pad2(this.blockSize, output, true);
    };
  }
  var options = {};
  options.decrypt = this._decrypt;
  options.overflow = this._input.length() % this.blockSize;
  if (!this._decrypt && this.mode.pad) {
    if (!this.mode.pad(this._input, options)) {
      return false;
    }
  }
  this._finish = true;
  this.update();
  if (this._decrypt && this.mode.unpad) {
    if (!this.mode.unpad(this.output, options)) {
      return false;
    }
  }
  if (this.mode.afterFinish) {
    if (!this.mode.afterFinish(this.output, options)) {
      return false;
    }
  }
  return true;
};
var forge$q = forge$t;
forge$q.cipher = forge$q.cipher || {};
var modes = forge$q.cipher.modes = forge$q.cipher.modes || {};
modes.ecb = function(options) {
  options = options || {};
  this.name = "ECB";
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = new Array(this._ints);
  this._outBlock = new Array(this._ints);
};
modes.ecb.prototype.start = function(options) {
};
modes.ecb.prototype.encrypt = function(input, output, finish2) {
  if (input.length() < this.blockSize && !(finish2 && input.length() > 0)) {
    return true;
  }
  for (var i2 = 0; i2 < this._ints; ++i2) {
    this._inBlock[i2] = input.getInt32();
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  for (var i2 = 0; i2 < this._ints; ++i2) {
    output.putInt32(this._outBlock[i2]);
  }
};
modes.ecb.prototype.decrypt = function(input, output, finish2) {
  if (input.length() < this.blockSize && !(finish2 && input.length() > 0)) {
    return true;
  }
  for (var i2 = 0; i2 < this._ints; ++i2) {
    this._inBlock[i2] = input.getInt32();
  }
  this.cipher.decrypt(this._inBlock, this._outBlock);
  for (var i2 = 0; i2 < this._ints; ++i2) {
    output.putInt32(this._outBlock[i2]);
  }
};
modes.ecb.prototype.pad = function(input, options) {
  var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
  input.fillWithByte(padding, padding);
  return true;
};
modes.ecb.prototype.unpad = function(output, options) {
  if (options.overflow > 0) {
    return false;
  }
  var len2 = output.length();
  var count = output.at(len2 - 1);
  if (count > this.blockSize << 2) {
    return false;
  }
  output.truncate(count);
  return true;
};
modes.cbc = function(options) {
  options = options || {};
  this.name = "CBC";
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = new Array(this._ints);
  this._outBlock = new Array(this._ints);
};
modes.cbc.prototype.start = function(options) {
  if (options.iv === null) {
    if (!this._prev) {
      throw new Error("Invalid IV parameter.");
    }
    this._iv = this._prev.slice(0);
  } else if (!("iv" in options)) {
    throw new Error("Invalid IV parameter.");
  } else {
    this._iv = transformIV(options.iv, this.blockSize);
    this._prev = this._iv.slice(0);
  }
};
modes.cbc.prototype.encrypt = function(input, output, finish2) {
  if (input.length() < this.blockSize && !(finish2 && input.length() > 0)) {
    return true;
  }
  for (var i2 = 0; i2 < this._ints; ++i2) {
    this._inBlock[i2] = this._prev[i2] ^ input.getInt32();
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  for (var i2 = 0; i2 < this._ints; ++i2) {
    output.putInt32(this._outBlock[i2]);
  }
  this._prev = this._outBlock;
};
modes.cbc.prototype.decrypt = function(input, output, finish2) {
  if (input.length() < this.blockSize && !(finish2 && input.length() > 0)) {
    return true;
  }
  for (var i2 = 0; i2 < this._ints; ++i2) {
    this._inBlock[i2] = input.getInt32();
  }
  this.cipher.decrypt(this._inBlock, this._outBlock);
  for (var i2 = 0; i2 < this._ints; ++i2) {
    output.putInt32(this._prev[i2] ^ this._outBlock[i2]);
  }
  this._prev = this._inBlock.slice(0);
};
modes.cbc.prototype.pad = function(input, options) {
  var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
  input.fillWithByte(padding, padding);
  return true;
};
modes.cbc.prototype.unpad = function(output, options) {
  if (options.overflow > 0) {
    return false;
  }
  var len2 = output.length();
  var count = output.at(len2 - 1);
  if (count > this.blockSize << 2) {
    return false;
  }
  output.truncate(count);
  return true;
};
modes.cfb = function(options) {
  options = options || {};
  this.name = "CFB";
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = null;
  this._outBlock = new Array(this._ints);
  this._partialBlock = new Array(this._ints);
  this._partialOutput = forge$q.util.createBuffer();
  this._partialBytes = 0;
};
modes.cfb.prototype.start = function(options) {
  if (!("iv" in options)) {
    throw new Error("Invalid IV parameter.");
  }
  this._iv = transformIV(options.iv, this.blockSize);
  this._inBlock = this._iv.slice(0);
  this._partialBytes = 0;
};
modes.cfb.prototype.encrypt = function(input, output, finish2) {
  var inputLength = input.length();
  if (inputLength === 0) {
    return true;
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  if (this._partialBytes === 0 && inputLength >= this.blockSize) {
    for (var i2 = 0; i2 < this._ints; ++i2) {
      this._inBlock[i2] = input.getInt32() ^ this._outBlock[i2];
      output.putInt32(this._inBlock[i2]);
    }
    return;
  }
  var partialBytes = (this.blockSize - inputLength) % this.blockSize;
  if (partialBytes > 0) {
    partialBytes = this.blockSize - partialBytes;
  }
  this._partialOutput.clear();
  for (var i2 = 0; i2 < this._ints; ++i2) {
    this._partialBlock[i2] = input.getInt32() ^ this._outBlock[i2];
    this._partialOutput.putInt32(this._partialBlock[i2]);
  }
  if (partialBytes > 0) {
    input.read -= this.blockSize;
  } else {
    for (var i2 = 0; i2 < this._ints; ++i2) {
      this._inBlock[i2] = this._partialBlock[i2];
    }
  }
  if (this._partialBytes > 0) {
    this._partialOutput.getBytes(this._partialBytes);
  }
  if (partialBytes > 0 && !finish2) {
    output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
    this._partialBytes = partialBytes;
    return true;
  }
  output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
  this._partialBytes = 0;
};
modes.cfb.prototype.decrypt = function(input, output, finish2) {
  var inputLength = input.length();
  if (inputLength === 0) {
    return true;
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  if (this._partialBytes === 0 && inputLength >= this.blockSize) {
    for (var i2 = 0; i2 < this._ints; ++i2) {
      this._inBlock[i2] = input.getInt32();
      output.putInt32(this._inBlock[i2] ^ this._outBlock[i2]);
    }
    return;
  }
  var partialBytes = (this.blockSize - inputLength) % this.blockSize;
  if (partialBytes > 0) {
    partialBytes = this.blockSize - partialBytes;
  }
  this._partialOutput.clear();
  for (var i2 = 0; i2 < this._ints; ++i2) {
    this._partialBlock[i2] = input.getInt32();
    this._partialOutput.putInt32(this._partialBlock[i2] ^ this._outBlock[i2]);
  }
  if (partialBytes > 0) {
    input.read -= this.blockSize;
  } else {
    for (var i2 = 0; i2 < this._ints; ++i2) {
      this._inBlock[i2] = this._partialBlock[i2];
    }
  }
  if (this._partialBytes > 0) {
    this._partialOutput.getBytes(this._partialBytes);
  }
  if (partialBytes > 0 && !finish2) {
    output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
    this._partialBytes = partialBytes;
    return true;
  }
  output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
  this._partialBytes = 0;
};
modes.ofb = function(options) {
  options = options || {};
  this.name = "OFB";
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = null;
  this._outBlock = new Array(this._ints);
  this._partialOutput = forge$q.util.createBuffer();
  this._partialBytes = 0;
};
modes.ofb.prototype.start = function(options) {
  if (!("iv" in options)) {
    throw new Error("Invalid IV parameter.");
  }
  this._iv = transformIV(options.iv, this.blockSize);
  this._inBlock = this._iv.slice(0);
  this._partialBytes = 0;
};
modes.ofb.prototype.encrypt = function(input, output, finish2) {
  var inputLength = input.length();
  if (input.length() === 0) {
    return true;
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  if (this._partialBytes === 0 && inputLength >= this.blockSize) {
    for (var i2 = 0; i2 < this._ints; ++i2) {
      output.putInt32(input.getInt32() ^ this._outBlock[i2]);
      this._inBlock[i2] = this._outBlock[i2];
    }
    return;
  }
  var partialBytes = (this.blockSize - inputLength) % this.blockSize;
  if (partialBytes > 0) {
    partialBytes = this.blockSize - partialBytes;
  }
  this._partialOutput.clear();
  for (var i2 = 0; i2 < this._ints; ++i2) {
    this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
  }
  if (partialBytes > 0) {
    input.read -= this.blockSize;
  } else {
    for (var i2 = 0; i2 < this._ints; ++i2) {
      this._inBlock[i2] = this._outBlock[i2];
    }
  }
  if (this._partialBytes > 0) {
    this._partialOutput.getBytes(this._partialBytes);
  }
  if (partialBytes > 0 && !finish2) {
    output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
    this._partialBytes = partialBytes;
    return true;
  }
  output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
  this._partialBytes = 0;
};
modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;
modes.ctr = function(options) {
  options = options || {};
  this.name = "CTR";
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = null;
  this._outBlock = new Array(this._ints);
  this._partialOutput = forge$q.util.createBuffer();
  this._partialBytes = 0;
};
modes.ctr.prototype.start = function(options) {
  if (!("iv" in options)) {
    throw new Error("Invalid IV parameter.");
  }
  this._iv = transformIV(options.iv, this.blockSize);
  this._inBlock = this._iv.slice(0);
  this._partialBytes = 0;
};
modes.ctr.prototype.encrypt = function(input, output, finish2) {
  var inputLength = input.length();
  if (inputLength === 0) {
    return true;
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  if (this._partialBytes === 0 && inputLength >= this.blockSize) {
    for (var i2 = 0; i2 < this._ints; ++i2) {
      output.putInt32(input.getInt32() ^ this._outBlock[i2]);
    }
  } else {
    var partialBytes = (this.blockSize - inputLength) % this.blockSize;
    if (partialBytes > 0) {
      partialBytes = this.blockSize - partialBytes;
    }
    this._partialOutput.clear();
    for (var i2 = 0; i2 < this._ints; ++i2) {
      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
    }
    if (partialBytes > 0) {
      input.read -= this.blockSize;
    }
    if (this._partialBytes > 0) {
      this._partialOutput.getBytes(this._partialBytes);
    }
    if (partialBytes > 0 && !finish2) {
      output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
      this._partialBytes = partialBytes;
      return true;
    }
    output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
    this._partialBytes = 0;
  }
  inc32(this._inBlock);
};
modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;
modes.gcm = function(options) {
  options = options || {};
  this.name = "GCM";
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = new Array(this._ints);
  this._outBlock = new Array(this._ints);
  this._partialOutput = forge$q.util.createBuffer();
  this._partialBytes = 0;
  this._R = 3774873600;
};
modes.gcm.prototype.start = function(options) {
  if (!("iv" in options)) {
    throw new Error("Invalid IV parameter.");
  }
  var iv = forge$q.util.createBuffer(options.iv);
  this._cipherLength = 0;
  var additionalData;
  if ("additionalData" in options) {
    additionalData = forge$q.util.createBuffer(options.additionalData);
  } else {
    additionalData = forge$q.util.createBuffer();
  }
  if ("tagLength" in options) {
    this._tagLength = options.tagLength;
  } else {
    this._tagLength = 128;
  }
  this._tag = null;
  if (options.decrypt) {
    this._tag = forge$q.util.createBuffer(options.tag).getBytes();
    if (this._tag.length !== this._tagLength / 8) {
      throw new Error("Authentication tag does not match tag length.");
    }
  }
  this._hashBlock = new Array(this._ints);
  this.tag = null;
  this._hashSubkey = new Array(this._ints);
  this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);
  this.componentBits = 4;
  this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
  var ivLength = iv.length();
  if (ivLength === 12) {
    this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];
  } else {
    this._j0 = [0, 0, 0, 0];
    while (iv.length() > 0) {
      this._j0 = this.ghash(this._hashSubkey, this._j0, [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]);
    }
    this._j0 = this.ghash(this._hashSubkey, this._j0, [0, 0].concat(from64To32(ivLength * 8)));
  }
  this._inBlock = this._j0.slice(0);
  inc32(this._inBlock);
  this._partialBytes = 0;
  additionalData = forge$q.util.createBuffer(additionalData);
  this._aDataLength = from64To32(additionalData.length() * 8);
  var overflow = additionalData.length() % this.blockSize;
  if (overflow) {
    additionalData.fillWithByte(0, this.blockSize - overflow);
  }
  this._s = [0, 0, 0, 0];
  while (additionalData.length() > 0) {
    this._s = this.ghash(this._hashSubkey, this._s, [additionalData.getInt32(), additionalData.getInt32(), additionalData.getInt32(), additionalData.getInt32()]);
  }
};
modes.gcm.prototype.encrypt = function(input, output, finish2) {
  var inputLength = input.length();
  if (inputLength === 0) {
    return true;
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  if (this._partialBytes === 0 && inputLength >= this.blockSize) {
    for (var i2 = 0; i2 < this._ints; ++i2) {
      output.putInt32(this._outBlock[i2] ^= input.getInt32());
    }
    this._cipherLength += this.blockSize;
  } else {
    var partialBytes = (this.blockSize - inputLength) % this.blockSize;
    if (partialBytes > 0) {
      partialBytes = this.blockSize - partialBytes;
    }
    this._partialOutput.clear();
    for (var i2 = 0; i2 < this._ints; ++i2) {
      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
    }
    if (partialBytes <= 0 || finish2) {
      if (finish2) {
        var overflow = inputLength % this.blockSize;
        this._cipherLength += overflow;
        this._partialOutput.truncate(this.blockSize - overflow);
      } else {
        this._cipherLength += this.blockSize;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._outBlock[i2] = this._partialOutput.getInt32();
      }
      this._partialOutput.read -= this.blockSize;
    }
    if (this._partialBytes > 0) {
      this._partialOutput.getBytes(this._partialBytes);
    }
    if (partialBytes > 0 && !finish2) {
      input.read -= this.blockSize;
      output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
      this._partialBytes = partialBytes;
      return true;
    }
    output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
    this._partialBytes = 0;
  }
  this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);
  inc32(this._inBlock);
};
modes.gcm.prototype.decrypt = function(input, output, finish2) {
  var inputLength = input.length();
  if (inputLength < this.blockSize && !(finish2 && inputLength > 0)) {
    return true;
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  inc32(this._inBlock);
  this._hashBlock[0] = input.getInt32();
  this._hashBlock[1] = input.getInt32();
  this._hashBlock[2] = input.getInt32();
  this._hashBlock[3] = input.getInt32();
  this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
  for (var i2 = 0; i2 < this._ints; ++i2) {
    output.putInt32(this._outBlock[i2] ^ this._hashBlock[i2]);
  }
  if (inputLength < this.blockSize) {
    this._cipherLength += inputLength % this.blockSize;
  } else {
    this._cipherLength += this.blockSize;
  }
};
modes.gcm.prototype.afterFinish = function(output, options) {
  var rval = true;
  if (options.decrypt && options.overflow) {
    output.truncate(this.blockSize - options.overflow);
  }
  this.tag = forge$q.util.createBuffer();
  var lengths2 = this._aDataLength.concat(from64To32(this._cipherLength * 8));
  this._s = this.ghash(this._hashSubkey, this._s, lengths2);
  var tag = [];
  this.cipher.encrypt(this._j0, tag);
  for (var i2 = 0; i2 < this._ints; ++i2) {
    this.tag.putInt32(this._s[i2] ^ tag[i2]);
  }
  this.tag.truncate(this.tag.length() % (this._tagLength / 8));
  if (options.decrypt && this.tag.bytes() !== this._tag) {
    rval = false;
  }
  return rval;
};
modes.gcm.prototype.multiply = function(x2, y3) {
  var z_i = [0, 0, 0, 0];
  var v_i = y3.slice(0);
  for (var i2 = 0; i2 < 128; ++i2) {
    var x_i = x2[i2 / 32 | 0] & 1 << 31 - i2 % 32;
    if (x_i) {
      z_i[0] ^= v_i[0];
      z_i[1] ^= v_i[1];
      z_i[2] ^= v_i[2];
      z_i[3] ^= v_i[3];
    }
    this.pow(v_i, v_i);
  }
  return z_i;
};
modes.gcm.prototype.pow = function(x2, out) {
  var lsb = x2[3] & 1;
  for (var i2 = 3; i2 > 0; --i2) {
    out[i2] = x2[i2] >>> 1 | (x2[i2 - 1] & 1) << 31;
  }
  out[0] = x2[0] >>> 1;
  if (lsb) {
    out[0] ^= this._R;
  }
};
modes.gcm.prototype.tableMultiply = function(x2) {
  var z2 = [0, 0, 0, 0];
  for (var i2 = 0; i2 < 32; ++i2) {
    var idx = i2 / 8 | 0;
    var x_i = x2[idx] >>> (7 - i2 % 8) * 4 & 15;
    var ah = this._m[i2][x_i];
    z2[0] ^= ah[0];
    z2[1] ^= ah[1];
    z2[2] ^= ah[2];
    z2[3] ^= ah[3];
  }
  return z2;
};
modes.gcm.prototype.ghash = function(h2, y3, x2) {
  y3[0] ^= x2[0];
  y3[1] ^= x2[1];
  y3[2] ^= x2[2];
  y3[3] ^= x2[3];
  return this.tableMultiply(y3);
};
modes.gcm.prototype.generateHashTable = function(h2, bits) {
  var multiplier = 8 / bits;
  var perInt = 4 * multiplier;
  var size = 16 * multiplier;
  var m2 = new Array(size);
  for (var i2 = 0; i2 < size; ++i2) {
    var tmp = [0, 0, 0, 0];
    var idx = i2 / perInt | 0;
    var shft = (perInt - 1 - i2 % perInt) * bits;
    tmp[idx] = 1 << bits - 1 << shft;
    m2[i2] = this.generateSubHashTable(this.multiply(tmp, h2), bits);
  }
  return m2;
};
modes.gcm.prototype.generateSubHashTable = function(mid, bits) {
  var size = 1 << bits;
  var half = size >>> 1;
  var m2 = new Array(size);
  m2[half] = mid.slice(0);
  var i2 = half >>> 1;
  while (i2 > 0) {
    this.pow(m2[2 * i2], m2[i2] = []);
    i2 >>= 1;
  }
  i2 = 2;
  while (i2 < half) {
    for (var j3 = 1; j3 < i2; ++j3) {
      var m_i = m2[i2];
      var m_j = m2[j3];
      m2[i2 + j3] = [m_i[0] ^ m_j[0], m_i[1] ^ m_j[1], m_i[2] ^ m_j[2], m_i[3] ^ m_j[3]];
    }
    i2 *= 2;
  }
  m2[0] = [0, 0, 0, 0];
  for (i2 = half + 1; i2 < size; ++i2) {
    var c3 = m2[i2 ^ half];
    m2[i2] = [mid[0] ^ c3[0], mid[1] ^ c3[1], mid[2] ^ c3[2], mid[3] ^ c3[3]];
  }
  return m2;
};
function transformIV(iv, blockSize) {
  if (typeof iv === "string") {
    iv = forge$q.util.createBuffer(iv);
  }
  if (forge$q.util.isArray(iv) && iv.length > 4) {
    var tmp = iv;
    iv = forge$q.util.createBuffer();
    for (var i2 = 0; i2 < tmp.length; ++i2) {
      iv.putByte(tmp[i2]);
    }
  }
  if (iv.length() < blockSize) {
    throw new Error("Invalid IV length; got " + iv.length() + " bytes and expected " + blockSize + " bytes.");
  }
  if (!forge$q.util.isArray(iv)) {
    var ints = [];
    var blocks2 = blockSize / 4;
    for (var i2 = 0; i2 < blocks2; ++i2) {
      ints.push(iv.getInt32());
    }
    iv = ints;
  }
  return iv;
}
function inc32(block) {
  block[block.length - 1] = block[block.length - 1] + 1 & 4294967295;
}
function from64To32(num) {
  return [num / 4294967296 | 0, num & 4294967295];
}
var forge$p = forge$t;
forge$p.aes = forge$p.aes || {};
forge$p.aes.startEncrypting = function(key3, iv, output, mode) {
  var cipher = _createCipher$1({ key: key3, output, decrypt: false, mode });
  cipher.start(iv);
  return cipher;
};
forge$p.aes.createEncryptionCipher = function(key3, mode) {
  return _createCipher$1({ key: key3, output: null, decrypt: false, mode });
};
forge$p.aes.startDecrypting = function(key3, iv, output, mode) {
  var cipher = _createCipher$1({ key: key3, output, decrypt: true, mode });
  cipher.start(iv);
  return cipher;
};
forge$p.aes.createDecryptionCipher = function(key3, mode) {
  return _createCipher$1({ key: key3, output: null, decrypt: true, mode });
};
forge$p.aes.Algorithm = function(name2, mode) {
  if (!init) {
    initialize();
  }
  var self2 = this;
  self2.name = name2;
  self2.mode = new mode({ blockSize: 16, cipher: { encrypt: function encrypt(inBlock, outBlock) {
    return _updateBlock$1(self2._w, inBlock, outBlock, false);
  }, decrypt: function decrypt(inBlock, outBlock) {
    return _updateBlock$1(self2._w, inBlock, outBlock, true);
  } } });
  self2._init = false;
};
forge$p.aes.Algorithm.prototype.initialize = function(options) {
  if (this._init) {
    return;
  }
  var key3 = options.key;
  var tmp;
  if (typeof key3 === "string" && (key3.length === 16 || key3.length === 24 || key3.length === 32)) {
    key3 = forge$p.util.createBuffer(key3);
  } else if (forge$p.util.isArray(key3) && (key3.length === 16 || key3.length === 24 || key3.length === 32)) {
    tmp = key3;
    key3 = forge$p.util.createBuffer();
    for (var i2 = 0; i2 < tmp.length; ++i2) {
      key3.putByte(tmp[i2]);
    }
  }
  if (!forge$p.util.isArray(key3)) {
    tmp = key3;
    key3 = [];
    var len2 = tmp.length();
    if (len2 === 16 || len2 === 24 || len2 === 32) {
      len2 = len2 >>> 2;
      for (var i2 = 0; i2 < len2; ++i2) {
        key3.push(tmp.getInt32());
      }
    }
  }
  if (!forge$p.util.isArray(key3) || !(key3.length === 4 || key3.length === 6 || key3.length === 8)) {
    throw new Error("Invalid key parameter.");
  }
  var mode = this.mode.name;
  var encryptOp = ["CFB", "OFB", "CTR", "GCM"].indexOf(mode) !== -1;
  this._w = _expandKey(key3, options.decrypt && !encryptOp);
  this._init = true;
};
forge$p.aes._expandKey = function(key3, decrypt) {
  if (!init) {
    initialize();
  }
  return _expandKey(key3, decrypt);
};
forge$p.aes._updateBlock = _updateBlock$1;
registerAlgorithm$1("AES-ECB", forge$p.cipher.modes.ecb);
registerAlgorithm$1("AES-CBC", forge$p.cipher.modes.cbc);
registerAlgorithm$1("AES-CFB", forge$p.cipher.modes.cfb);
registerAlgorithm$1("AES-OFB", forge$p.cipher.modes.ofb);
registerAlgorithm$1("AES-CTR", forge$p.cipher.modes.ctr);
registerAlgorithm$1("AES-GCM", forge$p.cipher.modes.gcm);
function registerAlgorithm$1(name2, mode) {
  var factory2 = function factory3() {
    return new forge$p.aes.Algorithm(name2, mode);
  };
  forge$p.cipher.registerAlgorithm(name2, factory2);
}
var init = false;
var Nb = 4;
var sbox;
var isbox;
var rcon;
var mix;
var imix;
function initialize() {
  init = true;
  rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
  var xtime = new Array(256);
  for (var i2 = 0; i2 < 128; ++i2) {
    xtime[i2] = i2 << 1;
    xtime[i2 + 128] = i2 + 128 << 1 ^ 283;
  }
  sbox = new Array(256);
  isbox = new Array(256);
  mix = new Array(4);
  imix = new Array(4);
  for (var i2 = 0; i2 < 4; ++i2) {
    mix[i2] = new Array(256);
    imix[i2] = new Array(256);
  }
  var e2 = 0, ei = 0, e22, e4, e8, sx, sx2, me, ime;
  for (var i2 = 0; i2 < 256; ++i2) {
    sx = ei ^ ei << 1 ^ ei << 2 ^ ei << 3 ^ ei << 4;
    sx = sx >> 8 ^ sx & 255 ^ 99;
    sbox[e2] = sx;
    isbox[sx] = e2;
    sx2 = xtime[sx];
    e22 = xtime[e2];
    e4 = xtime[e22];
    e8 = xtime[e4];
    me = sx2 << 24 ^ // 2
    sx << 16 ^ // 1
    sx << 8 ^ // 1
    (sx ^ sx2);
    ime = (e22 ^ e4 ^ e8) << 24 ^ // E (14)
    (e2 ^ e8) << 16 ^ // 9
    (e2 ^ e4 ^ e8) << 8 ^ // D (13)
    (e2 ^ e22 ^ e8);
    for (var n2 = 0; n2 < 4; ++n2) {
      mix[n2][e2] = me;
      imix[n2][sx] = ime;
      me = me << 24 | me >>> 8;
      ime = ime << 24 | ime >>> 8;
    }
    if (e2 === 0) {
      e2 = ei = 1;
    } else {
      e2 = e22 ^ xtime[xtime[xtime[e22 ^ e8]]];
      ei ^= xtime[xtime[ei]];
    }
  }
}
function _expandKey(key3, decrypt) {
  var w2 = key3.slice(0);
  var temp, iNk = 1;
  var Nk = w2.length;
  var Nr1 = Nk + 6 + 1;
  var end2 = Nb * Nr1;
  for (var i2 = Nk; i2 < end2; ++i2) {
    temp = w2[i2 - 1];
    if (i2 % Nk === 0) {
      temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ rcon[iNk] << 24;
      iNk++;
    } else if (Nk > 6 && i2 % Nk === 4) {
      temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255];
    }
    w2[i2] = w2[i2 - Nk] ^ temp;
  }
  if (decrypt) {
    var tmp;
    var m0 = imix[0];
    var m1 = imix[1];
    var m2 = imix[2];
    var m3 = imix[3];
    var wnew = w2.slice(0);
    end2 = w2.length;
    for (var i2 = 0, wi = end2 - Nb; i2 < end2; i2 += Nb, wi -= Nb) {
      if (i2 === 0 || i2 === end2 - Nb) {
        wnew[i2] = w2[wi];
        wnew[i2 + 1] = w2[wi + 3];
        wnew[i2 + 2] = w2[wi + 2];
        wnew[i2 + 3] = w2[wi + 1];
      } else {
        for (var n2 = 0; n2 < Nb; ++n2) {
          tmp = w2[wi + n2];
          wnew[i2 + (3 & -n2)] = m0[sbox[tmp >>> 24]] ^ m1[sbox[tmp >>> 16 & 255]] ^ m2[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];
        }
      }
    }
    w2 = wnew;
  }
  return w2;
}
function _updateBlock$1(w2, input, output, decrypt) {
  var Nr = w2.length / 4 - 1;
  var m0, m1, m2, m3, sub;
  if (decrypt) {
    m0 = imix[0];
    m1 = imix[1];
    m2 = imix[2];
    m3 = imix[3];
    sub = isbox;
  } else {
    m0 = mix[0];
    m1 = mix[1];
    m2 = mix[2];
    m3 = mix[3];
    sub = sbox;
  }
  var a2, b3, c3, d2, a22, b22, c22;
  a2 = input[0] ^ w2[0];
  b3 = input[decrypt ? 3 : 1] ^ w2[1];
  c3 = input[2] ^ w2[2];
  d2 = input[decrypt ? 1 : 3] ^ w2[3];
  var i2 = 3;
  for (var round = 1; round < Nr; ++round) {
    a22 = m0[a2 >>> 24] ^ m1[b3 >>> 16 & 255] ^ m2[c3 >>> 8 & 255] ^ m3[d2 & 255] ^ w2[++i2];
    b22 = m0[b3 >>> 24] ^ m1[c3 >>> 16 & 255] ^ m2[d2 >>> 8 & 255] ^ m3[a2 & 255] ^ w2[++i2];
    c22 = m0[c3 >>> 24] ^ m1[d2 >>> 16 & 255] ^ m2[a2 >>> 8 & 255] ^ m3[b3 & 255] ^ w2[++i2];
    d2 = m0[d2 >>> 24] ^ m1[a2 >>> 16 & 255] ^ m2[b3 >>> 8 & 255] ^ m3[c3 & 255] ^ w2[++i2];
    a2 = a22;
    b3 = b22;
    c3 = c22;
  }
  output[0] = sub[a2 >>> 24] << 24 ^ sub[b3 >>> 16 & 255] << 16 ^ sub[c3 >>> 8 & 255] << 8 ^ sub[d2 & 255] ^ w2[++i2];
  output[decrypt ? 3 : 1] = sub[b3 >>> 24] << 24 ^ sub[c3 >>> 16 & 255] << 16 ^ sub[d2 >>> 8 & 255] << 8 ^ sub[a2 & 255] ^ w2[++i2];
  output[2] = sub[c3 >>> 24] << 24 ^ sub[d2 >>> 16 & 255] << 16 ^ sub[a2 >>> 8 & 255] << 8 ^ sub[b3 & 255] ^ w2[++i2];
  output[decrypt ? 1 : 3] = sub[d2 >>> 24] << 24 ^ sub[a2 >>> 16 & 255] << 16 ^ sub[b3 >>> 8 & 255] << 8 ^ sub[c3 & 255] ^ w2[++i2];
}
function _createCipher$1(options) {
  options = options || {};
  var mode = (options.mode || "CBC").toUpperCase();
  var algorithm = "AES-" + mode;
  var cipher;
  if (options.decrypt) {
    cipher = forge$p.cipher.createDecipher(algorithm, options.key);
  } else {
    cipher = forge$p.cipher.createCipher(algorithm, options.key);
  }
  var start = cipher.start;
  cipher.start = function(iv, options2) {
    var output = null;
    if (options2 instanceof forge$p.util.ByteBuffer) {
      output = options2;
      options2 = {};
    }
    options2 = options2 || {};
    options2.output = output;
    options2.iv = iv;
    start.call(cipher, options2);
  };
  return cipher;
}
function base$1(ALPHABET2, name2) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j3 = 0; j3 < BASE_MAP.length; j3++) {
    BASE_MAP[j3] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET2.length; i2++) {
    var x2 = ALPHABET2.charAt(i2);
    var xc = x2.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x2 + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET2.length;
  var LEADER = ALPHABET2.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode7(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length3 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length3) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length3 = i3;
      pbegin++;
    }
    var it2 = size - length3;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET2.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length3 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length3) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length3 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length3;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j4 = zeroes;
    while (it4 !== size) {
      vch[j4++] = b256[it4++];
    }
    return vch;
  }
  function decode6(string2) {
    var buffer2 = decodeUnsafe(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error("Non-".concat(name2, " character"));
  }
  return { encode: encode7, decodeUnsafe, decode: decode6 };
}
var src = base$1;
var _brrp__multiformats_scope_baseX = src;
var coerce = function coerce2(o2) {
  if (o2 instanceof Uint8Array && o2.constructor.name === "Uint8Array")
    return o2;
  if (o2 instanceof ArrayBuffer)
    return new Uint8Array(o2);
  if (ArrayBuffer.isView(o2)) {
    return new Uint8Array(o2.buffer, o2.byteOffset, o2.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var fromString$3 = function fromString$32(str) {
  return new TextEncoder().encode(str);
};
var toString$2 = function toString$22(b3) {
  return new TextDecoder().decode(b3);
};
var Encoder = function() {
  function Encoder2(name2, prefix, baseEncode) {
    _classCallCheck2(this, Encoder2);
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  return _createClass(Encoder2, [{ key: "encode", value: function encode7(bytes) {
    if (bytes instanceof Uint8Array) {
      return "".concat(this.prefix).concat(this.baseEncode(bytes));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  } }]);
}();
var Decoder = function() {
  function Decoder2(name2, prefix, baseDecode) {
    _classCallCheck2(this, Decoder2);
    this.name = name2;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  return _createClass(Decoder2, [{ key: "decode", value: function decode6(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error("Unable to decode multibase string ".concat(JSON.stringify(text), ", ").concat(this.name, " decoder only supports inputs prefixed with ").concat(this.prefix));
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  } }, { key: "or", value: function or(decoder) {
    return _or(this, decoder);
  } }]);
}();
var ComposedDecoder = function() {
  function ComposedDecoder2(decoders2) {
    _classCallCheck2(this, ComposedDecoder2);
    this.decoders = decoders2;
  }
  return _createClass(ComposedDecoder2, [{ key: "or", value: function or(decoder) {
    return _or(this, decoder);
  } }, { key: "decode", value: function decode6(input) {
    var prefix = input[0];
    var decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError("Unable to decode multibase string ".concat(JSON.stringify(input), ", only inputs prefixed with ").concat(Object.keys(this.decoders), " are supported"));
    }
  } }]);
}();
var _or = function _or2(left, right) {
  return new ComposedDecoder(_objectSpread(_objectSpread({}, left.decoders || _defineProperty({}, left.prefix, left)), right.decoders || _defineProperty({}, right.prefix, right)));
};
var Codec = function() {
  function Codec2(name2, prefix, baseEncode, baseDecode) {
    _classCallCheck2(this, Codec2);
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name2, prefix, baseEncode);
    this.decoder = new Decoder(name2, prefix, baseDecode);
  }
  return _createClass(Codec2, [{ key: "encode", value: function encode7(input) {
    return this.encoder.encode(input);
  } }, { key: "decode", value: function decode6(input) {
    return this.decoder.decode(input);
  } }]);
}();
var from$1 = function from$12(_ref59) {
  var name2 = _ref59.name, prefix = _ref59.prefix, encode7 = _ref59.encode, decode6 = _ref59.decode;
  return new Codec(name2, prefix, encode7, decode6);
};
var baseX = function baseX2(_ref60) {
  var prefix = _ref60.prefix, name2 = _ref60.name, alphabet2 = _ref60.alphabet;
  var _brrp__multiformats_s = _brrp__multiformats_scope_baseX(alphabet2, name2), encode7 = _brrp__multiformats_s.encode, _decode = _brrp__multiformats_s.decode;
  return from$1({ prefix, name: name2, encode: encode7, decode: function decode6(text) {
    return coerce(_decode(text));
  } });
};
var decode$3 = function decode$32(string2, alphabet2, bitsPerChar, name2) {
  var codes = {};
  for (var _i55 = 0; _i55 < alphabet2.length; ++_i55) {
    codes[alphabet2[_i55]] = _i55;
  }
  var end2 = string2.length;
  while (string2[end2 - 1] === "=") {
    --end2;
  }
  var out = new Uint8Array(end2 * bitsPerChar / 8 | 0);
  var bits = 0;
  var buffer2 = 0;
  var written = 0;
  for (var _i56 = 0; _i56 < end2; ++_i56) {
    var value = codes[string2[_i56]];
    if (value === void 0) {
      throw new SyntaxError("Non-".concat(name2, " character"));
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode$4 = function encode$42(data, alphabet2, bitsPerChar) {
  var pad2 = alphabet2[alphabet2.length - 1] === "=";
  var mask = (1 << bitsPerChar) - 1;
  var out = "";
  var bits = 0;
  var buffer2 = 0;
  for (var _i57 = 0; _i57 < data.length; ++_i57) {
    buffer2 = buffer2 << 8 | data[_i57];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet2[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad2) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc4648 = function rfc46482(_ref61) {
  var name2 = _ref61.name, prefix = _ref61.prefix, bitsPerChar = _ref61.bitsPerChar, alphabet2 = _ref61.alphabet;
  return from$1({ prefix, name: name2, encode: function encode7(input) {
    return encode$4(input, alphabet2, bitsPerChar);
  }, decode: function decode6(input) {
    return decode$3(input, alphabet2, bitsPerChar, name2);
  } });
};
var identity$3 = from$1({ prefix: "\0", name: "identity", encode: function encode6(buf) {
  return toString$2(buf);
}, decode: function decode5(str) {
  return fromString$3(str);
} });
var identityBase = Object.freeze(Object.defineProperty({ __proto__: null, identity: identity$3 }, Symbol.toStringTag, { value: "Module" }));
var base2 = rfc4648({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var base2$1 = Object.freeze(Object.defineProperty({ __proto__: null, base2 }, Symbol.toStringTag, { value: "Module" }));
var base8 = rfc4648({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var base8$1 = Object.freeze(Object.defineProperty({ __proto__: null, base8 }, Symbol.toStringTag, { value: "Module" }));
var base10 = baseX({ prefix: "9", name: "base10", alphabet: "0123456789" });
var base10$1 = Object.freeze(Object.defineProperty({ __proto__: null, base10 }, Symbol.toStringTag, { value: "Module" }));
var base16 = rfc4648({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var base16upper = rfc4648({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var base16$1 = Object.freeze(Object.defineProperty({ __proto__: null, base16, base16upper }, Symbol.toStringTag, { value: "Module" }));
var base32 = rfc4648({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var base32upper = rfc4648({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var base32pad = rfc4648({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var base32padupper = rfc4648({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var base32hex = rfc4648({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var base32hexupper = rfc4648({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var base32hexpad = rfc4648({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var base32hexpadupper = rfc4648({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var base32z = rfc4648({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var base32$1 = Object.freeze(Object.defineProperty({ __proto__: null, base32, base32hex, base32hexpad, base32hexpadupper, base32hexupper, base32pad, base32padupper, base32upper, base32z }, Symbol.toStringTag, { value: "Module" }));
var base36 = baseX({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var base36upper = baseX({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var base36$1 = Object.freeze(Object.defineProperty({ __proto__: null, base36, base36upper }, Symbol.toStringTag, { value: "Module" }));
var base58btc$1 = baseX({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var base58flickr = baseX({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var base58 = Object.freeze(Object.defineProperty({ __proto__: null, base58btc: base58btc$1, base58flickr }, Symbol.toStringTag, { value: "Module" }));
var base64$4 = rfc4648({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var base64pad = rfc4648({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var base64url$1 = rfc4648({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var base64urlpad = rfc4648({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var base64$5 = Object.freeze(Object.defineProperty({ __proto__: null, base64: base64$4, base64pad, base64url: base64url$1, base64urlpad }, Symbol.toStringTag, { value: "Module" }));
var alphabet = Array.from("");
var alphabetBytesToChars = alphabet.reduce(function(p2, c3, i2) {
  p2[i2] = c3;
  return p2;
}, []);
var alphabetCharsToBytes = alphabet.reduce(function(p2, c3, i2) {
  p2[c3.codePointAt(0)] = i2;
  return p2;
}, []);
function encode$3(data) {
  return data.reduce(function(p2, c3) {
    p2 += alphabetBytesToChars[c3];
    return p2;
  }, "");
}
function decode$2(str) {
  var byts = [];
  var _iterator7 = _createForOfIteratorHelper(str), _step7;
  try {
    for (_iterator7.s(); !(_step7 = _iterator7.n()).done; ) {
      var char = _step7.value;
      var byt = alphabetCharsToBytes[char.codePointAt(0)];
      if (byt === void 0) {
        throw new Error("Non-base256emoji character: ".concat(char));
      }
      byts.push(byt);
    }
  } catch (err) {
    _iterator7.e(err);
  } finally {
    _iterator7.f();
  }
  return new Uint8Array(byts);
}
var base256emoji = from$1({ prefix: "", name: "base256emoji", encode: encode$3, decode: decode$2 });
var base256emoji$1 = Object.freeze(Object.defineProperty({ __proto__: null, base256emoji }, Symbol.toStringTag, { value: "Module" }));
var encode_1 = encode$2;
var MSB = 128;
var REST = 127;
var MSBALL = ~REST;
var INT = Math.pow(2, 31);
function encode$2(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode$2.bytes = offset - oldOffset + 1;
  return out;
}
var decode$1 = read;
var MSB$1 = 128;
var REST$1 = 127;
function read(buf, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b3, l2 = buf.length;
  do {
    if (counter >= l2) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b3 = buf[counter++];
    res += shift < 28 ? (b3 & REST$1) << shift : (b3 & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b3 >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function length2(value) {
  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
var varint = { encode: encode_1, decode: decode$1, encodingLength: length };
var _brrp_varint = varint;
var encodeTo = function encodeTo2(int, target) {
  var offset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  _brrp_varint.encode(int, target, offset);
  return target;
};
var encodingLength = function encodingLength2(int) {
  return _brrp_varint.encodingLength(int);
};
var create$3 = function create$32(code2, digest11) {
  var size = digest11.byteLength;
  var sizeOffset = encodingLength(code2);
  var digestOffset = sizeOffset + encodingLength(size);
  var bytes = new Uint8Array(digestOffset + size);
  encodeTo(code2, bytes, 0);
  encodeTo(size, bytes, sizeOffset);
  bytes.set(digest11, digestOffset);
  return new Digest(code2, size, digest11, bytes);
};
var Digest = _createClass(function Digest2(code2, size, digest11, bytes) {
  _classCallCheck2(this, Digest2);
  this.code = code2;
  this.size = size;
  this.digest = digest11;
  this.bytes = bytes;
});
var from = function from2(_ref62) {
  var name2 = _ref62.name, code2 = _ref62.code, encode7 = _ref62.encode;
  return new Hasher(name2, code2, encode7);
};
var Hasher = function() {
  function Hasher2(name2, code2, encode7) {
    _classCallCheck2(this, Hasher2);
    this.name = name2;
    this.code = code2;
    this.encode = encode7;
  }
  return _createClass(Hasher2, [{ key: "digest", value: function digest11(input) {
    var _this26 = this;
    if (input instanceof Uint8Array) {
      var result = this.encode(input);
      return result instanceof Uint8Array ? create$3(this.code, result) : result.then(function(digest12) {
        return create$3(_this26.code, digest12);
      });
    } else {
      throw Error("Unknown type, must be binary type");
    }
  } }]);
}();
var sha = function sha2(name2) {
  return function() {
    var _ref63 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee55(data) {
      return _regeneratorRuntime().wrap(function _callee55$(_context56) {
        while (1)
          switch (_context56.prev = _context56.next) {
            case 0:
              _context56.t0 = Uint8Array;
              _context56.next = 3;
              return crypto.subtle.digest(name2, data);
            case 3:
              _context56.t1 = _context56.sent;
              return _context56.abrupt("return", new _context56.t0(_context56.t1));
            case 5:
            case "end":
              return _context56.stop();
          }
      }, _callee55);
    }));
    return function(_x86) {
      return _ref63.apply(this, arguments);
    };
  }();
};
var sha256$4 = from({ name: "sha2-256", code: 18, encode: sha("SHA-256") });
var sha512$2 = from({ name: "sha2-512", code: 19, encode: sha("SHA-512") });
var sha2Browser = Object.freeze(Object.defineProperty({ __proto__: null, sha256: sha256$4, sha512: sha512$2 }, Symbol.toStringTag, { value: "Module" }));
var code = 0;
var name$1 = "identity";
var encode$1 = coerce;
var digest = function digest10(input) {
  return create$3(code, encode$1(input));
};
var identity$1 = { code, name: name$1, encode: encode$1, digest };
var identity$2 = Object.freeze(Object.defineProperty({ __proto__: null, identity: identity$1 }, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
var bases = _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, identityBase), base2$1), base8$1), base10$1), base16$1), base32$1), base36$1), base58), base64$5), base256emoji$1);
function asUint8Array(buf) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  return buf;
}
function allocUnsafe() {
  var size = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return asUint8Array(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}
function createCodec(name2, prefix, encode7, decode6) {
  return { name: name2, prefix, encoder: { name: name2, prefix, encode: encode7 }, decoder: { decode: decode6 } };
}
var string = createCodec("utf8", "u", function(buf) {
  var decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf);
}, function(str) {
  var encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
var ascii = createCodec("ascii", "a", function(buf) {
  var string2 = "a";
  for (var _i58 = 0; _i58 < buf.length; _i58++) {
    string2 += String.fromCharCode(buf[_i58]);
  }
  return string2;
}, function(str) {
  str = str.substring(1);
  var buf = allocUnsafe(str.length);
  for (var _i59 = 0; _i59 < str.length; _i59++) {
    buf[_i59] = str.charCodeAt(_i59);
  }
  return buf;
});
var BASES = _objectSpread({ utf8: string, "utf-8": string, hex: bases.base16, latin1: ascii, ascii, binary: ascii }, bases);
function toString(array) {
  var encoding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "utf8";
  var base3 = BASES[encoding];
  if (!base3) {
    throw new Error('Unsupported encoding "'.concat(encoding, '"'));
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base3.encoder.encode(array).substring(1);
}
var toString$1 = Object.freeze(Object.defineProperty({ __proto__: null, toString }, Symbol.toStringTag, { value: "Module" }));
var require$$4$1 = getAugmentedNamespace(toString$1);
function fromString$1(string2) {
  var encoding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "utf8";
  var base3 = BASES[encoding];
  if (!base3) {
    throw new Error('Unsupported encoding "'.concat(encoding, '"'));
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array(globalThis.Buffer.from(string2, "utf-8"));
  }
  return base3.decoder.decode("".concat(base3.prefix).concat(string2));
}
var fromString$2 = Object.freeze(Object.defineProperty({ __proto__: null, fromString: fromString$1 }, Symbol.toStringTag, { value: "Module" }));
var require$$5$1 = getAugmentedNamespace(fromString$2);
var forge$o = forge$t;
var uint8ArrayToString$4 = require$$4$1.toString;
var uint8ArrayFromString$3 = require$$5$1.fromString;
var ciphersBrowser = { createCipheriv: function createCipheriv(mode, key3, iv) {
  var cipher2 = forge$o.cipher.createCipher("AES-CTR", uint8ArrayToString$4(key3, "ascii"));
  cipher2.start({ iv: uint8ArrayToString$4(iv, "ascii") });
  return { update: function update5(data) {
    cipher2.update(forge$o.util.createBuffer(uint8ArrayToString$4(data, "ascii")));
    return uint8ArrayFromString$3(cipher2.output.getBytes(), "ascii");
  } };
}, createDecipheriv: function createDecipheriv(mode, key3, iv) {
  var cipher2 = forge$o.cipher.createDecipher("AES-CTR", uint8ArrayToString$4(key3, "ascii"));
  cipher2.start({ iv: uint8ArrayToString$4(iv, "ascii") });
  return { update: function update5(data) {
    cipher2.update(forge$o.util.createBuffer(uint8ArrayToString$4(data, "ascii")));
    return uint8ArrayFromString$3(cipher2.output.getBytes(), "ascii");
  } };
} };
function assign(obj2, props) {
  for (var _key21 in props) {
    Object.defineProperty(obj2, _key21, { value: props[_key21], enumerable: true, configurable: true });
  }
  return obj2;
}
function createError(err, code2, props) {
  if (!err || typeof err === "string") {
    throw new TypeError("Please pass an Error to err-code");
  }
  if (!props) {
    props = {};
  }
  if (_typeof(code2) === "object") {
    props = code2;
    code2 = "";
  }
  if (code2) {
    props.code = code2;
  }
  try {
    return assign(err, props);
  } catch (_) {
    props.message = err.message;
    props.stack = err.stack;
    var ErrClass = function ErrClass2() {
    };
    ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
    var output = assign(new ErrClass(), props);
    return output;
  }
}
var errCode = createError;
var errcode$6 = errCode;
var CIPHER_MODES = { 16: "aes-128-ctr", 32: "aes-256-ctr" };
var cipherMode$1 = function cipherMode$12(key3) {
  var mode = CIPHER_MODES[key3.length];
  if (!mode) {
    var _modes = Object.entries(CIPHER_MODES).map(function(_ref57) {
      var _ref58 = _slicedToArray(_ref57, 2), k3 = _ref58[0], v2 = _ref58[1];
      return "".concat(k3, " (").concat(v2, ")");
    }).join(" / ");
    throw errcode$6(new Error("Invalid key length ".concat(key3.length, " bytes. Must be ").concat(_modes)), "ERR_INVALID_KEY_LENGTH");
  }
  return mode;
};
var ciphers$2 = ciphersBrowser;
var cipherMode = cipherMode$1;
aes$1.create = function() {
  var _ref64 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee58(key3, iv) {
    var mode, cipher, decipher, res;
    return _regeneratorRuntime().wrap(function _callee58$(_context59) {
      while (1)
        switch (_context59.prev = _context59.next) {
          case 0:
            mode = cipherMode(key3);
            cipher = ciphers$2.createCipheriv(mode, key3, iv);
            decipher = ciphers$2.createDecipheriv(mode, key3, iv);
            res = { encrypt: function encrypt(data) {
              return _asyncToGenerator(_regeneratorRuntime().mark(function _callee56() {
                return _regeneratorRuntime().wrap(function _callee56$(_context57) {
                  while (1)
                    switch (_context57.prev = _context57.next) {
                      case 0:
                        return _context57.abrupt("return", cipher.update(data));
                      case 1:
                      case "end":
                        return _context57.stop();
                    }
                }, _callee56);
              }))();
            }, decrypt: function decrypt(data) {
              return _asyncToGenerator(_regeneratorRuntime().mark(function _callee57() {
                return _regeneratorRuntime().wrap(function _callee57$(_context58) {
                  while (1)
                    switch (_context58.prev = _context58.next) {
                      case 0:
                        return _context58.abrupt("return", decipher.update(data));
                      case 1:
                      case "end":
                        return _context58.stop();
                    }
                }, _callee57);
              }))();
            } };
            return _context59.abrupt("return", res);
          case 5:
          case "end":
            return _context59.stop();
        }
    }, _callee58);
  }));
  return function(_x87, _x88) {
    return _ref64.apply(this, arguments);
  };
}();
var indexMinimal = {};
var minimal$1 = {};
var aspromise = asPromise;
function asPromise(fn, ctx) {
  var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
  while (index < arguments.length)
    params[offset++] = arguments[index++];
  return new Promise(function executor(resolve, reject) {
    params[offset] = function callback(err) {
      if (pending) {
        pending = false;
        if (err)
          reject(err);
        else {
          var params2 = new Array(arguments.length - 1), offset2 = 0;
          while (offset2 < params2.length)
            params2[offset2++] = arguments[offset2];
          resolve.apply(null, params2);
        }
      }
    };
    try {
      fn.apply(ctx || null, params);
    } catch (err) {
      if (pending) {
        pending = false;
        reject(err);
      }
    }
  });
}
var base64$3 = {};
(function(exports) {
  var base642 = exports;
  base642.length = function length3(string2) {
    var p2 = string2.length;
    if (!p2)
      return 0;
    var n2 = 0;
    while (--p2 % 4 > 1 && string2.charAt(p2) === "=")
      ++n2;
    return Math.ceil(string2.length * 3) / 4 - n2;
  };
  var b64 = new Array(64);
  var s64 = new Array(123);
  for (var i2 = 0; i2 < 64; )
    s64[b64[i2] = i2 < 26 ? i2 + 65 : i2 < 52 ? i2 + 71 : i2 < 62 ? i2 - 4 : i2 - 59 | 43] = i2++;
  base642.encode = function encode7(buffer2, start, end2) {
    var parts = null, chunk = [];
    var i3 = 0, j3 = 0, t2;
    while (start < end2) {
      var b3 = buffer2[start++];
      switch (j3) {
        case 0:
          chunk[i3++] = b64[b3 >> 2];
          t2 = (b3 & 3) << 4;
          j3 = 1;
          break;
        case 1:
          chunk[i3++] = b64[t2 | b3 >> 4];
          t2 = (b3 & 15) << 2;
          j3 = 2;
          break;
        case 2:
          chunk[i3++] = b64[t2 | b3 >> 6];
          chunk[i3++] = b64[b3 & 63];
          j3 = 0;
          break;
      }
      if (i3 > 8191) {
        (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
        i3 = 0;
      }
    }
    if (j3) {
      chunk[i3++] = b64[t2];
      chunk[i3++] = 61;
      if (j3 === 1)
        chunk[i3++] = 61;
    }
    if (parts) {
      if (i3)
        parts.push(String.fromCharCode.apply(String, chunk.slice(0, i3)));
      return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i3));
  };
  var invalidEncoding = "invalid encoding";
  base642.decode = function decode6(string2, buffer2, offset) {
    var start = offset;
    var j3 = 0, t2;
    for (var i3 = 0; i3 < string2.length; ) {
      var c3 = string2.charCodeAt(i3++);
      if (c3 === 61 && j3 > 1)
        break;
      if ((c3 = s64[c3]) === void 0)
        throw Error(invalidEncoding);
      switch (j3) {
        case 0:
          t2 = c3;
          j3 = 1;
          break;
        case 1:
          buffer2[offset++] = t2 << 2 | (c3 & 48) >> 4;
          t2 = c3;
          j3 = 2;
          break;
        case 2:
          buffer2[offset++] = (t2 & 15) << 4 | (c3 & 60) >> 2;
          t2 = c3;
          j3 = 3;
          break;
        case 3:
          buffer2[offset++] = (t2 & 3) << 6 | c3;
          j3 = 0;
          break;
      }
    }
    if (j3 === 1)
      throw Error(invalidEncoding);
    return offset - start;
  };
  base642.test = function test3(string2) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string2);
  };
})(base64$3);
var eventemitter = EventEmitter;
function EventEmitter() {
  this._listeners = {};
}
EventEmitter.prototype.on = function on(evt, fn, ctx) {
  (this._listeners[evt] || (this._listeners[evt] = [])).push({ fn, ctx: ctx || this });
  return this;
};
EventEmitter.prototype.off = function off(evt, fn) {
  if (evt === void 0)
    this._listeners = {};
  else {
    if (fn === void 0)
      this._listeners[evt] = [];
    else {
      var listeners = this._listeners[evt];
      for (var i2 = 0; i2 < listeners.length; )
        if (listeners[i2].fn === fn)
          listeners.splice(i2, 1);
        else
          ++i2;
    }
  }
  return this;
};
EventEmitter.prototype.emit = function emit(evt) {
  var listeners = this._listeners[evt];
  if (listeners) {
    var args = [], i2 = 1;
    for (; i2 < arguments.length; )
      args.push(arguments[i2++]);
    for (i2 = 0; i2 < listeners.length; )
      listeners[i2].fn.apply(listeners[i2++].ctx, args);
  }
  return this;
};
var float = factory(factory);
function factory(exports) {
  if (typeof Float32Array !== "undefined")
    (function() {
      var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
      function writeFloat_f32_cpy(val, buf, pos) {
        f32[0] = val;
        buf[pos] = f8b[0];
        buf[pos + 1] = f8b[1];
        buf[pos + 2] = f8b[2];
        buf[pos + 3] = f8b[3];
      }
      function writeFloat_f32_rev(val, buf, pos) {
        f32[0] = val;
        buf[pos] = f8b[3];
        buf[pos + 1] = f8b[2];
        buf[pos + 2] = f8b[1];
        buf[pos + 3] = f8b[0];
      }
      exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
      exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
      function readFloat_f32_cpy(buf, pos) {
        f8b[0] = buf[pos];
        f8b[1] = buf[pos + 1];
        f8b[2] = buf[pos + 2];
        f8b[3] = buf[pos + 3];
        return f32[0];
      }
      function readFloat_f32_rev(buf, pos) {
        f8b[3] = buf[pos];
        f8b[2] = buf[pos + 1];
        f8b[1] = buf[pos + 2];
        f8b[0] = buf[pos + 3];
        return f32[0];
      }
      exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
      exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
    })();
  else
    (function() {
      function writeFloat_ieee754(writeUint, val, buf, pos) {
        var sign = val < 0 ? 1 : 0;
        if (sign)
          val = -val;
        if (val === 0)
          writeUint(1 / val > 0 ? (
            /* positive */
            0
          ) : (
            /* negative 0 */
            2147483648
          ), buf, pos);
        else if (isNaN(val))
          writeUint(2143289344, buf, pos);
        else if (val > 34028234663852886e22)
          writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
        else if (val < 11754943508222875e-54)
          writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
        else {
          var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
          writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
        }
      }
      exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
      exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
      function readFloat_ieee754(readUint, buf, pos) {
        var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
        return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
      }
      exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
      exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
    })();
  if (typeof Float64Array !== "undefined")
    (function() {
      var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
      function writeDouble_f64_cpy(val, buf, pos) {
        f64[0] = val;
        buf[pos] = f8b[0];
        buf[pos + 1] = f8b[1];
        buf[pos + 2] = f8b[2];
        buf[pos + 3] = f8b[3];
        buf[pos + 4] = f8b[4];
        buf[pos + 5] = f8b[5];
        buf[pos + 6] = f8b[6];
        buf[pos + 7] = f8b[7];
      }
      function writeDouble_f64_rev(val, buf, pos) {
        f64[0] = val;
        buf[pos] = f8b[7];
        buf[pos + 1] = f8b[6];
        buf[pos + 2] = f8b[5];
        buf[pos + 3] = f8b[4];
        buf[pos + 4] = f8b[3];
        buf[pos + 5] = f8b[2];
        buf[pos + 6] = f8b[1];
        buf[pos + 7] = f8b[0];
      }
      exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
      exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
      function readDouble_f64_cpy(buf, pos) {
        f8b[0] = buf[pos];
        f8b[1] = buf[pos + 1];
        f8b[2] = buf[pos + 2];
        f8b[3] = buf[pos + 3];
        f8b[4] = buf[pos + 4];
        f8b[5] = buf[pos + 5];
        f8b[6] = buf[pos + 6];
        f8b[7] = buf[pos + 7];
        return f64[0];
      }
      function readDouble_f64_rev(buf, pos) {
        f8b[7] = buf[pos];
        f8b[6] = buf[pos + 1];
        f8b[5] = buf[pos + 2];
        f8b[4] = buf[pos + 3];
        f8b[3] = buf[pos + 4];
        f8b[2] = buf[pos + 5];
        f8b[1] = buf[pos + 6];
        f8b[0] = buf[pos + 7];
        return f64[0];
      }
      exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
      exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
    })();
  else
    (function() {
      function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
        var sign = val < 0 ? 1 : 0;
        if (sign)
          val = -val;
        if (val === 0) {
          writeUint(0, buf, pos + off0);
          writeUint(1 / val > 0 ? (
            /* positive */
            0
          ) : (
            /* negative 0 */
            2147483648
          ), buf, pos + off1);
        } else if (isNaN(val)) {
          writeUint(0, buf, pos + off0);
          writeUint(2146959360, buf, pos + off1);
        } else if (val > 17976931348623157e292) {
          writeUint(0, buf, pos + off0);
          writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
        } else {
          var mantissa;
          if (val < 22250738585072014e-324) {
            mantissa = val / 5e-324;
            writeUint(mantissa >>> 0, buf, pos + off0);
            writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
          } else {
            var exponent = Math.floor(Math.log(val) / Math.LN2);
            if (exponent === 1024)
              exponent = 1023;
            mantissa = val * Math.pow(2, -exponent);
            writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
            writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
          }
        }
      }
      exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
      exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
      function readDouble_ieee754(readUint, off0, off1, buf, pos) {
        var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
        var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
        return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
      }
      exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
      exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
    })();
  return exports;
}
function writeUintLE(val, buf, pos) {
  buf[pos] = val & 255;
  buf[pos + 1] = val >>> 8 & 255;
  buf[pos + 2] = val >>> 16 & 255;
  buf[pos + 3] = val >>> 24;
}
function writeUintBE(val, buf, pos) {
  buf[pos] = val >>> 24;
  buf[pos + 1] = val >>> 16 & 255;
  buf[pos + 2] = val >>> 8 & 255;
  buf[pos + 3] = val & 255;
}
function readUintLE(buf, pos) {
  return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
}
function readUintBE(buf, pos) {
  return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
}
var inquire_1 = inquire;
function inquire(moduleName) {
  try {
    var mod = eval("quire".replace(/^/, "re"))(moduleName);
    if (mod && (mod.length || Object.keys(mod).length))
      return mod;
  } catch (e2) {
  }
  return null;
}
var utf8$2 = {};
(function(exports) {
  var utf82 = exports;
  utf82.length = function utf8_length(string2) {
    var len2 = 0, c3 = 0;
    for (var i2 = 0; i2 < string2.length; ++i2) {
      c3 = string2.charCodeAt(i2);
      if (c3 < 128)
        len2 += 1;
      else if (c3 < 2048)
        len2 += 2;
      else if ((c3 & 64512) === 55296 && (string2.charCodeAt(i2 + 1) & 64512) === 56320) {
        ++i2;
        len2 += 4;
      } else
        len2 += 3;
    }
    return len2;
  };
  utf82.read = function utf8_read(buffer2, start, end2) {
    var len2 = end2 - start;
    if (len2 < 1)
      return "";
    var parts = null, chunk = [], i2 = 0, t2;
    while (start < end2) {
      t2 = buffer2[start++];
      if (t2 < 128)
        chunk[i2++] = t2;
      else if (t2 > 191 && t2 < 224)
        chunk[i2++] = (t2 & 31) << 6 | buffer2[start++] & 63;
      else if (t2 > 239 && t2 < 365) {
        t2 = ((t2 & 7) << 18 | (buffer2[start++] & 63) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63) - 65536;
        chunk[i2++] = 55296 + (t2 >> 10);
        chunk[i2++] = 56320 + (t2 & 1023);
      } else
        chunk[i2++] = (t2 & 15) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63;
      if (i2 > 8191) {
        (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
        i2 = 0;
      }
    }
    if (parts) {
      if (i2)
        parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
      return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i2));
  };
  utf82.write = function utf8_write(string2, buffer2, offset) {
    var start = offset, c1, c22;
    for (var i2 = 0; i2 < string2.length; ++i2) {
      c1 = string2.charCodeAt(i2);
      if (c1 < 128) {
        buffer2[offset++] = c1;
      } else if (c1 < 2048) {
        buffer2[offset++] = c1 >> 6 | 192;
        buffer2[offset++] = c1 & 63 | 128;
      } else if ((c1 & 64512) === 55296 && ((c22 = string2.charCodeAt(i2 + 1)) & 64512) === 56320) {
        c1 = 65536 + ((c1 & 1023) << 10) + (c22 & 1023);
        ++i2;
        buffer2[offset++] = c1 >> 18 | 240;
        buffer2[offset++] = c1 >> 12 & 63 | 128;
        buffer2[offset++] = c1 >> 6 & 63 | 128;
        buffer2[offset++] = c1 & 63 | 128;
      } else {
        buffer2[offset++] = c1 >> 12 | 224;
        buffer2[offset++] = c1 >> 6 & 63 | 128;
        buffer2[offset++] = c1 & 63 | 128;
      }
    }
    return offset - start;
  };
})(utf8$2);
var pool_1 = pool;
function pool(alloc2, slice, size) {
  var SIZE = size || 8192;
  var MAX = SIZE >>> 1;
  var slab = null;
  var offset = SIZE;
  return function pool_alloc(size2) {
    if (size2 < 1 || size2 > MAX)
      return alloc2(size2);
    if (offset + size2 > SIZE) {
      slab = alloc2(SIZE);
      offset = 0;
    }
    var buf = slice.call(slab, offset, offset += size2);
    if (offset & 7)
      offset = (offset | 7) + 1;
    return buf;
  };
}
var longbits;
var hasRequiredLongbits;
function requireLongbits() {
  if (hasRequiredLongbits)
    return longbits;
  hasRequiredLongbits = 1;
  longbits = LongBits2;
  var util2 = requireMinimal();
  function LongBits2(lo, hi) {
    this.lo = lo >>> 0;
    this.hi = hi >>> 0;
  }
  var zero = LongBits2.zero = new LongBits2(0, 0);
  zero.toNumber = function() {
    return 0;
  };
  zero.zzEncode = zero.zzDecode = function() {
    return this;
  };
  zero.length = function() {
    return 1;
  };
  var zeroHash = LongBits2.zeroHash = "\0\0\0\0\0\0\0\0";
  LongBits2.fromNumber = function fromNumber(value) {
    if (value === 0)
      return zero;
    var sign = value < 0;
    if (sign)
      value = -value;
    var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
      hi = ~hi >>> 0;
      lo = ~lo >>> 0;
      if (++lo > 4294967295) {
        lo = 0;
        if (++hi > 4294967295)
          hi = 0;
      }
    }
    return new LongBits2(lo, hi);
  };
  LongBits2.from = function from3(value) {
    if (typeof value === "number")
      return LongBits2.fromNumber(value);
    if (util2.isString(value)) {
      if (util2.Long)
        value = util2.Long.fromString(value);
      else
        return LongBits2.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits2(value.low >>> 0, value.high >>> 0) : zero;
  };
  LongBits2.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
      var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
      if (!lo)
        hi = hi + 1 >>> 0;
      return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  };
  LongBits2.prototype.toLong = function toLong(unsigned) {
    return util2.Long ? new util2.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
  };
  var charCodeAt = String.prototype.charCodeAt;
  LongBits2.fromHash = function fromHash(hash2) {
    if (hash2 === zeroHash)
      return zero;
    return new LongBits2((charCodeAt.call(hash2, 0) | charCodeAt.call(hash2, 1) << 8 | charCodeAt.call(hash2, 2) << 16 | charCodeAt.call(hash2, 3) << 24) >>> 0, (charCodeAt.call(hash2, 4) | charCodeAt.call(hash2, 5) << 8 | charCodeAt.call(hash2, 6) << 16 | charCodeAt.call(hash2, 7) << 24) >>> 0);
  };
  LongBits2.prototype.toHash = function toHash() {
    return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
  };
  LongBits2.prototype.zzEncode = function zzEncode() {
    var mask = this.hi >> 31;
    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo = (this.lo << 1 ^ mask) >>> 0;
    return this;
  };
  LongBits2.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi = (this.hi >>> 1 ^ mask) >>> 0;
    return this;
  };
  LongBits2.prototype.length = function length3() {
    var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
    return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
  };
  return longbits;
}
var hasRequiredMinimal;
function requireMinimal() {
  if (hasRequiredMinimal)
    return minimal$1;
  hasRequiredMinimal = 1;
  (function(exports) {
    var util2 = exports;
    util2.asPromise = aspromise;
    util2.base64 = base64$3;
    util2.EventEmitter = eventemitter;
    util2.float = float;
    util2.inquire = inquire_1;
    util2.utf8 = utf8$2;
    util2.pool = pool_1;
    util2.LongBits = requireLongbits();
    util2.isNode = Boolean(typeof commonjsGlobal !== "undefined" && commonjsGlobal && commonjsGlobal.process && commonjsGlobal.process.versions && commonjsGlobal.process.versions.node);
    util2.global = util2.isNode && commonjsGlobal || typeof window !== "undefined" && window || typeof self !== "undefined" && self || commonjsGlobal;
    util2.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util2.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util2.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util2.isString = function isString2(value) {
      return typeof value === "string" || value instanceof String;
    };
    util2.isObject = function isObject3(value) {
      return value && _typeof(value) === "object";
    };
    util2.isset = /**
    * Checks if a property on a message is considered to be present.
    * @param {Object} obj Plain object or message instance
    * @param {string} prop Property name
    * @returns {boolean} `true` if considered to be present, otherwise `false`
    */
    util2.isSet = function isSet(obj2, prop) {
      var value = obj2[prop];
      if (value != null && obj2.hasOwnProperty(prop))
        return _typeof(value) !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util2.Buffer = function() {
      try {
        var Buffer2 = util2.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch (e2) {
        return null;
      }
    }();
    util2._Buffer_from = null;
    util2._Buffer_allocUnsafe = null;
    util2.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util2.Buffer ? util2._Buffer_allocUnsafe(sizeOrArray) : new util2.Array(sizeOrArray) : util2.Buffer ? util2._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util2.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util2.Long = /* istanbul ignore next */
    util2.global.dcodeIO && /* istanbul ignore next */
    util2.global.dcodeIO.Long || /* istanbul ignore next */
    util2.global.Long || util2.inquire("long");
    util2.key2Re = /^true|false|0|1$/;
    util2.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util2.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util2.longToHash = function longToHash(value) {
      return value ? util2.LongBits.from(value).toHash() : util2.LongBits.zeroHash;
    };
    util2.longFromHash = function longFromHash(hash2, unsigned) {
      var bits = util2.LongBits.fromHash(hash2);
      if (util2.Long)
        return util2.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge2(dst, src2, ifNotSet) {
      for (var keys2 = Object.keys(src2), i2 = 0; i2 < keys2.length; ++i2)
        if (dst[keys2[i2]] === void 0 || !ifNotSet)
          dst[keys2[i2]] = src2[keys2[i2]];
      return dst;
    }
    util2.merge = merge2;
    util2.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name2) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function get5() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge2(this, properties);
      }
      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
      Object.defineProperty(CustomError.prototype, "name", { get: function get5() {
        return name2;
      } });
      CustomError.prototype.toString = function toString3() {
        return this.name + ": " + this.message;
      };
      return CustomError;
    }
    util2.newError = newError;
    util2.ProtocolError = newError("ProtocolError");
    util2.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i2 = 0; i2 < fieldNames.length; ++i2)
        fieldMap[fieldNames[i2]] = 1;
      return function() {
        for (var keys2 = Object.keys(this), i3 = keys2.length - 1; i3 > -1; --i3)
          if (fieldMap[keys2[i3]] === 1 && this[keys2[i3]] !== void 0 && this[keys2[i3]] !== null)
            return keys2[i3];
      };
    };
    util2.oneOfSetter = function setOneOf(fieldNames) {
      return function(name2) {
        for (var i2 = 0; i2 < fieldNames.length; ++i2)
          if (fieldNames[i2] !== name2)
            delete this[fieldNames[i2]];
      };
    };
    util2.toJSONOptions = { longs: String, enums: String, bytes: String, json: true };
    util2._configure = function() {
      var Buffer2 = util2.Buffer;
      if (!Buffer2) {
        util2._Buffer_from = util2._Buffer_allocUnsafe = null;
        return;
      }
      util2._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      };
      util2._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  })(minimal$1);
  return minimal$1;
}
var writer = Writer$1;
var util$6 = requireMinimal();
var BufferWriter$1;
var LongBits$1 = util$6.LongBits;
var base64$2 = util$6.base64;
var utf8$1 = util$6.utf8;
function Op(fn, len2, val) {
  this.fn = fn;
  this.len = len2;
  this.next = void 0;
  this.val = val;
}
function noop() {
}
function State(writer2) {
  this.head = writer2.head;
  this.tail = writer2.tail;
  this.len = writer2.len;
  this.next = writer2.states;
}
function Writer$1() {
  this.len = 0;
  this.head = new Op(noop, 0, 0);
  this.tail = this.head;
  this.states = null;
}
var create$2 = function create4() {
  return util$6.Buffer ? function create_buffer_setup() {
    return (Writer$1.create = function create_buffer() {
      return new BufferWriter$1();
    })();
  } : function create_array3() {
    return new Writer$1();
  };
};
Writer$1.create = create$2();
Writer$1.alloc = function alloc(size) {
  return new util$6.Array(size);
};
if (util$6.Array !== Array)
  Writer$1.alloc = util$6.pool(Writer$1.alloc, util$6.Array.prototype.subarray);
Writer$1.prototype._push = function push(fn, len2, val) {
  this.tail = this.tail.next = new Op(fn, len2, val);
  this.len += len2;
  return this;
};
function writeByte(val, buf, pos) {
  buf[pos] = val & 255;
}
function writeVarint32(val, buf, pos) {
  while (val > 127) {
    buf[pos++] = val & 127 | 128;
    val >>>= 7;
  }
  buf[pos] = val;
}
function VarintOp(len2, val) {
  this.len = len2;
  this.next = void 0;
  this.val = val;
}
VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;
Writer$1.prototype.uint32 = function write_uint32(value) {
  this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
  return this;
};
Writer$1.prototype.int32 = function write_int32(value) {
  return value < 0 ? this._push(writeVarint64, 10, LongBits$1.fromNumber(value)) : this.uint32(value);
};
Writer$1.prototype.sint32 = function write_sint32(value) {
  return this.uint32((value << 1 ^ value >> 31) >>> 0);
};
function writeVarint64(val, buf, pos) {
  while (val.hi) {
    buf[pos++] = val.lo & 127 | 128;
    val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
    val.hi >>>= 7;
  }
  while (val.lo > 127) {
    buf[pos++] = val.lo & 127 | 128;
    val.lo = val.lo >>> 7;
  }
  buf[pos++] = val.lo;
}
Writer$1.prototype.uint64 = function write_uint64(value) {
  var bits = LongBits$1.from(value);
  return this._push(writeVarint64, bits.length(), bits);
};
Writer$1.prototype.int64 = Writer$1.prototype.uint64;
Writer$1.prototype.sint64 = function write_sint64(value) {
  var bits = LongBits$1.from(value).zzEncode();
  return this._push(writeVarint64, bits.length(), bits);
};
Writer$1.prototype.bool = function write_bool(value) {
  return this._push(writeByte, 1, value ? 1 : 0);
};
function writeFixed32(val, buf, pos) {
  buf[pos] = val & 255;
  buf[pos + 1] = val >>> 8 & 255;
  buf[pos + 2] = val >>> 16 & 255;
  buf[pos + 3] = val >>> 24;
}
Writer$1.prototype.fixed32 = function write_fixed32(value) {
  return this._push(writeFixed32, 4, value >>> 0);
};
Writer$1.prototype.sfixed32 = Writer$1.prototype.fixed32;
Writer$1.prototype.fixed64 = function write_fixed64(value) {
  var bits = LongBits$1.from(value);
  return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};
Writer$1.prototype.sfixed64 = Writer$1.prototype.fixed64;
Writer$1.prototype.float = function write_float(value) {
  return this._push(util$6.float.writeFloatLE, 4, value);
};
Writer$1.prototype.double = function write_double(value) {
  return this._push(util$6.float.writeDoubleLE, 8, value);
};
var writeBytes = util$6.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
  buf.set(val, pos);
} : function writeBytes_for(val, buf, pos) {
  for (var i2 = 0; i2 < val.length; ++i2)
    buf[pos + i2] = val[i2];
};
Writer$1.prototype.bytes = function write_bytes(value) {
  var len2 = value.length >>> 0;
  if (!len2)
    return this._push(writeByte, 1, 0);
  if (util$6.isString(value)) {
    var buf = Writer$1.alloc(len2 = base64$2.length(value));
    base64$2.decode(value, buf, 0);
    value = buf;
  }
  return this.uint32(len2)._push(writeBytes, len2, value);
};
Writer$1.prototype.string = function write_string(value) {
  var len2 = utf8$1.length(value);
  return len2 ? this.uint32(len2)._push(utf8$1.write, len2, value) : this._push(writeByte, 1, 0);
};
Writer$1.prototype.fork = function fork() {
  this.states = new State(this);
  this.head = this.tail = new Op(noop, 0, 0);
  this.len = 0;
  return this;
};
Writer$1.prototype.reset = function reset() {
  if (this.states) {
    this.head = this.states.head;
    this.tail = this.states.tail;
    this.len = this.states.len;
    this.states = this.states.next;
  } else {
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
  }
  return this;
};
Writer$1.prototype.ldelim = function ldelim() {
  var head = this.head, tail = this.tail, len2 = this.len;
  this.reset().uint32(len2);
  if (len2) {
    this.tail.next = head.next;
    this.tail = tail;
    this.len += len2;
  }
  return this;
};
Writer$1.prototype.finish = function finish() {
  var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
  while (head) {
    head.fn(head.val, buf, pos);
    pos += head.len;
    head = head.next;
  }
  return buf;
};
Writer$1._configure = function(BufferWriter_) {
  BufferWriter$1 = BufferWriter_;
  Writer$1.create = create$2();
  BufferWriter$1._configure();
};
var writer_buffer = BufferWriter;
var Writer = writer;
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
var util$5 = requireMinimal();
function BufferWriter() {
  Writer.call(this);
}
BufferWriter._configure = function() {
  BufferWriter.alloc = util$5._Buffer_allocUnsafe;
  BufferWriter.writeBytesBuffer = util$5.Buffer && util$5.Buffer.prototype instanceof Uint8Array && util$5.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
    buf.set(val, pos);
  } : function writeBytesBuffer_copy(val, buf, pos) {
    if (val.copy)
      val.copy(buf, pos, 0, val.length);
    else
      for (var i2 = 0; i2 < val.length; )
        buf[pos++] = val[i2++];
  };
};
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
  if (util$5.isString(value))
    value = util$5._Buffer_from(value, "base64");
  var len2 = value.length >>> 0;
  this.uint32(len2);
  if (len2)
    this._push(BufferWriter.writeBytesBuffer, len2, value);
  return this;
};
function writeStringBuffer(val, buf, pos) {
  if (val.length < 40)
    util$5.utf8.write(val, buf, pos);
  else if (buf.utf8Write)
    buf.utf8Write(val, pos);
  else
    buf.write(val, pos);
}
BufferWriter.prototype.string = function write_string_buffer(value) {
  var len2 = util$5.Buffer.byteLength(value);
  this.uint32(len2);
  if (len2)
    this._push(writeStringBuffer, len2, value);
  return this;
};
BufferWriter._configure();
var reader = Reader$1;
var util$4 = requireMinimal();
var BufferReader$1;
var LongBits = util$4.LongBits;
var utf8 = util$4.utf8;
function indexOutOfRange(reader2, writeLength) {
  return RangeError("index out of range: " + reader2.pos + " + " + (writeLength || 1) + " > " + reader2.len);
}
function Reader$1(buffer2) {
  this.buf = buffer2;
  this.pos = 0;
  this.len = buffer2.length;
}
var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer2) {
  if (buffer2 instanceof Uint8Array || Array.isArray(buffer2))
    return new Reader$1(buffer2);
  throw Error("illegal buffer");
} : function create_array2(buffer2) {
  if (Array.isArray(buffer2))
    return new Reader$1(buffer2);
  throw Error("illegal buffer");
};
var create$1 = function create5() {
  return util$4.Buffer ? function create_buffer_setup(buffer2) {
    return (Reader$1.create = function create_buffer(buffer3) {
      return util$4.Buffer.isBuffer(buffer3) ? new BufferReader$1(buffer3) : create_array(buffer3);
    })(buffer2);
  } : create_array;
};
Reader$1.create = create$1();
Reader$1.prototype._slice = util$4.Array.prototype.subarray || /* istanbul ignore next */
util$4.Array.prototype.slice;
Reader$1.prototype.uint32 = /* @__PURE__ */ function read_uint32_setup() {
  var value = 4294967295;
  return function read_uint32() {
    value = (this.buf[this.pos] & 127) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    if ((this.pos += 5) > this.len) {
      this.pos = this.len;
      throw indexOutOfRange(this, 10);
    }
    return value;
  };
}();
Reader$1.prototype.int32 = function read_int32() {
  return this.uint32() | 0;
};
Reader$1.prototype.sint32 = function read_sint32() {
  var value = this.uint32();
  return value >>> 1 ^ -(value & 1) | 0;
};
function readLongVarint() {
  var bits = new LongBits(0, 0);
  var i2 = 0;
  if (this.len - this.pos > 4) {
    for (; i2 < 4; ++i2) {
      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
    }
    bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
    bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
    if (this.buf[this.pos++] < 128)
      return bits;
    i2 = 0;
  } else {
    for (; i2 < 3; ++i2) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
    }
    bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i2 * 7) >>> 0;
    return bits;
  }
  if (this.len - this.pos > 4) {
    for (; i2 < 5; ++i2) {
      bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
    }
  } else {
    for (; i2 < 5; ++i2) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
    }
  }
  throw Error("invalid varint encoding");
}
Reader$1.prototype.bool = function read_bool() {
  return this.uint32() !== 0;
};
function readFixed32_end(buf, end2) {
  return (buf[end2 - 4] | buf[end2 - 3] << 8 | buf[end2 - 2] << 16 | buf[end2 - 1] << 24) >>> 0;
}
Reader$1.prototype.fixed32 = function read_fixed32() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4);
};
Reader$1.prototype.sfixed32 = function read_sfixed32() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4) | 0;
};
function readFixed64() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 8);
  return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}
Reader$1.prototype.float = function read_float() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  var value = util$4.float.readFloatLE(this.buf, this.pos);
  this.pos += 4;
  return value;
};
Reader$1.prototype.double = function read_double() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 4);
  var value = util$4.float.readDoubleLE(this.buf, this.pos);
  this.pos += 8;
  return value;
};
Reader$1.prototype.bytes = function read_bytes() {
  var length3 = this.uint32(), start = this.pos, end2 = this.pos + length3;
  if (end2 > this.len)
    throw indexOutOfRange(this, length3);
  this.pos += length3;
  if (Array.isArray(this.buf))
    return this.buf.slice(start, end2);
  return start === end2 ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end2);
};
Reader$1.prototype.string = function read_string() {
  var bytes = this.bytes();
  return utf8.read(bytes, 0, bytes.length);
};
Reader$1.prototype.skip = function skip2(length3) {
  if (typeof length3 === "number") {
    if (this.pos + length3 > this.len)
      throw indexOutOfRange(this, length3);
    this.pos += length3;
  } else {
    do {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
    } while (this.buf[this.pos++] & 128);
  }
  return this;
};
Reader$1.prototype.skipType = function(wireType) {
  switch (wireType) {
    case 0:
      this.skip();
      break;
    case 1:
      this.skip(8);
      break;
    case 2:
      this.skip(this.uint32());
      break;
    case 3:
      while ((wireType = this.uint32() & 7) !== 4) {
        this.skipType(wireType);
      }
      break;
    case 5:
      this.skip(4);
      break;
    default:
      throw Error("invalid wire type " + wireType + " at offset " + this.pos);
  }
  return this;
};
Reader$1._configure = function(BufferReader_) {
  BufferReader$1 = BufferReader_;
  Reader$1.create = create$1();
  BufferReader$1._configure();
  var fn = util$4.Long ? "toLong" : (
    /* istanbul ignore next */
    "toNumber"
  );
  util$4.merge(Reader$1.prototype, { int64: function read_int64() {
    return readLongVarint.call(this)[fn](false);
  }, uint64: function read_uint64() {
    return readLongVarint.call(this)[fn](true);
  }, sint64: function read_sint64() {
    return readLongVarint.call(this).zzDecode()[fn](false);
  }, fixed64: function read_fixed64() {
    return readFixed64.call(this)[fn](true);
  }, sfixed64: function read_sfixed64() {
    return readFixed64.call(this)[fn](false);
  } });
};
var reader_buffer = BufferReader;
var Reader = reader;
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
var util$3 = requireMinimal();
function BufferReader(buffer2) {
  Reader.call(this, buffer2);
}
BufferReader._configure = function() {
  if (util$3.Buffer)
    BufferReader.prototype._slice = util$3.Buffer.prototype.slice;
};
BufferReader.prototype.string = function read_string_buffer() {
  var len2 = this.uint32();
  return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len2, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len2, this.len));
};
BufferReader._configure();
var rpc = {};
var service = Service;
var util$2 = requireMinimal();
(Service.prototype = Object.create(util$2.EventEmitter.prototype)).constructor = Service;
function Service(rpcImpl, requestDelimited, responseDelimited) {
  if (typeof rpcImpl !== "function")
    throw TypeError("rpcImpl must be a function");
  util$2.EventEmitter.call(this);
  this.rpcImpl = rpcImpl;
  this.requestDelimited = Boolean(requestDelimited);
  this.responseDelimited = Boolean(responseDelimited);
}
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
  if (!request)
    throw TypeError("request must be specified");
  var self2 = this;
  if (!callback)
    return util$2.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
  if (!self2.rpcImpl) {
    setTimeout(function() {
      callback(Error("already ended"));
    }, 0);
    return void 0;
  }
  try {
    return self2.rpcImpl(method, requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(), function rpcCallback(err, response) {
      if (err) {
        self2.emit("error", err, method);
        return callback(err);
      }
      if (response === null) {
        self2.end(
          /* endedByRPC */
          true
        );
        return void 0;
      }
      if (!(response instanceof responseCtor)) {
        try {
          response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
        } catch (err2) {
          self2.emit("error", err2, method);
          return callback(err2);
        }
      }
      self2.emit("data", response, method);
      return callback(null, response);
    });
  } catch (err) {
    self2.emit("error", err, method);
    setTimeout(function() {
      callback(err);
    }, 0);
    return void 0;
  }
};
Service.prototype.end = function end(endedByRPC) {
  if (this.rpcImpl) {
    if (!endedByRPC)
      this.rpcImpl(null, null, null);
    this.rpcImpl = null;
    this.emit("end").off();
  }
  return this;
};
(function(exports) {
  var rpc2 = exports;
  rpc2.Service = service;
})(rpc);
var roots = {};
(function(exports) {
  var protobuf = exports;
  protobuf.build = "minimal";
  protobuf.Writer = writer;
  protobuf.BufferWriter = writer_buffer;
  protobuf.Reader = reader;
  protobuf.BufferReader = reader_buffer;
  protobuf.util = requireMinimal();
  protobuf.rpc = rpc;
  protobuf.roots = roots;
  protobuf.configure = configure;
  function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
  }
  configure();
})(indexMinimal);
var minimal = indexMinimal;
var $protobuf = minimal;
var $Reader = $protobuf.Reader;
var $Writer = $protobuf.Writer;
var $util = $protobuf.util;
var $root = $protobuf.roots["libp2p-crypto-keys"] || ($protobuf.roots["libp2p-crypto-keys"] = {});
$root.KeyType = function() {
  var valuesById = {}, values = Object.create(valuesById);
  values[valuesById[0] = "RSA"] = 0;
  values[valuesById[1] = "Ed25519"] = 1;
  values[valuesById[2] = "Secp256k1"] = 2;
  return values;
}();
$root.PublicKey = function() {
  function PublicKey(p2) {
    if (p2) {
      for (var ks = Object.keys(p2), i2 = 0; i2 < ks.length; ++i2)
        if (p2[ks[i2]] != null)
          this[ks[i2]] = p2[ks[i2]];
    }
  }
  PublicKey.prototype.Type = 0;
  PublicKey.prototype.Data = $util.newBuffer([]);
  PublicKey.encode = function encode7(m2, w2) {
    if (!w2)
      w2 = $Writer.create();
    w2.uint32(8).int32(m2.Type);
    w2.uint32(18).bytes(m2.Data);
    return w2;
  };
  PublicKey.decode = function decode6(r2, l2) {
    if (!(r2 instanceof $Reader))
      r2 = $Reader.create(r2);
    var c3 = l2 === void 0 ? r2.len : r2.pos + l2, m2 = new $root.PublicKey();
    while (r2.pos < c3) {
      var t2 = r2.uint32();
      switch (t2 >>> 3) {
        case 1:
          m2.Type = r2.int32();
          break;
        case 2:
          m2.Data = r2.bytes();
          break;
        default:
          r2.skipType(t2 & 7);
          break;
      }
    }
    if (!m2.hasOwnProperty("Type"))
      throw $util.ProtocolError("missing required 'Type'", { instance: m2 });
    if (!m2.hasOwnProperty("Data"))
      throw $util.ProtocolError("missing required 'Data'", { instance: m2 });
    return m2;
  };
  PublicKey.fromObject = function fromObject(d2) {
    if (d2 instanceof $root.PublicKey)
      return d2;
    var m2 = new $root.PublicKey();
    switch (d2.Type) {
      case "RSA":
      case 0:
        m2.Type = 0;
        break;
      case "Ed25519":
      case 1:
        m2.Type = 1;
        break;
      case "Secp256k1":
      case 2:
        m2.Type = 2;
        break;
    }
    if (d2.Data != null) {
      if (typeof d2.Data === "string")
        $util.base64.decode(d2.Data, m2.Data = $util.newBuffer($util.base64.length(d2.Data)), 0);
      else if (d2.Data.length)
        m2.Data = d2.Data;
    }
    return m2;
  };
  PublicKey.toObject = function toObject(m2, o2) {
    if (!o2)
      o2 = {};
    var d2 = {};
    if (o2.defaults) {
      d2.Type = o2.enums === String ? "RSA" : 0;
      if (o2.bytes === String)
        d2.Data = "";
      else {
        d2.Data = [];
        if (o2.bytes !== Array)
          d2.Data = $util.newBuffer(d2.Data);
      }
    }
    if (m2.Type != null && m2.hasOwnProperty("Type")) {
      d2.Type = o2.enums === String ? $root.KeyType[m2.Type] : m2.Type;
    }
    if (m2.Data != null && m2.hasOwnProperty("Data")) {
      d2.Data = o2.bytes === String ? $util.base64.encode(m2.Data, 0, m2.Data.length) : o2.bytes === Array ? Array.prototype.slice.call(m2.Data) : m2.Data;
    }
    return d2;
  };
  PublicKey.prototype.toJSON = function toJSON2() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };
  return PublicKey;
}();
$root.PrivateKey = function() {
  function PrivateKey(p2) {
    if (p2) {
      for (var ks = Object.keys(p2), i2 = 0; i2 < ks.length; ++i2)
        if (p2[ks[i2]] != null)
          this[ks[i2]] = p2[ks[i2]];
    }
  }
  PrivateKey.prototype.Type = 0;
  PrivateKey.prototype.Data = $util.newBuffer([]);
  PrivateKey.encode = function encode7(m2, w2) {
    if (!w2)
      w2 = $Writer.create();
    w2.uint32(8).int32(m2.Type);
    w2.uint32(18).bytes(m2.Data);
    return w2;
  };
  PrivateKey.decode = function decode6(r2, l2) {
    if (!(r2 instanceof $Reader))
      r2 = $Reader.create(r2);
    var c3 = l2 === void 0 ? r2.len : r2.pos + l2, m2 = new $root.PrivateKey();
    while (r2.pos < c3) {
      var t2 = r2.uint32();
      switch (t2 >>> 3) {
        case 1:
          m2.Type = r2.int32();
          break;
        case 2:
          m2.Data = r2.bytes();
          break;
        default:
          r2.skipType(t2 & 7);
          break;
      }
    }
    if (!m2.hasOwnProperty("Type"))
      throw $util.ProtocolError("missing required 'Type'", { instance: m2 });
    if (!m2.hasOwnProperty("Data"))
      throw $util.ProtocolError("missing required 'Data'", { instance: m2 });
    return m2;
  };
  PrivateKey.fromObject = function fromObject(d2) {
    if (d2 instanceof $root.PrivateKey)
      return d2;
    var m2 = new $root.PrivateKey();
    switch (d2.Type) {
      case "RSA":
      case 0:
        m2.Type = 0;
        break;
      case "Ed25519":
      case 1:
        m2.Type = 1;
        break;
      case "Secp256k1":
      case 2:
        m2.Type = 2;
        break;
    }
    if (d2.Data != null) {
      if (typeof d2.Data === "string")
        $util.base64.decode(d2.Data, m2.Data = $util.newBuffer($util.base64.length(d2.Data)), 0);
      else if (d2.Data.length)
        m2.Data = d2.Data;
    }
    return m2;
  };
  PrivateKey.toObject = function toObject(m2, o2) {
    if (!o2)
      o2 = {};
    var d2 = {};
    if (o2.defaults) {
      d2.Type = o2.enums === String ? "RSA" : 0;
      if (o2.bytes === String)
        d2.Data = "";
      else {
        d2.Data = [];
        if (o2.bytes !== Array)
          d2.Data = $util.newBuffer(d2.Data);
      }
    }
    if (m2.Type != null && m2.hasOwnProperty("Type")) {
      d2.Type = o2.enums === String ? $root.KeyType[m2.Type] : m2.Type;
    }
    if (m2.Data != null && m2.hasOwnProperty("Data")) {
      d2.Data = o2.bytes === String ? $util.base64.encode(m2.Data, 0, m2.Data.length) : o2.bytes === Array ? Array.prototype.slice.call(m2.Data) : m2.Data;
    }
    return d2;
  };
  PrivateKey.prototype.toJSON = function toJSON2() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };
  return PrivateKey;
}();
var keys$2 = $root;
var forge$n = forge$t;
forge$n.pki = forge$n.pki || {};
var oids$1 = forge$n.pki.oids = forge$n.oids = forge$n.oids || {};
function _IN(id, name2) {
  oids$1[id] = name2;
  oids$1[name2] = id;
}
function _I_(id, name2) {
  oids$1[id] = name2;
}
_IN("1.2.840.113549.1.1.1", "rsaEncryption");
_IN("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
_IN("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
_IN("1.2.840.113549.1.1.7", "RSAES-OAEP");
_IN("1.2.840.113549.1.1.8", "mgf1");
_IN("1.2.840.113549.1.1.9", "pSpecified");
_IN("1.2.840.113549.1.1.10", "RSASSA-PSS");
_IN("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
_IN("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
_IN("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
_IN("1.3.101.112", "EdDSA25519");
_IN("1.2.840.10040.4.3", "dsa-with-sha1");
_IN("1.3.14.3.2.7", "desCBC");
_IN("1.3.14.3.2.26", "sha1");
_IN("2.16.840.1.101.3.4.2.1", "sha256");
_IN("2.16.840.1.101.3.4.2.2", "sha384");
_IN("2.16.840.1.101.3.4.2.3", "sha512");
_IN("1.2.840.113549.2.5", "md5");
_IN("1.2.840.113549.1.7.1", "data");
_IN("1.2.840.113549.1.7.2", "signedData");
_IN("1.2.840.113549.1.7.3", "envelopedData");
_IN("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
_IN("1.2.840.113549.1.7.5", "digestedData");
_IN("1.2.840.113549.1.7.6", "encryptedData");
_IN("1.2.840.113549.1.9.1", "emailAddress");
_IN("1.2.840.113549.1.9.2", "unstructuredName");
_IN("1.2.840.113549.1.9.3", "contentType");
_IN("1.2.840.113549.1.9.4", "messageDigest");
_IN("1.2.840.113549.1.9.5", "signingTime");
_IN("1.2.840.113549.1.9.6", "counterSignature");
_IN("1.2.840.113549.1.9.7", "challengePassword");
_IN("1.2.840.113549.1.9.8", "unstructuredAddress");
_IN("1.2.840.113549.1.9.14", "extensionRequest");
_IN("1.2.840.113549.1.9.20", "friendlyName");
_IN("1.2.840.113549.1.9.21", "localKeyId");
_IN("1.2.840.113549.1.9.22.1", "x509Certificate");
_IN("1.2.840.113549.1.12.10.1.1", "keyBag");
_IN("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
_IN("1.2.840.113549.1.12.10.1.3", "certBag");
_IN("1.2.840.113549.1.12.10.1.4", "crlBag");
_IN("1.2.840.113549.1.12.10.1.5", "secretBag");
_IN("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
_IN("1.2.840.113549.1.5.13", "pkcs5PBES2");
_IN("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
_IN("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
_IN("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
_IN("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
_IN("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
_IN("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
_IN("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
_IN("1.2.840.113549.2.7", "hmacWithSHA1");
_IN("1.2.840.113549.2.8", "hmacWithSHA224");
_IN("1.2.840.113549.2.9", "hmacWithSHA256");
_IN("1.2.840.113549.2.10", "hmacWithSHA384");
_IN("1.2.840.113549.2.11", "hmacWithSHA512");
_IN("1.2.840.113549.3.7", "des-EDE3-CBC");
_IN("2.16.840.1.101.3.4.1.2", "aes128-CBC");
_IN("2.16.840.1.101.3.4.1.22", "aes192-CBC");
_IN("2.16.840.1.101.3.4.1.42", "aes256-CBC");
_IN("2.5.4.3", "commonName");
_IN("2.5.4.5", "serialName");
_IN("2.5.4.6", "countryName");
_IN("2.5.4.7", "localityName");
_IN("2.5.4.8", "stateOrProvinceName");
_IN("2.5.4.9", "streetAddress");
_IN("2.5.4.10", "organizationName");
_IN("2.5.4.11", "organizationalUnitName");
_IN("2.5.4.13", "description");
_IN("2.5.4.15", "businessCategory");
_IN("2.5.4.17", "postalCode");
_IN("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
_IN("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
_IN("2.16.840.1.113730.1.1", "nsCertType");
_IN("2.16.840.1.113730.1.13", "nsComment");
_I_("2.5.29.1", "authorityKeyIdentifier");
_I_("2.5.29.2", "keyAttributes");
_I_("2.5.29.3", "certificatePolicies");
_I_("2.5.29.4", "keyUsageRestriction");
_I_("2.5.29.5", "policyMapping");
_I_("2.5.29.6", "subtreesConstraint");
_I_("2.5.29.7", "subjectAltName");
_I_("2.5.29.8", "issuerAltName");
_I_("2.5.29.9", "subjectDirectoryAttributes");
_I_("2.5.29.10", "basicConstraints");
_I_("2.5.29.11", "nameConstraints");
_I_("2.5.29.12", "policyConstraints");
_I_("2.5.29.13", "basicConstraints");
_IN("2.5.29.14", "subjectKeyIdentifier");
_IN("2.5.29.15", "keyUsage");
_I_("2.5.29.16", "privateKeyUsagePeriod");
_IN("2.5.29.17", "subjectAltName");
_IN("2.5.29.18", "issuerAltName");
_IN("2.5.29.19", "basicConstraints");
_I_("2.5.29.20", "cRLNumber");
_I_("2.5.29.21", "cRLReason");
_I_("2.5.29.22", "expirationDate");
_I_("2.5.29.23", "instructionCode");
_I_("2.5.29.24", "invalidityDate");
_I_("2.5.29.25", "cRLDistributionPoints");
_I_("2.5.29.26", "issuingDistributionPoint");
_I_("2.5.29.27", "deltaCRLIndicator");
_I_("2.5.29.28", "issuingDistributionPoint");
_I_("2.5.29.29", "certificateIssuer");
_I_("2.5.29.30", "nameConstraints");
_IN("2.5.29.31", "cRLDistributionPoints");
_IN("2.5.29.32", "certificatePolicies");
_I_("2.5.29.33", "policyMappings");
_I_("2.5.29.34", "policyConstraints");
_IN("2.5.29.35", "authorityKeyIdentifier");
_I_("2.5.29.36", "policyConstraints");
_IN("2.5.29.37", "extKeyUsage");
_I_("2.5.29.46", "freshestCRL");
_I_("2.5.29.54", "inhibitAnyPolicy");
_IN("1.3.6.1.4.1.11129.2.4.2", "timestampList");
_IN("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
_IN("1.3.6.1.5.5.7.3.1", "serverAuth");
_IN("1.3.6.1.5.5.7.3.2", "clientAuth");
_IN("1.3.6.1.5.5.7.3.3", "codeSigning");
_IN("1.3.6.1.5.5.7.3.4", "emailProtection");
_IN("1.3.6.1.5.5.7.3.8", "timeStamping");
var forge$m = forge$t;
var asn1$3 = forge$m.asn1 = forge$m.asn1 || {};
asn1$3.Class = { UNIVERSAL: 0, APPLICATION: 64, CONTEXT_SPECIFIC: 128, PRIVATE: 192 };
asn1$3.Type = { NONE: 0, BOOLEAN: 1, INTEGER: 2, BITSTRING: 3, OCTETSTRING: 4, NULL: 5, OID: 6, ODESC: 7, EXTERNAL: 8, REAL: 9, ENUMERATED: 10, EMBEDDED: 11, UTF8: 12, ROID: 13, SEQUENCE: 16, SET: 17, PRINTABLESTRING: 19, IA5STRING: 22, UTCTIME: 23, GENERALIZEDTIME: 24, BMPSTRING: 30 };
asn1$3.create = function(tagClass, type, constructed, value, options) {
  if (forge$m.util.isArray(value)) {
    var tmp = [];
    for (var i2 = 0; i2 < value.length; ++i2) {
      if (value[i2] !== void 0) {
        tmp.push(value[i2]);
      }
    }
    value = tmp;
  }
  var obj2 = { tagClass, type, constructed, composed: constructed || forge$m.util.isArray(value), value };
  if (options && "bitStringContents" in options) {
    obj2.bitStringContents = options.bitStringContents;
    obj2.original = asn1$3.copy(obj2);
  }
  return obj2;
};
asn1$3.copy = function(obj2, options) {
  var copy;
  if (forge$m.util.isArray(obj2)) {
    copy = [];
    for (var i2 = 0; i2 < obj2.length; ++i2) {
      copy.push(asn1$3.copy(obj2[i2], options));
    }
    return copy;
  }
  if (typeof obj2 === "string") {
    return obj2;
  }
  copy = { tagClass: obj2.tagClass, type: obj2.type, constructed: obj2.constructed, composed: obj2.composed, value: asn1$3.copy(obj2.value, options) };
  if (options && !options.excludeBitStringContents) {
    copy.bitStringContents = obj2.bitStringContents;
  }
  return copy;
};
asn1$3.equals = function(obj1, obj2, options) {
  if (forge$m.util.isArray(obj1)) {
    if (!forge$m.util.isArray(obj2)) {
      return false;
    }
    if (obj1.length !== obj2.length) {
      return false;
    }
    for (var i2 = 0; i2 < obj1.length; ++i2) {
      if (!asn1$3.equals(obj1[i2], obj2[i2])) {
        return false;
      }
    }
    return true;
  }
  if (_typeof(obj1) !== _typeof(obj2)) {
    return false;
  }
  if (typeof obj1 === "string") {
    return obj1 === obj2;
  }
  var equal = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn1$3.equals(obj1.value, obj2.value);
  if (options && options.includeBitStringContents) {
    equal = equal && obj1.bitStringContents === obj2.bitStringContents;
  }
  return equal;
};
asn1$3.getBerValueLength = function(b3) {
  var b22 = b3.getByte();
  if (b22 === 128) {
    return void 0;
  }
  var length3;
  var longForm = b22 & 128;
  if (!longForm) {
    length3 = b22;
  } else {
    length3 = b3.getInt((b22 & 127) << 3);
  }
  return length3;
};
function _checkBufferLength(bytes, remaining, n2) {
  if (n2 > remaining) {
    var error3 = new Error("Too few bytes to parse DER.");
    error3.available = bytes.length();
    error3.remaining = remaining;
    error3.requested = n2;
    throw error3;
  }
}
var _getValueLength = function _getValueLength2(bytes, remaining) {
  var b22 = bytes.getByte();
  remaining--;
  if (b22 === 128) {
    return void 0;
  }
  var length3;
  var longForm = b22 & 128;
  if (!longForm) {
    length3 = b22;
  } else {
    var longFormBytes = b22 & 127;
    _checkBufferLength(bytes, remaining, longFormBytes);
    length3 = bytes.getInt(longFormBytes << 3);
  }
  if (length3 < 0) {
    throw new Error("Negative length: " + length3);
  }
  return length3;
};
asn1$3.fromDer = function(bytes, options) {
  if (options === void 0) {
    options = { strict: true, decodeBitStrings: true };
  }
  if (typeof options === "boolean") {
    options = { strict: options, decodeBitStrings: true };
  }
  if (!("strict" in options)) {
    options.strict = true;
  }
  if (!("decodeBitStrings" in options)) {
    options.decodeBitStrings = true;
  }
  if (typeof bytes === "string") {
    bytes = forge$m.util.createBuffer(bytes);
  }
  return _fromDer(bytes, bytes.length(), 0, options);
};
function _fromDer(bytes, remaining, depth, options) {
  var start;
  _checkBufferLength(bytes, remaining, 2);
  var b1 = bytes.getByte();
  remaining--;
  var tagClass = b1 & 192;
  var type = b1 & 31;
  start = bytes.length();
  var length3 = _getValueLength(bytes, remaining);
  remaining -= start - bytes.length();
  if (length3 !== void 0 && length3 > remaining) {
    if (options.strict) {
      var error3 = new Error("Too few bytes to read ASN.1 value.");
      error3.available = bytes.length();
      error3.remaining = remaining;
      error3.requested = length3;
      throw error3;
    }
    length3 = remaining;
  }
  var value;
  var bitStringContents;
  var constructed = (b1 & 32) === 32;
  if (constructed) {
    value = [];
    if (length3 === void 0) {
      for (; ; ) {
        _checkBufferLength(bytes, remaining, 2);
        if (bytes.bytes(2) === String.fromCharCode(0, 0)) {
          bytes.getBytes(2);
          remaining -= 2;
          break;
        }
        start = bytes.length();
        value.push(_fromDer(bytes, remaining, depth + 1, options));
        remaining -= start - bytes.length();
      }
    } else {
      while (length3 > 0) {
        start = bytes.length();
        value.push(_fromDer(bytes, length3, depth + 1, options));
        remaining -= start - bytes.length();
        length3 -= start - bytes.length();
      }
    }
  }
  if (value === void 0 && tagClass === asn1$3.Class.UNIVERSAL && type === asn1$3.Type.BITSTRING) {
    bitStringContents = bytes.bytes(length3);
  }
  if (value === void 0 && options.decodeBitStrings && tagClass === asn1$3.Class.UNIVERSAL && // FIXME: OCTET STRINGs not yet supported here
  // .. other parts of forge expect to decode OCTET STRINGs manually
  type === asn1$3.Type.BITSTRING && length3 > 1) {
    var savedRead = bytes.read;
    var savedRemaining = remaining;
    var unused = 0;
    if (type === asn1$3.Type.BITSTRING) {
      _checkBufferLength(bytes, remaining, 1);
      unused = bytes.getByte();
      remaining--;
    }
    if (unused === 0) {
      try {
        start = bytes.length();
        var subOptions = {
          // enforce strict mode to avoid parsing ASN.1 from plain data
          verbose: options.verbose,
          strict: true,
          decodeBitStrings: true
        };
        var composed = _fromDer(bytes, remaining, depth + 1, subOptions);
        var used = start - bytes.length();
        remaining -= used;
        if (type == asn1$3.Type.BITSTRING) {
          used++;
        }
        var tc = composed.tagClass;
        if (used === length3 && (tc === asn1$3.Class.UNIVERSAL || tc === asn1$3.Class.CONTEXT_SPECIFIC)) {
          value = [composed];
        }
      } catch (ex) {
      }
    }
    if (value === void 0) {
      bytes.read = savedRead;
      remaining = savedRemaining;
    }
  }
  if (value === void 0) {
    if (length3 === void 0) {
      if (options.strict) {
        throw new Error("Non-constructed ASN.1 object of indefinite length.");
      }
      length3 = remaining;
    }
    if (type === asn1$3.Type.BMPSTRING) {
      value = "";
      for (; length3 > 0; length3 -= 2) {
        _checkBufferLength(bytes, remaining, 2);
        value += String.fromCharCode(bytes.getInt16());
        remaining -= 2;
      }
    } else {
      value = bytes.getBytes(length3);
    }
  }
  var asn1Options = bitStringContents === void 0 ? null : { bitStringContents };
  return asn1$3.create(tagClass, type, constructed, value, asn1Options);
}
asn1$3.toDer = function(obj2) {
  var bytes = forge$m.util.createBuffer();
  var b1 = obj2.tagClass | obj2.type;
  var value = forge$m.util.createBuffer();
  var useBitStringContents = false;
  if ("bitStringContents" in obj2) {
    useBitStringContents = true;
    if (obj2.original) {
      useBitStringContents = asn1$3.equals(obj2, obj2.original);
    }
  }
  if (useBitStringContents) {
    value.putBytes(obj2.bitStringContents);
  } else if (obj2.composed) {
    if (obj2.constructed) {
      b1 |= 32;
    } else {
      value.putByte(0);
    }
    for (var i2 = 0; i2 < obj2.value.length; ++i2) {
      if (obj2.value[i2] !== void 0) {
        value.putBuffer(asn1$3.toDer(obj2.value[i2]));
      }
    }
  } else {
    if (obj2.type === asn1$3.Type.BMPSTRING) {
      for (var i2 = 0; i2 < obj2.value.length; ++i2) {
        value.putInt16(obj2.value.charCodeAt(i2));
      }
    } else {
      if (obj2.type === asn1$3.Type.INTEGER && obj2.value.length > 1 && // leading 0x00 for positive integer
      (obj2.value.charCodeAt(0) === 0 && (obj2.value.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer
      obj2.value.charCodeAt(0) === 255 && (obj2.value.charCodeAt(1) & 128) === 128)) {
        value.putBytes(obj2.value.substr(1));
      } else {
        value.putBytes(obj2.value);
      }
    }
  }
  bytes.putByte(b1);
  if (value.length() <= 127) {
    bytes.putByte(value.length() & 127);
  } else {
    var len2 = value.length();
    var lenBytes = "";
    do {
      lenBytes += String.fromCharCode(len2 & 255);
      len2 = len2 >>> 8;
    } while (len2 > 0);
    bytes.putByte(lenBytes.length | 128);
    for (var i2 = lenBytes.length - 1; i2 >= 0; --i2) {
      bytes.putByte(lenBytes.charCodeAt(i2));
    }
  }
  bytes.putBuffer(value);
  return bytes;
};
asn1$3.oidToDer = function(oid) {
  var values = oid.split(".");
  var bytes = forge$m.util.createBuffer();
  bytes.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));
  var last, valueBytes, value, b3;
  for (var i2 = 2; i2 < values.length; ++i2) {
    last = true;
    valueBytes = [];
    value = parseInt(values[i2], 10);
    do {
      b3 = value & 127;
      value = value >>> 7;
      if (!last) {
        b3 |= 128;
      }
      valueBytes.push(b3);
      last = false;
    } while (value > 0);
    for (var n2 = valueBytes.length - 1; n2 >= 0; --n2) {
      bytes.putByte(valueBytes[n2]);
    }
  }
  return bytes;
};
asn1$3.derToOid = function(bytes) {
  var oid;
  if (typeof bytes === "string") {
    bytes = forge$m.util.createBuffer(bytes);
  }
  var b3 = bytes.getByte();
  oid = Math.floor(b3 / 40) + "." + b3 % 40;
  var value = 0;
  while (bytes.length() > 0) {
    b3 = bytes.getByte();
    value = value << 7;
    if (b3 & 128) {
      value += b3 & 127;
    } else {
      oid += "." + (value + b3);
      value = 0;
    }
  }
  return oid;
};
asn1$3.utcTimeToDate = function(utc) {
  var date = /* @__PURE__ */ new Date();
  var year = parseInt(utc.substr(0, 2), 10);
  year = year >= 50 ? 1900 + year : 2e3 + year;
  var MM = parseInt(utc.substr(2, 2), 10) - 1;
  var DD = parseInt(utc.substr(4, 2), 10);
  var hh = parseInt(utc.substr(6, 2), 10);
  var mm = parseInt(utc.substr(8, 2), 10);
  var ss = 0;
  if (utc.length > 11) {
    var c3 = utc.charAt(10);
    var end2 = 10;
    if (c3 !== "+" && c3 !== "-") {
      ss = parseInt(utc.substr(10, 2), 10);
      end2 += 2;
    }
  }
  date.setUTCFullYear(year, MM, DD);
  date.setUTCHours(hh, mm, ss, 0);
  if (end2) {
    c3 = utc.charAt(end2);
    if (c3 === "+" || c3 === "-") {
      var hhoffset = parseInt(utc.substr(end2 + 1, 2), 10);
      var mmoffset = parseInt(utc.substr(end2 + 4, 2), 10);
      var offset = hhoffset * 60 + mmoffset;
      offset *= 6e4;
      if (c3 === "+") {
        date.setTime(+date - offset);
      } else {
        date.setTime(+date + offset);
      }
    }
  }
  return date;
};
asn1$3.generalizedTimeToDate = function(gentime) {
  var date = /* @__PURE__ */ new Date();
  var YYYY = parseInt(gentime.substr(0, 4), 10);
  var MM = parseInt(gentime.substr(4, 2), 10) - 1;
  var DD = parseInt(gentime.substr(6, 2), 10);
  var hh = parseInt(gentime.substr(8, 2), 10);
  var mm = parseInt(gentime.substr(10, 2), 10);
  var ss = parseInt(gentime.substr(12, 2), 10);
  var fff = 0;
  var offset = 0;
  var isUTC = false;
  if (gentime.charAt(gentime.length - 1) === "Z") {
    isUTC = true;
  }
  var end2 = gentime.length - 5, c3 = gentime.charAt(end2);
  if (c3 === "+" || c3 === "-") {
    var hhoffset = parseInt(gentime.substr(end2 + 1, 2), 10);
    var mmoffset = parseInt(gentime.substr(end2 + 4, 2), 10);
    offset = hhoffset * 60 + mmoffset;
    offset *= 6e4;
    if (c3 === "+") {
      offset *= -1;
    }
    isUTC = true;
  }
  if (gentime.charAt(14) === ".") {
    fff = parseFloat(gentime.substr(14), 10) * 1e3;
  }
  if (isUTC) {
    date.setUTCFullYear(YYYY, MM, DD);
    date.setUTCHours(hh, mm, ss, fff);
    date.setTime(+date + offset);
  } else {
    date.setFullYear(YYYY, MM, DD);
    date.setHours(hh, mm, ss, fff);
  }
  return date;
};
asn1$3.dateToUtcTime = function(date) {
  if (typeof date === "string") {
    return date;
  }
  var rval = "";
  var format = [];
  format.push(("" + date.getUTCFullYear()).substr(2));
  format.push("" + (date.getUTCMonth() + 1));
  format.push("" + date.getUTCDate());
  format.push("" + date.getUTCHours());
  format.push("" + date.getUTCMinutes());
  format.push("" + date.getUTCSeconds());
  for (var i2 = 0; i2 < format.length; ++i2) {
    if (format[i2].length < 2) {
      rval += "0";
    }
    rval += format[i2];
  }
  rval += "Z";
  return rval;
};
asn1$3.dateToGeneralizedTime = function(date) {
  if (typeof date === "string") {
    return date;
  }
  var rval = "";
  var format = [];
  format.push("" + date.getUTCFullYear());
  format.push("" + (date.getUTCMonth() + 1));
  format.push("" + date.getUTCDate());
  format.push("" + date.getUTCHours());
  format.push("" + date.getUTCMinutes());
  format.push("" + date.getUTCSeconds());
  for (var i2 = 0; i2 < format.length; ++i2) {
    if (format[i2].length < 2) {
      rval += "0";
    }
    rval += format[i2];
  }
  rval += "Z";
  return rval;
};
asn1$3.integerToDer = function(x2) {
  var rval = forge$m.util.createBuffer();
  if (x2 >= -128 && x2 < 128) {
    return rval.putSignedInt(x2, 8);
  }
  if (x2 >= -32768 && x2 < 32768) {
    return rval.putSignedInt(x2, 16);
  }
  if (x2 >= -8388608 && x2 < 8388608) {
    return rval.putSignedInt(x2, 24);
  }
  if (x2 >= -2147483648 && x2 < 2147483648) {
    return rval.putSignedInt(x2, 32);
  }
  var error3 = new Error("Integer too large; max is 32-bits.");
  error3.integer = x2;
  throw error3;
};
asn1$3.derToInteger = function(bytes) {
  if (typeof bytes === "string") {
    bytes = forge$m.util.createBuffer(bytes);
  }
  var n2 = bytes.length() * 8;
  if (n2 > 32) {
    throw new Error("Integer too large; max is 32-bits.");
  }
  return bytes.getSignedInt(n2);
};
asn1$3.validate = function(obj2, v2, capture, errors) {
  var rval = false;
  if ((obj2.tagClass === v2.tagClass || typeof v2.tagClass === "undefined") && (obj2.type === v2.type || typeof v2.type === "undefined")) {
    if (obj2.constructed === v2.constructed || typeof v2.constructed === "undefined") {
      rval = true;
      if (v2.value && forge$m.util.isArray(v2.value)) {
        var j3 = 0;
        for (var i2 = 0; rval && i2 < v2.value.length; ++i2) {
          rval = v2.value[i2].optional || false;
          if (obj2.value[j3]) {
            rval = asn1$3.validate(obj2.value[j3], v2.value[i2], capture, errors);
            if (rval) {
              ++j3;
            } else if (v2.value[i2].optional) {
              rval = true;
            }
          }
          if (!rval && errors) {
            errors.push("[" + v2.name + '] Tag class "' + v2.tagClass + '", type "' + v2.type + '" expected value length "' + v2.value.length + '", got "' + obj2.value.length + '"');
          }
        }
      }
      if (rval && capture) {
        if (v2.capture) {
          capture[v2.capture] = obj2.value;
        }
        if (v2.captureAsn1) {
          capture[v2.captureAsn1] = obj2;
        }
        if (v2.captureBitStringContents && "bitStringContents" in obj2) {
          capture[v2.captureBitStringContents] = obj2.bitStringContents;
        }
        if (v2.captureBitStringValue && "bitStringContents" in obj2) {
          if (obj2.bitStringContents.length < 2) {
            capture[v2.captureBitStringValue] = "";
          } else {
            var unused = obj2.bitStringContents.charCodeAt(0);
            if (unused !== 0) {
              throw new Error("captureBitStringValue only supported for zero unused bits");
            }
            capture[v2.captureBitStringValue] = obj2.bitStringContents.slice(1);
          }
        }
      }
    } else if (errors) {
      errors.push("[" + v2.name + '] Expected constructed "' + v2.constructed + '", got "' + obj2.constructed + '"');
    }
  } else if (errors) {
    if (obj2.tagClass !== v2.tagClass) {
      errors.push("[" + v2.name + '] Expected tag class "' + v2.tagClass + '", got "' + obj2.tagClass + '"');
    }
    if (obj2.type !== v2.type) {
      errors.push("[" + v2.name + '] Expected type "' + v2.type + '", got "' + obj2.type + '"');
    }
  }
  return rval;
};
var _nonLatinRegex = /[^\\u0000-\\u00ff]/;
asn1$3.prettyPrint = function(obj2, level, indentation) {
  var rval = "";
  level = level || 0;
  indentation = indentation || 2;
  if (level > 0) {
    rval += "\n";
  }
  var indent = "";
  for (var i2 = 0; i2 < level * indentation; ++i2) {
    indent += " ";
  }
  rval += indent + "Tag: ";
  switch (obj2.tagClass) {
    case asn1$3.Class.UNIVERSAL:
      rval += "Universal:";
      break;
    case asn1$3.Class.APPLICATION:
      rval += "Application:";
      break;
    case asn1$3.Class.CONTEXT_SPECIFIC:
      rval += "Context-Specific:";
      break;
    case asn1$3.Class.PRIVATE:
      rval += "Private:";
      break;
  }
  if (obj2.tagClass === asn1$3.Class.UNIVERSAL) {
    rval += obj2.type;
    switch (obj2.type) {
      case asn1$3.Type.NONE:
        rval += " (None)";
        break;
      case asn1$3.Type.BOOLEAN:
        rval += " (Boolean)";
        break;
      case asn1$3.Type.INTEGER:
        rval += " (Integer)";
        break;
      case asn1$3.Type.BITSTRING:
        rval += " (Bit string)";
        break;
      case asn1$3.Type.OCTETSTRING:
        rval += " (Octet string)";
        break;
      case asn1$3.Type.NULL:
        rval += " (Null)";
        break;
      case asn1$3.Type.OID:
        rval += " (Object Identifier)";
        break;
      case asn1$3.Type.ODESC:
        rval += " (Object Descriptor)";
        break;
      case asn1$3.Type.EXTERNAL:
        rval += " (External or Instance of)";
        break;
      case asn1$3.Type.REAL:
        rval += " (Real)";
        break;
      case asn1$3.Type.ENUMERATED:
        rval += " (Enumerated)";
        break;
      case asn1$3.Type.EMBEDDED:
        rval += " (Embedded PDV)";
        break;
      case asn1$3.Type.UTF8:
        rval += " (UTF8)";
        break;
      case asn1$3.Type.ROID:
        rval += " (Relative Object Identifier)";
        break;
      case asn1$3.Type.SEQUENCE:
        rval += " (Sequence)";
        break;
      case asn1$3.Type.SET:
        rval += " (Set)";
        break;
      case asn1$3.Type.PRINTABLESTRING:
        rval += " (Printable String)";
        break;
      case asn1$3.Type.IA5String:
        rval += " (IA5String (ASCII))";
        break;
      case asn1$3.Type.UTCTIME:
        rval += " (UTC time)";
        break;
      case asn1$3.Type.GENERALIZEDTIME:
        rval += " (Generalized time)";
        break;
      case asn1$3.Type.BMPSTRING:
        rval += " (BMP String)";
        break;
    }
  } else {
    rval += obj2.type;
  }
  rval += "\n";
  rval += indent + "Constructed: " + obj2.constructed + "\n";
  if (obj2.composed) {
    var subvalues = 0;
    var sub = "";
    for (var i2 = 0; i2 < obj2.value.length; ++i2) {
      if (obj2.value[i2] !== void 0) {
        subvalues += 1;
        sub += asn1$3.prettyPrint(obj2.value[i2], level + 1, indentation);
        if (i2 + 1 < obj2.value.length) {
          sub += ",";
        }
      }
    }
    rval += indent + "Sub values: " + subvalues + sub;
  } else {
    rval += indent + "Value: ";
    if (obj2.type === asn1$3.Type.OID) {
      var oid = asn1$3.derToOid(obj2.value);
      rval += oid;
      if (forge$m.pki && forge$m.pki.oids) {
        if (oid in forge$m.pki.oids) {
          rval += " (" + forge$m.pki.oids[oid] + ") ";
        }
      }
    }
    if (obj2.type === asn1$3.Type.INTEGER) {
      try {
        rval += asn1$3.derToInteger(obj2.value);
      } catch (ex) {
        rval += "0x" + forge$m.util.bytesToHex(obj2.value);
      }
    } else if (obj2.type === asn1$3.Type.BITSTRING) {
      if (obj2.value.length > 1) {
        rval += "0x" + forge$m.util.bytesToHex(obj2.value.slice(1));
      } else {
        rval += "(none)";
      }
      if (obj2.value.length > 0) {
        var unused = obj2.value.charCodeAt(0);
        if (unused == 1) {
          rval += " (1 unused bit shown)";
        } else if (unused > 1) {
          rval += " (" + unused + " unused bits shown)";
        }
      }
    } else if (obj2.type === asn1$3.Type.OCTETSTRING) {
      if (!_nonLatinRegex.test(obj2.value)) {
        rval += "(" + obj2.value + ") ";
      }
      rval += "0x" + forge$m.util.bytesToHex(obj2.value);
    } else if (obj2.type === asn1$3.Type.UTF8) {
      rval += forge$m.util.decodeUtf8(obj2.value);
    } else if (obj2.type === asn1$3.Type.PRINTABLESTRING || obj2.type === asn1$3.Type.IA5String) {
      rval += obj2.value;
    } else if (_nonLatinRegex.test(obj2.value)) {
      rval += "0x" + forge$m.util.bytesToHex(obj2.value);
    } else if (obj2.value.length === 0) {
      rval += "[null]";
    } else {
      rval += obj2.value;
    }
  }
  return rval;
};
var forge$l = forge$t;
forge$l.des = forge$l.des || {};
forge$l.des.startEncrypting = function(key3, iv, output, mode) {
  var cipher = _createCipher({ key: key3, output, decrypt: false, mode: mode || (iv === null ? "ECB" : "CBC") });
  cipher.start(iv);
  return cipher;
};
forge$l.des.createEncryptionCipher = function(key3, mode) {
  return _createCipher({ key: key3, output: null, decrypt: false, mode });
};
forge$l.des.startDecrypting = function(key3, iv, output, mode) {
  var cipher = _createCipher({ key: key3, output, decrypt: true, mode: mode || (iv === null ? "ECB" : "CBC") });
  cipher.start(iv);
  return cipher;
};
forge$l.des.createDecryptionCipher = function(key3, mode) {
  return _createCipher({ key: key3, output: null, decrypt: true, mode });
};
forge$l.des.Algorithm = function(name2, mode) {
  var self2 = this;
  self2.name = name2;
  self2.mode = new mode({ blockSize: 8, cipher: { encrypt: function encrypt(inBlock, outBlock) {
    return _updateBlock(self2._keys, inBlock, outBlock, false);
  }, decrypt: function decrypt(inBlock, outBlock) {
    return _updateBlock(self2._keys, inBlock, outBlock, true);
  } } });
  self2._init = false;
};
forge$l.des.Algorithm.prototype.initialize = function(options) {
  if (this._init) {
    return;
  }
  var key3 = forge$l.util.createBuffer(options.key);
  if (this.name.indexOf("3DES") === 0) {
    if (key3.length() !== 24) {
      throw new Error("Invalid Triple-DES key size: " + key3.length() * 8);
    }
  }
  this._keys = _createKeys(key3);
  this._init = true;
};
registerAlgorithm("DES-ECB", forge$l.cipher.modes.ecb);
registerAlgorithm("DES-CBC", forge$l.cipher.modes.cbc);
registerAlgorithm("DES-CFB", forge$l.cipher.modes.cfb);
registerAlgorithm("DES-OFB", forge$l.cipher.modes.ofb);
registerAlgorithm("DES-CTR", forge$l.cipher.modes.ctr);
registerAlgorithm("3DES-ECB", forge$l.cipher.modes.ecb);
registerAlgorithm("3DES-CBC", forge$l.cipher.modes.cbc);
registerAlgorithm("3DES-CFB", forge$l.cipher.modes.cfb);
registerAlgorithm("3DES-OFB", forge$l.cipher.modes.ofb);
registerAlgorithm("3DES-CTR", forge$l.cipher.modes.ctr);
function registerAlgorithm(name2, mode) {
  var factory2 = function factory3() {
    return new forge$l.des.Algorithm(name2, mode);
  };
  forge$l.cipher.registerAlgorithm(name2, factory2);
}
var spfunction1 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756];
var spfunction2 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344];
var spfunction3 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584];
var spfunction4 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928];
var spfunction5 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080];
var spfunction6 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312];
var spfunction7 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154];
var spfunction8 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
function _createKeys(key3) {
  var pc2bytes0 = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], pc2bytes1 = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], pc2bytes2 = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], pc2bytes3 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], pc2bytes4 = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], pc2bytes5 = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], pc2bytes6 = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], pc2bytes7 = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], pc2bytes8 = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], pc2bytes9 = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], pc2bytes10 = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], pc2bytes11 = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], pc2bytes12 = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], pc2bytes13 = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261];
  var iterations = key3.length() > 8 ? 3 : 1;
  var keys2 = [];
  var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];
  var n2 = 0, tmp;
  for (var j3 = 0; j3 < iterations; j3++) {
    var left = key3.getInt32();
    var right = key3.getInt32();
    tmp = (left >>> 4 ^ right) & 252645135;
    right ^= tmp;
    left ^= tmp << 4;
    tmp = (right >>> -16 ^ left) & 65535;
    left ^= tmp;
    right ^= tmp << -16;
    tmp = (left >>> 2 ^ right) & 858993459;
    right ^= tmp;
    left ^= tmp << 2;
    tmp = (right >>> -16 ^ left) & 65535;
    left ^= tmp;
    right ^= tmp << -16;
    tmp = (left >>> 1 ^ right) & 1431655765;
    right ^= tmp;
    left ^= tmp << 1;
    tmp = (right >>> 8 ^ left) & 16711935;
    left ^= tmp;
    right ^= tmp << 8;
    tmp = (left >>> 1 ^ right) & 1431655765;
    right ^= tmp;
    left ^= tmp << 1;
    tmp = left << 8 | right >>> 20 & 240;
    left = right << 24 | right << 8 & 16711680 | right >>> 8 & 65280 | right >>> 24 & 240;
    right = tmp;
    for (var i2 = 0; i2 < shifts.length; ++i2) {
      if (shifts[i2]) {
        left = left << 2 | left >>> 26;
        right = right << 2 | right >>> 26;
      } else {
        left = left << 1 | left >>> 27;
        right = right << 1 | right >>> 27;
      }
      left &= -15;
      right &= -15;
      var lefttmp = pc2bytes0[left >>> 28] | pc2bytes1[left >>> 24 & 15] | pc2bytes2[left >>> 20 & 15] | pc2bytes3[left >>> 16 & 15] | pc2bytes4[left >>> 12 & 15] | pc2bytes5[left >>> 8 & 15] | pc2bytes6[left >>> 4 & 15];
      var righttmp = pc2bytes7[right >>> 28] | pc2bytes8[right >>> 24 & 15] | pc2bytes9[right >>> 20 & 15] | pc2bytes10[right >>> 16 & 15] | pc2bytes11[right >>> 12 & 15] | pc2bytes12[right >>> 8 & 15] | pc2bytes13[right >>> 4 & 15];
      tmp = (righttmp >>> 16 ^ lefttmp) & 65535;
      keys2[n2++] = lefttmp ^ tmp;
      keys2[n2++] = righttmp ^ tmp << 16;
    }
  }
  return keys2;
}
function _updateBlock(keys2, input, output, decrypt) {
  var iterations = keys2.length === 32 ? 3 : 9;
  var looping;
  if (iterations === 3) {
    looping = decrypt ? [30, -2, -2] : [0, 32, 2];
  } else {
    looping = decrypt ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
  }
  var tmp;
  var left = input[0];
  var right = input[1];
  tmp = (left >>> 4 ^ right) & 252645135;
  right ^= tmp;
  left ^= tmp << 4;
  tmp = (left >>> 16 ^ right) & 65535;
  right ^= tmp;
  left ^= tmp << 16;
  tmp = (right >>> 2 ^ left) & 858993459;
  left ^= tmp;
  right ^= tmp << 2;
  tmp = (right >>> 8 ^ left) & 16711935;
  left ^= tmp;
  right ^= tmp << 8;
  tmp = (left >>> 1 ^ right) & 1431655765;
  right ^= tmp;
  left ^= tmp << 1;
  left = left << 1 | left >>> 31;
  right = right << 1 | right >>> 31;
  for (var j3 = 0; j3 < iterations; j3 += 3) {
    var endloop = looping[j3 + 1];
    var loopinc = looping[j3 + 2];
    for (var i2 = looping[j3]; i2 != endloop; i2 += loopinc) {
      var right1 = right ^ keys2[i2];
      var right2 = (right >>> 4 | right << 28) ^ keys2[i2 + 1];
      tmp = left;
      left = right;
      right = tmp ^ (spfunction2[right1 >>> 24 & 63] | spfunction4[right1 >>> 16 & 63] | spfunction6[right1 >>> 8 & 63] | spfunction8[right1 & 63] | spfunction1[right2 >>> 24 & 63] | spfunction3[right2 >>> 16 & 63] | spfunction5[right2 >>> 8 & 63] | spfunction7[right2 & 63]);
    }
    tmp = left;
    left = right;
    right = tmp;
  }
  left = left >>> 1 | left << 31;
  right = right >>> 1 | right << 31;
  tmp = (left >>> 1 ^ right) & 1431655765;
  right ^= tmp;
  left ^= tmp << 1;
  tmp = (right >>> 8 ^ left) & 16711935;
  left ^= tmp;
  right ^= tmp << 8;
  tmp = (right >>> 2 ^ left) & 858993459;
  left ^= tmp;
  right ^= tmp << 2;
  tmp = (left >>> 16 ^ right) & 65535;
  right ^= tmp;
  left ^= tmp << 16;
  tmp = (left >>> 4 ^ right) & 252645135;
  right ^= tmp;
  left ^= tmp << 4;
  output[0] = left;
  output[1] = right;
}
function _createCipher(options) {
  options = options || {};
  var mode = (options.mode || "CBC").toUpperCase();
  var algorithm = "DES-" + mode;
  var cipher;
  if (options.decrypt) {
    cipher = forge$l.cipher.createDecipher(algorithm, options.key);
  } else {
    cipher = forge$l.cipher.createCipher(algorithm, options.key);
  }
  var start = cipher.start;
  cipher.start = function(iv, options2) {
    var output = null;
    if (options2 instanceof forge$l.util.ByteBuffer) {
      output = options2;
      options2 = {};
    }
    options2 = options2 || {};
    options2.output = output;
    options2.iv = iv;
    start.call(cipher, options2);
  };
  return cipher;
}
var forge$k = forge$t;
forge$k.md = forge$k.md || {};
forge$k.md.algorithms = forge$k.md.algorithms || {};
var forge$j = forge$t;
var hmac$1 = forge$j.hmac = forge$j.hmac || {};
hmac$1.create = function() {
  var _key = null;
  var _md2 = null;
  var _ipadding = null;
  var _opadding = null;
  var ctx = {};
  ctx.start = function(md, key3) {
    if (md !== null) {
      if (typeof md === "string") {
        md = md.toLowerCase();
        if (md in forge$j.md.algorithms) {
          _md2 = forge$j.md.algorithms[md].create();
        } else {
          throw new Error('Unknown hash algorithm "' + md + '"');
        }
      } else {
        _md2 = md;
      }
    }
    if (key3 === null) {
      key3 = _key;
    } else {
      if (typeof key3 === "string") {
        key3 = forge$j.util.createBuffer(key3);
      } else if (forge$j.util.isArray(key3)) {
        var tmp = key3;
        key3 = forge$j.util.createBuffer();
        for (var i2 = 0; i2 < tmp.length; ++i2) {
          key3.putByte(tmp[i2]);
        }
      }
      var keylen = key3.length();
      if (keylen > _md2.blockLength) {
        _md2.start();
        _md2.update(key3.bytes());
        key3 = _md2.digest();
      }
      _ipadding = forge$j.util.createBuffer();
      _opadding = forge$j.util.createBuffer();
      keylen = key3.length();
      for (var i2 = 0; i2 < keylen; ++i2) {
        var tmp = key3.at(i2);
        _ipadding.putByte(54 ^ tmp);
        _opadding.putByte(92 ^ tmp);
      }
      if (keylen < _md2.blockLength) {
        var tmp = _md2.blockLength - keylen;
        for (var i2 = 0; i2 < tmp; ++i2) {
          _ipadding.putByte(54);
          _opadding.putByte(92);
        }
      }
      _key = key3;
      _ipadding = _ipadding.bytes();
      _opadding = _opadding.bytes();
    }
    _md2.start();
    _md2.update(_ipadding);
  };
  ctx.update = function(bytes) {
    _md2.update(bytes);
  };
  ctx.getMac = function() {
    var inner = _md2.digest().bytes();
    _md2.start();
    _md2.update(_opadding);
    _md2.update(inner);
    return _md2.digest();
  };
  ctx.digest = ctx.getMac;
  return ctx;
};
var forge$i = forge$t;
var pkcs5 = forge$i.pkcs5 = forge$i.pkcs5 || {};
var crypto$3;
if (forge$i.util.isNodejs && !forge$i.options.usePureJavaScript) {
  crypto$3 = require$$0$4;
}
var pbkdf2$1 = forge$i.pbkdf2 = pkcs5.pbkdf2 = function(p2, s2, c3, dkLen, md, callback) {
  if (typeof md === "function") {
    callback = md;
    md = null;
  }
  if (forge$i.util.isNodejs && !forge$i.options.usePureJavaScript && crypto$3.pbkdf2 && (md === null || _typeof(md) !== "object") && (crypto$3.pbkdf2Sync.length > 4 || !md || md === "sha1")) {
    if (typeof md !== "string") {
      md = "sha1";
    }
    p2 = Buffer.from(p2, "binary");
    s2 = Buffer.from(s2, "binary");
    if (!callback) {
      if (crypto$3.pbkdf2Sync.length === 4) {
        return crypto$3.pbkdf2Sync(p2, s2, c3, dkLen).toString("binary");
      }
      return crypto$3.pbkdf2Sync(p2, s2, c3, dkLen, md).toString("binary");
    }
    if (crypto$3.pbkdf2Sync.length === 4) {
      return crypto$3.pbkdf2(p2, s2, c3, dkLen, function(err2, key3) {
        if (err2) {
          return callback(err2);
        }
        callback(null, key3.toString("binary"));
      });
    }
    return crypto$3.pbkdf2(p2, s2, c3, dkLen, md, function(err2, key3) {
      if (err2) {
        return callback(err2);
      }
      callback(null, key3.toString("binary"));
    });
  }
  if (typeof md === "undefined" || md === null) {
    md = "sha1";
  }
  if (typeof md === "string") {
    if (!(md in forge$i.md.algorithms)) {
      throw new Error("Unknown hash algorithm: " + md);
    }
    md = forge$i.md[md].create();
  }
  var hLen = md.digestLength;
  if (dkLen > 4294967295 * hLen) {
    var err = new Error("Derived key is too long.");
    if (callback) {
      return callback(err);
    }
    throw err;
  }
  var len2 = Math.ceil(dkLen / hLen);
  var r2 = dkLen - (len2 - 1) * hLen;
  var prf = forge$i.hmac.create();
  prf.start(md, p2);
  var dk = "";
  var xor, u_c, u_c1;
  if (!callback) {
    for (var i2 = 1; i2 <= len2; ++i2) {
      prf.start(null, null);
      prf.update(s2);
      prf.update(forge$i.util.int32ToBytes(i2));
      xor = u_c1 = prf.digest().getBytes();
      for (var j3 = 2; j3 <= c3; ++j3) {
        prf.start(null, null);
        prf.update(u_c1);
        u_c = prf.digest().getBytes();
        xor = forge$i.util.xorBytes(xor, u_c, hLen);
        u_c1 = u_c;
      }
      dk += i2 < len2 ? xor : xor.substr(0, r2);
    }
    return dk;
  }
  var i2 = 1, j3;
  function outer() {
    if (i2 > len2) {
      return callback(null, dk);
    }
    prf.start(null, null);
    prf.update(s2);
    prf.update(forge$i.util.int32ToBytes(i2));
    xor = u_c1 = prf.digest().getBytes();
    j3 = 2;
    inner();
  }
  function inner() {
    if (j3 <= c3) {
      prf.start(null, null);
      prf.update(u_c1);
      u_c = prf.digest().getBytes();
      xor = forge$i.util.xorBytes(xor, u_c, hLen);
      u_c1 = u_c;
      ++j3;
      return forge$i.util.setImmediate(inner);
    }
    dk += i2 < len2 ? xor : xor.substr(0, r2);
    ++i2;
    outer();
  }
  outer();
};
var forge$h = forge$t;
var pem = forge$h.pem = forge$h.pem || {};
pem.encode = function(msg, options) {
  options = options || {};
  var rval = "-----BEGIN " + msg.type + "-----\r\n";
  var header;
  if (msg.procType) {
    header = { name: "Proc-Type", values: [String(msg.procType.version), msg.procType.type] };
    rval += foldHeader(header);
  }
  if (msg.contentDomain) {
    header = { name: "Content-Domain", values: [msg.contentDomain] };
    rval += foldHeader(header);
  }
  if (msg.dekInfo) {
    header = { name: "DEK-Info", values: [msg.dekInfo.algorithm] };
    if (msg.dekInfo.parameters) {
      header.values.push(msg.dekInfo.parameters);
    }
    rval += foldHeader(header);
  }
  if (msg.headers) {
    for (var i2 = 0; i2 < msg.headers.length; ++i2) {
      rval += foldHeader(msg.headers[i2]);
    }
  }
  if (msg.procType) {
    rval += "\r\n";
  }
  rval += forge$h.util.encode64(msg.body, options.maxline || 64) + "\r\n";
  rval += "-----END " + msg.type + "-----\r\n";
  return rval;
};
pem.decode = function(str) {
  var rval = [];
  var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
  var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
  var rCRLF = /\r?\n/;
  var match;
  while (true) {
    match = rMessage.exec(str);
    if (!match) {
      break;
    }
    var msg = { type: match[1], procType: null, contentDomain: null, dekInfo: null, headers: [], body: forge$h.util.decode64(match[3]) };
    rval.push(msg);
    if (!match[2]) {
      continue;
    }
    var lines = match[2].split(rCRLF);
    var li = 0;
    while (match && li < lines.length) {
      var line = lines[li].replace(/\s+$/, "");
      for (var nl = li + 1; nl < lines.length; ++nl) {
        var next = lines[nl];
        if (!/\s/.test(next[0])) {
          break;
        }
        line += next;
        li = nl;
      }
      match = line.match(rHeader);
      if (match) {
        var header = { name: match[1], values: [] };
        var values = match[2].split(",");
        for (var vi = 0; vi < values.length; ++vi) {
          header.values.push(ltrim(values[vi]));
        }
        if (!msg.procType) {
          if (header.name !== "Proc-Type") {
            throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
          } else if (header.values.length !== 2) {
            throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
          }
          msg.procType = { version: values[0], type: values[1] };
        } else if (!msg.contentDomain && header.name === "Content-Domain") {
          msg.contentDomain = values[0] || "";
        } else if (!msg.dekInfo && header.name === "DEK-Info") {
          if (header.values.length === 0) {
            throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
          }
          msg.dekInfo = { algorithm: values[0], parameters: values[1] || null };
        } else {
          msg.headers.push(header);
        }
      }
      ++li;
    }
    if (msg.procType === "ENCRYPTED" && !msg.dekInfo) {
      throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
    }
  }
  if (rval.length === 0) {
    throw new Error("Invalid PEM formatted message.");
  }
  return rval;
};
function foldHeader(header) {
  var rval = header.name + ": ";
  var values = [];
  var insertSpace = function insertSpace2(match, $1) {
    return " " + $1;
  };
  for (var i2 = 0; i2 < header.values.length; ++i2) {
    values.push(header.values[i2].replace(/^(\S+\r\n)/, insertSpace));
  }
  rval += values.join(",") + "\r\n";
  var length3 = 0;
  var candidate = -1;
  for (var i2 = 0; i2 < rval.length; ++i2, ++length3) {
    if (length3 > 65 && candidate !== -1) {
      var insert = rval[candidate];
      if (insert === ",") {
        ++candidate;
        rval = rval.substr(0, candidate) + "\r\n " + rval.substr(candidate);
      } else {
        rval = rval.substr(0, candidate) + "\r\n" + insert + rval.substr(candidate + 1);
      }
      length3 = i2 - candidate - 1;
      candidate = -1;
      ++i2;
    } else if (rval[i2] === " " || rval[i2] === "	" || rval[i2] === ",") {
      candidate = i2;
    }
  }
  return rval;
}
function ltrim(str) {
  return str.replace(/^\s+/, "");
}
var forge$g = forge$t;
var sha256$3 = forge$g.sha256 = forge$g.sha256 || {};
forge$g.md.sha256 = forge$g.md.algorithms.sha256 = sha256$3;
sha256$3.create = function() {
  if (!_initialized$2) {
    _init$2();
  }
  var _state = null;
  var _input = forge$g.util.createBuffer();
  var _w = new Array(64);
  var md = {
    algorithm: "sha256",
    blockLength: 64,
    digestLength: 32,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 8
  };
  md.start = function() {
    md.messageLength = 0;
    md.fullMessageLength = md.messageLength64 = [];
    var int32s = md.messageLengthSize / 4;
    for (var i2 = 0; i2 < int32s; ++i2) {
      md.fullMessageLength.push(0);
    }
    _input = forge$g.util.createBuffer();
    _state = { h0: 1779033703, h1: 3144134277, h2: 1013904242, h3: 2773480762, h4: 1359893119, h5: 2600822924, h6: 528734635, h7: 1541459225 };
    return md;
  };
  md.start();
  md.update = function(msg, encoding) {
    if (encoding === "utf8") {
      msg = forge$g.util.encodeUtf8(msg);
    }
    var len2 = msg.length;
    md.messageLength += len2;
    len2 = [len2 / 4294967296 >>> 0, len2 >>> 0];
    for (var i2 = md.fullMessageLength.length - 1; i2 >= 0; --i2) {
      md.fullMessageLength[i2] += len2[1];
      len2[1] = len2[0] + (md.fullMessageLength[i2] / 4294967296 >>> 0);
      md.fullMessageLength[i2] = md.fullMessageLength[i2] >>> 0;
      len2[0] = len2[1] / 4294967296 >>> 0;
    }
    _input.putBytes(msg);
    _update$2(_state, _w, _input);
    if (_input.read > 2048 || _input.length() === 0) {
      _input.compact();
    }
    return md;
  };
  md.digest = function() {
    var finalBlock = forge$g.util.createBuffer();
    finalBlock.putBytes(_input.bytes());
    var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
    var overflow = remaining & md.blockLength - 1;
    finalBlock.putBytes(_padding$2.substr(0, md.blockLength - overflow));
    var next, carry;
    var bits = md.fullMessageLength[0] * 8;
    for (var i2 = 0; i2 < md.fullMessageLength.length - 1; ++i2) {
      next = md.fullMessageLength[i2 + 1] * 8;
      carry = next / 4294967296 >>> 0;
      bits += carry;
      finalBlock.putInt32(bits >>> 0);
      bits = next >>> 0;
    }
    finalBlock.putInt32(bits);
    var s2 = { h0: _state.h0, h1: _state.h1, h2: _state.h2, h3: _state.h3, h4: _state.h4, h5: _state.h5, h6: _state.h6, h7: _state.h7 };
    _update$2(s2, _w, finalBlock);
    var rval = forge$g.util.createBuffer();
    rval.putInt32(s2.h0);
    rval.putInt32(s2.h1);
    rval.putInt32(s2.h2);
    rval.putInt32(s2.h3);
    rval.putInt32(s2.h4);
    rval.putInt32(s2.h5);
    rval.putInt32(s2.h6);
    rval.putInt32(s2.h7);
    return rval;
  };
  return md;
};
var _padding$2 = null;
var _initialized$2 = false;
var _k$1 = null;
function _init$2() {
  _padding$2 = String.fromCharCode(128);
  _padding$2 += forge$g.util.fillString(String.fromCharCode(0), 64);
  _k$1 = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
  _initialized$2 = true;
}
function _update$2(s2, w2, bytes) {
  var t1, t2, s0, s1, ch, maj, i2, a2, b3, c3, d2, e2, f2, g2, h2;
  var len2 = bytes.length();
  while (len2 >= 64) {
    for (i2 = 0; i2 < 16; ++i2) {
      w2[i2] = bytes.getInt32();
    }
    for (; i2 < 64; ++i2) {
      t1 = w2[i2 - 2];
      t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
      t2 = w2[i2 - 15];
      t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;
      w2[i2] = t1 + w2[i2 - 7] + t2 + w2[i2 - 16] | 0;
    }
    a2 = s2.h0;
    b3 = s2.h1;
    c3 = s2.h2;
    d2 = s2.h3;
    e2 = s2.h4;
    f2 = s2.h5;
    g2 = s2.h6;
    h2 = s2.h7;
    for (i2 = 0; i2 < 64; ++i2) {
      s1 = (e2 >>> 6 | e2 << 26) ^ (e2 >>> 11 | e2 << 21) ^ (e2 >>> 25 | e2 << 7);
      ch = g2 ^ e2 & (f2 ^ g2);
      s0 = (a2 >>> 2 | a2 << 30) ^ (a2 >>> 13 | a2 << 19) ^ (a2 >>> 22 | a2 << 10);
      maj = a2 & b3 | c3 & (a2 ^ b3);
      t1 = h2 + s1 + ch + _k$1[i2] + w2[i2];
      t2 = s0 + maj;
      h2 = g2;
      g2 = f2;
      f2 = e2;
      e2 = d2 + t1 >>> 0;
      d2 = c3;
      c3 = b3;
      b3 = a2;
      a2 = t1 + t2 >>> 0;
    }
    s2.h0 = s2.h0 + a2 | 0;
    s2.h1 = s2.h1 + b3 | 0;
    s2.h2 = s2.h2 + c3 | 0;
    s2.h3 = s2.h3 + d2 | 0;
    s2.h4 = s2.h4 + e2 | 0;
    s2.h5 = s2.h5 + f2 | 0;
    s2.h6 = s2.h6 + g2 | 0;
    s2.h7 = s2.h7 + h2 | 0;
    len2 -= 64;
  }
}
var forge$f = forge$t;
var _crypto$1 = null;
if (forge$f.util.isNodejs && !forge$f.options.usePureJavaScript && !process.versions["node-webkit"]) {
  _crypto$1 = require$$0$4;
}
var prng = forge$f.prng = forge$f.prng || {};
prng.create = function(plugin) {
  var ctx = {
    plugin,
    key: null,
    seed: null,
    time: null,
    // number of reseeds so far
    reseeds: 0,
    // amount of data generated so far
    generated: 0,
    // no initial key bytes
    keyBytes: ""
  };
  var md = plugin.md;
  var pools = new Array(32);
  for (var i2 = 0; i2 < 32; ++i2) {
    pools[i2] = md.create();
  }
  ctx.pools = pools;
  ctx.pool = 0;
  ctx.generate = function(count, callback) {
    if (!callback) {
      return ctx.generateSync(count);
    }
    var cipher = ctx.plugin.cipher;
    var increment = ctx.plugin.increment;
    var formatKey = ctx.plugin.formatKey;
    var formatSeed = ctx.plugin.formatSeed;
    var b3 = forge$f.util.createBuffer();
    ctx.key = null;
    generate2();
    function generate2(err) {
      if (err) {
        return callback(err);
      }
      if (b3.length() >= count) {
        return callback(null, b3.getBytes(count));
      }
      if (ctx.generated > 1048575) {
        ctx.key = null;
      }
      if (ctx.key === null) {
        return forge$f.util.nextTick(function() {
          _reseed(generate2);
        });
      }
      var bytes = cipher(ctx.key, ctx.seed);
      ctx.generated += bytes.length;
      b3.putBytes(bytes);
      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
      forge$f.util.setImmediate(generate2);
    }
  };
  ctx.generateSync = function(count) {
    var cipher = ctx.plugin.cipher;
    var increment = ctx.plugin.increment;
    var formatKey = ctx.plugin.formatKey;
    var formatSeed = ctx.plugin.formatSeed;
    ctx.key = null;
    var b3 = forge$f.util.createBuffer();
    while (b3.length() < count) {
      if (ctx.generated > 1048575) {
        ctx.key = null;
      }
      if (ctx.key === null) {
        _reseedSync();
      }
      var bytes = cipher(ctx.key, ctx.seed);
      ctx.generated += bytes.length;
      b3.putBytes(bytes);
      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
    }
    return b3.getBytes(count);
  };
  function _reseed(callback) {
    if (ctx.pools[0].messageLength >= 32) {
      _seed();
      return callback();
    }
    var needed = 32 - ctx.pools[0].messageLength << 5;
    ctx.seedFile(needed, function(err, bytes) {
      if (err) {
        return callback(err);
      }
      ctx.collect(bytes);
      _seed();
      callback();
    });
  }
  function _reseedSync() {
    if (ctx.pools[0].messageLength >= 32) {
      return _seed();
    }
    var needed = 32 - ctx.pools[0].messageLength << 5;
    ctx.collect(ctx.seedFileSync(needed));
    _seed();
  }
  function _seed() {
    ctx.reseeds = ctx.reseeds === 4294967295 ? 0 : ctx.reseeds + 1;
    var md2 = ctx.plugin.md.create();
    md2.update(ctx.keyBytes);
    var _2powK = 1;
    for (var k3 = 0; k3 < 32; ++k3) {
      if (ctx.reseeds % _2powK === 0) {
        md2.update(ctx.pools[k3].digest().getBytes());
        ctx.pools[k3].start();
      }
      _2powK = _2powK << 1;
    }
    ctx.keyBytes = md2.digest().getBytes();
    md2.start();
    md2.update(ctx.keyBytes);
    var seedBytes = md2.digest().getBytes();
    ctx.key = ctx.plugin.formatKey(ctx.keyBytes);
    ctx.seed = ctx.plugin.formatSeed(seedBytes);
    ctx.generated = 0;
  }
  function defaultSeedFile(needed) {
    var getRandomValues = null;
    var globalScope = forge$f.util.globalScope;
    var _crypto2 = globalScope.crypto || globalScope.msCrypto;
    if (_crypto2 && _crypto2.getRandomValues) {
      getRandomValues = function getRandomValues2(arr) {
        return _crypto2.getRandomValues(arr);
      };
    }
    var b3 = forge$f.util.createBuffer();
    if (getRandomValues) {
      while (b3.length() < needed) {
        var count = Math.max(1, Math.min(needed - b3.length(), 65536) / 4);
        var entropy = new Uint32Array(Math.floor(count));
        try {
          getRandomValues(entropy);
          for (var i3 = 0; i3 < entropy.length; ++i3) {
            b3.putInt32(entropy[i3]);
          }
        } catch (e2) {
          if (!(typeof QuotaExceededError !== "undefined" && e2 instanceof QuotaExceededError)) {
            throw e2;
          }
        }
      }
    }
    if (b3.length() < needed) {
      var hi, lo, next;
      var seed = Math.floor(Math.random() * 65536);
      while (b3.length() < needed) {
        lo = 16807 * (seed & 65535);
        hi = 16807 * (seed >> 16);
        lo += (hi & 32767) << 16;
        lo += hi >> 15;
        lo = (lo & 2147483647) + (lo >> 31);
        seed = lo & 4294967295;
        for (var i3 = 0; i3 < 3; ++i3) {
          next = seed >>> (i3 << 3);
          next ^= Math.floor(Math.random() * 256);
          b3.putByte(String.fromCharCode(next & 255));
        }
      }
    }
    return b3.getBytes(needed);
  }
  if (_crypto$1) {
    ctx.seedFile = function(needed, callback) {
      _crypto$1.randomBytes(needed, function(err, bytes) {
        if (err) {
          return callback(err);
        }
        callback(null, bytes.toString());
      });
    };
    ctx.seedFileSync = function(needed) {
      return _crypto$1.randomBytes(needed).toString();
    };
  } else {
    ctx.seedFile = function(needed, callback) {
      try {
        callback(null, defaultSeedFile(needed));
      } catch (e2) {
        callback(e2);
      }
    };
    ctx.seedFileSync = defaultSeedFile;
  }
  ctx.collect = function(bytes) {
    var count = bytes.length;
    for (var i3 = 0; i3 < count; ++i3) {
      ctx.pools[ctx.pool].update(bytes.substr(i3, 1));
      ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;
    }
  };
  ctx.collectInt = function(i3, n2) {
    var bytes = "";
    for (var x2 = 0; x2 < n2; x2 += 8) {
      bytes += String.fromCharCode(i3 >> x2 & 255);
    }
    ctx.collect(bytes);
  };
  ctx.registerWorker = function(worker) {
    if (worker === self) {
      ctx.seedFile = function(needed, callback) {
        function listener2(e2) {
          var data = e2.data;
          if (data.forge && data.forge.prng) {
            self.removeEventListener("message", listener2);
            callback(data.forge.prng.err, data.forge.prng.bytes);
          }
        }
        self.addEventListener("message", listener2);
        self.postMessage({ forge: { prng: { needed } } });
      };
    } else {
      var listener = function listener2(e2) {
        var data = e2.data;
        if (data.forge && data.forge.prng) {
          ctx.seedFile(data.forge.prng.needed, function(err, bytes) {
            worker.postMessage({ forge: { prng: { err, bytes } } });
          });
        }
      };
      worker.addEventListener("message", listener);
    }
  };
  return ctx;
};
var forge$e = forge$t;
(function() {
  if (forge$e.random && forge$e.random.getBytes) {
    forge$e.random;
    return;
  }
  (function(jQuery2) {
    var prng_aes = {};
    var _prng_aes_output = new Array(4);
    var _prng_aes_buffer = forge$e.util.createBuffer();
    prng_aes.formatKey = function(key4) {
      var tmp = forge$e.util.createBuffer(key4);
      key4 = new Array(4);
      key4[0] = tmp.getInt32();
      key4[1] = tmp.getInt32();
      key4[2] = tmp.getInt32();
      key4[3] = tmp.getInt32();
      return forge$e.aes._expandKey(key4, false);
    };
    prng_aes.formatSeed = function(seed) {
      var tmp = forge$e.util.createBuffer(seed);
      seed = new Array(4);
      seed[0] = tmp.getInt32();
      seed[1] = tmp.getInt32();
      seed[2] = tmp.getInt32();
      seed[3] = tmp.getInt32();
      return seed;
    };
    prng_aes.cipher = function(key4, seed) {
      forge$e.aes._updateBlock(key4, seed, _prng_aes_output, false);
      _prng_aes_buffer.putInt32(_prng_aes_output[0]);
      _prng_aes_buffer.putInt32(_prng_aes_output[1]);
      _prng_aes_buffer.putInt32(_prng_aes_output[2]);
      _prng_aes_buffer.putInt32(_prng_aes_output[3]);
      return _prng_aes_buffer.getBytes();
    };
    prng_aes.increment = function(seed) {
      ++seed[3];
      return seed;
    };
    prng_aes.md = forge$e.md.sha256;
    function spawnPrng() {
      var ctx = forge$e.prng.create(prng_aes);
      ctx.getBytes = function(count, callback) {
        return ctx.generate(count, callback);
      };
      ctx.getBytesSync = function(count) {
        return ctx.generate(count);
      };
      return ctx;
    }
    var _ctx = spawnPrng();
    var getRandomValues = null;
    var globalScope = forge$e.util.globalScope;
    var _crypto2 = globalScope.crypto || globalScope.msCrypto;
    if (_crypto2 && _crypto2.getRandomValues) {
      getRandomValues = function getRandomValues2(arr) {
        return _crypto2.getRandomValues(arr);
      };
    }
    if (forge$e.options.usePureJavaScript || !forge$e.util.isNodejs && !getRandomValues) {
      _ctx.collectInt(+/* @__PURE__ */ new Date(), 32);
      if (typeof navigator !== "undefined") {
        var _navBytes = "";
        for (var key3 in navigator) {
          try {
            if (typeof navigator[key3] == "string") {
              _navBytes += navigator[key3];
            }
          } catch (e2) {
          }
        }
        _ctx.collect(_navBytes);
        _navBytes = null;
      }
      if (jQuery2) {
        jQuery2().mousemove(function(e2) {
          _ctx.collectInt(e2.clientX, 16);
          _ctx.collectInt(e2.clientY, 16);
        });
        jQuery2().keypress(function(e2) {
          _ctx.collectInt(e2.charCode, 8);
        });
      }
    }
    if (!forge$e.random) {
      forge$e.random = _ctx;
    } else {
      for (var key3 in _ctx) {
        forge$e.random[key3] = _ctx[key3];
      }
    }
    forge$e.random.createInstance = spawnPrng;
    forge$e.random;
  })(typeof jQuery !== "undefined" ? jQuery : null);
})();
var forge$d = forge$t;
var piTable = [217, 120, 249, 196, 25, 221, 181, 237, 40, 233, 253, 121, 74, 160, 216, 157, 198, 126, 55, 131, 43, 118, 83, 142, 98, 76, 100, 136, 68, 139, 251, 162, 23, 154, 89, 245, 135, 179, 79, 19, 97, 69, 109, 141, 9, 129, 125, 50, 189, 143, 64, 235, 134, 183, 123, 11, 240, 149, 33, 34, 92, 107, 78, 130, 84, 214, 101, 147, 206, 96, 178, 28, 115, 86, 192, 20, 167, 140, 241, 220, 18, 117, 202, 31, 59, 190, 228, 209, 66, 61, 212, 48, 163, 60, 182, 38, 111, 191, 14, 218, 70, 105, 7, 87, 39, 242, 29, 155, 188, 148, 67, 3, 248, 17, 199, 246, 144, 239, 62, 231, 6, 195, 213, 47, 200, 102, 30, 215, 8, 232, 234, 222, 128, 82, 238, 247, 132, 170, 114, 172, 53, 77, 106, 42, 150, 26, 210, 113, 90, 21, 73, 116, 75, 159, 208, 94, 4, 24, 164, 236, 194, 224, 65, 110, 15, 81, 203, 204, 36, 145, 175, 80, 161, 244, 112, 57, 153, 124, 58, 133, 35, 184, 180, 122, 252, 2, 54, 91, 37, 85, 151, 49, 45, 93, 250, 152, 227, 138, 146, 174, 5, 223, 41, 16, 103, 108, 186, 201, 211, 0, 230, 207, 225, 158, 168, 44, 99, 22, 1, 63, 88, 226, 137, 169, 13, 56, 52, 27, 171, 51, 255, 176, 187, 72, 12, 95, 185, 177, 205, 46, 197, 243, 219, 71, 229, 165, 156, 119, 10, 166, 32, 104, 254, 127, 193, 173];
var s = [1, 2, 3, 5];
var rol = function rol2(word, bits) {
  return word << bits & 65535 | (word & 65535) >> 16 - bits;
};
var ror = function ror2(word, bits) {
  return (word & 65535) >> bits | word << 16 - bits & 65535;
};
forge$d.rc2 = forge$d.rc2 || {};
forge$d.rc2.expandKey = function(key3, effKeyBits) {
  if (typeof key3 === "string") {
    key3 = forge$d.util.createBuffer(key3);
  }
  effKeyBits = effKeyBits || 128;
  var L2 = key3;
  var T3 = key3.length();
  var T1 = effKeyBits;
  var T8 = Math.ceil(T1 / 8);
  var TM = 255 >> (T1 & 7);
  var i2;
  for (i2 = T3; i2 < 128; i2++) {
    L2.putByte(piTable[L2.at(i2 - 1) + L2.at(i2 - T3) & 255]);
  }
  L2.setAt(128 - T8, piTable[L2.at(128 - T8) & TM]);
  for (i2 = 127 - T8; i2 >= 0; i2--) {
    L2.setAt(i2, piTable[L2.at(i2 + 1) ^ L2.at(i2 + T8)]);
  }
  return L2;
};
var createCipher = function createCipher2(key3, bits, encrypt) {
  var _finish = false, _input = null, _output = null, _iv = null;
  var mixRound, mashRound;
  var i2, j3, K2 = [];
  key3 = forge$d.rc2.expandKey(key3, bits);
  for (i2 = 0; i2 < 64; i2++) {
    K2.push(key3.getInt16Le());
  }
  if (encrypt) {
    mixRound = function mixRound2(R2) {
      for (i2 = 0; i2 < 4; i2++) {
        R2[i2] += K2[j3] + (R2[(i2 + 3) % 4] & R2[(i2 + 2) % 4]) + (~R2[(i2 + 3) % 4] & R2[(i2 + 1) % 4]);
        R2[i2] = rol(R2[i2], s[i2]);
        j3++;
      }
    };
    mashRound = function mashRound2(R2) {
      for (i2 = 0; i2 < 4; i2++) {
        R2[i2] += K2[R2[(i2 + 3) % 4] & 63];
      }
    };
  } else {
    mixRound = function mixRound2(R2) {
      for (i2 = 3; i2 >= 0; i2--) {
        R2[i2] = ror(R2[i2], s[i2]);
        R2[i2] -= K2[j3] + (R2[(i2 + 3) % 4] & R2[(i2 + 2) % 4]) + (~R2[(i2 + 3) % 4] & R2[(i2 + 1) % 4]);
        j3--;
      }
    };
    mashRound = function mashRound2(R2) {
      for (i2 = 3; i2 >= 0; i2--) {
        R2[i2] -= K2[R2[(i2 + 3) % 4] & 63];
      }
    };
  }
  var runPlan = function runPlan2(plan) {
    var R2 = [];
    for (i2 = 0; i2 < 4; i2++) {
      var val = _input.getInt16Le();
      if (_iv !== null) {
        if (encrypt) {
          val ^= _iv.getInt16Le();
        } else {
          _iv.putInt16Le(val);
        }
      }
      R2.push(val & 65535);
    }
    j3 = encrypt ? 0 : 63;
    for (var ptr = 0; ptr < plan.length; ptr++) {
      for (var ctr = 0; ctr < plan[ptr][0]; ctr++) {
        plan[ptr][1](R2);
      }
    }
    for (i2 = 0; i2 < 4; i2++) {
      if (_iv !== null) {
        if (encrypt) {
          _iv.putInt16Le(R2[i2]);
        } else {
          R2[i2] ^= _iv.getInt16Le();
        }
      }
      _output.putInt16Le(R2[i2]);
    }
  };
  var cipher = null;
  cipher = {
    /**
    * Starts or restarts the encryption or decryption process, whichever
    * was previously configured.
    *
    * To use the cipher in CBC mode, iv may be given either as a string
    * of bytes, or as a byte buffer.  For ECB mode, give null as iv.
    *
    * @param iv the initialization vector to use, null for ECB mode.
    * @param output the output the buffer to write to, null to create one.
    */
    start: function start(iv, output) {
      if (iv) {
        if (typeof iv === "string") {
          iv = forge$d.util.createBuffer(iv);
        }
      }
      _finish = false;
      _input = forge$d.util.createBuffer();
      _output = output || new forge$d.util.createBuffer();
      _iv = iv;
      cipher.output = _output;
    },
    /**
    * Updates the next block.
    *
    * @param input the buffer to read from.
    */
    update: function update5(input) {
      if (!_finish) {
        _input.putBuffer(input);
      }
      while (_input.length() >= 8) {
        runPlan([[5, mixRound], [1, mashRound], [6, mixRound], [1, mashRound], [5, mixRound]]);
      }
    },
    /**
    * Finishes encrypting or decrypting.
    *
    * @param pad a padding function to use, null for PKCS#7 padding,
    *           signature(blockSize, buffer, decrypt).
    *
    * @return true if successful, false on error.
    */
    finish: function finish2(pad2) {
      var rval = true;
      if (encrypt) {
        if (pad2) {
          rval = pad2(8, _input, !encrypt);
        } else {
          var padding = _input.length() === 8 ? 8 : 8 - _input.length();
          _input.fillWithByte(padding, padding);
        }
      }
      if (rval) {
        _finish = true;
        cipher.update();
      }
      if (!encrypt) {
        rval = _input.length() === 0;
        if (rval) {
          if (pad2) {
            rval = pad2(8, _output, !encrypt);
          } else {
            var len2 = _output.length();
            var count = _output.at(len2 - 1);
            if (count > len2) {
              rval = false;
            } else {
              _output.truncate(count);
            }
          }
        }
      }
      return rval;
    }
  };
  return cipher;
};
forge$d.rc2.startEncrypting = function(key3, iv, output) {
  var cipher = forge$d.rc2.createEncryptionCipher(key3, 128);
  cipher.start(iv, output);
  return cipher;
};
forge$d.rc2.createEncryptionCipher = function(key3, bits) {
  return createCipher(key3, bits, true);
};
forge$d.rc2.startDecrypting = function(key3, iv, output) {
  var cipher = forge$d.rc2.createDecryptionCipher(key3, 128);
  cipher.start(iv, output);
  return cipher;
};
forge$d.rc2.createDecryptionCipher = function(key3, bits) {
  return createCipher(key3, bits, false);
};
var forge$c = forge$t;
forge$c.jsbn = forge$c.jsbn || {};
var dbits;
function BigInteger$3(a2, b3, c3) {
  this.data = [];
  if (a2 != null)
    if ("number" == typeof a2)
      this.fromNumber(a2, b3, c3);
    else if (b3 == null && "string" != typeof a2)
      this.fromString(a2, 256);
    else
      this.fromString(a2, b3);
}
forge$c.jsbn.BigInteger = BigInteger$3;
function nbi() {
  return new BigInteger$3(null);
}
function am1(i2, x2, w2, j3, c3, n2) {
  while (--n2 >= 0) {
    var v2 = x2 * this.data[i2++] + w2.data[j3] + c3;
    c3 = Math.floor(v2 / 67108864);
    w2.data[j3++] = v2 & 67108863;
  }
  return c3;
}
function am2(i2, x2, w2, j3, c3, n2) {
  var xl = x2 & 32767, xh = x2 >> 15;
  while (--n2 >= 0) {
    var l2 = this.data[i2] & 32767;
    var h2 = this.data[i2++] >> 15;
    var m2 = xh * l2 + h2 * xl;
    l2 = xl * l2 + ((m2 & 32767) << 15) + w2.data[j3] + (c3 & 1073741823);
    c3 = (l2 >>> 30) + (m2 >>> 15) + xh * h2 + (c3 >>> 30);
    w2.data[j3++] = l2 & 1073741823;
  }
  return c3;
}
function am3(i2, x2, w2, j3, c3, n2) {
  var xl = x2 & 16383, xh = x2 >> 14;
  while (--n2 >= 0) {
    var l2 = this.data[i2] & 16383;
    var h2 = this.data[i2++] >> 14;
    var m2 = xh * l2 + h2 * xl;
    l2 = xl * l2 + ((m2 & 16383) << 14) + w2.data[j3] + c3;
    c3 = (l2 >> 28) + (m2 >> 14) + xh * h2;
    w2.data[j3++] = l2 & 268435455;
  }
  return c3;
}
if (typeof navigator === "undefined") {
  BigInteger$3.prototype.am = am3;
  dbits = 28;
} else if (navigator.appName == "Microsoft Internet Explorer") {
  BigInteger$3.prototype.am = am2;
  dbits = 30;
} else if (navigator.appName != "Netscape") {
  BigInteger$3.prototype.am = am1;
  dbits = 26;
} else {
  BigInteger$3.prototype.am = am3;
  dbits = 28;
}
BigInteger$3.prototype.DB = dbits;
BigInteger$3.prototype.DM = (1 << dbits) - 1;
BigInteger$3.prototype.DV = 1 << dbits;
var BI_FP = 52;
BigInteger$3.prototype.FV = Math.pow(2, BI_FP);
BigInteger$3.prototype.F1 = BI_FP - dbits;
BigInteger$3.prototype.F2 = 2 * dbits - BI_FP;
var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
var BI_RC = new Array();
var rr;
var vv;
rr = "0".charCodeAt(0);
for (vv = 0; vv <= 9; ++vv)
  BI_RC[rr++] = vv;
rr = "a".charCodeAt(0);
for (vv = 10; vv < 36; ++vv)
  BI_RC[rr++] = vv;
rr = "A".charCodeAt(0);
for (vv = 10; vv < 36; ++vv)
  BI_RC[rr++] = vv;
function int2char(n2) {
  return BI_RM.charAt(n2);
}
function intAt(s2, i2) {
  var c3 = BI_RC[s2.charCodeAt(i2)];
  return c3 == null ? -1 : c3;
}
function bnpCopyTo(r2) {
  for (var i2 = this.t - 1; i2 >= 0; --i2)
    r2.data[i2] = this.data[i2];
  r2.t = this.t;
  r2.s = this.s;
}
function bnpFromInt(x2) {
  this.t = 1;
  this.s = x2 < 0 ? -1 : 0;
  if (x2 > 0)
    this.data[0] = x2;
  else if (x2 < -1)
    this.data[0] = x2 + this.DV;
  else
    this.t = 0;
}
function nbv(i2) {
  var r2 = nbi();
  r2.fromInt(i2);
  return r2;
}
function bnpFromString(s2, b3) {
  var k3;
  if (b3 == 16)
    k3 = 4;
  else if (b3 == 8)
    k3 = 3;
  else if (b3 == 256)
    k3 = 8;
  else if (b3 == 2)
    k3 = 1;
  else if (b3 == 32)
    k3 = 5;
  else if (b3 == 4)
    k3 = 2;
  else {
    this.fromRadix(s2, b3);
    return;
  }
  this.t = 0;
  this.s = 0;
  var i2 = s2.length, mi = false, sh2 = 0;
  while (--i2 >= 0) {
    var x2 = k3 == 8 ? s2[i2] & 255 : intAt(s2, i2);
    if (x2 < 0) {
      if (s2.charAt(i2) == "-")
        mi = true;
      continue;
    }
    mi = false;
    if (sh2 == 0)
      this.data[this.t++] = x2;
    else if (sh2 + k3 > this.DB) {
      this.data[this.t - 1] |= (x2 & (1 << this.DB - sh2) - 1) << sh2;
      this.data[this.t++] = x2 >> this.DB - sh2;
    } else
      this.data[this.t - 1] |= x2 << sh2;
    sh2 += k3;
    if (sh2 >= this.DB)
      sh2 -= this.DB;
  }
  if (k3 == 8 && (s2[0] & 128) != 0) {
    this.s = -1;
    if (sh2 > 0)
      this.data[this.t - 1] |= (1 << this.DB - sh2) - 1 << sh2;
  }
  this.clamp();
  if (mi)
    BigInteger$3.ZERO.subTo(this, this);
}
function bnpClamp() {
  var c3 = this.s & this.DM;
  while (this.t > 0 && this.data[this.t - 1] == c3)
    --this.t;
}
function bnToString(b3) {
  if (this.s < 0)
    return "-" + this.negate().toString(b3);
  var k3;
  if (b3 == 16)
    k3 = 4;
  else if (b3 == 8)
    k3 = 3;
  else if (b3 == 2)
    k3 = 1;
  else if (b3 == 32)
    k3 = 5;
  else if (b3 == 4)
    k3 = 2;
  else
    return this.toRadix(b3);
  var km = (1 << k3) - 1, d2, m2 = false, r2 = "", i2 = this.t;
  var p2 = this.DB - i2 * this.DB % k3;
  if (i2-- > 0) {
    if (p2 < this.DB && (d2 = this.data[i2] >> p2) > 0) {
      m2 = true;
      r2 = int2char(d2);
    }
    while (i2 >= 0) {
      if (p2 < k3) {
        d2 = (this.data[i2] & (1 << p2) - 1) << k3 - p2;
        d2 |= this.data[--i2] >> (p2 += this.DB - k3);
      } else {
        d2 = this.data[i2] >> (p2 -= k3) & km;
        if (p2 <= 0) {
          p2 += this.DB;
          --i2;
        }
      }
      if (d2 > 0)
        m2 = true;
      if (m2)
        r2 += int2char(d2);
    }
  }
  return m2 ? r2 : "0";
}
function bnNegate() {
  var r2 = nbi();
  BigInteger$3.ZERO.subTo(this, r2);
  return r2;
}
function bnAbs() {
  return this.s < 0 ? this.negate() : this;
}
function bnCompareTo(a2) {
  var r2 = this.s - a2.s;
  if (r2 != 0)
    return r2;
  var i2 = this.t;
  r2 = i2 - a2.t;
  if (r2 != 0)
    return this.s < 0 ? -r2 : r2;
  while (--i2 >= 0)
    if ((r2 = this.data[i2] - a2.data[i2]) != 0)
      return r2;
  return 0;
}
function nbits(x2) {
  var r2 = 1, t2;
  if ((t2 = x2 >>> 16) != 0) {
    x2 = t2;
    r2 += 16;
  }
  if ((t2 = x2 >> 8) != 0) {
    x2 = t2;
    r2 += 8;
  }
  if ((t2 = x2 >> 4) != 0) {
    x2 = t2;
    r2 += 4;
  }
  if ((t2 = x2 >> 2) != 0) {
    x2 = t2;
    r2 += 2;
  }
  if ((t2 = x2 >> 1) != 0) {
    x2 = t2;
    r2 += 1;
  }
  return r2;
}
function bnBitLength() {
  if (this.t <= 0)
    return 0;
  return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);
}
function bnpDLShiftTo(n2, r2) {
  var i2;
  for (i2 = this.t - 1; i2 >= 0; --i2)
    r2.data[i2 + n2] = this.data[i2];
  for (i2 = n2 - 1; i2 >= 0; --i2)
    r2.data[i2] = 0;
  r2.t = this.t + n2;
  r2.s = this.s;
}
function bnpDRShiftTo(n2, r2) {
  for (var i2 = n2; i2 < this.t; ++i2)
    r2.data[i2 - n2] = this.data[i2];
  r2.t = Math.max(this.t - n2, 0);
  r2.s = this.s;
}
function bnpLShiftTo(n2, r2) {
  var bs = n2 % this.DB;
  var cbs = this.DB - bs;
  var bm = (1 << cbs) - 1;
  var ds = Math.floor(n2 / this.DB), c3 = this.s << bs & this.DM, i2;
  for (i2 = this.t - 1; i2 >= 0; --i2) {
    r2.data[i2 + ds + 1] = this.data[i2] >> cbs | c3;
    c3 = (this.data[i2] & bm) << bs;
  }
  for (i2 = ds - 1; i2 >= 0; --i2)
    r2.data[i2] = 0;
  r2.data[ds] = c3;
  r2.t = this.t + ds + 1;
  r2.s = this.s;
  r2.clamp();
}
function bnpRShiftTo(n2, r2) {
  r2.s = this.s;
  var ds = Math.floor(n2 / this.DB);
  if (ds >= this.t) {
    r2.t = 0;
    return;
  }
  var bs = n2 % this.DB;
  var cbs = this.DB - bs;
  var bm = (1 << bs) - 1;
  r2.data[0] = this.data[ds] >> bs;
  for (var i2 = ds + 1; i2 < this.t; ++i2) {
    r2.data[i2 - ds - 1] |= (this.data[i2] & bm) << cbs;
    r2.data[i2 - ds] = this.data[i2] >> bs;
  }
  if (bs > 0)
    r2.data[this.t - ds - 1] |= (this.s & bm) << cbs;
  r2.t = this.t - ds;
  r2.clamp();
}
function bnpSubTo(a2, r2) {
  var i2 = 0, c3 = 0, m2 = Math.min(a2.t, this.t);
  while (i2 < m2) {
    c3 += this.data[i2] - a2.data[i2];
    r2.data[i2++] = c3 & this.DM;
    c3 >>= this.DB;
  }
  if (a2.t < this.t) {
    c3 -= a2.s;
    while (i2 < this.t) {
      c3 += this.data[i2];
      r2.data[i2++] = c3 & this.DM;
      c3 >>= this.DB;
    }
    c3 += this.s;
  } else {
    c3 += this.s;
    while (i2 < a2.t) {
      c3 -= a2.data[i2];
      r2.data[i2++] = c3 & this.DM;
      c3 >>= this.DB;
    }
    c3 -= a2.s;
  }
  r2.s = c3 < 0 ? -1 : 0;
  if (c3 < -1)
    r2.data[i2++] = this.DV + c3;
  else if (c3 > 0)
    r2.data[i2++] = c3;
  r2.t = i2;
  r2.clamp();
}
function bnpMultiplyTo(a2, r2) {
  var x2 = this.abs(), y3 = a2.abs();
  var i2 = x2.t;
  r2.t = i2 + y3.t;
  while (--i2 >= 0)
    r2.data[i2] = 0;
  for (i2 = 0; i2 < y3.t; ++i2)
    r2.data[i2 + x2.t] = x2.am(0, y3.data[i2], r2, i2, 0, x2.t);
  r2.s = 0;
  r2.clamp();
  if (this.s != a2.s)
    BigInteger$3.ZERO.subTo(r2, r2);
}
function bnpSquareTo(r2) {
  var x2 = this.abs();
  var i2 = r2.t = 2 * x2.t;
  while (--i2 >= 0)
    r2.data[i2] = 0;
  for (i2 = 0; i2 < x2.t - 1; ++i2) {
    var c3 = x2.am(i2, x2.data[i2], r2, 2 * i2, 0, 1);
    if ((r2.data[i2 + x2.t] += x2.am(i2 + 1, 2 * x2.data[i2], r2, 2 * i2 + 1, c3, x2.t - i2 - 1)) >= x2.DV) {
      r2.data[i2 + x2.t] -= x2.DV;
      r2.data[i2 + x2.t + 1] = 1;
    }
  }
  if (r2.t > 0)
    r2.data[r2.t - 1] += x2.am(i2, x2.data[i2], r2, 2 * i2, 0, 1);
  r2.s = 0;
  r2.clamp();
}
function bnpDivRemTo(m2, q3, r2) {
  var pm = m2.abs();
  if (pm.t <= 0)
    return;
  var pt2 = this.abs();
  if (pt2.t < pm.t) {
    if (q3 != null)
      q3.fromInt(0);
    if (r2 != null)
      this.copyTo(r2);
    return;
  }
  if (r2 == null)
    r2 = nbi();
  var y3 = nbi(), ts = this.s, ms = m2.s;
  var nsh = this.DB - nbits(pm.data[pm.t - 1]);
  if (nsh > 0) {
    pm.lShiftTo(nsh, y3);
    pt2.lShiftTo(nsh, r2);
  } else {
    pm.copyTo(y3);
    pt2.copyTo(r2);
  }
  var ys = y3.t;
  var y0 = y3.data[ys - 1];
  if (y0 == 0)
    return;
  var yt2 = y0 * (1 << this.F1) + (ys > 1 ? y3.data[ys - 2] >> this.F2 : 0);
  var d1 = this.FV / yt2, d2 = (1 << this.F1) / yt2, e2 = 1 << this.F2;
  var i2 = r2.t, j3 = i2 - ys, t2 = q3 == null ? nbi() : q3;
  y3.dlShiftTo(j3, t2);
  if (r2.compareTo(t2) >= 0) {
    r2.data[r2.t++] = 1;
    r2.subTo(t2, r2);
  }
  BigInteger$3.ONE.dlShiftTo(ys, t2);
  t2.subTo(y3, y3);
  while (y3.t < ys)
    y3.data[y3.t++] = 0;
  while (--j3 >= 0) {
    var qd = r2.data[--i2] == y0 ? this.DM : Math.floor(r2.data[i2] * d1 + (r2.data[i2 - 1] + e2) * d2);
    if ((r2.data[i2] += y3.am(0, qd, r2, j3, 0, ys)) < qd) {
      y3.dlShiftTo(j3, t2);
      r2.subTo(t2, r2);
      while (r2.data[i2] < --qd)
        r2.subTo(t2, r2);
    }
  }
  if (q3 != null) {
    r2.drShiftTo(ys, q3);
    if (ts != ms)
      BigInteger$3.ZERO.subTo(q3, q3);
  }
  r2.t = ys;
  r2.clamp();
  if (nsh > 0)
    r2.rShiftTo(nsh, r2);
  if (ts < 0)
    BigInteger$3.ZERO.subTo(r2, r2);
}
function bnMod(a2) {
  var r2 = nbi();
  this.abs().divRemTo(a2, null, r2);
  if (this.s < 0 && r2.compareTo(BigInteger$3.ZERO) > 0)
    a2.subTo(r2, r2);
  return r2;
}
function Classic(m2) {
  this.m = m2;
}
function cConvert(x2) {
  if (x2.s < 0 || x2.compareTo(this.m) >= 0)
    return x2.mod(this.m);
  else
    return x2;
}
function cRevert(x2) {
  return x2;
}
function cReduce(x2) {
  x2.divRemTo(this.m, null, x2);
}
function cMulTo(x2, y3, r2) {
  x2.multiplyTo(y3, r2);
  this.reduce(r2);
}
function cSqrTo(x2, r2) {
  x2.squareTo(r2);
  this.reduce(r2);
}
Classic.prototype.convert = cConvert;
Classic.prototype.revert = cRevert;
Classic.prototype.reduce = cReduce;
Classic.prototype.mulTo = cMulTo;
Classic.prototype.sqrTo = cSqrTo;
function bnpInvDigit() {
  if (this.t < 1)
    return 0;
  var x2 = this.data[0];
  if ((x2 & 1) == 0)
    return 0;
  var y3 = x2 & 3;
  y3 = y3 * (2 - (x2 & 15) * y3) & 15;
  y3 = y3 * (2 - (x2 & 255) * y3) & 255;
  y3 = y3 * (2 - ((x2 & 65535) * y3 & 65535)) & 65535;
  y3 = y3 * (2 - x2 * y3 % this.DV) % this.DV;
  return y3 > 0 ? this.DV - y3 : -y3;
}
function Montgomery(m2) {
  this.m = m2;
  this.mp = m2.invDigit();
  this.mpl = this.mp & 32767;
  this.mph = this.mp >> 15;
  this.um = (1 << m2.DB - 15) - 1;
  this.mt2 = 2 * m2.t;
}
function montConvert(x2) {
  var r2 = nbi();
  x2.abs().dlShiftTo(this.m.t, r2);
  r2.divRemTo(this.m, null, r2);
  if (x2.s < 0 && r2.compareTo(BigInteger$3.ZERO) > 0)
    this.m.subTo(r2, r2);
  return r2;
}
function montRevert(x2) {
  var r2 = nbi();
  x2.copyTo(r2);
  this.reduce(r2);
  return r2;
}
function montReduce(x2) {
  while (x2.t <= this.mt2)
    x2.data[x2.t++] = 0;
  for (var i2 = 0; i2 < this.m.t; ++i2) {
    var j3 = x2.data[i2] & 32767;
    var u0 = j3 * this.mpl + ((j3 * this.mph + (x2.data[i2] >> 15) * this.mpl & this.um) << 15) & x2.DM;
    j3 = i2 + this.m.t;
    x2.data[j3] += this.m.am(0, u0, x2, i2, 0, this.m.t);
    while (x2.data[j3] >= x2.DV) {
      x2.data[j3] -= x2.DV;
      x2.data[++j3]++;
    }
  }
  x2.clamp();
  x2.drShiftTo(this.m.t, x2);
  if (x2.compareTo(this.m) >= 0)
    x2.subTo(this.m, x2);
}
function montSqrTo(x2, r2) {
  x2.squareTo(r2);
  this.reduce(r2);
}
function montMulTo(x2, y3, r2) {
  x2.multiplyTo(y3, r2);
  this.reduce(r2);
}
Montgomery.prototype.convert = montConvert;
Montgomery.prototype.revert = montRevert;
Montgomery.prototype.reduce = montReduce;
Montgomery.prototype.mulTo = montMulTo;
Montgomery.prototype.sqrTo = montSqrTo;
function bnpIsEven() {
  return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
}
function bnpExp(e2, z2) {
  if (e2 > 4294967295 || e2 < 1)
    return BigInteger$3.ONE;
  var r2 = nbi(), r22 = nbi(), g2 = z2.convert(this), i2 = nbits(e2) - 1;
  g2.copyTo(r2);
  while (--i2 >= 0) {
    z2.sqrTo(r2, r22);
    if ((e2 & 1 << i2) > 0)
      z2.mulTo(r22, g2, r2);
    else {
      var t2 = r2;
      r2 = r22;
      r22 = t2;
    }
  }
  return z2.revert(r2);
}
function bnModPowInt(e2, m2) {
  var z2;
  if (e2 < 256 || m2.isEven())
    z2 = new Classic(m2);
  else
    z2 = new Montgomery(m2);
  return this.exp(e2, z2);
}
BigInteger$3.prototype.copyTo = bnpCopyTo;
BigInteger$3.prototype.fromInt = bnpFromInt;
BigInteger$3.prototype.fromString = bnpFromString;
BigInteger$3.prototype.clamp = bnpClamp;
BigInteger$3.prototype.dlShiftTo = bnpDLShiftTo;
BigInteger$3.prototype.drShiftTo = bnpDRShiftTo;
BigInteger$3.prototype.lShiftTo = bnpLShiftTo;
BigInteger$3.prototype.rShiftTo = bnpRShiftTo;
BigInteger$3.prototype.subTo = bnpSubTo;
BigInteger$3.prototype.multiplyTo = bnpMultiplyTo;
BigInteger$3.prototype.squareTo = bnpSquareTo;
BigInteger$3.prototype.divRemTo = bnpDivRemTo;
BigInteger$3.prototype.invDigit = bnpInvDigit;
BigInteger$3.prototype.isEven = bnpIsEven;
BigInteger$3.prototype.exp = bnpExp;
BigInteger$3.prototype.toString = bnToString;
BigInteger$3.prototype.negate = bnNegate;
BigInteger$3.prototype.abs = bnAbs;
BigInteger$3.prototype.compareTo = bnCompareTo;
BigInteger$3.prototype.bitLength = bnBitLength;
BigInteger$3.prototype.mod = bnMod;
BigInteger$3.prototype.modPowInt = bnModPowInt;
BigInteger$3.ZERO = nbv(0);
BigInteger$3.ONE = nbv(1);
function bnClone() {
  var r2 = nbi();
  this.copyTo(r2);
  return r2;
}
function bnIntValue() {
  if (this.s < 0) {
    if (this.t == 1)
      return this.data[0] - this.DV;
    else if (this.t == 0)
      return -1;
  } else if (this.t == 1)
    return this.data[0];
  else if (this.t == 0)
    return 0;
  return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
}
function bnByteValue() {
  return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
}
function bnShortValue() {
  return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
}
function bnpChunkSize(r2) {
  return Math.floor(Math.LN2 * this.DB / Math.log(r2));
}
function bnSigNum() {
  if (this.s < 0)
    return -1;
  else if (this.t <= 0 || this.t == 1 && this.data[0] <= 0)
    return 0;
  else
    return 1;
}
function bnpToRadix(b3) {
  if (b3 == null)
    b3 = 10;
  if (this.signum() == 0 || b3 < 2 || b3 > 36)
    return "0";
  var cs = this.chunkSize(b3);
  var a2 = Math.pow(b3, cs);
  var d2 = nbv(a2), y3 = nbi(), z2 = nbi(), r2 = "";
  this.divRemTo(d2, y3, z2);
  while (y3.signum() > 0) {
    r2 = (a2 + z2.intValue()).toString(b3).substr(1) + r2;
    y3.divRemTo(d2, y3, z2);
  }
  return z2.intValue().toString(b3) + r2;
}
function bnpFromRadix(s2, b3) {
  this.fromInt(0);
  if (b3 == null)
    b3 = 10;
  var cs = this.chunkSize(b3);
  var d2 = Math.pow(b3, cs), mi = false, j3 = 0, w2 = 0;
  for (var i2 = 0; i2 < s2.length; ++i2) {
    var x2 = intAt(s2, i2);
    if (x2 < 0) {
      if (s2.charAt(i2) == "-" && this.signum() == 0)
        mi = true;
      continue;
    }
    w2 = b3 * w2 + x2;
    if (++j3 >= cs) {
      this.dMultiply(d2);
      this.dAddOffset(w2, 0);
      j3 = 0;
      w2 = 0;
    }
  }
  if (j3 > 0) {
    this.dMultiply(Math.pow(b3, j3));
    this.dAddOffset(w2, 0);
  }
  if (mi)
    BigInteger$3.ZERO.subTo(this, this);
}
function bnpFromNumber(a2, b3, c3) {
  if ("number" == typeof b3) {
    if (a2 < 2)
      this.fromInt(1);
    else {
      this.fromNumber(a2, c3);
      if (!this.testBit(a2 - 1))
        this.bitwiseTo(BigInteger$3.ONE.shiftLeft(a2 - 1), op_or, this);
      if (this.isEven())
        this.dAddOffset(1, 0);
      while (!this.isProbablePrime(b3)) {
        this.dAddOffset(2, 0);
        if (this.bitLength() > a2)
          this.subTo(BigInteger$3.ONE.shiftLeft(a2 - 1), this);
      }
    }
  } else {
    var x2 = new Array(), t2 = a2 & 7;
    x2.length = (a2 >> 3) + 1;
    b3.nextBytes(x2);
    if (t2 > 0)
      x2[0] &= (1 << t2) - 1;
    else
      x2[0] = 0;
    this.fromString(x2, 256);
  }
}
function bnToByteArray() {
  var i2 = this.t, r2 = new Array();
  r2[0] = this.s;
  var p2 = this.DB - i2 * this.DB % 8, d2, k3 = 0;
  if (i2-- > 0) {
    if (p2 < this.DB && (d2 = this.data[i2] >> p2) != (this.s & this.DM) >> p2)
      r2[k3++] = d2 | this.s << this.DB - p2;
    while (i2 >= 0) {
      if (p2 < 8) {
        d2 = (this.data[i2] & (1 << p2) - 1) << 8 - p2;
        d2 |= this.data[--i2] >> (p2 += this.DB - 8);
      } else {
        d2 = this.data[i2] >> (p2 -= 8) & 255;
        if (p2 <= 0) {
          p2 += this.DB;
          --i2;
        }
      }
      if ((d2 & 128) != 0)
        d2 |= -256;
      if (k3 == 0 && (this.s & 128) != (d2 & 128))
        ++k3;
      if (k3 > 0 || d2 != this.s)
        r2[k3++] = d2;
    }
  }
  return r2;
}
function bnEquals(a2) {
  return this.compareTo(a2) == 0;
}
function bnMin(a2) {
  return this.compareTo(a2) < 0 ? this : a2;
}
function bnMax(a2) {
  return this.compareTo(a2) > 0 ? this : a2;
}
function bnpBitwiseTo(a2, op, r2) {
  var i2, f2, m2 = Math.min(a2.t, this.t);
  for (i2 = 0; i2 < m2; ++i2)
    r2.data[i2] = op(this.data[i2], a2.data[i2]);
  if (a2.t < this.t) {
    f2 = a2.s & this.DM;
    for (i2 = m2; i2 < this.t; ++i2)
      r2.data[i2] = op(this.data[i2], f2);
    r2.t = this.t;
  } else {
    f2 = this.s & this.DM;
    for (i2 = m2; i2 < a2.t; ++i2)
      r2.data[i2] = op(f2, a2.data[i2]);
    r2.t = a2.t;
  }
  r2.s = op(this.s, a2.s);
  r2.clamp();
}
function op_and(x2, y3) {
  return x2 & y3;
}
function bnAnd(a2) {
  var r2 = nbi();
  this.bitwiseTo(a2, op_and, r2);
  return r2;
}
function op_or(x2, y3) {
  return x2 | y3;
}
function bnOr(a2) {
  var r2 = nbi();
  this.bitwiseTo(a2, op_or, r2);
  return r2;
}
function op_xor(x2, y3) {
  return x2 ^ y3;
}
function bnXor(a2) {
  var r2 = nbi();
  this.bitwiseTo(a2, op_xor, r2);
  return r2;
}
function op_andnot(x2, y3) {
  return x2 & ~y3;
}
function bnAndNot(a2) {
  var r2 = nbi();
  this.bitwiseTo(a2, op_andnot, r2);
  return r2;
}
function bnNot() {
  var r2 = nbi();
  for (var i2 = 0; i2 < this.t; ++i2)
    r2.data[i2] = this.DM & ~this.data[i2];
  r2.t = this.t;
  r2.s = ~this.s;
  return r2;
}
function bnShiftLeft(n2) {
  var r2 = nbi();
  if (n2 < 0)
    this.rShiftTo(-n2, r2);
  else
    this.lShiftTo(n2, r2);
  return r2;
}
function bnShiftRight(n2) {
  var r2 = nbi();
  if (n2 < 0)
    this.lShiftTo(-n2, r2);
  else
    this.rShiftTo(n2, r2);
  return r2;
}
function lbit(x2) {
  if (x2 == 0)
    return -1;
  var r2 = 0;
  if ((x2 & 65535) == 0) {
    x2 >>= 16;
    r2 += 16;
  }
  if ((x2 & 255) == 0) {
    x2 >>= 8;
    r2 += 8;
  }
  if ((x2 & 15) == 0) {
    x2 >>= 4;
    r2 += 4;
  }
  if ((x2 & 3) == 0) {
    x2 >>= 2;
    r2 += 2;
  }
  if ((x2 & 1) == 0)
    ++r2;
  return r2;
}
function bnGetLowestSetBit() {
  for (var i2 = 0; i2 < this.t; ++i2)
    if (this.data[i2] != 0)
      return i2 * this.DB + lbit(this.data[i2]);
  if (this.s < 0)
    return this.t * this.DB;
  return -1;
}
function cbit(x2) {
  var r2 = 0;
  while (x2 != 0) {
    x2 &= x2 - 1;
    ++r2;
  }
  return r2;
}
function bnBitCount() {
  var r2 = 0, x2 = this.s & this.DM;
  for (var i2 = 0; i2 < this.t; ++i2)
    r2 += cbit(this.data[i2] ^ x2);
  return r2;
}
function bnTestBit(n2) {
  var j3 = Math.floor(n2 / this.DB);
  if (j3 >= this.t)
    return this.s != 0;
  return (this.data[j3] & 1 << n2 % this.DB) != 0;
}
function bnpChangeBit(n2, op) {
  var r2 = BigInteger$3.ONE.shiftLeft(n2);
  this.bitwiseTo(r2, op, r2);
  return r2;
}
function bnSetBit(n2) {
  return this.changeBit(n2, op_or);
}
function bnClearBit(n2) {
  return this.changeBit(n2, op_andnot);
}
function bnFlipBit(n2) {
  return this.changeBit(n2, op_xor);
}
function bnpAddTo(a2, r2) {
  var i2 = 0, c3 = 0, m2 = Math.min(a2.t, this.t);
  while (i2 < m2) {
    c3 += this.data[i2] + a2.data[i2];
    r2.data[i2++] = c3 & this.DM;
    c3 >>= this.DB;
  }
  if (a2.t < this.t) {
    c3 += a2.s;
    while (i2 < this.t) {
      c3 += this.data[i2];
      r2.data[i2++] = c3 & this.DM;
      c3 >>= this.DB;
    }
    c3 += this.s;
  } else {
    c3 += this.s;
    while (i2 < a2.t) {
      c3 += a2.data[i2];
      r2.data[i2++] = c3 & this.DM;
      c3 >>= this.DB;
    }
    c3 += a2.s;
  }
  r2.s = c3 < 0 ? -1 : 0;
  if (c3 > 0)
    r2.data[i2++] = c3;
  else if (c3 < -1)
    r2.data[i2++] = this.DV + c3;
  r2.t = i2;
  r2.clamp();
}
function bnAdd(a2) {
  var r2 = nbi();
  this.addTo(a2, r2);
  return r2;
}
function bnSubtract(a2) {
  var r2 = nbi();
  this.subTo(a2, r2);
  return r2;
}
function bnMultiply(a2) {
  var r2 = nbi();
  this.multiplyTo(a2, r2);
  return r2;
}
function bnDivide(a2) {
  var r2 = nbi();
  this.divRemTo(a2, r2, null);
  return r2;
}
function bnRemainder(a2) {
  var r2 = nbi();
  this.divRemTo(a2, null, r2);
  return r2;
}
function bnDivideAndRemainder(a2) {
  var q3 = nbi(), r2 = nbi();
  this.divRemTo(a2, q3, r2);
  return new Array(q3, r2);
}
function bnpDMultiply(n2) {
  this.data[this.t] = this.am(0, n2 - 1, this, 0, 0, this.t);
  ++this.t;
  this.clamp();
}
function bnpDAddOffset(n2, w2) {
  if (n2 == 0)
    return;
  while (this.t <= w2)
    this.data[this.t++] = 0;
  this.data[w2] += n2;
  while (this.data[w2] >= this.DV) {
    this.data[w2] -= this.DV;
    if (++w2 >= this.t)
      this.data[this.t++] = 0;
    ++this.data[w2];
  }
}
function NullExp() {
}
function nNop(x2) {
  return x2;
}
function nMulTo(x2, y3, r2) {
  x2.multiplyTo(y3, r2);
}
function nSqrTo(x2, r2) {
  x2.squareTo(r2);
}
NullExp.prototype.convert = nNop;
NullExp.prototype.revert = nNop;
NullExp.prototype.mulTo = nMulTo;
NullExp.prototype.sqrTo = nSqrTo;
function bnPow(e2) {
  return this.exp(e2, new NullExp());
}
function bnpMultiplyLowerTo(a2, n2, r2) {
  var i2 = Math.min(this.t + a2.t, n2);
  r2.s = 0;
  r2.t = i2;
  while (i2 > 0)
    r2.data[--i2] = 0;
  var j3;
  for (j3 = r2.t - this.t; i2 < j3; ++i2)
    r2.data[i2 + this.t] = this.am(0, a2.data[i2], r2, i2, 0, this.t);
  for (j3 = Math.min(a2.t, n2); i2 < j3; ++i2)
    this.am(0, a2.data[i2], r2, i2, 0, n2 - i2);
  r2.clamp();
}
function bnpMultiplyUpperTo(a2, n2, r2) {
  --n2;
  var i2 = r2.t = this.t + a2.t - n2;
  r2.s = 0;
  while (--i2 >= 0)
    r2.data[i2] = 0;
  for (i2 = Math.max(n2 - this.t, 0); i2 < a2.t; ++i2)
    r2.data[this.t + i2 - n2] = this.am(n2 - i2, a2.data[i2], r2, 0, 0, this.t + i2 - n2);
  r2.clamp();
  r2.drShiftTo(1, r2);
}
function Barrett(m2) {
  this.r2 = nbi();
  this.q3 = nbi();
  BigInteger$3.ONE.dlShiftTo(2 * m2.t, this.r2);
  this.mu = this.r2.divide(m2);
  this.m = m2;
}
function barrettConvert(x2) {
  if (x2.s < 0 || x2.t > 2 * this.m.t)
    return x2.mod(this.m);
  else if (x2.compareTo(this.m) < 0)
    return x2;
  else {
    var r2 = nbi();
    x2.copyTo(r2);
    this.reduce(r2);
    return r2;
  }
}
function barrettRevert(x2) {
  return x2;
}
function barrettReduce(x2) {
  x2.drShiftTo(this.m.t - 1, this.r2);
  if (x2.t > this.m.t + 1) {
    x2.t = this.m.t + 1;
    x2.clamp();
  }
  this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
  this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
  while (x2.compareTo(this.r2) < 0)
    x2.dAddOffset(1, this.m.t + 1);
  x2.subTo(this.r2, x2);
  while (x2.compareTo(this.m) >= 0)
    x2.subTo(this.m, x2);
}
function barrettSqrTo(x2, r2) {
  x2.squareTo(r2);
  this.reduce(r2);
}
function barrettMulTo(x2, y3, r2) {
  x2.multiplyTo(y3, r2);
  this.reduce(r2);
}
Barrett.prototype.convert = barrettConvert;
Barrett.prototype.revert = barrettRevert;
Barrett.prototype.reduce = barrettReduce;
Barrett.prototype.mulTo = barrettMulTo;
Barrett.prototype.sqrTo = barrettSqrTo;
function bnModPow(e2, m2) {
  var i2 = e2.bitLength(), k3, r2 = nbv(1), z2;
  if (i2 <= 0)
    return r2;
  else if (i2 < 18)
    k3 = 1;
  else if (i2 < 48)
    k3 = 3;
  else if (i2 < 144)
    k3 = 4;
  else if (i2 < 768)
    k3 = 5;
  else
    k3 = 6;
  if (i2 < 8)
    z2 = new Classic(m2);
  else if (m2.isEven())
    z2 = new Barrett(m2);
  else
    z2 = new Montgomery(m2);
  var g2 = new Array(), n2 = 3, k1 = k3 - 1, km = (1 << k3) - 1;
  g2[1] = z2.convert(this);
  if (k3 > 1) {
    var g22 = nbi();
    z2.sqrTo(g2[1], g22);
    while (n2 <= km) {
      g2[n2] = nbi();
      z2.mulTo(g22, g2[n2 - 2], g2[n2]);
      n2 += 2;
    }
  }
  var j3 = e2.t - 1, w2, is1 = true, r22 = nbi(), t2;
  i2 = nbits(e2.data[j3]) - 1;
  while (j3 >= 0) {
    if (i2 >= k1)
      w2 = e2.data[j3] >> i2 - k1 & km;
    else {
      w2 = (e2.data[j3] & (1 << i2 + 1) - 1) << k1 - i2;
      if (j3 > 0)
        w2 |= e2.data[j3 - 1] >> this.DB + i2 - k1;
    }
    n2 = k3;
    while ((w2 & 1) == 0) {
      w2 >>= 1;
      --n2;
    }
    if ((i2 -= n2) < 0) {
      i2 += this.DB;
      --j3;
    }
    if (is1) {
      g2[w2].copyTo(r2);
      is1 = false;
    } else {
      while (n2 > 1) {
        z2.sqrTo(r2, r22);
        z2.sqrTo(r22, r2);
        n2 -= 2;
      }
      if (n2 > 0)
        z2.sqrTo(r2, r22);
      else {
        t2 = r2;
        r2 = r22;
        r22 = t2;
      }
      z2.mulTo(r22, g2[w2], r2);
    }
    while (j3 >= 0 && (e2.data[j3] & 1 << i2) == 0) {
      z2.sqrTo(r2, r22);
      t2 = r2;
      r2 = r22;
      r22 = t2;
      if (--i2 < 0) {
        i2 = this.DB - 1;
        --j3;
      }
    }
  }
  return z2.revert(r2);
}
function bnGCD(a2) {
  var x2 = this.s < 0 ? this.negate() : this.clone();
  var y3 = a2.s < 0 ? a2.negate() : a2.clone();
  if (x2.compareTo(y3) < 0) {
    var t2 = x2;
    x2 = y3;
    y3 = t2;
  }
  var i2 = x2.getLowestSetBit(), g2 = y3.getLowestSetBit();
  if (g2 < 0)
    return x2;
  if (i2 < g2)
    g2 = i2;
  if (g2 > 0) {
    x2.rShiftTo(g2, x2);
    y3.rShiftTo(g2, y3);
  }
  while (x2.signum() > 0) {
    if ((i2 = x2.getLowestSetBit()) > 0)
      x2.rShiftTo(i2, x2);
    if ((i2 = y3.getLowestSetBit()) > 0)
      y3.rShiftTo(i2, y3);
    if (x2.compareTo(y3) >= 0) {
      x2.subTo(y3, x2);
      x2.rShiftTo(1, x2);
    } else {
      y3.subTo(x2, y3);
      y3.rShiftTo(1, y3);
    }
  }
  if (g2 > 0)
    y3.lShiftTo(g2, y3);
  return y3;
}
function bnpModInt(n2) {
  if (n2 <= 0)
    return 0;
  var d2 = this.DV % n2, r2 = this.s < 0 ? n2 - 1 : 0;
  if (this.t > 0)
    if (d2 == 0)
      r2 = this.data[0] % n2;
    else
      for (var i2 = this.t - 1; i2 >= 0; --i2)
        r2 = (d2 * r2 + this.data[i2]) % n2;
  return r2;
}
function bnModInverse(m2) {
  var ac = m2.isEven();
  if (this.isEven() && ac || m2.signum() == 0)
    return BigInteger$3.ZERO;
  var u2 = m2.clone(), v2 = this.clone();
  var a2 = nbv(1), b3 = nbv(0), c3 = nbv(0), d2 = nbv(1);
  while (u2.signum() != 0) {
    while (u2.isEven()) {
      u2.rShiftTo(1, u2);
      if (ac) {
        if (!a2.isEven() || !b3.isEven()) {
          a2.addTo(this, a2);
          b3.subTo(m2, b3);
        }
        a2.rShiftTo(1, a2);
      } else if (!b3.isEven())
        b3.subTo(m2, b3);
      b3.rShiftTo(1, b3);
    }
    while (v2.isEven()) {
      v2.rShiftTo(1, v2);
      if (ac) {
        if (!c3.isEven() || !d2.isEven()) {
          c3.addTo(this, c3);
          d2.subTo(m2, d2);
        }
        c3.rShiftTo(1, c3);
      } else if (!d2.isEven())
        d2.subTo(m2, d2);
      d2.rShiftTo(1, d2);
    }
    if (u2.compareTo(v2) >= 0) {
      u2.subTo(v2, u2);
      if (ac)
        a2.subTo(c3, a2);
      b3.subTo(d2, b3);
    } else {
      v2.subTo(u2, v2);
      if (ac)
        c3.subTo(a2, c3);
      d2.subTo(b3, d2);
    }
  }
  if (v2.compareTo(BigInteger$3.ONE) != 0)
    return BigInteger$3.ZERO;
  if (d2.compareTo(m2) >= 0)
    return d2.subtract(m2);
  if (d2.signum() < 0)
    d2.addTo(m2, d2);
  else
    return d2;
  if (d2.signum() < 0)
    return d2.add(m2);
  else
    return d2;
}
var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];
var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
function bnIsProbablePrime(t2) {
  var i2, x2 = this.abs();
  if (x2.t == 1 && x2.data[0] <= lowprimes[lowprimes.length - 1]) {
    for (i2 = 0; i2 < lowprimes.length; ++i2)
      if (x2.data[0] == lowprimes[i2])
        return true;
    return false;
  }
  if (x2.isEven())
    return false;
  i2 = 1;
  while (i2 < lowprimes.length) {
    var m2 = lowprimes[i2], j3 = i2 + 1;
    while (j3 < lowprimes.length && m2 < lplim)
      m2 *= lowprimes[j3++];
    m2 = x2.modInt(m2);
    while (i2 < j3)
      if (m2 % lowprimes[i2++] == 0)
        return false;
  }
  return x2.millerRabin(t2);
}
function bnpMillerRabin(t2) {
  var n1 = this.subtract(BigInteger$3.ONE);
  var k3 = n1.getLowestSetBit();
  if (k3 <= 0)
    return false;
  var r2 = n1.shiftRight(k3);
  var prng2 = bnGetPrng();
  var a2;
  for (var i2 = 0; i2 < t2; ++i2) {
    do {
      a2 = new BigInteger$3(this.bitLength(), prng2);
    } while (a2.compareTo(BigInteger$3.ONE) <= 0 || a2.compareTo(n1) >= 0);
    var y3 = a2.modPow(r2, this);
    if (y3.compareTo(BigInteger$3.ONE) != 0 && y3.compareTo(n1) != 0) {
      var j3 = 1;
      while (j3++ < k3 && y3.compareTo(n1) != 0) {
        y3 = y3.modPowInt(2, this);
        if (y3.compareTo(BigInteger$3.ONE) == 0)
          return false;
      }
      if (y3.compareTo(n1) != 0)
        return false;
    }
  }
  return true;
}
function bnGetPrng() {
  return {
    // x is an array to fill with bytes
    nextBytes: function nextBytes(x2) {
      for (var i2 = 0; i2 < x2.length; ++i2) {
        x2[i2] = Math.floor(Math.random() * 256);
      }
    }
  };
}
BigInteger$3.prototype.chunkSize = bnpChunkSize;
BigInteger$3.prototype.toRadix = bnpToRadix;
BigInteger$3.prototype.fromRadix = bnpFromRadix;
BigInteger$3.prototype.fromNumber = bnpFromNumber;
BigInteger$3.prototype.bitwiseTo = bnpBitwiseTo;
BigInteger$3.prototype.changeBit = bnpChangeBit;
BigInteger$3.prototype.addTo = bnpAddTo;
BigInteger$3.prototype.dMultiply = bnpDMultiply;
BigInteger$3.prototype.dAddOffset = bnpDAddOffset;
BigInteger$3.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
BigInteger$3.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
BigInteger$3.prototype.modInt = bnpModInt;
BigInteger$3.prototype.millerRabin = bnpMillerRabin;
BigInteger$3.prototype.clone = bnClone;
BigInteger$3.prototype.intValue = bnIntValue;
BigInteger$3.prototype.byteValue = bnByteValue;
BigInteger$3.prototype.shortValue = bnShortValue;
BigInteger$3.prototype.signum = bnSigNum;
BigInteger$3.prototype.toByteArray = bnToByteArray;
BigInteger$3.prototype.equals = bnEquals;
BigInteger$3.prototype.min = bnMin;
BigInteger$3.prototype.max = bnMax;
BigInteger$3.prototype.and = bnAnd;
BigInteger$3.prototype.or = bnOr;
BigInteger$3.prototype.xor = bnXor;
BigInteger$3.prototype.andNot = bnAndNot;
BigInteger$3.prototype.not = bnNot;
BigInteger$3.prototype.shiftLeft = bnShiftLeft;
BigInteger$3.prototype.shiftRight = bnShiftRight;
BigInteger$3.prototype.getLowestSetBit = bnGetLowestSetBit;
BigInteger$3.prototype.bitCount = bnBitCount;
BigInteger$3.prototype.testBit = bnTestBit;
BigInteger$3.prototype.setBit = bnSetBit;
BigInteger$3.prototype.clearBit = bnClearBit;
BigInteger$3.prototype.flipBit = bnFlipBit;
BigInteger$3.prototype.add = bnAdd;
BigInteger$3.prototype.subtract = bnSubtract;
BigInteger$3.prototype.multiply = bnMultiply;
BigInteger$3.prototype.divide = bnDivide;
BigInteger$3.prototype.remainder = bnRemainder;
BigInteger$3.prototype.divideAndRemainder = bnDivideAndRemainder;
BigInteger$3.prototype.modPow = bnModPow;
BigInteger$3.prototype.modInverse = bnModInverse;
BigInteger$3.prototype.pow = bnPow;
BigInteger$3.prototype.gcd = bnGCD;
BigInteger$3.prototype.isProbablePrime = bnIsProbablePrime;
var forge$b = forge$t;
var sha1 = forge$b.sha1 = forge$b.sha1 || {};
forge$b.md.sha1 = forge$b.md.algorithms.sha1 = sha1;
sha1.create = function() {
  if (!_initialized$1) {
    _init$1();
  }
  var _state = null;
  var _input = forge$b.util.createBuffer();
  var _w = new Array(80);
  var md = {
    algorithm: "sha1",
    blockLength: 64,
    digestLength: 20,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 8
  };
  md.start = function() {
    md.messageLength = 0;
    md.fullMessageLength = md.messageLength64 = [];
    var int32s = md.messageLengthSize / 4;
    for (var i2 = 0; i2 < int32s; ++i2) {
      md.fullMessageLength.push(0);
    }
    _input = forge$b.util.createBuffer();
    _state = { h0: 1732584193, h1: 4023233417, h2: 2562383102, h3: 271733878, h4: 3285377520 };
    return md;
  };
  md.start();
  md.update = function(msg, encoding) {
    if (encoding === "utf8") {
      msg = forge$b.util.encodeUtf8(msg);
    }
    var len2 = msg.length;
    md.messageLength += len2;
    len2 = [len2 / 4294967296 >>> 0, len2 >>> 0];
    for (var i2 = md.fullMessageLength.length - 1; i2 >= 0; --i2) {
      md.fullMessageLength[i2] += len2[1];
      len2[1] = len2[0] + (md.fullMessageLength[i2] / 4294967296 >>> 0);
      md.fullMessageLength[i2] = md.fullMessageLength[i2] >>> 0;
      len2[0] = len2[1] / 4294967296 >>> 0;
    }
    _input.putBytes(msg);
    _update$1(_state, _w, _input);
    if (_input.read > 2048 || _input.length() === 0) {
      _input.compact();
    }
    return md;
  };
  md.digest = function() {
    var finalBlock = forge$b.util.createBuffer();
    finalBlock.putBytes(_input.bytes());
    var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
    var overflow = remaining & md.blockLength - 1;
    finalBlock.putBytes(_padding$1.substr(0, md.blockLength - overflow));
    var next, carry;
    var bits = md.fullMessageLength[0] * 8;
    for (var i2 = 0; i2 < md.fullMessageLength.length - 1; ++i2) {
      next = md.fullMessageLength[i2 + 1] * 8;
      carry = next / 4294967296 >>> 0;
      bits += carry;
      finalBlock.putInt32(bits >>> 0);
      bits = next >>> 0;
    }
    finalBlock.putInt32(bits);
    var s2 = { h0: _state.h0, h1: _state.h1, h2: _state.h2, h3: _state.h3, h4: _state.h4 };
    _update$1(s2, _w, finalBlock);
    var rval = forge$b.util.createBuffer();
    rval.putInt32(s2.h0);
    rval.putInt32(s2.h1);
    rval.putInt32(s2.h2);
    rval.putInt32(s2.h3);
    rval.putInt32(s2.h4);
    return rval;
  };
  return md;
};
var _padding$1 = null;
var _initialized$1 = false;
function _init$1() {
  _padding$1 = String.fromCharCode(128);
  _padding$1 += forge$b.util.fillString(String.fromCharCode(0), 64);
  _initialized$1 = true;
}
function _update$1(s2, w2, bytes) {
  var t2, a2, b3, c3, d2, e2, f2, i2;
  var len2 = bytes.length();
  while (len2 >= 64) {
    a2 = s2.h0;
    b3 = s2.h1;
    c3 = s2.h2;
    d2 = s2.h3;
    e2 = s2.h4;
    for (i2 = 0; i2 < 16; ++i2) {
      t2 = bytes.getInt32();
      w2[i2] = t2;
      f2 = d2 ^ b3 & (c3 ^ d2);
      t2 = (a2 << 5 | a2 >>> 27) + f2 + e2 + 1518500249 + t2;
      e2 = d2;
      d2 = c3;
      c3 = (b3 << 30 | b3 >>> 2) >>> 0;
      b3 = a2;
      a2 = t2;
    }
    for (; i2 < 20; ++i2) {
      t2 = w2[i2 - 3] ^ w2[i2 - 8] ^ w2[i2 - 14] ^ w2[i2 - 16];
      t2 = t2 << 1 | t2 >>> 31;
      w2[i2] = t2;
      f2 = d2 ^ b3 & (c3 ^ d2);
      t2 = (a2 << 5 | a2 >>> 27) + f2 + e2 + 1518500249 + t2;
      e2 = d2;
      d2 = c3;
      c3 = (b3 << 30 | b3 >>> 2) >>> 0;
      b3 = a2;
      a2 = t2;
    }
    for (; i2 < 32; ++i2) {
      t2 = w2[i2 - 3] ^ w2[i2 - 8] ^ w2[i2 - 14] ^ w2[i2 - 16];
      t2 = t2 << 1 | t2 >>> 31;
      w2[i2] = t2;
      f2 = b3 ^ c3 ^ d2;
      t2 = (a2 << 5 | a2 >>> 27) + f2 + e2 + 1859775393 + t2;
      e2 = d2;
      d2 = c3;
      c3 = (b3 << 30 | b3 >>> 2) >>> 0;
      b3 = a2;
      a2 = t2;
    }
    for (; i2 < 40; ++i2) {
      t2 = w2[i2 - 6] ^ w2[i2 - 16] ^ w2[i2 - 28] ^ w2[i2 - 32];
      t2 = t2 << 2 | t2 >>> 30;
      w2[i2] = t2;
      f2 = b3 ^ c3 ^ d2;
      t2 = (a2 << 5 | a2 >>> 27) + f2 + e2 + 1859775393 + t2;
      e2 = d2;
      d2 = c3;
      c3 = (b3 << 30 | b3 >>> 2) >>> 0;
      b3 = a2;
      a2 = t2;
    }
    for (; i2 < 60; ++i2) {
      t2 = w2[i2 - 6] ^ w2[i2 - 16] ^ w2[i2 - 28] ^ w2[i2 - 32];
      t2 = t2 << 2 | t2 >>> 30;
      w2[i2] = t2;
      f2 = b3 & c3 | d2 & (b3 ^ c3);
      t2 = (a2 << 5 | a2 >>> 27) + f2 + e2 + 2400959708 + t2;
      e2 = d2;
      d2 = c3;
      c3 = (b3 << 30 | b3 >>> 2) >>> 0;
      b3 = a2;
      a2 = t2;
    }
    for (; i2 < 80; ++i2) {
      t2 = w2[i2 - 6] ^ w2[i2 - 16] ^ w2[i2 - 28] ^ w2[i2 - 32];
      t2 = t2 << 2 | t2 >>> 30;
      w2[i2] = t2;
      f2 = b3 ^ c3 ^ d2;
      t2 = (a2 << 5 | a2 >>> 27) + f2 + e2 + 3395469782 + t2;
      e2 = d2;
      d2 = c3;
      c3 = (b3 << 30 | b3 >>> 2) >>> 0;
      b3 = a2;
      a2 = t2;
    }
    s2.h0 = s2.h0 + a2 | 0;
    s2.h1 = s2.h1 + b3 | 0;
    s2.h2 = s2.h2 + c3 | 0;
    s2.h3 = s2.h3 + d2 | 0;
    s2.h4 = s2.h4 + e2 | 0;
    len2 -= 64;
  }
}
var forge$a = forge$t;
var pkcs1 = forge$a.pkcs1 = forge$a.pkcs1 || {};
pkcs1.encode_rsa_oaep = function(key3, message, options) {
  var label;
  var seed;
  var md;
  var mgf1Md;
  if (typeof options === "string") {
    label = options;
    seed = arguments[3] || void 0;
    md = arguments[4] || void 0;
  } else if (options) {
    label = options.label || void 0;
    seed = options.seed || void 0;
    md = options.md || void 0;
    if (options.mgf1 && options.mgf1.md) {
      mgf1Md = options.mgf1.md;
    }
  }
  if (!md) {
    md = forge$a.md.sha1.create();
  } else {
    md.start();
  }
  if (!mgf1Md) {
    mgf1Md = md;
  }
  var keyLength = Math.ceil(key3.n.bitLength() / 8);
  var maxLength = keyLength - 2 * md.digestLength - 2;
  if (message.length > maxLength) {
    var error3 = new Error("RSAES-OAEP input message length is too long.");
    error3.length = message.length;
    error3.maxLength = maxLength;
    throw error3;
  }
  if (!label) {
    label = "";
  }
  md.update(label, "raw");
  var lHash = md.digest();
  var PS = "";
  var PS_length = maxLength - message.length;
  for (var i2 = 0; i2 < PS_length; i2++) {
    PS += "\0";
  }
  var DB = lHash.getBytes() + PS + "" + message;
  if (!seed) {
    seed = forge$a.random.getBytes(md.digestLength);
  } else if (seed.length !== md.digestLength) {
    var error3 = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
    error3.seedLength = seed.length;
    error3.digestLength = md.digestLength;
    throw error3;
  }
  var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
  var maskedDB = forge$a.util.xorBytes(DB, dbMask, DB.length);
  var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
  var maskedSeed = forge$a.util.xorBytes(seed, seedMask, seed.length);
  return "\0" + maskedSeed + maskedDB;
};
pkcs1.decode_rsa_oaep = function(key3, em, options) {
  var label;
  var md;
  var mgf1Md;
  if (typeof options === "string") {
    label = options;
    md = arguments[3] || void 0;
  } else if (options) {
    label = options.label || void 0;
    md = options.md || void 0;
    if (options.mgf1 && options.mgf1.md) {
      mgf1Md = options.mgf1.md;
    }
  }
  var keyLength = Math.ceil(key3.n.bitLength() / 8);
  if (em.length !== keyLength) {
    var error3 = new Error("RSAES-OAEP encoded message length is invalid.");
    error3.length = em.length;
    error3.expectedLength = keyLength;
    throw error3;
  }
  if (md === void 0) {
    md = forge$a.md.sha1.create();
  } else {
    md.start();
  }
  if (!mgf1Md) {
    mgf1Md = md;
  }
  if (keyLength < 2 * md.digestLength + 2) {
    throw new Error("RSAES-OAEP key is too short for the hash function.");
  }
  if (!label) {
    label = "";
  }
  md.update(label, "raw");
  var lHash = md.digest().getBytes();
  var y3 = em.charAt(0);
  var maskedSeed = em.substring(1, md.digestLength + 1);
  var maskedDB = em.substring(1 + md.digestLength);
  var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
  var seed = forge$a.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);
  var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
  var db = forge$a.util.xorBytes(maskedDB, dbMask, maskedDB.length);
  var lHashPrime = db.substring(0, md.digestLength);
  var error3 = y3 !== "\0";
  for (var i2 = 0; i2 < md.digestLength; ++i2) {
    error3 |= lHash.charAt(i2) !== lHashPrime.charAt(i2);
  }
  var in_ps = 1;
  var index = md.digestLength;
  for (var j3 = md.digestLength; j3 < db.length; j3++) {
    var code2 = db.charCodeAt(j3);
    var is_0 = code2 & 1 ^ 1;
    var error_mask = in_ps ? 65534 : 0;
    error3 |= code2 & error_mask;
    in_ps = in_ps & is_0;
    index += in_ps;
  }
  if (error3 || db.charCodeAt(index) !== 1) {
    throw new Error("Invalid RSAES-OAEP padding.");
  }
  return db.substring(index + 1);
};
function rsa_mgf1(seed, maskLength, hash2) {
  if (!hash2) {
    hash2 = forge$a.md.sha1.create();
  }
  var t2 = "";
  var count = Math.ceil(maskLength / hash2.digestLength);
  for (var i2 = 0; i2 < count; ++i2) {
    var c3 = String.fromCharCode(i2 >> 24 & 255, i2 >> 16 & 255, i2 >> 8 & 255, i2 & 255);
    hash2.start();
    hash2.update(seed + c3);
    t2 += hash2.digest().getBytes();
  }
  return t2.substring(0, maskLength);
}
var forge$9 = forge$t;
(function() {
  if (forge$9.prime) {
    forge$9.prime;
    return;
  }
  var prime = forge$9.prime = forge$9.prime || {};
  var BigInteger2 = forge$9.jsbn.BigInteger;
  var GCD_30_DELTA2 = [6, 4, 2, 4, 2, 4, 6, 2];
  var THIRTY = new BigInteger2(null);
  THIRTY.fromInt(30);
  var op_or2 = function op_or3(x2, y3) {
    return x2 | y3;
  };
  prime.generateProbablePrime = function(bits, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    options = options || {};
    var algorithm = options.algorithm || "PRIMEINC";
    if (typeof algorithm === "string") {
      algorithm = { name: algorithm };
    }
    algorithm.options = algorithm.options || {};
    var prng2 = options.prng || forge$9.random;
    var rng = {
      // x is an array to fill with bytes
      nextBytes: function nextBytes(x2) {
        var b3 = prng2.getBytesSync(x2.length);
        for (var i2 = 0; i2 < x2.length; ++i2) {
          x2[i2] = b3.charCodeAt(i2);
        }
      }
    };
    if (algorithm.name === "PRIMEINC") {
      return primeincFindPrime(bits, rng, algorithm.options, callback);
    }
    throw new Error("Invalid prime generation algorithm: " + algorithm.name);
  };
  function primeincFindPrime(bits, rng, options, callback) {
    if ("workers" in options) {
      return primeincFindPrimeWithWorkers(bits, rng, options, callback);
    }
    return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
  }
  function primeincFindPrimeWithoutWorkers(bits, rng, options, callback) {
    var num = generateRandom(bits, rng);
    var deltaIdx = 0;
    var mrTests = getMillerRabinTests(num.bitLength());
    if ("millerRabinTests" in options) {
      mrTests = options.millerRabinTests;
    }
    var maxBlockTime = 10;
    if ("maxBlockTime" in options) {
      maxBlockTime = options.maxBlockTime;
    }
    _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
  }
  function _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback) {
    var start = +/* @__PURE__ */ new Date();
    do {
      if (num.bitLength() > bits) {
        num = generateRandom(bits, rng);
      }
      if (num.isProbablePrime(mrTests)) {
        return callback(null, num);
      }
      num.dAddOffset(GCD_30_DELTA2[deltaIdx++ % 8], 0);
    } while (maxBlockTime < 0 || +/* @__PURE__ */ new Date() - start < maxBlockTime);
    forge$9.util.setImmediate(function() {
      _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
    });
  }
  function primeincFindPrimeWithWorkers(bits, rng, options, callback) {
    if (typeof Worker === "undefined") {
      return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
    }
    var num = generateRandom(bits, rng);
    var numWorkers = options.workers;
    var workLoad = options.workLoad || 100;
    var range = workLoad * 30 / 8;
    var workerScript = options.workerScript || "forge/prime.worker.js";
    if (numWorkers === -1) {
      return forge$9.util.estimateCores(function(err, cores) {
        if (err) {
          cores = 2;
        }
        numWorkers = cores - 1;
        generate2();
      });
    }
    generate2();
    function generate2() {
      numWorkers = Math.max(1, numWorkers);
      var workers = [];
      for (var i2 = 0; i2 < numWorkers; ++i2) {
        workers[i2] = new Worker(workerScript);
      }
      for (var i2 = 0; i2 < numWorkers; ++i2) {
        workers[i2].addEventListener("message", workerMessage);
      }
      var found = false;
      function workerMessage(e2) {
        if (found) {
          return;
        }
        var data = e2.data;
        if (data.found) {
          for (var i3 = 0; i3 < workers.length; ++i3) {
            workers[i3].terminate();
          }
          found = true;
          return callback(null, new BigInteger2(data.prime, 16));
        }
        if (num.bitLength() > bits) {
          num = generateRandom(bits, rng);
        }
        var hex = num.toString(16);
        e2.target.postMessage({ hex, workLoad });
        num.dAddOffset(range, 0);
      }
    }
  }
  function generateRandom(bits, rng) {
    var num = new BigInteger2(bits, rng);
    var bits1 = bits - 1;
    if (!num.testBit(bits1)) {
      num.bitwiseTo(BigInteger2.ONE.shiftLeft(bits1), op_or2, num);
    }
    num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);
    return num;
  }
  function getMillerRabinTests(bits) {
    if (bits <= 100)
      return 27;
    if (bits <= 150)
      return 18;
    if (bits <= 200)
      return 15;
    if (bits <= 250)
      return 12;
    if (bits <= 300)
      return 9;
    if (bits <= 350)
      return 8;
    if (bits <= 400)
      return 7;
    if (bits <= 500)
      return 6;
    if (bits <= 600)
      return 5;
    if (bits <= 800)
      return 4;
    if (bits <= 1250)
      return 3;
    return 2;
  }
})();
var forge$8 = forge$t;
if (typeof BigInteger$2 === "undefined") {
  BigInteger$2 = forge$8.jsbn.BigInteger;
}
var BigInteger$2;
var _crypto = forge$8.util.isNodejs ? require$$0$4 : null;
var asn1$2 = forge$8.asn1;
var util$1 = forge$8.util;
forge$8.pki = forge$8.pki || {};
forge$8.pki.rsa = forge$8.rsa = forge$8.rsa || {};
var pki$1 = forge$8.pki;
var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
var privateKeyValidator$1 = {
  // PrivateKeyInfo
  name: "PrivateKeyInfo",
  tagClass: asn1$2.Class.UNIVERSAL,
  type: asn1$2.Type.SEQUENCE,
  constructed: true,
  value: [{
    // Version (INTEGER)
    name: "PrivateKeyInfo.version",
    tagClass: asn1$2.Class.UNIVERSAL,
    type: asn1$2.Type.INTEGER,
    constructed: false,
    capture: "privateKeyVersion"
  }, {
    // privateKeyAlgorithm
    name: "PrivateKeyInfo.privateKeyAlgorithm",
    tagClass: asn1$2.Class.UNIVERSAL,
    type: asn1$2.Type.SEQUENCE,
    constructed: true,
    value: [{ name: "AlgorithmIdentifier.algorithm", tagClass: asn1$2.Class.UNIVERSAL, type: asn1$2.Type.OID, constructed: false, capture: "privateKeyOid" }]
  }, {
    // PrivateKey
    name: "PrivateKeyInfo",
    tagClass: asn1$2.Class.UNIVERSAL,
    type: asn1$2.Type.OCTETSTRING,
    constructed: false,
    capture: "privateKey"
  }]
};
var rsaPrivateKeyValidator = {
  // RSAPrivateKey
  name: "RSAPrivateKey",
  tagClass: asn1$2.Class.UNIVERSAL,
  type: asn1$2.Type.SEQUENCE,
  constructed: true,
  value: [{
    // Version (INTEGER)
    name: "RSAPrivateKey.version",
    tagClass: asn1$2.Class.UNIVERSAL,
    type: asn1$2.Type.INTEGER,
    constructed: false,
    capture: "privateKeyVersion"
  }, {
    // modulus (n)
    name: "RSAPrivateKey.modulus",
    tagClass: asn1$2.Class.UNIVERSAL,
    type: asn1$2.Type.INTEGER,
    constructed: false,
    capture: "privateKeyModulus"
  }, {
    // publicExponent (e)
    name: "RSAPrivateKey.publicExponent",
    tagClass: asn1$2.Class.UNIVERSAL,
    type: asn1$2.Type.INTEGER,
    constructed: false,
    capture: "privateKeyPublicExponent"
  }, {
    // privateExponent (d)
    name: "RSAPrivateKey.privateExponent",
    tagClass: asn1$2.Class.UNIVERSAL,
    type: asn1$2.Type.INTEGER,
    constructed: false,
    capture: "privateKeyPrivateExponent"
  }, {
    // prime1 (p)
    name: "RSAPrivateKey.prime1",
    tagClass: asn1$2.Class.UNIVERSAL,
    type: asn1$2.Type.INTEGER,
    constructed: false,
    capture: "privateKeyPrime1"
  }, {
    // prime2 (q)
    name: "RSAPrivateKey.prime2",
    tagClass: asn1$2.Class.UNIVERSAL,
    type: asn1$2.Type.INTEGER,
    constructed: false,
    capture: "privateKeyPrime2"
  }, {
    // exponent1 (d mod (p-1))
    name: "RSAPrivateKey.exponent1",
    tagClass: asn1$2.Class.UNIVERSAL,
    type: asn1$2.Type.INTEGER,
    constructed: false,
    capture: "privateKeyExponent1"
  }, {
    // exponent2 (d mod (q-1))
    name: "RSAPrivateKey.exponent2",
    tagClass: asn1$2.Class.UNIVERSAL,
    type: asn1$2.Type.INTEGER,
    constructed: false,
    capture: "privateKeyExponent2"
  }, {
    // coefficient ((inverse of q) mod p)
    name: "RSAPrivateKey.coefficient",
    tagClass: asn1$2.Class.UNIVERSAL,
    type: asn1$2.Type.INTEGER,
    constructed: false,
    capture: "privateKeyCoefficient"
  }]
};
var rsaPublicKeyValidator = {
  // RSAPublicKey
  name: "RSAPublicKey",
  tagClass: asn1$2.Class.UNIVERSAL,
  type: asn1$2.Type.SEQUENCE,
  constructed: true,
  value: [{
    // modulus (n)
    name: "RSAPublicKey.modulus",
    tagClass: asn1$2.Class.UNIVERSAL,
    type: asn1$2.Type.INTEGER,
    constructed: false,
    capture: "publicKeyModulus"
  }, {
    // publicExponent (e)
    name: "RSAPublicKey.exponent",
    tagClass: asn1$2.Class.UNIVERSAL,
    type: asn1$2.Type.INTEGER,
    constructed: false,
    capture: "publicKeyExponent"
  }]
};
var publicKeyValidator$1 = forge$8.pki.rsa.publicKeyValidator = { name: "SubjectPublicKeyInfo", tagClass: asn1$2.Class.UNIVERSAL, type: asn1$2.Type.SEQUENCE, constructed: true, captureAsn1: "subjectPublicKeyInfo", value: [{ name: "SubjectPublicKeyInfo.AlgorithmIdentifier", tagClass: asn1$2.Class.UNIVERSAL, type: asn1$2.Type.SEQUENCE, constructed: true, value: [{ name: "AlgorithmIdentifier.algorithm", tagClass: asn1$2.Class.UNIVERSAL, type: asn1$2.Type.OID, constructed: false, capture: "publicKeyOid" }] }, {
  // subjectPublicKey
  name: "SubjectPublicKeyInfo.subjectPublicKey",
  tagClass: asn1$2.Class.UNIVERSAL,
  type: asn1$2.Type.BITSTRING,
  constructed: false,
  value: [{
    // RSAPublicKey
    name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
    tagClass: asn1$2.Class.UNIVERSAL,
    type: asn1$2.Type.SEQUENCE,
    constructed: true,
    optional: true,
    captureAsn1: "rsaPublicKey"
  }]
}] };
var emsaPkcs1v15encode = function emsaPkcs1v15encode2(md) {
  var oid;
  if (md.algorithm in pki$1.oids) {
    oid = pki$1.oids[md.algorithm];
  } else {
    var error3 = new Error("Unknown message digest algorithm.");
    error3.algorithm = md.algorithm;
    throw error3;
  }
  var oidBytes = asn1$2.oidToDer(oid).getBytes();
  var digestInfo = asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.SEQUENCE, true, []);
  var digestAlgorithm = asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.SEQUENCE, true, []);
  digestAlgorithm.value.push(asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.OID, false, oidBytes));
  digestAlgorithm.value.push(asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.NULL, false, ""));
  var digest11 = asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.OCTETSTRING, false, md.digest().getBytes());
  digestInfo.value.push(digestAlgorithm);
  digestInfo.value.push(digest11);
  return asn1$2.toDer(digestInfo).getBytes();
};
var _modPow = function _modPow2(x2, key3, pub) {
  if (pub) {
    return x2.modPow(key3.e, key3.n);
  }
  if (!key3.p || !key3.q) {
    return x2.modPow(key3.d, key3.n);
  }
  if (!key3.dP) {
    key3.dP = key3.d.mod(key3.p.subtract(BigInteger$2.ONE));
  }
  if (!key3.dQ) {
    key3.dQ = key3.d.mod(key3.q.subtract(BigInteger$2.ONE));
  }
  if (!key3.qInv) {
    key3.qInv = key3.q.modInverse(key3.p);
  }
  var r2;
  do {
    r2 = new BigInteger$2(forge$8.util.bytesToHex(forge$8.random.getBytes(key3.n.bitLength() / 8)), 16);
  } while (r2.compareTo(key3.n) >= 0 || !r2.gcd(key3.n).equals(BigInteger$2.ONE));
  x2 = x2.multiply(r2.modPow(key3.e, key3.n)).mod(key3.n);
  var xp = x2.mod(key3.p).modPow(key3.dP, key3.p);
  var xq = x2.mod(key3.q).modPow(key3.dQ, key3.q);
  while (xp.compareTo(xq) < 0) {
    xp = xp.add(key3.p);
  }
  var y3 = xp.subtract(xq).multiply(key3.qInv).mod(key3.p).multiply(key3.q).add(xq);
  y3 = y3.multiply(r2.modInverse(key3.n)).mod(key3.n);
  return y3;
};
pki$1.rsa.encrypt = function(m2, key3, bt) {
  var pub = bt;
  var eb;
  var k3 = Math.ceil(key3.n.bitLength() / 8);
  if (bt !== false && bt !== true) {
    pub = bt === 2;
    eb = _encodePkcs1_v1_5(m2, key3, bt);
  } else {
    eb = forge$8.util.createBuffer();
    eb.putBytes(m2);
  }
  var x2 = new BigInteger$2(eb.toHex(), 16);
  var y3 = _modPow(x2, key3, pub);
  var yhex = y3.toString(16);
  var ed = forge$8.util.createBuffer();
  var zeros = k3 - Math.ceil(yhex.length / 2);
  while (zeros > 0) {
    ed.putByte(0);
    --zeros;
  }
  ed.putBytes(forge$8.util.hexToBytes(yhex));
  return ed.getBytes();
};
pki$1.rsa.decrypt = function(ed, key3, pub, ml) {
  var k3 = Math.ceil(key3.n.bitLength() / 8);
  if (ed.length !== k3) {
    var error3 = new Error("Encrypted message length is invalid.");
    error3.length = ed.length;
    error3.expected = k3;
    throw error3;
  }
  var y3 = new BigInteger$2(forge$8.util.createBuffer(ed).toHex(), 16);
  if (y3.compareTo(key3.n) >= 0) {
    throw new Error("Encrypted message is invalid.");
  }
  var x2 = _modPow(y3, key3, pub);
  var xhex = x2.toString(16);
  var eb = forge$8.util.createBuffer();
  var zeros = k3 - Math.ceil(xhex.length / 2);
  while (zeros > 0) {
    eb.putByte(0);
    --zeros;
  }
  eb.putBytes(forge$8.util.hexToBytes(xhex));
  if (ml !== false) {
    return _decodePkcs1_v1_5(eb.getBytes(), key3, pub);
  }
  return eb.getBytes();
};
pki$1.rsa.createKeyPairGenerationState = function(bits, e2, options) {
  if (typeof bits === "string") {
    bits = parseInt(bits, 10);
  }
  bits = bits || 2048;
  options = options || {};
  var prng2 = options.prng || forge$8.random;
  var rng = {
    // x is an array to fill with bytes
    nextBytes: function nextBytes(x2) {
      var b3 = prng2.getBytesSync(x2.length);
      for (var i2 = 0; i2 < x2.length; ++i2) {
        x2[i2] = b3.charCodeAt(i2);
      }
    }
  };
  var algorithm = options.algorithm || "PRIMEINC";
  var rval;
  if (algorithm === "PRIMEINC") {
    rval = { algorithm, state: 0, bits, rng, eInt: e2 || 65537, e: new BigInteger$2(null), p: null, q: null, qBits: bits >> 1, pBits: bits - (bits >> 1), pqState: 0, num: null, keys: null };
    rval.e.fromInt(rval.eInt);
  } else {
    throw new Error("Invalid key generation algorithm: " + algorithm);
  }
  return rval;
};
pki$1.rsa.stepKeyPairGenerationState = function(state, n2) {
  if (!("algorithm" in state)) {
    state.algorithm = "PRIMEINC";
  }
  var THIRTY = new BigInteger$2(null);
  THIRTY.fromInt(30);
  var deltaIdx = 0;
  var op_or2 = function op_or3(x2, y3) {
    return x2 | y3;
  };
  var t1 = +/* @__PURE__ */ new Date();
  var t2;
  var total = 0;
  while (state.keys === null && (n2 <= 0 || total < n2)) {
    if (state.state === 0) {
      var bits = state.p === null ? state.pBits : state.qBits;
      var bits1 = bits - 1;
      if (state.pqState === 0) {
        state.num = new BigInteger$2(bits, state.rng);
        if (!state.num.testBit(bits1)) {
          state.num.bitwiseTo(BigInteger$2.ONE.shiftLeft(bits1), op_or2, state.num);
        }
        state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);
        deltaIdx = 0;
        ++state.pqState;
      } else if (state.pqState === 1) {
        if (state.num.bitLength() > bits) {
          state.pqState = 0;
        } else if (state.num.isProbablePrime(_getMillerRabinTests(state.num.bitLength()))) {
          ++state.pqState;
        } else {
          state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
        }
      } else if (state.pqState === 2) {
        state.pqState = state.num.subtract(BigInteger$2.ONE).gcd(state.e).compareTo(BigInteger$2.ONE) === 0 ? 3 : 0;
      } else if (state.pqState === 3) {
        state.pqState = 0;
        if (state.p === null) {
          state.p = state.num;
        } else {
          state.q = state.num;
        }
        if (state.p !== null && state.q !== null) {
          ++state.state;
        }
        state.num = null;
      }
    } else if (state.state === 1) {
      if (state.p.compareTo(state.q) < 0) {
        state.num = state.p;
        state.p = state.q;
        state.q = state.num;
      }
      ++state.state;
    } else if (state.state === 2) {
      state.p1 = state.p.subtract(BigInteger$2.ONE);
      state.q1 = state.q.subtract(BigInteger$2.ONE);
      state.phi = state.p1.multiply(state.q1);
      ++state.state;
    } else if (state.state === 3) {
      if (state.phi.gcd(state.e).compareTo(BigInteger$2.ONE) === 0) {
        ++state.state;
      } else {
        state.p = null;
        state.q = null;
        state.state = 0;
      }
    } else if (state.state === 4) {
      state.n = state.p.multiply(state.q);
      if (state.n.bitLength() === state.bits) {
        ++state.state;
      } else {
        state.q = null;
        state.state = 0;
      }
    } else if (state.state === 5) {
      var d2 = state.e.modInverse(state.phi);
      state.keys = { privateKey: pki$1.rsa.setPrivateKey(state.n, state.e, d2, state.p, state.q, d2.mod(state.p1), d2.mod(state.q1), state.q.modInverse(state.p)), publicKey: pki$1.rsa.setPublicKey(state.n, state.e) };
    }
    t2 = +/* @__PURE__ */ new Date();
    total += t2 - t1;
    t1 = t2;
  }
  return state.keys !== null;
};
pki$1.rsa.generateKeyPair = function(bits, e2, options, callback) {
  if (arguments.length === 1) {
    if (_typeof(bits) === "object") {
      options = bits;
      bits = void 0;
    } else if (typeof bits === "function") {
      callback = bits;
      bits = void 0;
    }
  } else if (arguments.length === 2) {
    if (typeof bits === "number") {
      if (typeof e2 === "function") {
        callback = e2;
        e2 = void 0;
      } else if (typeof e2 !== "number") {
        options = e2;
        e2 = void 0;
      }
    } else {
      options = bits;
      callback = e2;
      bits = void 0;
      e2 = void 0;
    }
  } else if (arguments.length === 3) {
    if (typeof e2 === "number") {
      if (typeof options === "function") {
        callback = options;
        options = void 0;
      }
    } else {
      callback = options;
      options = e2;
      e2 = void 0;
    }
  }
  options = options || {};
  if (bits === void 0) {
    bits = options.bits || 2048;
  }
  if (e2 === void 0) {
    e2 = options.e || 65537;
  }
  if (!forge$8.options.usePureJavaScript && !options.prng && bits >= 256 && bits <= 16384 && (e2 === 65537 || e2 === 3)) {
    if (callback) {
      if (_detectNodeCrypto("generateKeyPair")) {
        return _crypto.generateKeyPair("rsa", { modulusLength: bits, publicExponent: e2, publicKeyEncoding: { type: "spki", format: "pem" }, privateKeyEncoding: { type: "pkcs8", format: "pem" } }, function(err, pub, priv) {
          if (err) {
            return callback(err);
          }
          callback(null, { privateKey: pki$1.privateKeyFromPem(priv), publicKey: pki$1.publicKeyFromPem(pub) });
        });
      }
      if (_detectSubtleCrypto("generateKey") && _detectSubtleCrypto("exportKey")) {
        return util$1.globalScope.crypto.subtle.generateKey({ name: "RSASSA-PKCS1-v1_5", modulusLength: bits, publicExponent: _intToUint8Array(e2), hash: { name: "SHA-256" } }, true, ["sign", "verify"]).then(function(pair) {
          return util$1.globalScope.crypto.subtle.exportKey("pkcs8", pair.privateKey);
        }).then(void 0, function(err) {
          callback(err);
        }).then(function(pkcs8) {
          if (pkcs8) {
            var privateKey = pki$1.privateKeyFromAsn1(asn1$2.fromDer(forge$8.util.createBuffer(pkcs8)));
            callback(null, { privateKey, publicKey: pki$1.setRsaPublicKey(privateKey.n, privateKey.e) });
          }
        });
      }
      if (_detectSubtleMsCrypto("generateKey") && _detectSubtleMsCrypto("exportKey")) {
        var genOp = util$1.globalScope.msCrypto.subtle.generateKey({ name: "RSASSA-PKCS1-v1_5", modulusLength: bits, publicExponent: _intToUint8Array(e2), hash: { name: "SHA-256" } }, true, ["sign", "verify"]);
        genOp.oncomplete = function(e3) {
          var pair = e3.target.result;
          var exportOp = util$1.globalScope.msCrypto.subtle.exportKey("pkcs8", pair.privateKey);
          exportOp.oncomplete = function(e4) {
            var pkcs8 = e4.target.result;
            var privateKey = pki$1.privateKeyFromAsn1(asn1$2.fromDer(forge$8.util.createBuffer(pkcs8)));
            callback(null, { privateKey, publicKey: pki$1.setRsaPublicKey(privateKey.n, privateKey.e) });
          };
          exportOp.onerror = function(err) {
            callback(err);
          };
        };
        genOp.onerror = function(err) {
          callback(err);
        };
        return;
      }
    } else {
      if (_detectNodeCrypto("generateKeyPairSync")) {
        var keypair = _crypto.generateKeyPairSync("rsa", { modulusLength: bits, publicExponent: e2, publicKeyEncoding: { type: "spki", format: "pem" }, privateKeyEncoding: { type: "pkcs8", format: "pem" } });
        return { privateKey: pki$1.privateKeyFromPem(keypair.privateKey), publicKey: pki$1.publicKeyFromPem(keypair.publicKey) };
      }
    }
  }
  var state = pki$1.rsa.createKeyPairGenerationState(bits, e2, options);
  if (!callback) {
    pki$1.rsa.stepKeyPairGenerationState(state, 0);
    return state.keys;
  }
  _generateKeyPair(state, options, callback);
};
pki$1.setRsaPublicKey = pki$1.rsa.setPublicKey = function(n2, e2) {
  var key3 = { n: n2, e: e2 };
  key3.encrypt = function(data, scheme, schemeOptions) {
    if (typeof scheme === "string") {
      scheme = scheme.toUpperCase();
    } else if (scheme === void 0) {
      scheme = "RSAES-PKCS1-V1_5";
    }
    if (scheme === "RSAES-PKCS1-V1_5") {
      scheme = { encode: function encode7(m2, key4, pub) {
        return _encodePkcs1_v1_5(m2, key4, 2).getBytes();
      } };
    } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
      scheme = { encode: function encode7(m2, key4) {
        return forge$8.pkcs1.encode_rsa_oaep(key4, m2, schemeOptions);
      } };
    } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
      scheme = { encode: function encode7(e4) {
        return e4;
      } };
    } else if (typeof scheme === "string") {
      throw new Error('Unsupported encryption scheme: "' + scheme + '".');
    }
    var e3 = scheme.encode(data, key3, true);
    return pki$1.rsa.encrypt(e3, key3, true);
  };
  key3.verify = function(digest11, signature2, scheme) {
    if (typeof scheme === "string") {
      scheme = scheme.toUpperCase();
    } else if (scheme === void 0) {
      scheme = "RSASSA-PKCS1-V1_5";
    }
    if (scheme === "RSASSA-PKCS1-V1_5") {
      scheme = { verify: function verify(digest12, d3) {
        d3 = _decodePkcs1_v1_5(d3, key3, true);
        var obj2 = asn1$2.fromDer(d3);
        return digest12 === obj2.value[1].value;
      } };
    } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
      scheme = { verify: function verify(digest12, d3) {
        d3 = _decodePkcs1_v1_5(d3, key3, true);
        return digest12 === d3;
      } };
    }
    var d2 = pki$1.rsa.decrypt(signature2, key3, true, false);
    return scheme.verify(digest11, d2, key3.n.bitLength());
  };
  return key3;
};
pki$1.setRsaPrivateKey = pki$1.rsa.setPrivateKey = function(n2, e2, d2, p2, q3, dP, dQ, qInv) {
  var key3 = { n: n2, e: e2, d: d2, p: p2, q: q3, dP, dQ, qInv };
  key3.decrypt = function(data, scheme, schemeOptions) {
    if (typeof scheme === "string") {
      scheme = scheme.toUpperCase();
    } else if (scheme === void 0) {
      scheme = "RSAES-PKCS1-V1_5";
    }
    var d3 = pki$1.rsa.decrypt(data, key3, false, false);
    if (scheme === "RSAES-PKCS1-V1_5") {
      scheme = { decode: _decodePkcs1_v1_5 };
    } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
      scheme = { decode: function decode6(d4, key4) {
        return forge$8.pkcs1.decode_rsa_oaep(key4, d4, schemeOptions);
      } };
    } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
      scheme = { decode: function decode6(d4) {
        return d4;
      } };
    } else {
      throw new Error('Unsupported encryption scheme: "' + scheme + '".');
    }
    return scheme.decode(d3, key3, false);
  };
  key3.sign = function(md, scheme) {
    var bt = false;
    if (typeof scheme === "string") {
      scheme = scheme.toUpperCase();
    }
    if (scheme === void 0 || scheme === "RSASSA-PKCS1-V1_5") {
      scheme = { encode: emsaPkcs1v15encode };
      bt = 1;
    } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
      scheme = { encode: function encode7() {
        return md;
      } };
      bt = 1;
    }
    var d3 = scheme.encode(md, key3.n.bitLength());
    return pki$1.rsa.encrypt(d3, key3, bt);
  };
  return key3;
};
pki$1.wrapRsaPrivateKey = function(rsaKey) {
  return asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.SEQUENCE, true, [
    // version (0)
    asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.INTEGER, false, asn1$2.integerToDer(0).getBytes()),
    // privateKeyAlgorithm
    asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.SEQUENCE, true, [asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.OID, false, asn1$2.oidToDer(pki$1.oids.rsaEncryption).getBytes()), asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.NULL, false, "")]),
    // PrivateKey
    asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.OCTETSTRING, false, asn1$2.toDer(rsaKey).getBytes())
  ]);
};
pki$1.privateKeyFromAsn1 = function(obj2) {
  var capture = {};
  var errors = [];
  if (asn1$2.validate(obj2, privateKeyValidator$1, capture, errors)) {
    obj2 = asn1$2.fromDer(forge$8.util.createBuffer(capture.privateKey));
  }
  capture = {};
  errors = [];
  if (!asn1$2.validate(obj2, rsaPrivateKeyValidator, capture, errors)) {
    var error3 = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
    error3.errors = errors;
    throw error3;
  }
  var n2, e2, d2, p2, q3, dP, dQ, qInv;
  n2 = forge$8.util.createBuffer(capture.privateKeyModulus).toHex();
  e2 = forge$8.util.createBuffer(capture.privateKeyPublicExponent).toHex();
  d2 = forge$8.util.createBuffer(capture.privateKeyPrivateExponent).toHex();
  p2 = forge$8.util.createBuffer(capture.privateKeyPrime1).toHex();
  q3 = forge$8.util.createBuffer(capture.privateKeyPrime2).toHex();
  dP = forge$8.util.createBuffer(capture.privateKeyExponent1).toHex();
  dQ = forge$8.util.createBuffer(capture.privateKeyExponent2).toHex();
  qInv = forge$8.util.createBuffer(capture.privateKeyCoefficient).toHex();
  return pki$1.setRsaPrivateKey(new BigInteger$2(n2, 16), new BigInteger$2(e2, 16), new BigInteger$2(d2, 16), new BigInteger$2(p2, 16), new BigInteger$2(q3, 16), new BigInteger$2(dP, 16), new BigInteger$2(dQ, 16), new BigInteger$2(qInv, 16));
};
pki$1.privateKeyToAsn1 = pki$1.privateKeyToRSAPrivateKey = function(key3) {
  return asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.SEQUENCE, true, [
    // version (0 = only 2 primes, 1 multiple primes)
    asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.INTEGER, false, asn1$2.integerToDer(0).getBytes()),
    // modulus (n)
    asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.INTEGER, false, _bnToBytes(key3.n)),
    // publicExponent (e)
    asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.INTEGER, false, _bnToBytes(key3.e)),
    // privateExponent (d)
    asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.INTEGER, false, _bnToBytes(key3.d)),
    // privateKeyPrime1 (p)
    asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.INTEGER, false, _bnToBytes(key3.p)),
    // privateKeyPrime2 (q)
    asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.INTEGER, false, _bnToBytes(key3.q)),
    // privateKeyExponent1 (dP)
    asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.INTEGER, false, _bnToBytes(key3.dP)),
    // privateKeyExponent2 (dQ)
    asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.INTEGER, false, _bnToBytes(key3.dQ)),
    // coefficient (qInv)
    asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.INTEGER, false, _bnToBytes(key3.qInv))
  ]);
};
pki$1.publicKeyFromAsn1 = function(obj2) {
  var capture = {};
  var errors = [];
  if (asn1$2.validate(obj2, publicKeyValidator$1, capture, errors)) {
    var oid = asn1$2.derToOid(capture.publicKeyOid);
    if (oid !== pki$1.oids.rsaEncryption) {
      var error3 = new Error("Cannot read public key. Unknown OID.");
      error3.oid = oid;
      throw error3;
    }
    obj2 = capture.rsaPublicKey;
  }
  errors = [];
  if (!asn1$2.validate(obj2, rsaPublicKeyValidator, capture, errors)) {
    var error3 = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
    error3.errors = errors;
    throw error3;
  }
  var n2 = forge$8.util.createBuffer(capture.publicKeyModulus).toHex();
  var e2 = forge$8.util.createBuffer(capture.publicKeyExponent).toHex();
  return pki$1.setRsaPublicKey(new BigInteger$2(n2, 16), new BigInteger$2(e2, 16));
};
pki$1.publicKeyToAsn1 = pki$1.publicKeyToSubjectPublicKeyInfo = function(key3) {
  return asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.SEQUENCE, true, [
    // AlgorithmIdentifier
    asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.SEQUENCE, true, [
      // algorithm
      asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.OID, false, asn1$2.oidToDer(pki$1.oids.rsaEncryption).getBytes()),
      // parameters (null)
      asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.NULL, false, "")
    ]),
    // subjectPublicKey
    asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.BITSTRING, false, [pki$1.publicKeyToRSAPublicKey(key3)])
  ]);
};
pki$1.publicKeyToRSAPublicKey = function(key3) {
  return asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.SEQUENCE, true, [
    // modulus (n)
    asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.INTEGER, false, _bnToBytes(key3.n)),
    // publicExponent (e)
    asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.INTEGER, false, _bnToBytes(key3.e))
  ]);
};
function _encodePkcs1_v1_5(m2, key3, bt) {
  var eb = forge$8.util.createBuffer();
  var k3 = Math.ceil(key3.n.bitLength() / 8);
  if (m2.length > k3 - 11) {
    var error3 = new Error("Message is too long for PKCS#1 v1.5 padding.");
    error3.length = m2.length;
    error3.max = k3 - 11;
    throw error3;
  }
  eb.putByte(0);
  eb.putByte(bt);
  var padNum = k3 - 3 - m2.length;
  var padByte;
  if (bt === 0 || bt === 1) {
    padByte = bt === 0 ? 0 : 255;
    for (var i2 = 0; i2 < padNum; ++i2) {
      eb.putByte(padByte);
    }
  } else {
    while (padNum > 0) {
      var numZeros = 0;
      var padBytes = forge$8.random.getBytes(padNum);
      for (var i2 = 0; i2 < padNum; ++i2) {
        padByte = padBytes.charCodeAt(i2);
        if (padByte === 0) {
          ++numZeros;
        } else {
          eb.putByte(padByte);
        }
      }
      padNum = numZeros;
    }
  }
  eb.putByte(0);
  eb.putBytes(m2);
  return eb;
}
function _decodePkcs1_v1_5(em, key3, pub, ml) {
  var k3 = Math.ceil(key3.n.bitLength() / 8);
  var eb = forge$8.util.createBuffer(em);
  var first = eb.getByte();
  var bt = eb.getByte();
  if (first !== 0 || pub && bt !== 0 && bt !== 1 || !pub && bt != 2 || pub && bt === 0 && typeof ml === "undefined") {
    throw new Error("Encryption block is invalid.");
  }
  var padNum = 0;
  if (bt === 0) {
    padNum = k3 - 3 - ml;
    for (var i2 = 0; i2 < padNum; ++i2) {
      if (eb.getByte() !== 0) {
        throw new Error("Encryption block is invalid.");
      }
    }
  } else if (bt === 1) {
    padNum = 0;
    while (eb.length() > 1) {
      if (eb.getByte() !== 255) {
        --eb.read;
        break;
      }
      ++padNum;
    }
  } else if (bt === 2) {
    padNum = 0;
    while (eb.length() > 1) {
      if (eb.getByte() === 0) {
        --eb.read;
        break;
      }
      ++padNum;
    }
  }
  var zero = eb.getByte();
  if (zero !== 0 || padNum !== k3 - 3 - eb.length()) {
    throw new Error("Encryption block is invalid.");
  }
  return eb.getBytes();
}
function _generateKeyPair(state, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = {};
  }
  options = options || {};
  var opts = { algorithm: { name: options.algorithm || "PRIMEINC", options: { workers: options.workers || 2, workLoad: options.workLoad || 100, workerScript: options.workerScript } } };
  if ("prng" in options) {
    opts.prng = options.prng;
  }
  generate2();
  function generate2() {
    getPrime(state.pBits, function(err, num) {
      if (err) {
        return callback(err);
      }
      state.p = num;
      if (state.q !== null) {
        return finish2(err, state.q);
      }
      getPrime(state.qBits, finish2);
    });
  }
  function getPrime(bits, callback2) {
    forge$8.prime.generateProbablePrime(bits, opts, callback2);
  }
  function finish2(err, num) {
    if (err) {
      return callback(err);
    }
    state.q = num;
    if (state.p.compareTo(state.q) < 0) {
      var tmp = state.p;
      state.p = state.q;
      state.q = tmp;
    }
    if (state.p.subtract(BigInteger$2.ONE).gcd(state.e).compareTo(BigInteger$2.ONE) !== 0) {
      state.p = null;
      generate2();
      return;
    }
    if (state.q.subtract(BigInteger$2.ONE).gcd(state.e).compareTo(BigInteger$2.ONE) !== 0) {
      state.q = null;
      getPrime(state.qBits, finish2);
      return;
    }
    state.p1 = state.p.subtract(BigInteger$2.ONE);
    state.q1 = state.q.subtract(BigInteger$2.ONE);
    state.phi = state.p1.multiply(state.q1);
    if (state.phi.gcd(state.e).compareTo(BigInteger$2.ONE) !== 0) {
      state.p = state.q = null;
      generate2();
      return;
    }
    state.n = state.p.multiply(state.q);
    if (state.n.bitLength() !== state.bits) {
      state.q = null;
      getPrime(state.qBits, finish2);
      return;
    }
    var d2 = state.e.modInverse(state.phi);
    state.keys = { privateKey: pki$1.rsa.setPrivateKey(state.n, state.e, d2, state.p, state.q, d2.mod(state.p1), d2.mod(state.q1), state.q.modInverse(state.p)), publicKey: pki$1.rsa.setPublicKey(state.n, state.e) };
    callback(null, state.keys);
  }
}
function _bnToBytes(b3) {
  var hex = b3.toString(16);
  if (hex[0] >= "8") {
    hex = "00" + hex;
  }
  var bytes = forge$8.util.hexToBytes(hex);
  if (bytes.length > 1 && // leading 0x00 for positive integer
  (bytes.charCodeAt(0) === 0 && (bytes.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer
  bytes.charCodeAt(0) === 255 && (bytes.charCodeAt(1) & 128) === 128)) {
    return bytes.substr(1);
  }
  return bytes;
}
function _getMillerRabinTests(bits) {
  if (bits <= 100)
    return 27;
  if (bits <= 150)
    return 18;
  if (bits <= 200)
    return 15;
  if (bits <= 250)
    return 12;
  if (bits <= 300)
    return 9;
  if (bits <= 350)
    return 8;
  if (bits <= 400)
    return 7;
  if (bits <= 500)
    return 6;
  if (bits <= 600)
    return 5;
  if (bits <= 800)
    return 4;
  if (bits <= 1250)
    return 3;
  return 2;
}
function _detectNodeCrypto(fn) {
  return forge$8.util.isNodejs && typeof _crypto[fn] === "function";
}
function _detectSubtleCrypto(fn) {
  return typeof util$1.globalScope !== "undefined" && _typeof(util$1.globalScope.crypto) === "object" && _typeof(util$1.globalScope.crypto.subtle) === "object" && typeof util$1.globalScope.crypto.subtle[fn] === "function";
}
function _detectSubtleMsCrypto(fn) {
  return typeof util$1.globalScope !== "undefined" && _typeof(util$1.globalScope.msCrypto) === "object" && _typeof(util$1.globalScope.msCrypto.subtle) === "object" && typeof util$1.globalScope.msCrypto.subtle[fn] === "function";
}
function _intToUint8Array(x2) {
  var bytes = forge$8.util.hexToBytes(x2.toString(16));
  var buffer2 = new Uint8Array(bytes.length);
  for (var i2 = 0; i2 < bytes.length; ++i2) {
    buffer2[i2] = bytes.charCodeAt(i2);
  }
  return buffer2;
}
var forge$7 = forge$t;
if (typeof BigInteger$1 === "undefined") {
  BigInteger$1 = forge$7.jsbn.BigInteger;
}
var BigInteger$1;
var asn1$1 = forge$7.asn1;
var pki = forge$7.pki = forge$7.pki || {};
pki.pbe = forge$7.pbe = forge$7.pbe || {};
var oids = pki.oids;
var encryptedPrivateKeyValidator = { name: "EncryptedPrivateKeyInfo", tagClass: asn1$1.Class.UNIVERSAL, type: asn1$1.Type.SEQUENCE, constructed: true, value: [{ name: "EncryptedPrivateKeyInfo.encryptionAlgorithm", tagClass: asn1$1.Class.UNIVERSAL, type: asn1$1.Type.SEQUENCE, constructed: true, value: [{ name: "AlgorithmIdentifier.algorithm", tagClass: asn1$1.Class.UNIVERSAL, type: asn1$1.Type.OID, constructed: false, capture: "encryptionOid" }, { name: "AlgorithmIdentifier.parameters", tagClass: asn1$1.Class.UNIVERSAL, type: asn1$1.Type.SEQUENCE, constructed: true, captureAsn1: "encryptionParams" }] }, {
  // encryptedData
  name: "EncryptedPrivateKeyInfo.encryptedData",
  tagClass: asn1$1.Class.UNIVERSAL,
  type: asn1$1.Type.OCTETSTRING,
  constructed: false,
  capture: "encryptedData"
}] };
var PBES2AlgorithmsValidator = { name: "PBES2Algorithms", tagClass: asn1$1.Class.UNIVERSAL, type: asn1$1.Type.SEQUENCE, constructed: true, value: [{ name: "PBES2Algorithms.keyDerivationFunc", tagClass: asn1$1.Class.UNIVERSAL, type: asn1$1.Type.SEQUENCE, constructed: true, value: [{ name: "PBES2Algorithms.keyDerivationFunc.oid", tagClass: asn1$1.Class.UNIVERSAL, type: asn1$1.Type.OID, constructed: false, capture: "kdfOid" }, { name: "PBES2Algorithms.params", tagClass: asn1$1.Class.UNIVERSAL, type: asn1$1.Type.SEQUENCE, constructed: true, value: [{ name: "PBES2Algorithms.params.salt", tagClass: asn1$1.Class.UNIVERSAL, type: asn1$1.Type.OCTETSTRING, constructed: false, capture: "kdfSalt" }, { name: "PBES2Algorithms.params.iterationCount", tagClass: asn1$1.Class.UNIVERSAL, type: asn1$1.Type.INTEGER, constructed: false, capture: "kdfIterationCount" }, { name: "PBES2Algorithms.params.keyLength", tagClass: asn1$1.Class.UNIVERSAL, type: asn1$1.Type.INTEGER, constructed: false, optional: true, capture: "keyLength" }, {
  // prf
  name: "PBES2Algorithms.params.prf",
  tagClass: asn1$1.Class.UNIVERSAL,
  type: asn1$1.Type.SEQUENCE,
  constructed: true,
  optional: true,
  value: [{ name: "PBES2Algorithms.params.prf.algorithm", tagClass: asn1$1.Class.UNIVERSAL, type: asn1$1.Type.OID, constructed: false, capture: "prfOid" }]
}] }] }, { name: "PBES2Algorithms.encryptionScheme", tagClass: asn1$1.Class.UNIVERSAL, type: asn1$1.Type.SEQUENCE, constructed: true, value: [{ name: "PBES2Algorithms.encryptionScheme.oid", tagClass: asn1$1.Class.UNIVERSAL, type: asn1$1.Type.OID, constructed: false, capture: "encOid" }, { name: "PBES2Algorithms.encryptionScheme.iv", tagClass: asn1$1.Class.UNIVERSAL, type: asn1$1.Type.OCTETSTRING, constructed: false, capture: "encIv" }] }] };
var pkcs12PbeParamsValidator = { name: "pkcs-12PbeParams", tagClass: asn1$1.Class.UNIVERSAL, type: asn1$1.Type.SEQUENCE, constructed: true, value: [{ name: "pkcs-12PbeParams.salt", tagClass: asn1$1.Class.UNIVERSAL, type: asn1$1.Type.OCTETSTRING, constructed: false, capture: "salt" }, { name: "pkcs-12PbeParams.iterations", tagClass: asn1$1.Class.UNIVERSAL, type: asn1$1.Type.INTEGER, constructed: false, capture: "iterations" }] };
pki.encryptPrivateKeyInfo = function(obj2, password, options) {
  options = options || {};
  options.saltSize = options.saltSize || 8;
  options.count = options.count || 2048;
  options.algorithm = options.algorithm || "aes128";
  options.prfAlgorithm = options.prfAlgorithm || "sha1";
  var salt2 = forge$7.random.getBytesSync(options.saltSize);
  var count = options.count;
  var countBytes = asn1$1.integerToDer(count);
  var dkLen;
  var encryptionAlgorithm;
  var encryptedData;
  if (options.algorithm.indexOf("aes") === 0 || options.algorithm === "des") {
    var ivLen, encOid, cipherFn;
    switch (options.algorithm) {
      case "aes128":
        dkLen = 16;
        ivLen = 16;
        encOid = oids["aes128-CBC"];
        cipherFn = forge$7.aes.createEncryptionCipher;
        break;
      case "aes192":
        dkLen = 24;
        ivLen = 16;
        encOid = oids["aes192-CBC"];
        cipherFn = forge$7.aes.createEncryptionCipher;
        break;
      case "aes256":
        dkLen = 32;
        ivLen = 16;
        encOid = oids["aes256-CBC"];
        cipherFn = forge$7.aes.createEncryptionCipher;
        break;
      case "des":
        dkLen = 8;
        ivLen = 8;
        encOid = oids["desCBC"];
        cipherFn = forge$7.des.createEncryptionCipher;
        break;
      default:
        var error3 = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
        error3.algorithm = options.algorithm;
        throw error3;
    }
    var prfAlgorithm = "hmacWith" + options.prfAlgorithm.toUpperCase();
    var md = prfAlgorithmToMessageDigest(prfAlgorithm);
    var dk = forge$7.pkcs5.pbkdf2(password, salt2, count, dkLen, md);
    var iv = forge$7.random.getBytesSync(ivLen);
    var cipher = cipherFn(dk);
    cipher.start(iv);
    cipher.update(asn1$1.toDer(obj2));
    cipher.finish();
    encryptedData = cipher.output.getBytes();
    var params = createPbkdf2Params(salt2, countBytes, dkLen, prfAlgorithm);
    encryptionAlgorithm = asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.OID, false, asn1$1.oidToDer(oids["pkcs5PBES2"]).getBytes()), asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
      // keyDerivationFunc
      asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
        asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.OID, false, asn1$1.oidToDer(oids["pkcs5PBKDF2"]).getBytes()),
        // PBKDF2-params
        params
      ]),
      // encryptionScheme
      asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
        asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.OID, false, asn1$1.oidToDer(encOid).getBytes()),
        // iv
        asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.OCTETSTRING, false, iv)
      ])
    ])]);
  } else if (options.algorithm === "3des") {
    dkLen = 24;
    var saltBytes = new forge$7.util.ByteBuffer(salt2);
    var dk = pki.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);
    var iv = pki.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);
    var cipher = forge$7.des.createEncryptionCipher(dk);
    cipher.start(iv);
    cipher.update(asn1$1.toDer(obj2));
    cipher.finish();
    encryptedData = cipher.output.getBytes();
    encryptionAlgorithm = asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
      asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.OID, false, asn1$1.oidToDer(oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()),
      // pkcs-12PbeParams
      asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
        // salt
        asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.OCTETSTRING, false, salt2),
        // iteration count
        asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.INTEGER, false, countBytes.getBytes())
      ])
    ]);
  } else {
    var error3 = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
    error3.algorithm = options.algorithm;
    throw error3;
  }
  var rval = asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
    // encryptionAlgorithm
    encryptionAlgorithm,
    // encryptedData
    asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.OCTETSTRING, false, encryptedData)
  ]);
  return rval;
};
pki.decryptPrivateKeyInfo = function(obj2, password) {
  var rval = null;
  var capture = {};
  var errors = [];
  if (!asn1$1.validate(obj2, encryptedPrivateKeyValidator, capture, errors)) {
    var error3 = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
    error3.errors = errors;
    throw error3;
  }
  var oid = asn1$1.derToOid(capture.encryptionOid);
  var cipher = pki.pbe.getCipher(oid, capture.encryptionParams, password);
  var encrypted = forge$7.util.createBuffer(capture.encryptedData);
  cipher.update(encrypted);
  if (cipher.finish()) {
    rval = asn1$1.fromDer(cipher.output);
  }
  return rval;
};
pki.encryptedPrivateKeyToPem = function(epki, maxline) {
  var msg = { type: "ENCRYPTED PRIVATE KEY", body: asn1$1.toDer(epki).getBytes() };
  return forge$7.pem.encode(msg, { maxline });
};
pki.encryptedPrivateKeyFromPem = function(pem2) {
  var msg = forge$7.pem.decode(pem2)[0];
  if (msg.type !== "ENCRYPTED PRIVATE KEY") {
    var error3 = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
    error3.headerType = msg.type;
    throw error3;
  }
  if (msg.procType && msg.procType.type === "ENCRYPTED") {
    throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
  }
  return asn1$1.fromDer(msg.body);
};
pki.encryptRsaPrivateKey = function(rsaKey, password, options) {
  options = options || {};
  if (!options.legacy) {
    var rval = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey));
    rval = pki.encryptPrivateKeyInfo(rval, password, options);
    return pki.encryptedPrivateKeyToPem(rval);
  }
  var algorithm;
  var iv;
  var dkLen;
  var cipherFn;
  switch (options.algorithm) {
    case "aes128":
      algorithm = "AES-128-CBC";
      dkLen = 16;
      iv = forge$7.random.getBytesSync(16);
      cipherFn = forge$7.aes.createEncryptionCipher;
      break;
    case "aes192":
      algorithm = "AES-192-CBC";
      dkLen = 24;
      iv = forge$7.random.getBytesSync(16);
      cipherFn = forge$7.aes.createEncryptionCipher;
      break;
    case "aes256":
      algorithm = "AES-256-CBC";
      dkLen = 32;
      iv = forge$7.random.getBytesSync(16);
      cipherFn = forge$7.aes.createEncryptionCipher;
      break;
    case "3des":
      algorithm = "DES-EDE3-CBC";
      dkLen = 24;
      iv = forge$7.random.getBytesSync(8);
      cipherFn = forge$7.des.createEncryptionCipher;
      break;
    case "des":
      algorithm = "DES-CBC";
      dkLen = 8;
      iv = forge$7.random.getBytesSync(8);
      cipherFn = forge$7.des.createEncryptionCipher;
      break;
    default:
      var error3 = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + options.algorithm + '".');
      error3.algorithm = options.algorithm;
      throw error3;
  }
  var dk = forge$7.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
  var cipher = cipherFn(dk);
  cipher.start(iv);
  cipher.update(asn1$1.toDer(pki.privateKeyToAsn1(rsaKey)));
  cipher.finish();
  var msg = { type: "RSA PRIVATE KEY", procType: { version: "4", type: "ENCRYPTED" }, dekInfo: { algorithm, parameters: forge$7.util.bytesToHex(iv).toUpperCase() }, body: cipher.output.getBytes() };
  return forge$7.pem.encode(msg);
};
pki.decryptRsaPrivateKey = function(pem2, password) {
  var rval = null;
  var msg = forge$7.pem.decode(pem2)[0];
  if (msg.type !== "ENCRYPTED PRIVATE KEY" && msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
    var error3 = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
    error3.headerType = error3;
    throw error3;
  }
  if (msg.procType && msg.procType.type === "ENCRYPTED") {
    var dkLen;
    var cipherFn;
    switch (msg.dekInfo.algorithm) {
      case "DES-CBC":
        dkLen = 8;
        cipherFn = forge$7.des.createDecryptionCipher;
        break;
      case "DES-EDE3-CBC":
        dkLen = 24;
        cipherFn = forge$7.des.createDecryptionCipher;
        break;
      case "AES-128-CBC":
        dkLen = 16;
        cipherFn = forge$7.aes.createDecryptionCipher;
        break;
      case "AES-192-CBC":
        dkLen = 24;
        cipherFn = forge$7.aes.createDecryptionCipher;
        break;
      case "AES-256-CBC":
        dkLen = 32;
        cipherFn = forge$7.aes.createDecryptionCipher;
        break;
      case "RC2-40-CBC":
        dkLen = 5;
        cipherFn = function cipherFn2(key3) {
          return forge$7.rc2.createDecryptionCipher(key3, 40);
        };
        break;
      case "RC2-64-CBC":
        dkLen = 8;
        cipherFn = function cipherFn2(key3) {
          return forge$7.rc2.createDecryptionCipher(key3, 64);
        };
        break;
      case "RC2-128-CBC":
        dkLen = 16;
        cipherFn = function cipherFn2(key3) {
          return forge$7.rc2.createDecryptionCipher(key3, 128);
        };
        break;
      default:
        var error3 = new Error('Could not decrypt private key; unsupported encryption algorithm "' + msg.dekInfo.algorithm + '".');
        error3.algorithm = msg.dekInfo.algorithm;
        throw error3;
    }
    var iv = forge$7.util.hexToBytes(msg.dekInfo.parameters);
    var dk = forge$7.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
    var cipher = cipherFn(dk);
    cipher.start(iv);
    cipher.update(forge$7.util.createBuffer(msg.body));
    if (cipher.finish()) {
      rval = cipher.output.getBytes();
    } else {
      return rval;
    }
  } else {
    rval = msg.body;
  }
  if (msg.type === "ENCRYPTED PRIVATE KEY") {
    rval = pki.decryptPrivateKeyInfo(asn1$1.fromDer(rval), password);
  } else {
    rval = asn1$1.fromDer(rval);
  }
  if (rval !== null) {
    rval = pki.privateKeyFromAsn1(rval);
  }
  return rval;
};
pki.pbe.generatePkcs12Key = function(password, salt2, id, iter, n2, md) {
  var j3, l2;
  if (typeof md === "undefined" || md === null) {
    if (!("sha1" in forge$7.md)) {
      throw new Error('"sha1" hash algorithm unavailable.');
    }
    md = forge$7.md.sha1.create();
  }
  var u2 = md.digestLength;
  var v2 = md.blockLength;
  var result = new forge$7.util.ByteBuffer();
  var passBuf = new forge$7.util.ByteBuffer();
  if (password !== null && password !== void 0) {
    for (l2 = 0; l2 < password.length; l2++) {
      passBuf.putInt16(password.charCodeAt(l2));
    }
    passBuf.putInt16(0);
  }
  var p2 = passBuf.length();
  var s2 = salt2.length();
  var D3 = new forge$7.util.ByteBuffer();
  D3.fillWithByte(id, v2);
  var Slen = v2 * Math.ceil(s2 / v2);
  var S2 = new forge$7.util.ByteBuffer();
  for (l2 = 0; l2 < Slen; l2++) {
    S2.putByte(salt2.at(l2 % s2));
  }
  var Plen = v2 * Math.ceil(p2 / v2);
  var P3 = new forge$7.util.ByteBuffer();
  for (l2 = 0; l2 < Plen; l2++) {
    P3.putByte(passBuf.at(l2 % p2));
  }
  var I2 = S2;
  I2.putBuffer(P3);
  var c3 = Math.ceil(n2 / u2);
  for (var i2 = 1; i2 <= c3; i2++) {
    var buf = new forge$7.util.ByteBuffer();
    buf.putBytes(D3.bytes());
    buf.putBytes(I2.bytes());
    for (var round = 0; round < iter; round++) {
      md.start();
      md.update(buf.getBytes());
      buf = md.digest();
    }
    var B2 = new forge$7.util.ByteBuffer();
    for (l2 = 0; l2 < v2; l2++) {
      B2.putByte(buf.at(l2 % u2));
    }
    var k3 = Math.ceil(s2 / v2) + Math.ceil(p2 / v2);
    var Inew = new forge$7.util.ByteBuffer();
    for (j3 = 0; j3 < k3; j3++) {
      var chunk = new forge$7.util.ByteBuffer(I2.getBytes(v2));
      var x2 = 511;
      for (l2 = B2.length() - 1; l2 >= 0; l2--) {
        x2 = x2 >> 8;
        x2 += B2.at(l2) + chunk.at(l2);
        chunk.setAt(l2, x2 & 255);
      }
      Inew.putBuffer(chunk);
    }
    I2 = Inew;
    result.putBuffer(buf);
  }
  result.truncate(result.length() - n2);
  return result;
};
pki.pbe.getCipher = function(oid, params, password) {
  switch (oid) {
    case pki.oids["pkcs5PBES2"]:
      return pki.pbe.getCipherForPBES2(oid, params, password);
    case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
    case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
      return pki.pbe.getCipherForPKCS12PBE(oid, params, password);
    default:
      var error3 = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
      error3.oid = oid;
      error3.supportedOids = ["pkcs5PBES2", "pbeWithSHAAnd3-KeyTripleDES-CBC", "pbewithSHAAnd40BitRC2-CBC"];
      throw error3;
  }
};
pki.pbe.getCipherForPBES2 = function(oid, params, password) {
  var capture = {};
  var errors = [];
  if (!asn1$1.validate(params, PBES2AlgorithmsValidator, capture, errors)) {
    var error3 = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
    error3.errors = errors;
    throw error3;
  }
  oid = asn1$1.derToOid(capture.kdfOid);
  if (oid !== pki.oids["pkcs5PBKDF2"]) {
    var error3 = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
    error3.oid = oid;
    error3.supportedOids = ["pkcs5PBKDF2"];
    throw error3;
  }
  oid = asn1$1.derToOid(capture.encOid);
  if (oid !== pki.oids["aes128-CBC"] && oid !== pki.oids["aes192-CBC"] && oid !== pki.oids["aes256-CBC"] && oid !== pki.oids["des-EDE3-CBC"] && oid !== pki.oids["desCBC"]) {
    var error3 = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
    error3.oid = oid;
    error3.supportedOids = ["aes128-CBC", "aes192-CBC", "aes256-CBC", "des-EDE3-CBC", "desCBC"];
    throw error3;
  }
  var salt2 = capture.kdfSalt;
  var count = forge$7.util.createBuffer(capture.kdfIterationCount);
  count = count.getInt(count.length() << 3);
  var dkLen;
  var cipherFn;
  switch (pki.oids[oid]) {
    case "aes128-CBC":
      dkLen = 16;
      cipherFn = forge$7.aes.createDecryptionCipher;
      break;
    case "aes192-CBC":
      dkLen = 24;
      cipherFn = forge$7.aes.createDecryptionCipher;
      break;
    case "aes256-CBC":
      dkLen = 32;
      cipherFn = forge$7.aes.createDecryptionCipher;
      break;
    case "des-EDE3-CBC":
      dkLen = 24;
      cipherFn = forge$7.des.createDecryptionCipher;
      break;
    case "desCBC":
      dkLen = 8;
      cipherFn = forge$7.des.createDecryptionCipher;
      break;
  }
  var md = prfOidToMessageDigest(capture.prfOid);
  var dk = forge$7.pkcs5.pbkdf2(password, salt2, count, dkLen, md);
  var iv = capture.encIv;
  var cipher = cipherFn(dk);
  cipher.start(iv);
  return cipher;
};
pki.pbe.getCipherForPKCS12PBE = function(oid, params, password) {
  var capture = {};
  var errors = [];
  if (!asn1$1.validate(params, pkcs12PbeParamsValidator, capture, errors)) {
    var error3 = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
    error3.errors = errors;
    throw error3;
  }
  var salt2 = forge$7.util.createBuffer(capture.salt);
  var count = forge$7.util.createBuffer(capture.iterations);
  count = count.getInt(count.length() << 3);
  var dkLen, dIvLen, cipherFn;
  switch (oid) {
    case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
      dkLen = 24;
      dIvLen = 8;
      cipherFn = forge$7.des.startDecrypting;
      break;
    case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
      dkLen = 5;
      dIvLen = 8;
      cipherFn = function cipherFn2(key4, iv2) {
        var cipher = forge$7.rc2.createDecryptionCipher(key4, 40);
        cipher.start(iv2, null);
        return cipher;
      };
      break;
    default:
      var error3 = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
      error3.oid = oid;
      throw error3;
  }
  var md = prfOidToMessageDigest(capture.prfOid);
  var key3 = pki.pbe.generatePkcs12Key(password, salt2, 1, count, dkLen, md);
  md.start();
  var iv = pki.pbe.generatePkcs12Key(password, salt2, 2, count, dIvLen, md);
  return cipherFn(key3, iv);
};
pki.pbe.opensslDeriveBytes = function(password, salt2, dkLen, md) {
  if (typeof md === "undefined" || md === null) {
    if (!("md5" in forge$7.md)) {
      throw new Error('"md5" hash algorithm unavailable.');
    }
    md = forge$7.md.md5.create();
  }
  if (salt2 === null) {
    salt2 = "";
  }
  var digests = [hash$1(md, password + salt2)];
  for (var length3 = 16, i2 = 1; length3 < dkLen; ++i2, length3 += 16) {
    digests.push(hash$1(md, digests[i2 - 1] + password + salt2));
  }
  return digests.join("").substr(0, dkLen);
};
function hash$1(md, bytes) {
  return md.start().update(bytes).digest().getBytes();
}
function prfOidToMessageDigest(prfOid) {
  var prfAlgorithm;
  if (!prfOid) {
    prfAlgorithm = "hmacWithSHA1";
  } else {
    prfAlgorithm = pki.oids[asn1$1.derToOid(prfOid)];
    if (!prfAlgorithm) {
      var error3 = new Error("Unsupported PRF OID.");
      error3.oid = prfOid;
      error3.supported = ["hmacWithSHA1", "hmacWithSHA224", "hmacWithSHA256", "hmacWithSHA384", "hmacWithSHA512"];
      throw error3;
    }
  }
  return prfAlgorithmToMessageDigest(prfAlgorithm);
}
function prfAlgorithmToMessageDigest(prfAlgorithm) {
  var factory2 = forge$7.md;
  switch (prfAlgorithm) {
    case "hmacWithSHA224":
      factory2 = forge$7.md.sha512;
    case "hmacWithSHA1":
    case "hmacWithSHA256":
    case "hmacWithSHA384":
    case "hmacWithSHA512":
      prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();
      break;
    default:
      var error3 = new Error("Unsupported PRF algorithm.");
      error3.algorithm = prfAlgorithm;
      error3.supported = ["hmacWithSHA1", "hmacWithSHA224", "hmacWithSHA256", "hmacWithSHA384", "hmacWithSHA512"];
      throw error3;
  }
  if (!factory2 || !(prfAlgorithm in factory2)) {
    throw new Error("Unknown hash algorithm: " + prfAlgorithm);
  }
  return factory2[prfAlgorithm].create();
}
function createPbkdf2Params(salt2, countBytes, dkLen, prfAlgorithm) {
  var params = asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
    // salt
    asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.OCTETSTRING, false, salt2),
    // iteration count
    asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.INTEGER, false, countBytes.getBytes())
  ]);
  if (prfAlgorithm !== "hmacWithSHA1") {
    params.value.push(
      // key length
      asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.INTEGER, false, forge$7.util.hexToBytes(dkLen.toString(16))),
      // AlgorithmIdentifier
      asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
        // algorithm
        asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.OID, false, asn1$1.oidToDer(pki.oids[prfAlgorithm]).getBytes()),
        // parameters (null)
        asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.NULL, false, "")
      ])
    );
  }
  return params;
}
var require$$0$2 = getAugmentedNamespace(base64$5);
function concat$1(arrays, length3) {
  if (!length3) {
    length3 = arrays.reduce(function(acc, curr) {
      return acc + curr.length;
    }, 0);
  }
  var output = allocUnsafe(length3);
  var offset = 0;
  var _iterator8 = _createForOfIteratorHelper(arrays), _step8;
  try {
    for (_iterator8.s(); !(_step8 = _iterator8.n()).done; ) {
      var arr = _step8.value;
      output.set(arr, offset);
      offset += arr.length;
    }
  } catch (err) {
    _iterator8.e(err);
  } finally {
    _iterator8.f();
  }
  return asUint8Array(output);
}
var concat$2 = Object.freeze(Object.defineProperty({ __proto__: null, concat: concat$1 }, Symbol.toStringTag, { value: "Module" }));
var require$$5 = getAugmentedNamespace(concat$2);
var concat = require$$5.concat;
var fromString = require$$5$1.fromString;
var webcrypto$1 = webcrypto$3;
function create() {
  var _ref65 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref65$algorithm = _ref65.algorithm, algorithm = _ref65$algorithm === void 0 ? "AES-GCM" : _ref65$algorithm, _ref65$nonceLength = _ref65.nonceLength, nonceLength = _ref65$nonceLength === void 0 ? 12 : _ref65$nonceLength, _ref65$keyLength = _ref65.keyLength, keyLength = _ref65$keyLength === void 0 ? 16 : _ref65$keyLength, _ref65$digest = _ref65.digest, digest11 = _ref65$digest === void 0 ? "SHA-256" : _ref65$digest, _ref65$saltLength = _ref65.saltLength, saltLength = _ref65$saltLength === void 0 ? 16 : _ref65$saltLength, _ref65$iterations = _ref65.iterations, iterations = _ref65$iterations === void 0 ? 32767 : _ref65$iterations;
  var crypto2 = webcrypto$1.get();
  keyLength *= 8;
  function encrypt(_x89, _x90) {
    return _encrypt.apply(this, arguments);
  }
  function _encrypt() {
    _encrypt = _asyncToGenerator(_regeneratorRuntime().mark(function _callee59(data, password) {
      var salt2, nonce, aesGcm, deriveParams, rawKey, cryptoKey, ciphertext;
      return _regeneratorRuntime().wrap(function _callee59$(_context60) {
        while (1)
          switch (_context60.prev = _context60.next) {
            case 0:
              salt2 = crypto2.getRandomValues(new Uint8Array(saltLength));
              nonce = crypto2.getRandomValues(new Uint8Array(nonceLength));
              aesGcm = { name: algorithm, iv: nonce };
              deriveParams = { name: "PBKDF2", salt: salt2, iterations, hash: { name: digest11 } };
              _context60.next = 6;
              return crypto2.subtle.importKey("raw", fromString(password), { name: "PBKDF2" }, false, ["deriveKey", "deriveBits"]);
            case 6:
              rawKey = _context60.sent;
              _context60.next = 9;
              return crypto2.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["encrypt"]);
            case 9:
              cryptoKey = _context60.sent;
              _context60.next = 12;
              return crypto2.subtle.encrypt(aesGcm, cryptoKey, data);
            case 12:
              ciphertext = _context60.sent;
              return _context60.abrupt("return", concat([salt2, aesGcm.iv, new Uint8Array(ciphertext)]));
            case 14:
            case "end":
              return _context60.stop();
          }
      }, _callee59);
    }));
    return _encrypt.apply(this, arguments);
  }
  function decrypt(_x91, _x92) {
    return _decrypt.apply(this, arguments);
  }
  function _decrypt() {
    _decrypt = _asyncToGenerator(_regeneratorRuntime().mark(function _callee60(data, password) {
      var salt2, nonce, ciphertext, aesGcm, deriveParams, rawKey, cryptoKey, plaintext;
      return _regeneratorRuntime().wrap(function _callee60$(_context61) {
        while (1)
          switch (_context61.prev = _context61.next) {
            case 0:
              salt2 = data.slice(0, saltLength);
              nonce = data.slice(saltLength, saltLength + nonceLength);
              ciphertext = data.slice(saltLength + nonceLength);
              aesGcm = { name: algorithm, iv: nonce };
              deriveParams = { name: "PBKDF2", salt: salt2, iterations, hash: { name: digest11 } };
              _context61.next = 7;
              return crypto2.subtle.importKey("raw", fromString(password), { name: "PBKDF2" }, false, ["deriveKey", "deriveBits"]);
            case 7:
              rawKey = _context61.sent;
              _context61.next = 10;
              return crypto2.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["decrypt"]);
            case 10:
              cryptoKey = _context61.sent;
              _context61.next = 13;
              return crypto2.subtle.decrypt(aesGcm, cryptoKey, ciphertext);
            case 13:
              plaintext = _context61.sent;
              return _context61.abrupt("return", new Uint8Array(plaintext));
            case 15:
            case "end":
              return _context61.stop();
          }
      }, _callee60);
    }));
    return _decrypt.apply(this, arguments);
  }
  return { encrypt, decrypt };
}
var aesGcm_browser = { create };
var base64$1 = require$$0$2.base64;
var ciphers$1 = aesGcm_browser;
var importer$1 = {
  /**
  * Attempts to decrypt a base64 encoded PrivateKey string
  * with the given password. The privateKey must have been exported
  * using the same password and underlying cipher (aes-gcm)
  *
  * @param {string} privateKey - A base64 encoded encrypted key
  * @param {string} password
  * @returns {Promise<Uint8Array>} The private key protobuf
  */
  import: function() {
    var _import2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee61(privateKey, password) {
      var encryptedKey, cipher;
      return _regeneratorRuntime().wrap(function _callee61$(_context62) {
        while (1)
          switch (_context62.prev = _context62.next) {
            case 0:
              encryptedKey = base64$1.decode(privateKey);
              cipher = ciphers$1.create();
              _context62.next = 4;
              return cipher.decrypt(encryptedKey, password);
            case 4:
              return _context62.abrupt("return", _context62.sent);
            case 5:
            case "end":
              return _context62.stop();
          }
      }, _callee61);
    }));
    function _import(_x93, _x94) {
      return _import2.apply(this, arguments);
    }
    return _import;
  }()
};
var require$$0$1 = getAugmentedNamespace(sha2Browser);
function equals(a2, b3) {
  if (a2 === b3) {
    return true;
  }
  if (a2.byteLength !== b3.byteLength) {
    return false;
  }
  for (var _i60 = 0; _i60 < a2.byteLength; _i60++) {
    if (a2[_i60] !== b3[_i60]) {
      return false;
    }
  }
  return true;
}
var equals$1 = Object.freeze(Object.defineProperty({ __proto__: null, equals }, Symbol.toStringTag, { value: "Module" }));
var require$$6 = getAugmentedNamespace(equals$1);
var forge$6 = forge$t;
var sha512$1 = forge$6.sha512 = forge$6.sha512 || {};
forge$6.md.sha512 = forge$6.md.algorithms.sha512 = sha512$1;
var sha384 = forge$6.sha384 = forge$6.sha512.sha384 = forge$6.sha512.sha384 || {};
sha384.create = function() {
  return sha512$1.create("SHA-384");
};
forge$6.md.sha384 = forge$6.md.algorithms.sha384 = sha384;
forge$6.sha512.sha256 = forge$6.sha512.sha256 || { create: function create6() {
  return sha512$1.create("SHA-512/256");
} };
forge$6.md["sha512/256"] = forge$6.md.algorithms["sha512/256"] = forge$6.sha512.sha256;
forge$6.sha512.sha224 = forge$6.sha512.sha224 || { create: function create7() {
  return sha512$1.create("SHA-512/224");
} };
forge$6.md["sha512/224"] = forge$6.md.algorithms["sha512/224"] = forge$6.sha512.sha224;
sha512$1.create = function(algorithm) {
  if (!_initialized) {
    _init();
  }
  if (typeof algorithm === "undefined") {
    algorithm = "SHA-512";
  }
  if (!(algorithm in _states)) {
    throw new Error("Invalid SHA-512 algorithm: " + algorithm);
  }
  var _state = _states[algorithm];
  var _h = null;
  var _input = forge$6.util.createBuffer();
  var _w = new Array(80);
  for (var wi = 0; wi < 80; ++wi) {
    _w[wi] = new Array(2);
  }
  var digestLength = 64;
  switch (algorithm) {
    case "SHA-384":
      digestLength = 48;
      break;
    case "SHA-512/256":
      digestLength = 32;
      break;
    case "SHA-512/224":
      digestLength = 28;
      break;
  }
  var md = {
    // SHA-512 => sha512
    algorithm: algorithm.replace("-", "").toLowerCase(),
    blockLength: 128,
    digestLength,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 16
  };
  md.start = function() {
    md.messageLength = 0;
    md.fullMessageLength = md.messageLength128 = [];
    var int32s = md.messageLengthSize / 4;
    for (var i2 = 0; i2 < int32s; ++i2) {
      md.fullMessageLength.push(0);
    }
    _input = forge$6.util.createBuffer();
    _h = new Array(_state.length);
    for (var i2 = 0; i2 < _state.length; ++i2) {
      _h[i2] = _state[i2].slice(0);
    }
    return md;
  };
  md.start();
  md.update = function(msg, encoding) {
    if (encoding === "utf8") {
      msg = forge$6.util.encodeUtf8(msg);
    }
    var len2 = msg.length;
    md.messageLength += len2;
    len2 = [len2 / 4294967296 >>> 0, len2 >>> 0];
    for (var i2 = md.fullMessageLength.length - 1; i2 >= 0; --i2) {
      md.fullMessageLength[i2] += len2[1];
      len2[1] = len2[0] + (md.fullMessageLength[i2] / 4294967296 >>> 0);
      md.fullMessageLength[i2] = md.fullMessageLength[i2] >>> 0;
      len2[0] = len2[1] / 4294967296 >>> 0;
    }
    _input.putBytes(msg);
    _update(_h, _w, _input);
    if (_input.read > 2048 || _input.length() === 0) {
      _input.compact();
    }
    return md;
  };
  md.digest = function() {
    var finalBlock = forge$6.util.createBuffer();
    finalBlock.putBytes(_input.bytes());
    var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
    var overflow = remaining & md.blockLength - 1;
    finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
    var next, carry;
    var bits = md.fullMessageLength[0] * 8;
    for (var i2 = 0; i2 < md.fullMessageLength.length - 1; ++i2) {
      next = md.fullMessageLength[i2 + 1] * 8;
      carry = next / 4294967296 >>> 0;
      bits += carry;
      finalBlock.putInt32(bits >>> 0);
      bits = next >>> 0;
    }
    finalBlock.putInt32(bits);
    var h2 = new Array(_h.length);
    for (var i2 = 0; i2 < _h.length; ++i2) {
      h2[i2] = _h[i2].slice(0);
    }
    _update(h2, _w, finalBlock);
    var rval = forge$6.util.createBuffer();
    var hlen;
    if (algorithm === "SHA-512") {
      hlen = h2.length;
    } else if (algorithm === "SHA-384") {
      hlen = h2.length - 2;
    } else {
      hlen = h2.length - 4;
    }
    for (var i2 = 0; i2 < hlen; ++i2) {
      rval.putInt32(h2[i2][0]);
      if (i2 !== hlen - 1 || algorithm !== "SHA-512/224") {
        rval.putInt32(h2[i2][1]);
      }
    }
    return rval;
  };
  return md;
};
var _padding = null;
var _initialized = false;
var _k = null;
var _states = null;
function _init() {
  _padding = String.fromCharCode(128);
  _padding += forge$6.util.fillString(String.fromCharCode(0), 128);
  _k = [[1116352408, 3609767458], [1899447441, 602891725], [3049323471, 3964484399], [3921009573, 2173295548], [961987163, 4081628472], [1508970993, 3053834265], [2453635748, 2937671579], [2870763221, 3664609560], [3624381080, 2734883394], [310598401, 1164996542], [607225278, 1323610764], [1426881987, 3590304994], [1925078388, 4068182383], [2162078206, 991336113], [2614888103, 633803317], [3248222580, 3479774868], [3835390401, 2666613458], [4022224774, 944711139], [264347078, 2341262773], [604807628, 2007800933], [770255983, 1495990901], [1249150122, 1856431235], [1555081692, 3175218132], [1996064986, 2198950837], [2554220882, 3999719339], [2821834349, 766784016], [2952996808, 2566594879], [3210313671, 3203337956], [3336571891, 1034457026], [3584528711, 2466948901], [113926993, 3758326383], [338241895, 168717936], [666307205, 1188179964], [773529912, 1546045734], [1294757372, 1522805485], [1396182291, 2643833823], [1695183700, 2343527390], [1986661051, 1014477480], [2177026350, 1206759142], [2456956037, 344077627], [2730485921, 1290863460], [2820302411, 3158454273], [3259730800, 3505952657], [3345764771, 106217008], [3516065817, 3606008344], [3600352804, 1432725776], [4094571909, 1467031594], [275423344, 851169720], [430227734, 3100823752], [506948616, 1363258195], [659060556, 3750685593], [883997877, 3785050280], [958139571, 3318307427], [1322822218, 3812723403], [1537002063, 2003034995], [1747873779, 3602036899], [1955562222, 1575990012], [2024104815, 1125592928], [2227730452, 2716904306], [2361852424, 442776044], [2428436474, 593698344], [2756734187, 3733110249], [3204031479, 2999351573], [3329325298, 3815920427], [3391569614, 3928383900], [3515267271, 566280711], [3940187606, 3454069534], [4118630271, 4000239992], [116418474, 1914138554], [174292421, 2731055270], [289380356, 3203993006], [460393269, 320620315], [685471733, 587496836], [852142971, 1086792851], [1017036298, 365543100], [1126000580, 2618297676], [1288033470, 3409855158], [1501505948, 4234509866], [1607167915, 987167468], [1816402316, 1246189591]];
  _states = {};
  _states["SHA-512"] = [[1779033703, 4089235720], [3144134277, 2227873595], [1013904242, 4271175723], [2773480762, 1595750129], [1359893119, 2917565137], [2600822924, 725511199], [528734635, 4215389547], [1541459225, 327033209]];
  _states["SHA-384"] = [[3418070365, 3238371032], [1654270250, 914150663], [2438529370, 812702999], [355462360, 4144912697], [1731405415, 4290775857], [2394180231, 1750603025], [3675008525, 1694076839], [1203062813, 3204075428]];
  _states["SHA-512/256"] = [[573645204, 4230739756], [2673172387, 3360449730], [596883563, 1867755857], [2520282905, 1497426621], [2519219938, 2827943907], [3193839141, 1401305490], [721525244, 746961066], [246885852, 2177182882]];
  _states["SHA-512/224"] = [[2352822216, 424955298], [1944164710, 2312950998], [502970286, 855612546], [1738396948, 1479516111], [258812777, 2077511080], [2011393907, 79989058], [1067287976, 1780299464], [286451373, 2446758561]];
  _initialized = true;
}
function _update(s2, w2, bytes) {
  var t1_hi, t1_lo;
  var t2_hi, t2_lo;
  var s0_hi, s0_lo;
  var s1_hi, s1_lo;
  var ch_hi, ch_lo;
  var maj_hi, maj_lo;
  var a_hi, a_lo;
  var b_hi, b_lo;
  var c_hi, c_lo;
  var d_hi, d_lo;
  var e_hi, e_lo;
  var f_hi, f_lo;
  var g_hi, g_lo;
  var h_hi, h_lo;
  var i2, hi, lo, w22, w7, w15, w16;
  var len2 = bytes.length();
  while (len2 >= 128) {
    for (i2 = 0; i2 < 16; ++i2) {
      w2[i2][0] = bytes.getInt32() >>> 0;
      w2[i2][1] = bytes.getInt32() >>> 0;
    }
    for (; i2 < 80; ++i2) {
      w22 = w2[i2 - 2];
      hi = w22[0];
      lo = w22[1];
      t1_hi = ((hi >>> 19 | lo << 13) ^ // ROTR 19
      (lo >>> 29 | hi << 3) ^ // ROTR 61/(swap + ROTR 29)
      hi >>> 6) >>> 0;
      t1_lo = ((hi << 13 | lo >>> 19) ^ // ROTR 19
      (lo << 3 | hi >>> 29) ^ // ROTR 61/(swap + ROTR 29)
      (hi << 26 | lo >>> 6)) >>> 0;
      w15 = w2[i2 - 15];
      hi = w15[0];
      lo = w15[1];
      t2_hi = ((hi >>> 1 | lo << 31) ^ // ROTR 1
      (hi >>> 8 | lo << 24) ^ // ROTR 8
      hi >>> 7) >>> 0;
      t2_lo = ((hi << 31 | lo >>> 1) ^ // ROTR 1
      (hi << 24 | lo >>> 8) ^ // ROTR 8
      (hi << 25 | lo >>> 7)) >>> 0;
      w7 = w2[i2 - 7];
      w16 = w2[i2 - 16];
      lo = t1_lo + w7[1] + t2_lo + w16[1];
      w2[i2][0] = t1_hi + w7[0] + t2_hi + w16[0] + (lo / 4294967296 >>> 0) >>> 0;
      w2[i2][1] = lo >>> 0;
    }
    a_hi = s2[0][0];
    a_lo = s2[0][1];
    b_hi = s2[1][0];
    b_lo = s2[1][1];
    c_hi = s2[2][0];
    c_lo = s2[2][1];
    d_hi = s2[3][0];
    d_lo = s2[3][1];
    e_hi = s2[4][0];
    e_lo = s2[4][1];
    f_hi = s2[5][0];
    f_lo = s2[5][1];
    g_hi = s2[6][0];
    g_lo = s2[6][1];
    h_hi = s2[7][0];
    h_lo = s2[7][1];
    for (i2 = 0; i2 < 80; ++i2) {
      s1_hi = ((e_hi >>> 14 | e_lo << 18) ^ // ROTR 14
      (e_hi >>> 18 | e_lo << 14) ^ // ROTR 18
      (e_lo >>> 9 | e_hi << 23)) >>> 0;
      s1_lo = ((e_hi << 18 | e_lo >>> 14) ^ // ROTR 14
      (e_hi << 14 | e_lo >>> 18) ^ // ROTR 18
      (e_lo << 23 | e_hi >>> 9)) >>> 0;
      ch_hi = (g_hi ^ e_hi & (f_hi ^ g_hi)) >>> 0;
      ch_lo = (g_lo ^ e_lo & (f_lo ^ g_lo)) >>> 0;
      s0_hi = ((a_hi >>> 28 | a_lo << 4) ^ // ROTR 28
      (a_lo >>> 2 | a_hi << 30) ^ // ROTR 34/(swap + ROTR 2)
      (a_lo >>> 7 | a_hi << 25)) >>> 0;
      s0_lo = ((a_hi << 4 | a_lo >>> 28) ^ // ROTR 28
      (a_lo << 30 | a_hi >>> 2) ^ // ROTR 34/(swap + ROTR 2)
      (a_lo << 25 | a_hi >>> 7)) >>> 0;
      maj_hi = (a_hi & b_hi | c_hi & (a_hi ^ b_hi)) >>> 0;
      maj_lo = (a_lo & b_lo | c_lo & (a_lo ^ b_lo)) >>> 0;
      lo = h_lo + s1_lo + ch_lo + _k[i2][1] + w2[i2][1];
      t1_hi = h_hi + s1_hi + ch_hi + _k[i2][0] + w2[i2][0] + (lo / 4294967296 >>> 0) >>> 0;
      t1_lo = lo >>> 0;
      lo = s0_lo + maj_lo;
      t2_hi = s0_hi + maj_hi + (lo / 4294967296 >>> 0) >>> 0;
      t2_lo = lo >>> 0;
      h_hi = g_hi;
      h_lo = g_lo;
      g_hi = f_hi;
      g_lo = f_lo;
      f_hi = e_hi;
      f_lo = e_lo;
      lo = d_lo + t1_lo;
      e_hi = d_hi + t1_hi + (lo / 4294967296 >>> 0) >>> 0;
      e_lo = lo >>> 0;
      d_hi = c_hi;
      d_lo = c_lo;
      c_hi = b_hi;
      c_lo = b_lo;
      b_hi = a_hi;
      b_lo = a_lo;
      lo = t1_lo + t2_lo;
      a_hi = t1_hi + t2_hi + (lo / 4294967296 >>> 0) >>> 0;
      a_lo = lo >>> 0;
    }
    lo = s2[0][1] + a_lo;
    s2[0][0] = s2[0][0] + a_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[0][1] = lo >>> 0;
    lo = s2[1][1] + b_lo;
    s2[1][0] = s2[1][0] + b_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[1][1] = lo >>> 0;
    lo = s2[2][1] + c_lo;
    s2[2][0] = s2[2][0] + c_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[2][1] = lo >>> 0;
    lo = s2[3][1] + d_lo;
    s2[3][0] = s2[3][0] + d_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[3][1] = lo >>> 0;
    lo = s2[4][1] + e_lo;
    s2[4][0] = s2[4][0] + e_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[4][1] = lo >>> 0;
    lo = s2[5][1] + f_lo;
    s2[5][0] = s2[5][0] + f_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[5][1] = lo >>> 0;
    lo = s2[6][1] + g_lo;
    s2[6][0] = s2[6][0] + g_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[6][1] = lo >>> 0;
    lo = s2[7][1] + h_lo;
    s2[7][0] = s2[7][0] + h_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[7][1] = lo >>> 0;
    len2 -= 128;
  }
}
var asn1Validator$1 = {};
var forge$5 = forge$t;
var asn1 = forge$5.asn1;
asn1Validator$1.privateKeyValidator = {
  // PrivateKeyInfo
  name: "PrivateKeyInfo",
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    // Version (INTEGER)
    name: "PrivateKeyInfo.version",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: "privateKeyVersion"
  }, {
    // privateKeyAlgorithm
    name: "PrivateKeyInfo.privateKeyAlgorithm",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{ name: "AlgorithmIdentifier.algorithm", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.OID, constructed: false, capture: "privateKeyOid" }]
  }, {
    // PrivateKey
    name: "PrivateKeyInfo",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.OCTETSTRING,
    constructed: false,
    capture: "privateKey"
  }]
};
asn1Validator$1.publicKeyValidator = { name: "SubjectPublicKeyInfo", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, captureAsn1: "subjectPublicKeyInfo", value: [
  { name: "SubjectPublicKeyInfo.AlgorithmIdentifier", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "AlgorithmIdentifier.algorithm", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.OID, constructed: false, capture: "publicKeyOid" }] },
  // capture group for ed25519PublicKey
  { tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.BITSTRING, constructed: false, composed: true, captureBitStringValue: "ed25519PublicKey" }
  // FIXME: this is capture group for rsaPublicKey, use it in this API or
  // discard?
  /* {
      // subjectPublicKey
      name: 'SubjectPublicKeyInfo.subjectPublicKey',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.BITSTRING,
      constructed: false,
      value: [{
        // RSAPublicKey
        name: 'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        optional: true,
        captureAsn1: 'rsaPublicKey'
      }]
    } */
] };
var forge$4 = forge$t;
var asn1Validator = asn1Validator$1;
var publicKeyValidator = asn1Validator.publicKeyValidator;
var privateKeyValidator = asn1Validator.privateKeyValidator;
if (typeof BigInteger === "undefined") {
  BigInteger = forge$4.jsbn.BigInteger;
}
var BigInteger;
var ByteBuffer = forge$4.util.ByteBuffer;
var NativeBuffer = typeof Buffer === "undefined" ? Uint8Array : Buffer;
forge$4.pki = forge$4.pki || {};
forge$4.pki.ed25519 = forge$4.ed25519 = forge$4.ed25519 || {};
var ed25519$1 = forge$4.ed25519;
ed25519$1.constants = {};
ed25519$1.constants.PUBLIC_KEY_BYTE_LENGTH = 32;
ed25519$1.constants.PRIVATE_KEY_BYTE_LENGTH = 64;
ed25519$1.constants.SEED_BYTE_LENGTH = 32;
ed25519$1.constants.SIGN_BYTE_LENGTH = 64;
ed25519$1.constants.HASH_BYTE_LENGTH = 64;
ed25519$1.generateKeyPair = function(options) {
  options = options || {};
  var seed = options.seed;
  if (seed === void 0) {
    seed = forge$4.random.getBytesSync(ed25519$1.constants.SEED_BYTE_LENGTH);
  } else if (typeof seed === "string") {
    if (seed.length !== ed25519$1.constants.SEED_BYTE_LENGTH) {
      throw new TypeError('"seed" must be ' + ed25519$1.constants.SEED_BYTE_LENGTH + " bytes in length.");
    }
  } else if (!(seed instanceof Uint8Array)) {
    throw new TypeError('"seed" must be a node.js Buffer, Uint8Array, or a binary string.');
  }
  seed = messageToNativeBuffer({ message: seed, encoding: "binary" });
  var pk = new NativeBuffer(ed25519$1.constants.PUBLIC_KEY_BYTE_LENGTH);
  var sk = new NativeBuffer(ed25519$1.constants.PRIVATE_KEY_BYTE_LENGTH);
  for (var i2 = 0; i2 < 32; ++i2) {
    sk[i2] = seed[i2];
  }
  crypto_sign_keypair(pk, sk);
  return { publicKey: pk, privateKey: sk };
};
ed25519$1.privateKeyFromAsn1 = function(obj2) {
  var capture = {};
  var errors = [];
  var valid = forge$4.asn1.validate(obj2, privateKeyValidator, capture, errors);
  if (!valid) {
    var error3 = new Error("Invalid Key.");
    error3.errors = errors;
    throw error3;
  }
  var oid = forge$4.asn1.derToOid(capture.privateKeyOid);
  var ed25519Oid = forge$4.oids.EdDSA25519;
  if (oid !== ed25519Oid) {
    throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
  }
  var privateKey = capture.privateKey;
  var privateKeyBytes = messageToNativeBuffer({ message: forge$4.asn1.fromDer(privateKey).value, encoding: "binary" });
  return { privateKeyBytes };
};
ed25519$1.publicKeyFromAsn1 = function(obj2) {
  var capture = {};
  var errors = [];
  var valid = forge$4.asn1.validate(obj2, publicKeyValidator, capture, errors);
  if (!valid) {
    var error3 = new Error("Invalid Key.");
    error3.errors = errors;
    throw error3;
  }
  var oid = forge$4.asn1.derToOid(capture.publicKeyOid);
  var ed25519Oid = forge$4.oids.EdDSA25519;
  if (oid !== ed25519Oid) {
    throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
  }
  var publicKeyBytes = capture.ed25519PublicKey;
  if (publicKeyBytes.length !== ed25519$1.constants.PUBLIC_KEY_BYTE_LENGTH) {
    throw new Error("Key length is invalid.");
  }
  return messageToNativeBuffer({ message: publicKeyBytes, encoding: "binary" });
};
ed25519$1.publicKeyFromPrivateKey = function(options) {
  options = options || {};
  var privateKey = messageToNativeBuffer({ message: options.privateKey, encoding: "binary" });
  if (privateKey.length !== ed25519$1.constants.PRIVATE_KEY_BYTE_LENGTH) {
    throw new TypeError('"options.privateKey" must have a byte length of ' + ed25519$1.constants.PRIVATE_KEY_BYTE_LENGTH);
  }
  var pk = new NativeBuffer(ed25519$1.constants.PUBLIC_KEY_BYTE_LENGTH);
  for (var i2 = 0; i2 < pk.length; ++i2) {
    pk[i2] = privateKey[32 + i2];
  }
  return pk;
};
ed25519$1.sign = function(options) {
  options = options || {};
  var msg = messageToNativeBuffer(options);
  var privateKey = messageToNativeBuffer({ message: options.privateKey, encoding: "binary" });
  if (privateKey.length === ed25519$1.constants.SEED_BYTE_LENGTH) {
    var keyPair = ed25519$1.generateKeyPair({ seed: privateKey });
    privateKey = keyPair.privateKey;
  } else if (privateKey.length !== ed25519$1.constants.PRIVATE_KEY_BYTE_LENGTH) {
    throw new TypeError('"options.privateKey" must have a byte length of ' + ed25519$1.constants.SEED_BYTE_LENGTH + " or " + ed25519$1.constants.PRIVATE_KEY_BYTE_LENGTH);
  }
  var signedMsg = new NativeBuffer(ed25519$1.constants.SIGN_BYTE_LENGTH + msg.length);
  crypto_sign(signedMsg, msg, msg.length, privateKey);
  var sig = new NativeBuffer(ed25519$1.constants.SIGN_BYTE_LENGTH);
  for (var i2 = 0; i2 < sig.length; ++i2) {
    sig[i2] = signedMsg[i2];
  }
  return sig;
};
ed25519$1.verify = function(options) {
  options = options || {};
  var msg = messageToNativeBuffer(options);
  if (options.signature === void 0) {
    throw new TypeError('"options.signature" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.');
  }
  var sig = messageToNativeBuffer({ message: options.signature, encoding: "binary" });
  if (sig.length !== ed25519$1.constants.SIGN_BYTE_LENGTH) {
    throw new TypeError('"options.signature" must have a byte length of ' + ed25519$1.constants.SIGN_BYTE_LENGTH);
  }
  var publicKey = messageToNativeBuffer({ message: options.publicKey, encoding: "binary" });
  if (publicKey.length !== ed25519$1.constants.PUBLIC_KEY_BYTE_LENGTH) {
    throw new TypeError('"options.publicKey" must have a byte length of ' + ed25519$1.constants.PUBLIC_KEY_BYTE_LENGTH);
  }
  var sm = new NativeBuffer(ed25519$1.constants.SIGN_BYTE_LENGTH + msg.length);
  var m2 = new NativeBuffer(ed25519$1.constants.SIGN_BYTE_LENGTH + msg.length);
  var i2;
  for (i2 = 0; i2 < ed25519$1.constants.SIGN_BYTE_LENGTH; ++i2) {
    sm[i2] = sig[i2];
  }
  for (i2 = 0; i2 < msg.length; ++i2) {
    sm[i2 + ed25519$1.constants.SIGN_BYTE_LENGTH] = msg[i2];
  }
  return crypto_sign_open(m2, sm, sm.length, publicKey) >= 0;
};
function messageToNativeBuffer(options) {
  var message = options.message;
  if (message instanceof Uint8Array || message instanceof NativeBuffer) {
    return message;
  }
  var encoding = options.encoding;
  if (message === void 0) {
    if (options.md) {
      message = options.md.digest().getBytes();
      encoding = "binary";
    } else {
      throw new TypeError('"options.message" or "options.md" not specified.');
    }
  }
  if (typeof message === "string" && !encoding) {
    throw new TypeError('"options.encoding" must be "binary" or "utf8".');
  }
  if (typeof message === "string") {
    if (typeof Buffer !== "undefined") {
      return Buffer.from(message, encoding);
    }
    message = new ByteBuffer(message, encoding);
  } else if (!(message instanceof ByteBuffer)) {
    throw new TypeError('"options.message" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with "options.encoding" specifying its encoding.');
  }
  var buffer2 = new NativeBuffer(message.length());
  for (var i2 = 0; i2 < buffer2.length; ++i2) {
    buffer2[i2] = message.at(i2);
  }
  return buffer2;
}
var gf0 = gf();
var gf1 = gf([1]);
var D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]);
var D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]);
var X$1 = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]);
var Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]);
var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
var I$1 = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
function sha512(msg, msgLen) {
  var md = forge$4.md.sha512.create();
  var buffer2 = new ByteBuffer(msg);
  md.update(buffer2.getBytes(msgLen), "binary");
  var hash2 = md.digest().getBytes();
  if (typeof Buffer !== "undefined") {
    return Buffer.from(hash2, "binary");
  }
  var out = new NativeBuffer(ed25519$1.constants.HASH_BYTE_LENGTH);
  for (var i2 = 0; i2 < 64; ++i2) {
    out[i2] = hash2.charCodeAt(i2);
  }
  return out;
}
function crypto_sign_keypair(pk, sk) {
  var p2 = [gf(), gf(), gf(), gf()];
  var i2;
  var d2 = sha512(sk, 32);
  d2[0] &= 248;
  d2[31] &= 127;
  d2[31] |= 64;
  scalarbase(p2, d2);
  pack(pk, p2);
  for (i2 = 0; i2 < 32; ++i2) {
    sk[i2 + 32] = pk[i2];
  }
  return 0;
}
function crypto_sign(sm, m2, n2, sk) {
  var i2, j3, x2 = new Float64Array(64);
  var p2 = [gf(), gf(), gf(), gf()];
  var d2 = sha512(sk, 32);
  d2[0] &= 248;
  d2[31] &= 127;
  d2[31] |= 64;
  var smlen = n2 + 64;
  for (i2 = 0; i2 < n2; ++i2) {
    sm[64 + i2] = m2[i2];
  }
  for (i2 = 0; i2 < 32; ++i2) {
    sm[32 + i2] = d2[32 + i2];
  }
  var r2 = sha512(sm.subarray(32), n2 + 32);
  reduce(r2);
  scalarbase(p2, r2);
  pack(sm, p2);
  for (i2 = 32; i2 < 64; ++i2) {
    sm[i2] = sk[i2];
  }
  var h2 = sha512(sm, n2 + 64);
  reduce(h2);
  for (i2 = 32; i2 < 64; ++i2) {
    x2[i2] = 0;
  }
  for (i2 = 0; i2 < 32; ++i2) {
    x2[i2] = r2[i2];
  }
  for (i2 = 0; i2 < 32; ++i2) {
    for (j3 = 0; j3 < 32; j3++) {
      x2[i2 + j3] += h2[i2] * d2[j3];
    }
  }
  modL(sm.subarray(32), x2);
  return smlen;
}
function crypto_sign_open(m2, sm, n2, pk) {
  var i2, mlen;
  var t2 = new NativeBuffer(32);
  var p2 = [gf(), gf(), gf(), gf()], q3 = [gf(), gf(), gf(), gf()];
  mlen = -1;
  if (n2 < 64) {
    return -1;
  }
  if (unpackneg(q3, pk)) {
    return -1;
  }
  for (i2 = 0; i2 < n2; ++i2) {
    m2[i2] = sm[i2];
  }
  for (i2 = 0; i2 < 32; ++i2) {
    m2[i2 + 32] = pk[i2];
  }
  var h2 = sha512(m2, n2);
  reduce(h2);
  scalarmult(p2, q3, h2);
  scalarbase(q3, sm.subarray(32));
  add(p2, q3);
  pack(t2, p2);
  n2 -= 64;
  if (crypto_verify_32(sm, 0, t2, 0)) {
    for (i2 = 0; i2 < n2; ++i2) {
      m2[i2] = 0;
    }
    return -1;
  }
  for (i2 = 0; i2 < n2; ++i2) {
    m2[i2] = sm[i2 + 64];
  }
  mlen = n2;
  return mlen;
}
function modL(r2, x2) {
  var carry, i2, j3, k3;
  for (i2 = 63; i2 >= 32; --i2) {
    carry = 0;
    for (j3 = i2 - 32, k3 = i2 - 12; j3 < k3; ++j3) {
      x2[j3] += carry - 16 * x2[i2] * L[j3 - (i2 - 32)];
      carry = x2[j3] + 128 >> 8;
      x2[j3] -= carry * 256;
    }
    x2[j3] += carry;
    x2[i2] = 0;
  }
  carry = 0;
  for (j3 = 0; j3 < 32; ++j3) {
    x2[j3] += carry - (x2[31] >> 4) * L[j3];
    carry = x2[j3] >> 8;
    x2[j3] &= 255;
  }
  for (j3 = 0; j3 < 32; ++j3) {
    x2[j3] -= carry * L[j3];
  }
  for (i2 = 0; i2 < 32; ++i2) {
    x2[i2 + 1] += x2[i2] >> 8;
    r2[i2] = x2[i2] & 255;
  }
}
function reduce(r2) {
  var x2 = new Float64Array(64);
  for (var i2 = 0; i2 < 64; ++i2) {
    x2[i2] = r2[i2];
    r2[i2] = 0;
  }
  modL(r2, x2);
}
function add(p2, q3) {
  var a2 = gf(), b3 = gf(), c3 = gf(), d2 = gf(), e2 = gf(), f2 = gf(), g2 = gf(), h2 = gf(), t2 = gf();
  Z$1(a2, p2[1], p2[0]);
  Z$1(t2, q3[1], q3[0]);
  M$1(a2, a2, t2);
  A(b3, p2[0], p2[1]);
  A(t2, q3[0], q3[1]);
  M$1(b3, b3, t2);
  M$1(c3, p2[3], q3[3]);
  M$1(c3, c3, D2);
  M$1(d2, p2[2], q3[2]);
  A(d2, d2, d2);
  Z$1(e2, b3, a2);
  Z$1(f2, d2, c3);
  A(g2, d2, c3);
  A(h2, b3, a2);
  M$1(p2[0], e2, f2);
  M$1(p2[1], h2, g2);
  M$1(p2[2], g2, f2);
  M$1(p2[3], e2, h2);
}
function cswap(p2, q3, b3) {
  for (var i2 = 0; i2 < 4; ++i2) {
    sel25519(p2[i2], q3[i2], b3);
  }
}
function pack(r2, p2) {
  var tx = gf(), ty = gf(), zi = gf();
  inv25519(zi, p2[2]);
  M$1(tx, p2[0], zi);
  M$1(ty, p2[1], zi);
  pack25519(r2, ty);
  r2[31] ^= par25519(tx) << 7;
}
function pack25519(o2, n2) {
  var i2, j3, b3;
  var m2 = gf(), t2 = gf();
  for (i2 = 0; i2 < 16; ++i2) {
    t2[i2] = n2[i2];
  }
  car25519(t2);
  car25519(t2);
  car25519(t2);
  for (j3 = 0; j3 < 2; ++j3) {
    m2[0] = t2[0] - 65517;
    for (i2 = 1; i2 < 15; ++i2) {
      m2[i2] = t2[i2] - 65535 - (m2[i2 - 1] >> 16 & 1);
      m2[i2 - 1] &= 65535;
    }
    m2[15] = t2[15] - 32767 - (m2[14] >> 16 & 1);
    b3 = m2[15] >> 16 & 1;
    m2[14] &= 65535;
    sel25519(t2, m2, 1 - b3);
  }
  for (i2 = 0; i2 < 16; i2++) {
    o2[2 * i2] = t2[i2] & 255;
    o2[2 * i2 + 1] = t2[i2] >> 8;
  }
}
function unpackneg(r2, p2) {
  var t2 = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
  set25519(r2[2], gf1);
  unpack25519(r2[1], p2);
  S(num, r2[1]);
  M$1(den, num, D);
  Z$1(num, num, r2[2]);
  A(den, r2[2], den);
  S(den2, den);
  S(den4, den2);
  M$1(den6, den4, den2);
  M$1(t2, den6, num);
  M$1(t2, t2, den);
  pow2523(t2, t2);
  M$1(t2, t2, num);
  M$1(t2, t2, den);
  M$1(t2, t2, den);
  M$1(r2[0], t2, den);
  S(chk, r2[0]);
  M$1(chk, chk, den);
  if (neq25519(chk, num)) {
    M$1(r2[0], r2[0], I$1);
  }
  S(chk, r2[0]);
  M$1(chk, chk, den);
  if (neq25519(chk, num)) {
    return -1;
  }
  if (par25519(r2[0]) === p2[31] >> 7) {
    Z$1(r2[0], gf0, r2[0]);
  }
  M$1(r2[3], r2[0], r2[1]);
  return 0;
}
function unpack25519(o2, n2) {
  var i2;
  for (i2 = 0; i2 < 16; ++i2) {
    o2[i2] = n2[2 * i2] + (n2[2 * i2 + 1] << 8);
  }
  o2[15] &= 32767;
}
function pow2523(o2, i2) {
  var c3 = gf();
  var a2;
  for (a2 = 0; a2 < 16; ++a2) {
    c3[a2] = i2[a2];
  }
  for (a2 = 250; a2 >= 0; --a2) {
    S(c3, c3);
    if (a2 !== 1) {
      M$1(c3, c3, i2);
    }
  }
  for (a2 = 0; a2 < 16; ++a2) {
    o2[a2] = c3[a2];
  }
}
function neq25519(a2, b3) {
  var c3 = new NativeBuffer(32);
  var d2 = new NativeBuffer(32);
  pack25519(c3, a2);
  pack25519(d2, b3);
  return crypto_verify_32(c3, 0, d2, 0);
}
function crypto_verify_32(x2, xi, y3, yi) {
  return vn(x2, xi, y3, yi, 32);
}
function vn(x2, xi, y3, yi, n2) {
  var i2, d2 = 0;
  for (i2 = 0; i2 < n2; ++i2) {
    d2 |= x2[xi + i2] ^ y3[yi + i2];
  }
  return (1 & d2 - 1 >>> 8) - 1;
}
function par25519(a2) {
  var d2 = new NativeBuffer(32);
  pack25519(d2, a2);
  return d2[0] & 1;
}
function scalarmult(p2, q3, s2) {
  var b3, i2;
  set25519(p2[0], gf0);
  set25519(p2[1], gf1);
  set25519(p2[2], gf1);
  set25519(p2[3], gf0);
  for (i2 = 255; i2 >= 0; --i2) {
    b3 = s2[i2 / 8 | 0] >> (i2 & 7) & 1;
    cswap(p2, q3, b3);
    add(q3, p2);
    add(p2, p2);
    cswap(p2, q3, b3);
  }
}
function scalarbase(p2, s2) {
  var q3 = [gf(), gf(), gf(), gf()];
  set25519(q3[0], X$1);
  set25519(q3[1], Y);
  set25519(q3[2], gf1);
  M$1(q3[3], X$1, Y);
  scalarmult(p2, q3, s2);
}
function set25519(r2, a2) {
  var i2;
  for (i2 = 0; i2 < 16; i2++) {
    r2[i2] = a2[i2] | 0;
  }
}
function inv25519(o2, i2) {
  var c3 = gf();
  var a2;
  for (a2 = 0; a2 < 16; ++a2) {
    c3[a2] = i2[a2];
  }
  for (a2 = 253; a2 >= 0; --a2) {
    S(c3, c3);
    if (a2 !== 2 && a2 !== 4) {
      M$1(c3, c3, i2);
    }
  }
  for (a2 = 0; a2 < 16; ++a2) {
    o2[a2] = c3[a2];
  }
}
function car25519(o2) {
  var i2, v2, c3 = 1;
  for (i2 = 0; i2 < 16; ++i2) {
    v2 = o2[i2] + c3 + 65535;
    c3 = Math.floor(v2 / 65536);
    o2[i2] = v2 - c3 * 65536;
  }
  o2[0] += c3 - 1 + 37 * (c3 - 1);
}
function sel25519(p2, q3, b3) {
  var t2, c3 = ~(b3 - 1);
  for (var i2 = 0; i2 < 16; ++i2) {
    t2 = c3 & (p2[i2] ^ q3[i2]);
    p2[i2] ^= t2;
    q3[i2] ^= t2;
  }
}
function gf(init5) {
  var i2, r2 = new Float64Array(16);
  if (init5) {
    for (i2 = 0; i2 < init5.length; ++i2) {
      r2[i2] = init5[i2];
    }
  }
  return r2;
}
function A(o2, a2, b3) {
  for (var i2 = 0; i2 < 16; ++i2) {
    o2[i2] = a2[i2] + b3[i2];
  }
}
function Z$1(o2, a2, b3) {
  for (var i2 = 0; i2 < 16; ++i2) {
    o2[i2] = a2[i2] - b3[i2];
  }
}
function S(o2, a2) {
  M$1(o2, a2, a2);
}
function M$1(o2, a2, b3) {
  var v2, c3, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b3[0], b1 = b3[1], b22 = b3[2], b32 = b3[3], b4 = b3[4], b5 = b3[5], b6 = b3[6], b7 = b3[7], b8 = b3[8], b9 = b3[9], b10 = b3[10], b11 = b3[11], b12 = b3[12], b13 = b3[13], b14 = b3[14], b15 = b3[15];
  v2 = a2[0];
  t0 += v2 * b0;
  t1 += v2 * b1;
  t2 += v2 * b22;
  t3 += v2 * b32;
  t4 += v2 * b4;
  t5 += v2 * b5;
  t6 += v2 * b6;
  t7 += v2 * b7;
  t8 += v2 * b8;
  t9 += v2 * b9;
  t10 += v2 * b10;
  t11 += v2 * b11;
  t12 += v2 * b12;
  t13 += v2 * b13;
  t14 += v2 * b14;
  t15 += v2 * b15;
  v2 = a2[1];
  t1 += v2 * b0;
  t2 += v2 * b1;
  t3 += v2 * b22;
  t4 += v2 * b32;
  t5 += v2 * b4;
  t6 += v2 * b5;
  t7 += v2 * b6;
  t8 += v2 * b7;
  t9 += v2 * b8;
  t10 += v2 * b9;
  t11 += v2 * b10;
  t12 += v2 * b11;
  t13 += v2 * b12;
  t14 += v2 * b13;
  t15 += v2 * b14;
  t16 += v2 * b15;
  v2 = a2[2];
  t2 += v2 * b0;
  t3 += v2 * b1;
  t4 += v2 * b22;
  t5 += v2 * b32;
  t6 += v2 * b4;
  t7 += v2 * b5;
  t8 += v2 * b6;
  t9 += v2 * b7;
  t10 += v2 * b8;
  t11 += v2 * b9;
  t12 += v2 * b10;
  t13 += v2 * b11;
  t14 += v2 * b12;
  t15 += v2 * b13;
  t16 += v2 * b14;
  t17 += v2 * b15;
  v2 = a2[3];
  t3 += v2 * b0;
  t4 += v2 * b1;
  t5 += v2 * b22;
  t6 += v2 * b32;
  t7 += v2 * b4;
  t8 += v2 * b5;
  t9 += v2 * b6;
  t10 += v2 * b7;
  t11 += v2 * b8;
  t12 += v2 * b9;
  t13 += v2 * b10;
  t14 += v2 * b11;
  t15 += v2 * b12;
  t16 += v2 * b13;
  t17 += v2 * b14;
  t18 += v2 * b15;
  v2 = a2[4];
  t4 += v2 * b0;
  t5 += v2 * b1;
  t6 += v2 * b22;
  t7 += v2 * b32;
  t8 += v2 * b4;
  t9 += v2 * b5;
  t10 += v2 * b6;
  t11 += v2 * b7;
  t12 += v2 * b8;
  t13 += v2 * b9;
  t14 += v2 * b10;
  t15 += v2 * b11;
  t16 += v2 * b12;
  t17 += v2 * b13;
  t18 += v2 * b14;
  t19 += v2 * b15;
  v2 = a2[5];
  t5 += v2 * b0;
  t6 += v2 * b1;
  t7 += v2 * b22;
  t8 += v2 * b32;
  t9 += v2 * b4;
  t10 += v2 * b5;
  t11 += v2 * b6;
  t12 += v2 * b7;
  t13 += v2 * b8;
  t14 += v2 * b9;
  t15 += v2 * b10;
  t16 += v2 * b11;
  t17 += v2 * b12;
  t18 += v2 * b13;
  t19 += v2 * b14;
  t20 += v2 * b15;
  v2 = a2[6];
  t6 += v2 * b0;
  t7 += v2 * b1;
  t8 += v2 * b22;
  t9 += v2 * b32;
  t10 += v2 * b4;
  t11 += v2 * b5;
  t12 += v2 * b6;
  t13 += v2 * b7;
  t14 += v2 * b8;
  t15 += v2 * b9;
  t16 += v2 * b10;
  t17 += v2 * b11;
  t18 += v2 * b12;
  t19 += v2 * b13;
  t20 += v2 * b14;
  t21 += v2 * b15;
  v2 = a2[7];
  t7 += v2 * b0;
  t8 += v2 * b1;
  t9 += v2 * b22;
  t10 += v2 * b32;
  t11 += v2 * b4;
  t12 += v2 * b5;
  t13 += v2 * b6;
  t14 += v2 * b7;
  t15 += v2 * b8;
  t16 += v2 * b9;
  t17 += v2 * b10;
  t18 += v2 * b11;
  t19 += v2 * b12;
  t20 += v2 * b13;
  t21 += v2 * b14;
  t22 += v2 * b15;
  v2 = a2[8];
  t8 += v2 * b0;
  t9 += v2 * b1;
  t10 += v2 * b22;
  t11 += v2 * b32;
  t12 += v2 * b4;
  t13 += v2 * b5;
  t14 += v2 * b6;
  t15 += v2 * b7;
  t16 += v2 * b8;
  t17 += v2 * b9;
  t18 += v2 * b10;
  t19 += v2 * b11;
  t20 += v2 * b12;
  t21 += v2 * b13;
  t22 += v2 * b14;
  t23 += v2 * b15;
  v2 = a2[9];
  t9 += v2 * b0;
  t10 += v2 * b1;
  t11 += v2 * b22;
  t12 += v2 * b32;
  t13 += v2 * b4;
  t14 += v2 * b5;
  t15 += v2 * b6;
  t16 += v2 * b7;
  t17 += v2 * b8;
  t18 += v2 * b9;
  t19 += v2 * b10;
  t20 += v2 * b11;
  t21 += v2 * b12;
  t22 += v2 * b13;
  t23 += v2 * b14;
  t24 += v2 * b15;
  v2 = a2[10];
  t10 += v2 * b0;
  t11 += v2 * b1;
  t12 += v2 * b22;
  t13 += v2 * b32;
  t14 += v2 * b4;
  t15 += v2 * b5;
  t16 += v2 * b6;
  t17 += v2 * b7;
  t18 += v2 * b8;
  t19 += v2 * b9;
  t20 += v2 * b10;
  t21 += v2 * b11;
  t22 += v2 * b12;
  t23 += v2 * b13;
  t24 += v2 * b14;
  t25 += v2 * b15;
  v2 = a2[11];
  t11 += v2 * b0;
  t12 += v2 * b1;
  t13 += v2 * b22;
  t14 += v2 * b32;
  t15 += v2 * b4;
  t16 += v2 * b5;
  t17 += v2 * b6;
  t18 += v2 * b7;
  t19 += v2 * b8;
  t20 += v2 * b9;
  t21 += v2 * b10;
  t22 += v2 * b11;
  t23 += v2 * b12;
  t24 += v2 * b13;
  t25 += v2 * b14;
  t26 += v2 * b15;
  v2 = a2[12];
  t12 += v2 * b0;
  t13 += v2 * b1;
  t14 += v2 * b22;
  t15 += v2 * b32;
  t16 += v2 * b4;
  t17 += v2 * b5;
  t18 += v2 * b6;
  t19 += v2 * b7;
  t20 += v2 * b8;
  t21 += v2 * b9;
  t22 += v2 * b10;
  t23 += v2 * b11;
  t24 += v2 * b12;
  t25 += v2 * b13;
  t26 += v2 * b14;
  t27 += v2 * b15;
  v2 = a2[13];
  t13 += v2 * b0;
  t14 += v2 * b1;
  t15 += v2 * b22;
  t16 += v2 * b32;
  t17 += v2 * b4;
  t18 += v2 * b5;
  t19 += v2 * b6;
  t20 += v2 * b7;
  t21 += v2 * b8;
  t22 += v2 * b9;
  t23 += v2 * b10;
  t24 += v2 * b11;
  t25 += v2 * b12;
  t26 += v2 * b13;
  t27 += v2 * b14;
  t28 += v2 * b15;
  v2 = a2[14];
  t14 += v2 * b0;
  t15 += v2 * b1;
  t16 += v2 * b22;
  t17 += v2 * b32;
  t18 += v2 * b4;
  t19 += v2 * b5;
  t20 += v2 * b6;
  t21 += v2 * b7;
  t22 += v2 * b8;
  t23 += v2 * b9;
  t24 += v2 * b10;
  t25 += v2 * b11;
  t26 += v2 * b12;
  t27 += v2 * b13;
  t28 += v2 * b14;
  t29 += v2 * b15;
  v2 = a2[15];
  t15 += v2 * b0;
  t16 += v2 * b1;
  t17 += v2 * b22;
  t18 += v2 * b32;
  t19 += v2 * b4;
  t20 += v2 * b5;
  t21 += v2 * b6;
  t22 += v2 * b7;
  t23 += v2 * b8;
  t24 += v2 * b9;
  t25 += v2 * b10;
  t26 += v2 * b11;
  t27 += v2 * b12;
  t28 += v2 * b13;
  t29 += v2 * b14;
  t30 += v2 * b15;
  t0 += 38 * t16;
  t1 += 38 * t17;
  t2 += 38 * t18;
  t3 += 38 * t19;
  t4 += 38 * t20;
  t5 += 38 * t21;
  t6 += 38 * t22;
  t7 += 38 * t23;
  t8 += 38 * t24;
  t9 += 38 * t25;
  t10 += 38 * t26;
  t11 += 38 * t27;
  t12 += 38 * t28;
  t13 += 38 * t29;
  t14 += 38 * t30;
  c3 = 1;
  v2 = t0 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t0 = v2 - c3 * 65536;
  v2 = t1 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t1 = v2 - c3 * 65536;
  v2 = t2 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t2 = v2 - c3 * 65536;
  v2 = t3 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t3 = v2 - c3 * 65536;
  v2 = t4 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t4 = v2 - c3 * 65536;
  v2 = t5 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t5 = v2 - c3 * 65536;
  v2 = t6 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t6 = v2 - c3 * 65536;
  v2 = t7 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t7 = v2 - c3 * 65536;
  v2 = t8 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t8 = v2 - c3 * 65536;
  v2 = t9 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t9 = v2 - c3 * 65536;
  v2 = t10 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t10 = v2 - c3 * 65536;
  v2 = t11 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t11 = v2 - c3 * 65536;
  v2 = t12 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t12 = v2 - c3 * 65536;
  v2 = t13 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t13 = v2 - c3 * 65536;
  v2 = t14 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t14 = v2 - c3 * 65536;
  v2 = t15 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t15 = v2 - c3 * 65536;
  t0 += c3 - 1 + 37 * (c3 - 1);
  c3 = 1;
  v2 = t0 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t0 = v2 - c3 * 65536;
  v2 = t1 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t1 = v2 - c3 * 65536;
  v2 = t2 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t2 = v2 - c3 * 65536;
  v2 = t3 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t3 = v2 - c3 * 65536;
  v2 = t4 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t4 = v2 - c3 * 65536;
  v2 = t5 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t5 = v2 - c3 * 65536;
  v2 = t6 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t6 = v2 - c3 * 65536;
  v2 = t7 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t7 = v2 - c3 * 65536;
  v2 = t8 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t8 = v2 - c3 * 65536;
  v2 = t9 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t9 = v2 - c3 * 65536;
  v2 = t10 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t10 = v2 - c3 * 65536;
  v2 = t11 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t11 = v2 - c3 * 65536;
  v2 = t12 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t12 = v2 - c3 * 65536;
  v2 = t13 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t13 = v2 - c3 * 65536;
  v2 = t14 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t14 = v2 - c3 * 65536;
  v2 = t15 + c3 + 65535;
  c3 = Math.floor(v2 / 65536);
  t15 = v2 - c3 * 65536;
  t0 += c3 - 1 + 37 * (c3 - 1);
  o2[0] = t0;
  o2[1] = t1;
  o2[2] = t2;
  o2[3] = t3;
  o2[4] = t4;
  o2[5] = t5;
  o2[6] = t6;
  o2[7] = t7;
  o2[8] = t8;
  o2[9] = t9;
  o2[10] = t10;
  o2[11] = t11;
  o2[12] = t12;
  o2[13] = t13;
  o2[14] = t14;
  o2[15] = t15;
}
var rsaBrowser = {};
var MAX_BYTES = 65536;
function randomBytes$2(size) {
  var bytes = new Uint8Array(size);
  var generated = 0;
  if (size > 0) {
    if (size > MAX_BYTES) {
      while (generated < size) {
        if (generated + MAX_BYTES > size) {
          crypto.getRandomValues(bytes.subarray(generated, generated + (size - generated)));
          generated += size - generated;
        } else {
          crypto.getRandomValues(bytes.subarray(generated, generated + MAX_BYTES));
          generated += MAX_BYTES;
        }
      }
    } else {
      crypto.getRandomValues(bytes);
    }
  }
  return bytes;
}
var random_browser = randomBytes$2;
var randomBytes$1 = random_browser;
var errcode$5 = errCode;
var randomBytes_1 = function randomBytes_12(length3) {
  if (isNaN(length3) || length3 <= 0) {
    throw errcode$5(new Error("random bytes length must be a Number bigger than 0"), "ERR_INVALID_LENGTH");
  }
  return randomBytes$1(length3);
};
var rsaUtils = {};
var util = {};
(function(exports) {
  var forge2 = forge$t;
  var uint8ArrayFromString2 = require$$5$1.fromString;
  var uint8ArrayToString2 = require$$4$1.toString;
  var uint8ArrayConcat = require$$5.concat;
  exports.bigIntegerToUintBase64url = function(num, len2) {
    var buf = Uint8Array.from(num.abs().toByteArray());
    buf = buf[0] === 0 ? buf.slice(1) : buf;
    if (len2 != null) {
      if (buf.length > len2)
        throw new Error("byte array longer than desired length");
      buf = uint8ArrayConcat([new Uint8Array(len2 - buf.length), buf]);
    }
    return uint8ArrayToString2(buf, "base64url");
  };
  exports.base64urlToBigInteger = function(str) {
    var buf = exports.base64urlToBuffer(str);
    return new forge2.jsbn.BigInteger(uint8ArrayToString2(buf, "base16"), 16);
  };
  exports.base64urlToBuffer = function(str, len2) {
    var buf = uint8ArrayFromString2(str, "base64urlpad");
    if (len2 != null) {
      if (buf.length > len2)
        throw new Error("byte array longer than desired length");
      buf = uint8ArrayConcat([new Uint8Array(len2 - buf.length), buf]);
    }
    return buf;
  };
})(util);
var forge$3 = forge$t;
var bigIntegerToUintBase64url = util.bigIntegerToUintBase64url;
var base64urlToBigInteger = util.base64urlToBigInteger;
var uint8ArrayFromString$2 = require$$5$1.fromString;
var uint8ArrayToString$3 = require$$4$1.toString;
rsaUtils.pkcs1ToJwk = function(bytes) {
  var asn12 = forge$3.asn1.fromDer(uint8ArrayToString$3(bytes, "ascii"));
  var privateKey = forge$3.pki.privateKeyFromAsn1(asn12);
  return { kty: "RSA", n: bigIntegerToUintBase64url(privateKey.n), e: bigIntegerToUintBase64url(privateKey.e), d: bigIntegerToUintBase64url(privateKey.d), p: bigIntegerToUintBase64url(privateKey.p), q: bigIntegerToUintBase64url(privateKey.q), dp: bigIntegerToUintBase64url(privateKey.dP), dq: bigIntegerToUintBase64url(privateKey.dQ), qi: bigIntegerToUintBase64url(privateKey.qInv), alg: "RS256", kid: "2011-04-29" };
};
rsaUtils.jwkToPkcs1 = function(jwk) {
  var asn12 = forge$3.pki.privateKeyToAsn1({ n: base64urlToBigInteger(jwk.n), e: base64urlToBigInteger(jwk.e), d: base64urlToBigInteger(jwk.d), p: base64urlToBigInteger(jwk.p), q: base64urlToBigInteger(jwk.q), dP: base64urlToBigInteger(jwk.dp), dQ: base64urlToBigInteger(jwk.dq), qInv: base64urlToBigInteger(jwk.qi) });
  return uint8ArrayFromString$2(forge$3.asn1.toDer(asn12).getBytes(), "ascii");
};
rsaUtils.pkixToJwk = function(bytes) {
  var asn12 = forge$3.asn1.fromDer(uint8ArrayToString$3(bytes, "ascii"));
  var publicKey = forge$3.pki.publicKeyFromAsn1(asn12);
  return { kty: "RSA", n: bigIntegerToUintBase64url(publicKey.n), e: bigIntegerToUintBase64url(publicKey.e), alg: "RS256", kid: "2011-04-29" };
};
rsaUtils.jwkToPkix = function(jwk) {
  var asn12 = forge$3.pki.publicKeyToAsn1({ n: base64urlToBigInteger(jwk.n), e: base64urlToBigInteger(jwk.e) });
  return uint8ArrayFromString$2(forge$3.asn1.toDer(asn12).getBytes(), "ascii");
};
var jwk2pem;
var hasRequiredJwk2pem;
function requireJwk2pem() {
  if (hasRequiredJwk2pem)
    return jwk2pem;
  hasRequiredJwk2pem = 1;
  var forge2 = forge$t;
  var base64urlToBigInteger2 = util.base64urlToBigInteger;
  function convert(key3, types) {
    return types.map(function(t2) {
      return base64urlToBigInteger2(key3[t2]);
    });
  }
  function jwk2priv2(key3) {
    var _forge$pki;
    return (_forge$pki = forge2.pki).setRsaPrivateKey.apply(_forge$pki, _toConsumableArray(convert(key3, ["n", "e", "d", "p", "q", "dp", "dq", "qi"])));
  }
  function jwk2pub2(key3) {
    var _forge$pki2;
    return (_forge$pki2 = forge2.pki).setRsaPublicKey.apply(_forge$pki2, _toConsumableArray(convert(key3, ["n", "e"])));
  }
  jwk2pem = { jwk2pub: jwk2pub2, jwk2priv: jwk2priv2 };
  return jwk2pem;
}
var webcrypto = webcrypto$3;
var randomBytes = randomBytes_1;
var uint8ArrayToString$2 = require$$4$1.toString;
var uint8ArrayFromString$1 = require$$5$1.fromString;
rsaBrowser.utils = rsaUtils;
rsaBrowser.generateKey = function() {
  var _ref66 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee62(bits) {
    var pair, keys2;
    return _regeneratorRuntime().wrap(function _callee62$(_context63) {
      while (1)
        switch (_context63.prev = _context63.next) {
          case 0:
            _context63.next = 2;
            return webcrypto.get().subtle.generateKey({ name: "RSASSA-PKCS1-v1_5", modulusLength: bits, publicExponent: new Uint8Array([1, 0, 1]), hash: { name: "SHA-256" } }, true, ["sign", "verify"]);
          case 2:
            pair = _context63.sent;
            _context63.next = 5;
            return exportKey(pair);
          case 5:
            keys2 = _context63.sent;
            return _context63.abrupt("return", { privateKey: keys2[0], publicKey: keys2[1] });
          case 7:
          case "end":
            return _context63.stop();
        }
    }, _callee62);
  }));
  return function(_x95) {
    return _ref66.apply(this, arguments);
  };
}();
rsaBrowser.unmarshalPrivateKey = function() {
  var _ref67 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee63(key3) {
    var privateKey, pair, keys2;
    return _regeneratorRuntime().wrap(function _callee63$(_context64) {
      while (1)
        switch (_context64.prev = _context64.next) {
          case 0:
            _context64.next = 2;
            return webcrypto.get().subtle.importKey("jwk", key3, { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-256" } }, true, ["sign"]);
          case 2:
            privateKey = _context64.sent;
            _context64.t0 = privateKey;
            _context64.next = 6;
            return derivePublicFromPrivate(key3);
          case 6:
            _context64.t1 = _context64.sent;
            pair = [_context64.t0, _context64.t1];
            _context64.next = 10;
            return exportKey({ privateKey: pair[0], publicKey: pair[1] });
          case 10:
            keys2 = _context64.sent;
            return _context64.abrupt("return", { privateKey: keys2[0], publicKey: keys2[1] });
          case 12:
          case "end":
            return _context64.stop();
        }
    }, _callee63);
  }));
  return function(_x96) {
    return _ref67.apply(this, arguments);
  };
}();
rsaBrowser.getRandomValues = randomBytes;
rsaBrowser.hashAndSign = function() {
  var _ref68 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee64(key3, msg) {
    var privateKey, sig;
    return _regeneratorRuntime().wrap(function _callee64$(_context65) {
      while (1)
        switch (_context65.prev = _context65.next) {
          case 0:
            _context65.next = 2;
            return webcrypto.get().subtle.importKey("jwk", key3, { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-256" } }, false, ["sign"]);
          case 2:
            privateKey = _context65.sent;
            _context65.next = 5;
            return webcrypto.get().subtle.sign({ name: "RSASSA-PKCS1-v1_5" }, privateKey, Uint8Array.from(msg));
          case 5:
            sig = _context65.sent;
            return _context65.abrupt("return", new Uint8Array(sig, sig.byteOffset, sig.byteLength));
          case 7:
          case "end":
            return _context65.stop();
        }
    }, _callee64);
  }));
  return function(_x97, _x98) {
    return _ref68.apply(this, arguments);
  };
}();
rsaBrowser.hashAndVerify = function() {
  var _ref69 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee65(key3, sig, msg) {
    var publicKey;
    return _regeneratorRuntime().wrap(function _callee65$(_context66) {
      while (1)
        switch (_context66.prev = _context66.next) {
          case 0:
            _context66.next = 2;
            return webcrypto.get().subtle.importKey("jwk", key3, { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-256" } }, false, ["verify"]);
          case 2:
            publicKey = _context66.sent;
            return _context66.abrupt("return", webcrypto.get().subtle.verify({ name: "RSASSA-PKCS1-v1_5" }, publicKey, sig, msg));
          case 4:
          case "end":
            return _context66.stop();
        }
    }, _callee65);
  }));
  return function(_x99, _x100, _x101) {
    return _ref69.apply(this, arguments);
  };
}();
function exportKey(pair) {
  return Promise.all([webcrypto.get().subtle.exportKey("jwk", pair.privateKey), webcrypto.get().subtle.exportKey("jwk", pair.publicKey)]);
}
function derivePublicFromPrivate(jwKey) {
  return webcrypto.get().subtle.importKey("jwk", { kty: jwKey.kty, n: jwKey.n, e: jwKey.e }, { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-256" } }, true, ["verify"]);
}
var _requireJwk2pem = requireJwk2pem();
var jwk2pub = _requireJwk2pem.jwk2pub;
var jwk2priv = _requireJwk2pem.jwk2priv;
function convertKey(key3, pub, msg, handle) {
  var fkey = pub ? jwk2pub(key3) : jwk2priv(key3);
  var fmsg = uint8ArrayToString$2(Uint8Array.from(msg), "ascii");
  var fomsg = handle(fmsg, fkey);
  return uint8ArrayFromString$1(fomsg, "ascii");
}
rsaBrowser.encrypt = function(key3, msg) {
  return convertKey(key3, true, msg, function(msg2, key4) {
    return key4.encrypt(msg2);
  });
};
rsaBrowser.decrypt = function(key3, msg) {
  return convertKey(key3, false, msg, function(msg2, key4) {
    return key4.decrypt(msg2);
  });
};
var base64 = require$$0$2.base64;
var ciphers = aesGcm_browser;
var exporter$3 = {
  /**
  * Exports the given PrivateKey as a base64 encoded string.
  * The PrivateKey is encrypted via a password derived PBKDF2 key
  * leveraging the aes-gcm cipher algorithm.
  *
  * @param {Uint8Array} privateKey - The PrivateKey protobuf
  * @param {string} password
  * @returns {Promise<string>} A base64 encoded string
  */
  export: function() {
    var _export2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee66(privateKey, password) {
      var cipher, encryptedKey;
      return _regeneratorRuntime().wrap(function _callee66$(_context67) {
        while (1)
          switch (_context67.prev = _context67.next) {
            case 0:
              cipher = ciphers.create();
              _context67.next = 3;
              return cipher.encrypt(privateKey, password);
            case 3:
              encryptedKey = _context67.sent;
              return _context67.abrupt("return", base64.encode(encryptedKey));
            case 5:
            case "end":
              return _context67.stop();
          }
      }, _callee66);
    }));
    function _export(_x102, _x103) {
      return _export2.apply(this, arguments);
    }
    return _export;
  }()
};
var sha256$2 = require$$0$1.sha256;
var errcode$4 = errCode;
var uint8ArrayEquals$2 = require$$6.equals;
var uint8ArrayToString$1 = require$$4$1.toString;
var forge$2 = forge$t;
var crypto$2 = rsaBrowser;
var pbm$1 = keys$2;
var exporter$2 = exporter$3;
var RsaPublicKey = function() {
  function RsaPublicKey2(key3) {
    _classCallCheck2(this, RsaPublicKey2);
    this._key = key3;
  }
  return _createClass(RsaPublicKey2, [{ key: "verify", value: function() {
    var _verify = _asyncToGenerator(_regeneratorRuntime().mark(function _callee67(data, sig) {
      return _regeneratorRuntime().wrap(function _callee67$(_context68) {
        while (1)
          switch (_context68.prev = _context68.next) {
            case 0:
              return _context68.abrupt("return", crypto$2.hashAndVerify(this._key, sig, data));
            case 1:
            case "end":
              return _context68.stop();
          }
      }, _callee67, this);
    }));
    function verify(_x104, _x105) {
      return _verify.apply(this, arguments);
    }
    return verify;
  }() }, { key: "marshal", value: function marshal() {
    return crypto$2.utils.jwkToPkix(this._key);
  } }, { key: "bytes", get: function get5() {
    return pbm$1.PublicKey.encode({ Type: pbm$1.KeyType.RSA, Data: this.marshal() }).finish();
  } }, { key: "encrypt", value: function encrypt(bytes) {
    return crypto$2.encrypt(this._key, bytes);
  } }, { key: "equals", value: function equals2(key3) {
    return uint8ArrayEquals$2(this.bytes, key3.bytes);
  } }, { key: "hash", value: function() {
    var _hash = _asyncToGenerator(_regeneratorRuntime().mark(function _callee68() {
      var _yield$sha256$2$diges, bytes;
      return _regeneratorRuntime().wrap(function _callee68$(_context69) {
        while (1)
          switch (_context69.prev = _context69.next) {
            case 0:
              _context69.next = 2;
              return sha256$2.digest(this.bytes);
            case 2:
              _yield$sha256$2$diges = _context69.sent;
              bytes = _yield$sha256$2$diges.bytes;
              return _context69.abrupt("return", bytes);
            case 5:
            case "end":
              return _context69.stop();
          }
      }, _callee68, this);
    }));
    function hash2() {
      return _hash.apply(this, arguments);
    }
    return hash2;
  }() }]);
}();
var RsaPrivateKey = function() {
  function RsaPrivateKey2(key3, publicKey) {
    _classCallCheck2(this, RsaPrivateKey2);
    this._key = key3;
    this._publicKey = publicKey;
  }
  return _createClass(RsaPrivateKey2, [{ key: "genSecret", value: function genSecret() {
    return crypto$2.getRandomValues(16);
  } }, { key: "sign", value: function() {
    var _sign = _asyncToGenerator(_regeneratorRuntime().mark(function _callee69(message) {
      return _regeneratorRuntime().wrap(function _callee69$(_context70) {
        while (1)
          switch (_context70.prev = _context70.next) {
            case 0:
              return _context70.abrupt("return", crypto$2.hashAndSign(this._key, message));
            case 1:
            case "end":
              return _context70.stop();
          }
      }, _callee69, this);
    }));
    function sign(_x106) {
      return _sign.apply(this, arguments);
    }
    return sign;
  }() }, { key: "public", get: function get5() {
    if (!this._publicKey) {
      throw errcode$4(new Error("public key not provided"), "ERR_PUBKEY_NOT_PROVIDED");
    }
    return new RsaPublicKey(this._publicKey);
  } }, { key: "decrypt", value: function decrypt(bytes) {
    return crypto$2.decrypt(this._key, bytes);
  } }, { key: "marshal", value: function marshal() {
    return crypto$2.utils.jwkToPkcs1(this._key);
  } }, { key: "bytes", get: function get5() {
    return pbm$1.PrivateKey.encode({ Type: pbm$1.KeyType.RSA, Data: this.marshal() }).finish();
  } }, { key: "equals", value: function equals2(key3) {
    return uint8ArrayEquals$2(this.bytes, key3.bytes);
  } }, {
    key: "hash",
    value: function() {
      var _hash2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee70() {
        var _yield$sha256$2$diges2, bytes;
        return _regeneratorRuntime().wrap(function _callee70$(_context71) {
          while (1)
            switch (_context71.prev = _context71.next) {
              case 0:
                _context71.next = 2;
                return sha256$2.digest(this.bytes);
              case 2:
                _yield$sha256$2$diges2 = _context71.sent;
                bytes = _yield$sha256$2$diges2.bytes;
                return _context71.abrupt("return", bytes);
              case 5:
              case "end":
                return _context71.stop();
            }
        }, _callee70, this);
      }));
      function hash2() {
        return _hash2.apply(this, arguments);
      }
      return hash2;
    }()
    /**
    * Gets the ID of the key.
    *
    * The key id is the base58 encoding of the SHA-256 multihash of its public key.
    * The public key is a protobuf encoding containing a type and the DER encoding
    * of the PKCS SubjectPublicKeyInfo.
    *
    * @returns {Promise<string>}
    */
  }, { key: "id", value: function() {
    var _id = _asyncToGenerator(_regeneratorRuntime().mark(function _callee71() {
      var hash2;
      return _regeneratorRuntime().wrap(function _callee71$(_context72) {
        while (1)
          switch (_context72.prev = _context72.next) {
            case 0:
              _context72.next = 2;
              return this.public.hash();
            case 2:
              hash2 = _context72.sent;
              return _context72.abrupt("return", uint8ArrayToString$1(hash2, "base58btc"));
            case 4:
            case "end":
              return _context72.stop();
          }
      }, _callee71, this);
    }));
    function id() {
      return _id.apply(this, arguments);
    }
    return id;
  }() }, { key: "export", value: function() {
    var _export3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee72(password) {
      var format, _buffer, _asn, privateKey, options, _args8 = arguments;
      return _regeneratorRuntime().wrap(function _callee72$(_context73) {
        while (1)
          switch (_context73.prev = _context73.next) {
            case 0:
              format = _args8.length > 1 && _args8[1] !== void 0 ? _args8[1] : "pkcs-8";
              if (!(format === "pkcs-8")) {
                _context73.next = 9;
                break;
              }
              _buffer = new forge$2.util.ByteBuffer(this.marshal());
              _asn = forge$2.asn1.fromDer(_buffer);
              privateKey = forge$2.pki.privateKeyFromAsn1(_asn);
              options = { algorithm: "aes256", count: 1e4, saltSize: 128 / 8, prfAlgorithm: "sha512" };
              return _context73.abrupt("return", forge$2.pki.encryptRsaPrivateKey(privateKey, password, options));
            case 9:
              if (!(format === "libp2p-key")) {
                _context73.next = 13;
                break;
              }
              return _context73.abrupt("return", exporter$2.export(this.bytes, password));
            case 13:
              throw errcode$4(new Error("export format '".concat(format, "' is not supported")), "ERR_INVALID_EXPORT_FORMAT");
            case 14:
            case "end":
              return _context73.stop();
          }
      }, _callee72, this);
    }));
    function _export(_x107) {
      return _export3.apply(this, arguments);
    }
    return _export;
  }() }]);
}();
function unmarshalRsaPrivateKey(_x108) {
  return _unmarshalRsaPrivateKey.apply(this, arguments);
}
function _unmarshalRsaPrivateKey() {
  _unmarshalRsaPrivateKey = _asyncToGenerator(_regeneratorRuntime().mark(function _callee218(bytes) {
    var jwk, keys2;
    return _regeneratorRuntime().wrap(function _callee218$(_context220) {
      while (1)
        switch (_context220.prev = _context220.next) {
          case 0:
            jwk = crypto$2.utils.pkcs1ToJwk(bytes);
            _context220.next = 3;
            return crypto$2.unmarshalPrivateKey(jwk);
          case 3:
            keys2 = _context220.sent;
            return _context220.abrupt("return", new RsaPrivateKey(keys2.privateKey, keys2.publicKey));
          case 5:
          case "end":
            return _context220.stop();
        }
    }, _callee218);
  }));
  return _unmarshalRsaPrivateKey.apply(this, arguments);
}
function unmarshalRsaPublicKey(bytes) {
  var jwk = crypto$2.utils.pkixToJwk(bytes);
  return new RsaPublicKey(jwk);
}
function fromJwk(_x109) {
  return _fromJwk.apply(this, arguments);
}
function _fromJwk() {
  _fromJwk = _asyncToGenerator(_regeneratorRuntime().mark(function _callee219(jwk) {
    var keys2;
    return _regeneratorRuntime().wrap(function _callee219$(_context221) {
      while (1)
        switch (_context221.prev = _context221.next) {
          case 0:
            _context221.next = 2;
            return crypto$2.unmarshalPrivateKey(jwk);
          case 2:
            keys2 = _context221.sent;
            return _context221.abrupt("return", new RsaPrivateKey(keys2.privateKey, keys2.publicKey));
          case 4:
          case "end":
            return _context221.stop();
        }
    }, _callee219);
  }));
  return _fromJwk.apply(this, arguments);
}
function generateKeyPair$2(_x110) {
  return _generateKeyPair$.apply(this, arguments);
}
function _generateKeyPair$() {
  _generateKeyPair$ = _asyncToGenerator(_regeneratorRuntime().mark(function _callee220(bits) {
    var keys2;
    return _regeneratorRuntime().wrap(function _callee220$(_context222) {
      while (1)
        switch (_context222.prev = _context222.next) {
          case 0:
            _context222.next = 2;
            return crypto$2.generateKey(bits);
          case 2:
            keys2 = _context222.sent;
            return _context222.abrupt("return", new RsaPrivateKey(keys2.privateKey, keys2.publicKey));
          case 4:
          case "end":
            return _context222.stop();
        }
    }, _callee220);
  }));
  return _generateKeyPair$.apply(this, arguments);
}
var rsaClass = { RsaPublicKey, RsaPrivateKey, unmarshalRsaPublicKey, unmarshalRsaPrivateKey, generateKeyPair: generateKeyPair$2, fromJwk };
var require$$3 = getAugmentedNamespace(base58);
var require$$4 = getAugmentedNamespace(identity$2);
var ed25519 = {};
var forge$1 = forge$t;
ed25519.publicKeyLength = forge$1.pki.ed25519.constants.PUBLIC_KEY_BYTE_LENGTH;
ed25519.privateKeyLength = forge$1.pki.ed25519.constants.PRIVATE_KEY_BYTE_LENGTH;
ed25519.generateKey = _asyncToGenerator(_regeneratorRuntime().mark(function _callee73() {
  return _regeneratorRuntime().wrap(function _callee73$(_context74) {
    while (1)
      switch (_context74.prev = _context74.next) {
        case 0:
          return _context74.abrupt("return", forge$1.pki.ed25519.generateKeyPair());
        case 1:
        case "end":
          return _context74.stop();
      }
  }, _callee73);
}));
ed25519.generateKeyFromSeed = function() {
  var _ref71 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee74(seed) {
    return _regeneratorRuntime().wrap(function _callee74$(_context75) {
      while (1)
        switch (_context75.prev = _context75.next) {
          case 0:
            return _context75.abrupt("return", forge$1.pki.ed25519.generateKeyPair({ seed }));
          case 1:
          case "end":
            return _context75.stop();
        }
    }, _callee74);
  }));
  return function(_x111) {
    return _ref71.apply(this, arguments);
  };
}();
ed25519.hashAndSign = function() {
  var _ref72 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee75(key3, msg) {
    return _regeneratorRuntime().wrap(function _callee75$(_context76) {
      while (1)
        switch (_context76.prev = _context76.next) {
          case 0:
            return _context76.abrupt("return", forge$1.pki.ed25519.sign({ message: msg, privateKey: key3 }));
          case 1:
          case "end":
            return _context76.stop();
        }
    }, _callee75);
  }));
  return function(_x112, _x113) {
    return _ref72.apply(this, arguments);
  };
}();
ed25519.hashAndVerify = function() {
  var _ref73 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee76(key3, sig, msg) {
    return _regeneratorRuntime().wrap(function _callee76$(_context77) {
      while (1)
        switch (_context77.prev = _context77.next) {
          case 0:
            return _context77.abrupt("return", forge$1.pki.ed25519.verify({ signature: sig, message: msg, publicKey: key3 }));
          case 1:
          case "end":
            return _context77.stop();
        }
    }, _callee76);
  }));
  return function(_x114, _x115, _x116) {
    return _ref73.apply(this, arguments);
  };
}();
var errcode$3 = errCode;
var uint8ArrayEquals$1 = require$$6.equals;
var sha256$1 = require$$0$1.sha256;
var base58btc = require$$3.base58btc;
var identity = require$$4.identity;
var crypto$1 = ed25519;
var pbm = keys$2;
var exporter$1 = exporter$3;
var Ed25519PublicKey = function() {
  function Ed25519PublicKey2(key3) {
    _classCallCheck2(this, Ed25519PublicKey2);
    this._key = ensureKey(key3, crypto$1.publicKeyLength);
  }
  return _createClass(Ed25519PublicKey2, [{ key: "verify", value: function() {
    var _verify3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee77(data, sig) {
      return _regeneratorRuntime().wrap(function _callee77$(_context78) {
        while (1)
          switch (_context78.prev = _context78.next) {
            case 0:
              return _context78.abrupt("return", crypto$1.hashAndVerify(this._key, sig, data));
            case 1:
            case "end":
              return _context78.stop();
          }
      }, _callee77, this);
    }));
    function verify(_x117, _x118) {
      return _verify3.apply(this, arguments);
    }
    return verify;
  }() }, { key: "marshal", value: function marshal() {
    return this._key;
  } }, { key: "bytes", get: function get5() {
    return pbm.PublicKey.encode({ Type: pbm.KeyType.Ed25519, Data: this.marshal() }).finish();
  } }, { key: "equals", value: function equals2(key3) {
    return uint8ArrayEquals$1(this.bytes, key3.bytes);
  } }, { key: "hash", value: function() {
    var _hash3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee78() {
      var _yield$sha256$1$diges, bytes;
      return _regeneratorRuntime().wrap(function _callee78$(_context79) {
        while (1)
          switch (_context79.prev = _context79.next) {
            case 0:
              _context79.next = 2;
              return sha256$1.digest(this.bytes);
            case 2:
              _yield$sha256$1$diges = _context79.sent;
              bytes = _yield$sha256$1$diges.bytes;
              return _context79.abrupt("return", bytes);
            case 5:
            case "end":
              return _context79.stop();
          }
      }, _callee78, this);
    }));
    function hash2() {
      return _hash3.apply(this, arguments);
    }
    return hash2;
  }() }]);
}();
var Ed25519PrivateKey = function() {
  function Ed25519PrivateKey2(key3, publicKey) {
    _classCallCheck2(this, Ed25519PrivateKey2);
    this._key = ensureKey(key3, crypto$1.privateKeyLength);
    this._publicKey = ensureKey(publicKey, crypto$1.publicKeyLength);
  }
  return _createClass(Ed25519PrivateKey2, [{ key: "sign", value: function() {
    var _sign2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee79(message) {
      return _regeneratorRuntime().wrap(function _callee79$(_context80) {
        while (1)
          switch (_context80.prev = _context80.next) {
            case 0:
              return _context80.abrupt("return", crypto$1.hashAndSign(this._key, message));
            case 1:
            case "end":
              return _context80.stop();
          }
      }, _callee79, this);
    }));
    function sign(_x119) {
      return _sign2.apply(this, arguments);
    }
    return sign;
  }() }, { key: "public", get: function get5() {
    return new Ed25519PublicKey(this._publicKey);
  } }, { key: "marshal", value: function marshal() {
    return this._key;
  } }, { key: "bytes", get: function get5() {
    return pbm.PrivateKey.encode({ Type: pbm.KeyType.Ed25519, Data: this.marshal() }).finish();
  } }, { key: "equals", value: function equals2(key3) {
    return uint8ArrayEquals$1(this.bytes, key3.bytes);
  } }, {
    key: "hash",
    value: function() {
      var _hash4 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee80() {
        var _yield$sha256$1$diges2, bytes;
        return _regeneratorRuntime().wrap(function _callee80$(_context81) {
          while (1)
            switch (_context81.prev = _context81.next) {
              case 0:
                _context81.next = 2;
                return sha256$1.digest(this.bytes);
              case 2:
                _yield$sha256$1$diges2 = _context81.sent;
                bytes = _yield$sha256$1$diges2.bytes;
                return _context81.abrupt("return", bytes);
              case 5:
              case "end":
                return _context81.stop();
            }
        }, _callee80, this);
      }));
      function hash2() {
        return _hash4.apply(this, arguments);
      }
      return hash2;
    }()
    /**
    * Gets the ID of the key.
    *
    * The key id is the base58 encoding of the identity multihash containing its public key.
    * The public key is a protobuf encoding containing a type and the DER encoding
    * of the PKCS SubjectPublicKeyInfo.
    *
    * @returns {Promise<string>}
    */
  }, { key: "id", value: function() {
    var _id2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee81() {
      var encoding;
      return _regeneratorRuntime().wrap(function _callee81$(_context82) {
        while (1)
          switch (_context82.prev = _context82.next) {
            case 0:
              _context82.next = 2;
              return identity.digest(this.public.bytes);
            case 2:
              encoding = _context82.sent;
              return _context82.abrupt("return", base58btc.encode(encoding.bytes).substring(1));
            case 4:
            case "end":
              return _context82.stop();
          }
      }, _callee81, this);
    }));
    function id() {
      return _id2.apply(this, arguments);
    }
    return id;
  }() }, { key: "export", value: function() {
    var _export4 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee82(password) {
      var format, _args9 = arguments;
      return _regeneratorRuntime().wrap(function _callee82$(_context83) {
        while (1)
          switch (_context83.prev = _context83.next) {
            case 0:
              format = _args9.length > 1 && _args9[1] !== void 0 ? _args9[1] : "libp2p-key";
              if (!(format === "libp2p-key")) {
                _context83.next = 5;
                break;
              }
              return _context83.abrupt("return", exporter$1.export(this.bytes, password));
            case 5:
              throw errcode$3(new Error("export format '".concat(format, "' is not supported")), "ERR_INVALID_EXPORT_FORMAT");
            case 6:
            case "end":
              return _context83.stop();
          }
      }, _callee82, this);
    }));
    function _export(_x120) {
      return _export4.apply(this, arguments);
    }
    return _export;
  }() }]);
}();
function unmarshalEd25519PrivateKey(bytes) {
  if (bytes.length > crypto$1.privateKeyLength) {
    bytes = ensureKey(bytes, crypto$1.privateKeyLength + crypto$1.publicKeyLength);
    var _privateKeyBytes = bytes.slice(0, crypto$1.privateKeyLength);
    var _publicKeyBytes = bytes.slice(crypto$1.privateKeyLength, bytes.length);
    return new Ed25519PrivateKey(_privateKeyBytes, _publicKeyBytes);
  }
  bytes = ensureKey(bytes, crypto$1.privateKeyLength);
  var privateKeyBytes = bytes.slice(0, crypto$1.privateKeyLength);
  var publicKeyBytes = bytes.slice(crypto$1.publicKeyLength);
  return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);
}
function unmarshalEd25519PublicKey(bytes) {
  bytes = ensureKey(bytes, crypto$1.publicKeyLength);
  return new Ed25519PublicKey(bytes);
}
function generateKeyPair$1() {
  return _generateKeyPair$2.apply(this, arguments);
}
function _generateKeyPair$2() {
  _generateKeyPair$2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee221() {
    var _yield$crypto$1$gener, privateKey, publicKey;
    return _regeneratorRuntime().wrap(function _callee221$(_context223) {
      while (1)
        switch (_context223.prev = _context223.next) {
          case 0:
            _context223.next = 2;
            return crypto$1.generateKey();
          case 2:
            _yield$crypto$1$gener = _context223.sent;
            privateKey = _yield$crypto$1$gener.privateKey;
            publicKey = _yield$crypto$1$gener.publicKey;
            return _context223.abrupt("return", new Ed25519PrivateKey(privateKey, publicKey));
          case 6:
          case "end":
            return _context223.stop();
        }
    }, _callee221);
  }));
  return _generateKeyPair$2.apply(this, arguments);
}
function generateKeyPairFromSeed$1(_x121) {
  return _generateKeyPairFromSeed$.apply(this, arguments);
}
function _generateKeyPairFromSeed$() {
  _generateKeyPairFromSeed$ = _asyncToGenerator(_regeneratorRuntime().mark(function _callee222(seed) {
    var _yield$crypto$1$gener2, privateKey, publicKey;
    return _regeneratorRuntime().wrap(function _callee222$(_context224) {
      while (1)
        switch (_context224.prev = _context224.next) {
          case 0:
            _context224.next = 2;
            return crypto$1.generateKeyFromSeed(seed);
          case 2:
            _yield$crypto$1$gener2 = _context224.sent;
            privateKey = _yield$crypto$1$gener2.privateKey;
            publicKey = _yield$crypto$1$gener2.publicKey;
            return _context224.abrupt("return", new Ed25519PrivateKey(privateKey, publicKey));
          case 6:
          case "end":
            return _context224.stop();
        }
    }, _callee222);
  }));
  return _generateKeyPairFromSeed$.apply(this, arguments);
}
function ensureKey(key3, length3) {
  key3 = Uint8Array.from(key3 || []);
  if (key3.length !== length3) {
    throw errcode$3(new Error("Key must be a Uint8Array of length ".concat(length3, ", got ").concat(key3.length)), "ERR_INVALID_KEY_TYPE");
  }
  return key3;
}
var ed25519Class = { Ed25519PublicKey, Ed25519PrivateKey, unmarshalEd25519PrivateKey, unmarshalEd25519PublicKey, generateKeyPair: generateKeyPair$1, generateKeyPairFromSeed: generateKeyPairFromSeed$1 };
var lib;
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib)
    return lib;
  hasRequiredLib = 1;
  var errors = { IMPOSSIBLE_CASE: "Impossible case. Please create issue.", TWEAK_ADD: "The tweak was out of range or the resulted private key is invalid", TWEAK_MUL: "The tweak was out of range or equal to zero", CONTEXT_RANDOMIZE_UNKNOW: "Unknow error on context randomization", SECKEY_INVALID: "Private Key is invalid", PUBKEY_PARSE: "Public Key could not be parsed", PUBKEY_SERIALIZE: "Public Key serialization error", PUBKEY_COMBINE: "The sum of the public keys is not valid", SIG_PARSE: "Signature could not be parsed", SIGN: "The nonce generation function failed, or the private key was invalid", RECOVER: "Public key could not be recover", ECDH: "Scalar was invalid (zero or overflow)" };
  function assert2(cond, msg) {
    if (!cond)
      throw new Error(msg);
  }
  function isUint8Array(name2, value, length3) {
    assert2(value instanceof Uint8Array, "Expected ".concat(name2, " to be an Uint8Array"));
    if (length3 !== void 0) {
      if (Array.isArray(length3)) {
        var numbers = length3.join(", ");
        var msg = "Expected ".concat(name2, " to be an Uint8Array with length [").concat(numbers, "]");
        assert2(length3.includes(value.length), msg);
      } else {
        var _msg = "Expected ".concat(name2, " to be an Uint8Array with length ").concat(length3);
        assert2(value.length === length3, _msg);
      }
    }
  }
  function isCompressed(value) {
    assert2(toTypeString(value) === "Boolean", "Expected compressed to be a Boolean");
  }
  function getAssertedOutput() {
    var output = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function(len2) {
      return new Uint8Array(len2);
    };
    var length3 = arguments.length > 1 ? arguments[1] : void 0;
    if (typeof output === "function")
      output = output(length3);
    isUint8Array("output", output, length3);
    return output;
  }
  function toTypeString(value) {
    return Object.prototype.toString.call(value).slice(8, -1);
  }
  lib = function lib2(secp256k12) {
    return { contextRandomize: function contextRandomize(seed) {
      assert2(seed === null || seed instanceof Uint8Array, "Expected seed to be an Uint8Array or null");
      if (seed !== null)
        isUint8Array("seed", seed, 32);
      switch (secp256k12.contextRandomize(seed)) {
        case 1:
          throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW);
      }
    }, privateKeyVerify: function privateKeyVerify(seckey) {
      isUint8Array("private key", seckey, 32);
      return secp256k12.privateKeyVerify(seckey) === 0;
    }, privateKeyNegate: function privateKeyNegate(seckey) {
      isUint8Array("private key", seckey, 32);
      switch (secp256k12.privateKeyNegate(seckey)) {
        case 0:
          return seckey;
        case 1:
          throw new Error(errors.IMPOSSIBLE_CASE);
      }
    }, privateKeyTweakAdd: function privateKeyTweakAdd(seckey, tweak) {
      isUint8Array("private key", seckey, 32);
      isUint8Array("tweak", tweak, 32);
      switch (secp256k12.privateKeyTweakAdd(seckey, tweak)) {
        case 0:
          return seckey;
        case 1:
          throw new Error(errors.TWEAK_ADD);
      }
    }, privateKeyTweakMul: function privateKeyTweakMul(seckey, tweak) {
      isUint8Array("private key", seckey, 32);
      isUint8Array("tweak", tweak, 32);
      switch (secp256k12.privateKeyTweakMul(seckey, tweak)) {
        case 0:
          return seckey;
        case 1:
          throw new Error(errors.TWEAK_MUL);
      }
    }, publicKeyVerify: function publicKeyVerify(pubkey) {
      isUint8Array("public key", pubkey, [33, 65]);
      return secp256k12.publicKeyVerify(pubkey) === 0;
    }, publicKeyCreate: function publicKeyCreate(seckey) {
      var compressed = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var output = arguments.length > 2 ? arguments[2] : void 0;
      isUint8Array("private key", seckey, 32);
      isCompressed(compressed);
      output = getAssertedOutput(output, compressed ? 33 : 65);
      switch (secp256k12.publicKeyCreate(output, seckey)) {
        case 0:
          return output;
        case 1:
          throw new Error(errors.SECKEY_INVALID);
        case 2:
          throw new Error(errors.PUBKEY_SERIALIZE);
      }
    }, publicKeyConvert: function publicKeyConvert(pubkey) {
      var compressed = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var output = arguments.length > 2 ? arguments[2] : void 0;
      isUint8Array("public key", pubkey, [33, 65]);
      isCompressed(compressed);
      output = getAssertedOutput(output, compressed ? 33 : 65);
      switch (secp256k12.publicKeyConvert(output, pubkey)) {
        case 0:
          return output;
        case 1:
          throw new Error(errors.PUBKEY_PARSE);
        case 2:
          throw new Error(errors.PUBKEY_SERIALIZE);
      }
    }, publicKeyNegate: function publicKeyNegate(pubkey) {
      var compressed = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var output = arguments.length > 2 ? arguments[2] : void 0;
      isUint8Array("public key", pubkey, [33, 65]);
      isCompressed(compressed);
      output = getAssertedOutput(output, compressed ? 33 : 65);
      switch (secp256k12.publicKeyNegate(output, pubkey)) {
        case 0:
          return output;
        case 1:
          throw new Error(errors.PUBKEY_PARSE);
        case 2:
          throw new Error(errors.IMPOSSIBLE_CASE);
        case 3:
          throw new Error(errors.PUBKEY_SERIALIZE);
      }
    }, publicKeyCombine: function publicKeyCombine(pubkeys) {
      var compressed = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var output = arguments.length > 2 ? arguments[2] : void 0;
      assert2(Array.isArray(pubkeys), "Expected public keys to be an Array");
      assert2(pubkeys.length > 0, "Expected public keys array will have more than zero items");
      var _iterator9 = _createForOfIteratorHelper(pubkeys), _step9;
      try {
        for (_iterator9.s(); !(_step9 = _iterator9.n()).done; ) {
          var pubkey = _step9.value;
          isUint8Array("public key", pubkey, [33, 65]);
        }
      } catch (err) {
        _iterator9.e(err);
      } finally {
        _iterator9.f();
      }
      isCompressed(compressed);
      output = getAssertedOutput(output, compressed ? 33 : 65);
      switch (secp256k12.publicKeyCombine(output, pubkeys)) {
        case 0:
          return output;
        case 1:
          throw new Error(errors.PUBKEY_PARSE);
        case 2:
          throw new Error(errors.PUBKEY_COMBINE);
        case 3:
          throw new Error(errors.PUBKEY_SERIALIZE);
      }
    }, publicKeyTweakAdd: function publicKeyTweakAdd(pubkey, tweak) {
      var compressed = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var output = arguments.length > 3 ? arguments[3] : void 0;
      isUint8Array("public key", pubkey, [33, 65]);
      isUint8Array("tweak", tweak, 32);
      isCompressed(compressed);
      output = getAssertedOutput(output, compressed ? 33 : 65);
      switch (secp256k12.publicKeyTweakAdd(output, pubkey, tweak)) {
        case 0:
          return output;
        case 1:
          throw new Error(errors.PUBKEY_PARSE);
        case 2:
          throw new Error(errors.TWEAK_ADD);
      }
    }, publicKeyTweakMul: function publicKeyTweakMul(pubkey, tweak) {
      var compressed = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var output = arguments.length > 3 ? arguments[3] : void 0;
      isUint8Array("public key", pubkey, [33, 65]);
      isUint8Array("tweak", tweak, 32);
      isCompressed(compressed);
      output = getAssertedOutput(output, compressed ? 33 : 65);
      switch (secp256k12.publicKeyTweakMul(output, pubkey, tweak)) {
        case 0:
          return output;
        case 1:
          throw new Error(errors.PUBKEY_PARSE);
        case 2:
          throw new Error(errors.TWEAK_MUL);
      }
    }, signatureNormalize: function signatureNormalize(sig) {
      isUint8Array("signature", sig, 64);
      switch (secp256k12.signatureNormalize(sig)) {
        case 0:
          return sig;
        case 1:
          throw new Error(errors.SIG_PARSE);
      }
    }, signatureExport: function signatureExport(sig, output) {
      isUint8Array("signature", sig, 64);
      output = getAssertedOutput(output, 72);
      var obj2 = { output, outputlen: 72 };
      switch (secp256k12.signatureExport(obj2, sig)) {
        case 0:
          return output.slice(0, obj2.outputlen);
        case 1:
          throw new Error(errors.SIG_PARSE);
        case 2:
          throw new Error(errors.IMPOSSIBLE_CASE);
      }
    }, signatureImport: function signatureImport(sig, output) {
      isUint8Array("signature", sig);
      output = getAssertedOutput(output, 64);
      switch (secp256k12.signatureImport(output, sig)) {
        case 0:
          return output;
        case 1:
          throw new Error(errors.SIG_PARSE);
        case 2:
          throw new Error(errors.IMPOSSIBLE_CASE);
      }
    }, ecdsaSign: function ecdsaSign(msg32, seckey) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var output = arguments.length > 3 ? arguments[3] : void 0;
      isUint8Array("message", msg32, 32);
      isUint8Array("private key", seckey, 32);
      assert2(toTypeString(options) === "Object", "Expected options to be an Object");
      if (options.data !== void 0)
        isUint8Array("options.data", options.data);
      if (options.noncefn !== void 0)
        assert2(toTypeString(options.noncefn) === "Function", "Expected options.noncefn to be a Function");
      output = getAssertedOutput(output, 64);
      var obj2 = { signature: output, recid: null };
      switch (secp256k12.ecdsaSign(obj2, msg32, seckey, options.data, options.noncefn)) {
        case 0:
          return obj2;
        case 1:
          throw new Error(errors.SIGN);
        case 2:
          throw new Error(errors.IMPOSSIBLE_CASE);
      }
    }, ecdsaVerify: function ecdsaVerify(sig, msg32, pubkey) {
      isUint8Array("signature", sig, 64);
      isUint8Array("message", msg32, 32);
      isUint8Array("public key", pubkey, [33, 65]);
      switch (secp256k12.ecdsaVerify(sig, msg32, pubkey)) {
        case 0:
          return true;
        case 3:
          return false;
        case 1:
          throw new Error(errors.SIG_PARSE);
        case 2:
          throw new Error(errors.PUBKEY_PARSE);
      }
    }, ecdsaRecover: function ecdsaRecover(sig, recid, msg32) {
      var compressed = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
      var output = arguments.length > 4 ? arguments[4] : void 0;
      isUint8Array("signature", sig, 64);
      assert2(toTypeString(recid) === "Number" && recid >= 0 && recid <= 3, "Expected recovery id to be a Number within interval [0, 3]");
      isUint8Array("message", msg32, 32);
      isCompressed(compressed);
      output = getAssertedOutput(output, compressed ? 33 : 65);
      switch (secp256k12.ecdsaRecover(output, sig, recid, msg32)) {
        case 0:
          return output;
        case 1:
          throw new Error(errors.SIG_PARSE);
        case 2:
          throw new Error(errors.RECOVER);
        case 3:
          throw new Error(errors.IMPOSSIBLE_CASE);
      }
    }, ecdh: function ecdh(pubkey, seckey) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var output = arguments.length > 3 ? arguments[3] : void 0;
      isUint8Array("public key", pubkey, [33, 65]);
      isUint8Array("private key", seckey, 32);
      assert2(toTypeString(options) === "Object", "Expected options to be an Object");
      if (options.data !== void 0)
        isUint8Array("options.data", options.data);
      if (options.hashfn !== void 0) {
        assert2(toTypeString(options.hashfn) === "Function", "Expected options.hashfn to be a Function");
        if (options.xbuf !== void 0)
          isUint8Array("options.xbuf", options.xbuf, 32);
        if (options.ybuf !== void 0)
          isUint8Array("options.ybuf", options.ybuf, 32);
        isUint8Array("output", output);
      } else {
        output = getAssertedOutput(output, 32);
      }
      switch (secp256k12.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {
        case 0:
          return output;
        case 1:
          throw new Error(errors.PUBKEY_PARSE);
        case 2:
          throw new Error(errors.ECDH);
      }
    } };
  };
  return lib;
}
var elliptic$2 = {};
var name = "elliptic";
var version = "6.6.1";
var description = "EC cryptography";
var main = "lib/elliptic.js";
var files = ["lib"];
var scripts = { lint: "eslint lib test", "lint:fix": "npm run lint -- --fix", unit: "istanbul test _mocha --reporter=spec test/index.js", test: "npm run lint && npm run unit", version: "grunt dist && git add dist/" };
var repository = { type: "git", url: "git@github.com:indutny/elliptic" };
var keywords = ["EC", "Elliptic", "curve", "Cryptography"];
var author = "Fedor Indutny <fedor@indutny.com>";
var license = "MIT";
var bugs = { url: "https://github.com/indutny/elliptic/issues" };
var homepage = "https://github.com/indutny/elliptic";
var devDependencies = { brfs: "^2.0.2", coveralls: "^3.1.0", eslint: "^7.6.0", grunt: "^1.2.1", "grunt-browserify": "^5.3.0", "grunt-cli": "^1.3.2", "grunt-contrib-connect": "^3.0.0", "grunt-contrib-copy": "^1.0.0", "grunt-contrib-uglify": "^5.0.0", "grunt-mocha-istanbul": "^5.0.2", "grunt-saucelabs": "^9.0.1", istanbul: "^0.4.5", mocha: "^8.0.1" };
var dependencies = { "bn.js": "^4.11.9", brorand: "^1.1.0", "hash.js": "^1.0.0", "hmac-drbg": "^1.0.1", inherits: "^2.0.4", "minimalistic-assert": "^1.0.1", "minimalistic-crypto-utils": "^1.0.1" };
var require$$0 = { name, version, description, main, files, scripts, repository, keywords, author, license, bugs, homepage, devDependencies, dependencies };
var utils$1 = {};
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils)
    return utils$1;
  hasRequiredUtils = 1;
  (function(exports) {
    var utils2 = exports;
    var BN = bnExports;
    var minAssert = minimalisticAssert;
    var minUtils = utils$3;
    utils2.assert = minAssert;
    utils2.toArray = minUtils.toArray;
    utils2.zero2 = minUtils.zero2;
    utils2.toHex = minUtils.toHex;
    utils2.encode = minUtils.encode;
    function getNAF(num, w2, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1);
      var i2;
      for (i2 = 0; i2 < naf.length; i2 += 1) {
        naf[i2] = 0;
      }
      var ws = 1 << w2 + 1;
      var k3 = num.clone();
      for (i2 = 0; i2 < naf.length; i2++) {
        var z2;
        var mod2 = k3.andln(ws - 1);
        if (k3.isOdd()) {
          if (mod2 > (ws >> 1) - 1)
            z2 = (ws >> 1) - mod2;
          else
            z2 = mod2;
          k3.isubn(z2);
        } else {
          z2 = 0;
        }
        naf[i2] = z2;
        k3.iushrn(1);
      }
      return naf;
    }
    utils2.getNAF = getNAF;
    function getJSF(k1, k22) {
      var jsf = [[], []];
      k1 = k1.clone();
      k22 = k22.clone();
      var d1 = 0;
      var d2 = 0;
      var m8;
      while (k1.cmpn(-d1) > 0 || k22.cmpn(-d2) > 0) {
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k22.andln(3) + d2 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u1;
        if ((m14 & 1) === 0) {
          u1 = 0;
        } else {
          m8 = k1.andln(7) + d1 & 7;
          if ((m8 === 3 || m8 === 5) && m24 === 2)
            u1 = -m14;
          else
            u1 = m14;
        }
        jsf[0].push(u1);
        var u2;
        if ((m24 & 1) === 0) {
          u2 = 0;
        } else {
          m8 = k22.andln(7) + d2 & 7;
          if ((m8 === 3 || m8 === 5) && m14 === 2)
            u2 = -m24;
          else
            u2 = m24;
        }
        jsf[1].push(u2);
        if (2 * d1 === u1 + 1)
          d1 = 1 - d1;
        if (2 * d2 === u2 + 1)
          d2 = 1 - d2;
        k1.iushrn(1);
        k22.iushrn(1);
      }
      return jsf;
    }
    utils2.getJSF = getJSF;
    function cachedProperty(obj2, name2, computer) {
      var key3 = "_" + name2;
      obj2.prototype[name2] = function cachedProperty2() {
        return this[key3] !== void 0 ? this[key3] : this[key3] = computer.call(this);
      };
    }
    utils2.cachedProperty = cachedProperty;
    function parseBytes(bytes) {
      return typeof bytes === "string" ? utils2.toArray(bytes, "hex") : bytes;
    }
    utils2.parseBytes = parseBytes;
    function intFromLE(bytes) {
      return new BN(bytes, "hex", "le");
    }
    utils2.intFromLE = intFromLE;
  })(utils$1);
  return utils$1;
}
var brorand = { exports: {} };
var hasRequiredBrorand;
function requireBrorand() {
  if (hasRequiredBrorand)
    return brorand.exports;
  hasRequiredBrorand = 1;
  var r2;
  brorand.exports = function rand(len2) {
    if (!r2)
      r2 = new Rand(null);
    return r2.generate(len2);
  };
  function Rand(rand) {
    this.rand = rand;
  }
  brorand.exports.Rand = Rand;
  Rand.prototype.generate = function generate2(len2) {
    return this._rand(len2);
  };
  Rand.prototype._rand = function _rand(n2) {
    if (this.rand.getBytes)
      return this.rand.getBytes(n2);
    var res = new Uint8Array(n2);
    for (var i2 = 0; i2 < res.length; i2++)
      res[i2] = this.rand.getByte();
    return res;
  };
  if ((typeof self === "undefined" ? "undefined" : _typeof(self)) === "object") {
    if (self.crypto && self.crypto.getRandomValues) {
      Rand.prototype._rand = function _rand(n2) {
        var arr = new Uint8Array(n2);
        self.crypto.getRandomValues(arr);
        return arr;
      };
    } else if (self.msCrypto && self.msCrypto.getRandomValues) {
      Rand.prototype._rand = function _rand(n2) {
        var arr = new Uint8Array(n2);
        self.msCrypto.getRandomValues(arr);
        return arr;
      };
    } else if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") {
      Rand.prototype._rand = function() {
        throw new Error("Not implemented yet");
      };
    }
  } else {
    try {
      var crypto2 = require$$0$4;
      if (typeof crypto2.randomBytes !== "function")
        throw new Error("Not supported");
      Rand.prototype._rand = function _rand(n2) {
        return crypto2.randomBytes(n2);
      };
    } catch (e2) {
    }
  }
  return brorand.exports;
}
var curve = {};
var base;
var hasRequiredBase;
function requireBase() {
  if (hasRequiredBase)
    return base;
  hasRequiredBase = 1;
  var BN = bnExports;
  var utils2 = requireUtils();
  var getNAF = utils2.getNAF;
  var getJSF = utils2.getJSF;
  var assert2 = utils2.assert;
  function BaseCurve(type, conf) {
    this.type = type;
    this.p = new BN(conf.p, 16);
    this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
    this.zero = new BN(0).toRed(this.red);
    this.one = new BN(1).toRed(this.red);
    this.two = new BN(2).toRed(this.red);
    this.n = conf.n && new BN(conf.n, 16);
    this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
    this._wnafT1 = new Array(4);
    this._wnafT2 = new Array(4);
    this._wnafT3 = new Array(4);
    this._wnafT4 = new Array(4);
    this._bitLength = this.n ? this.n.bitLength() : 0;
    var adjustCount = this.n && this.p.div(this.n);
    if (!adjustCount || adjustCount.cmpn(100) > 0) {
      this.redN = null;
    } else {
      this._maxwellTrick = true;
      this.redN = this.n.toRed(this.red);
    }
  }
  base = BaseCurve;
  BaseCurve.prototype.point = function point() {
    throw new Error("Not implemented");
  };
  BaseCurve.prototype.validate = function validate() {
    throw new Error("Not implemented");
  };
  BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p2, k3) {
    assert2(p2.precomputed);
    var doubles = p2._getDoubles();
    var naf = getNAF(k3, 1, this._bitLength);
    var I2 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
    I2 /= 3;
    var repr = [];
    var j3;
    var nafW;
    for (j3 = 0; j3 < naf.length; j3 += doubles.step) {
      nafW = 0;
      for (var l2 = j3 + doubles.step - 1; l2 >= j3; l2--)
        nafW = (nafW << 1) + naf[l2];
      repr.push(nafW);
    }
    var a2 = this.jpoint(null, null, null);
    var b3 = this.jpoint(null, null, null);
    for (var i2 = I2; i2 > 0; i2--) {
      for (j3 = 0; j3 < repr.length; j3++) {
        nafW = repr[j3];
        if (nafW === i2)
          b3 = b3.mixedAdd(doubles.points[j3]);
        else if (nafW === -i2)
          b3 = b3.mixedAdd(doubles.points[j3].neg());
      }
      a2 = a2.add(b3);
    }
    return a2.toP();
  };
  BaseCurve.prototype._wnafMul = function _wnafMul(p2, k3) {
    var w2 = 4;
    var nafPoints = p2._getNAFPoints(w2);
    w2 = nafPoints.wnd;
    var wnd = nafPoints.points;
    var naf = getNAF(k3, w2, this._bitLength);
    var acc = this.jpoint(null, null, null);
    for (var i2 = naf.length - 1; i2 >= 0; i2--) {
      for (var l2 = 0; i2 >= 0 && naf[i2] === 0; i2--)
        l2++;
      if (i2 >= 0)
        l2++;
      acc = acc.dblp(l2);
      if (i2 < 0)
        break;
      var z2 = naf[i2];
      assert2(z2 !== 0);
      if (p2.type === "affine") {
        if (z2 > 0)
          acc = acc.mixedAdd(wnd[z2 - 1 >> 1]);
        else
          acc = acc.mixedAdd(wnd[-z2 - 1 >> 1].neg());
      } else {
        if (z2 > 0)
          acc = acc.add(wnd[z2 - 1 >> 1]);
        else
          acc = acc.add(wnd[-z2 - 1 >> 1].neg());
      }
    }
    return p2.type === "affine" ? acc.toP() : acc;
  };
  BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len2, jacobianResult) {
    var wndWidth = this._wnafT1;
    var wnd = this._wnafT2;
    var naf = this._wnafT3;
    var max = 0;
    var i2;
    var j3;
    var p2;
    for (i2 = 0; i2 < len2; i2++) {
      p2 = points[i2];
      var nafPoints = p2._getNAFPoints(defW);
      wndWidth[i2] = nafPoints.wnd;
      wnd[i2] = nafPoints.points;
    }
    for (i2 = len2 - 1; i2 >= 1; i2 -= 2) {
      var a2 = i2 - 1;
      var b3 = i2;
      if (wndWidth[a2] !== 1 || wndWidth[b3] !== 1) {
        naf[a2] = getNAF(coeffs[a2], wndWidth[a2], this._bitLength);
        naf[b3] = getNAF(coeffs[b3], wndWidth[b3], this._bitLength);
        max = Math.max(naf[a2].length, max);
        max = Math.max(naf[b3].length, max);
        continue;
      }
      var comb = [
        points[a2],
        /* 1 */
        null,
        /* 3 */
        null,
        /* 5 */
        points[b3]
        /* 7 */
      ];
      if (points[a2].y.cmp(points[b3].y) === 0) {
        comb[1] = points[a2].add(points[b3]);
        comb[2] = points[a2].toJ().mixedAdd(points[b3].neg());
      } else if (points[a2].y.cmp(points[b3].y.redNeg()) === 0) {
        comb[1] = points[a2].toJ().mixedAdd(points[b3]);
        comb[2] = points[a2].add(points[b3].neg());
      } else {
        comb[1] = points[a2].toJ().mixedAdd(points[b3]);
        comb[2] = points[a2].toJ().mixedAdd(points[b3].neg());
      }
      var index = [
        -3,
        /* -1 -1 */
        -1,
        /* -1 0 */
        -5,
        /* -1 1 */
        -7,
        /* 0 -1 */
        0,
        /* 0 0 */
        7,
        /* 0 1 */
        5,
        /* 1 -1 */
        1,
        /* 1 0 */
        3
        /* 1 1 */
      ];
      var jsf = getJSF(coeffs[a2], coeffs[b3]);
      max = Math.max(jsf[0].length, max);
      naf[a2] = new Array(max);
      naf[b3] = new Array(max);
      for (j3 = 0; j3 < max; j3++) {
        var ja = jsf[0][j3] | 0;
        var jb = jsf[1][j3] | 0;
        naf[a2][j3] = index[(ja + 1) * 3 + (jb + 1)];
        naf[b3][j3] = 0;
        wnd[a2] = comb;
      }
    }
    var acc = this.jpoint(null, null, null);
    var tmp = this._wnafT4;
    for (i2 = max; i2 >= 0; i2--) {
      var k3 = 0;
      while (i2 >= 0) {
        var zero = true;
        for (j3 = 0; j3 < len2; j3++) {
          tmp[j3] = naf[j3][i2] | 0;
          if (tmp[j3] !== 0)
            zero = false;
        }
        if (!zero)
          break;
        k3++;
        i2--;
      }
      if (i2 >= 0)
        k3++;
      acc = acc.dblp(k3);
      if (i2 < 0)
        break;
      for (j3 = 0; j3 < len2; j3++) {
        var z2 = tmp[j3];
        if (z2 === 0)
          continue;
        else if (z2 > 0)
          p2 = wnd[j3][z2 - 1 >> 1];
        else if (z2 < 0)
          p2 = wnd[j3][-z2 - 1 >> 1].neg();
        if (p2.type === "affine")
          acc = acc.mixedAdd(p2);
        else
          acc = acc.add(p2);
      }
    }
    for (i2 = 0; i2 < len2; i2++)
      wnd[i2] = null;
    if (jacobianResult)
      return acc;
    else
      return acc.toP();
  };
  function BasePoint(curve2, type) {
    this.curve = curve2;
    this.type = type;
    this.precomputed = null;
  }
  BaseCurve.BasePoint = BasePoint;
  BasePoint.prototype.eq = function eq() {
    throw new Error("Not implemented");
  };
  BasePoint.prototype.validate = function validate() {
    return this.curve.validate(this);
  };
  BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
    bytes = utils2.toArray(bytes, enc);
    var len2 = this.p.byteLength();
    if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len2) {
      if (bytes[0] === 6)
        assert2(bytes[bytes.length - 1] % 2 === 0);
      else if (bytes[0] === 7)
        assert2(bytes[bytes.length - 1] % 2 === 1);
      var res = this.point(bytes.slice(1, 1 + len2), bytes.slice(1 + len2, 1 + 2 * len2));
      return res;
    } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len2) {
      return this.pointFromX(bytes.slice(1, 1 + len2), bytes[0] === 3);
    }
    throw new Error("Unknown point format");
  };
  BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
    return this.encode(enc, true);
  };
  BasePoint.prototype._encode = function _encode(compact) {
    var len2 = this.curve.p.byteLength();
    var x2 = this.getX().toArray("be", len2);
    if (compact)
      return [this.getY().isEven() ? 2 : 3].concat(x2);
    return [4].concat(x2, this.getY().toArray("be", len2));
  };
  BasePoint.prototype.encode = function encode7(enc, compact) {
    return utils2.encode(this._encode(compact), enc);
  };
  BasePoint.prototype.precompute = function precompute(power) {
    if (this.precomputed)
      return this;
    var precomputed = { doubles: null, naf: null, beta: null };
    precomputed.naf = this._getNAFPoints(8);
    precomputed.doubles = this._getDoubles(4, power);
    precomputed.beta = this._getBeta();
    this.precomputed = precomputed;
    return this;
  };
  BasePoint.prototype._hasDoubles = function _hasDoubles(k3) {
    if (!this.precomputed)
      return false;
    var doubles = this.precomputed.doubles;
    if (!doubles)
      return false;
    return doubles.points.length >= Math.ceil((k3.bitLength() + 1) / doubles.step);
  };
  BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    var doubles = [this];
    var acc = this;
    for (var i2 = 0; i2 < power; i2 += step) {
      for (var j3 = 0; j3 < step; j3++)
        acc = acc.dbl();
      doubles.push(acc);
    }
    return { step, points: doubles };
  };
  BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    var res = [this];
    var max = (1 << wnd) - 1;
    var dbl = max === 1 ? null : this.dbl();
    for (var i2 = 1; i2 < max; i2++)
      res[i2] = res[i2 - 1].add(dbl);
    return { wnd, points: res };
  };
  BasePoint.prototype._getBeta = function _getBeta() {
    return null;
  };
  BasePoint.prototype.dblp = function dblp(k3) {
    var r2 = this;
    for (var i2 = 0; i2 < k3; i2++)
      r2 = r2.dbl();
    return r2;
  };
  return base;
}
var short;
var hasRequiredShort;
function requireShort() {
  if (hasRequiredShort)
    return short;
  hasRequiredShort = 1;
  var utils2 = requireUtils();
  var BN = bnExports;
  var inherits2 = inherits_browserExports;
  var Base = requireBase();
  var assert2 = utils2.assert;
  function ShortCurve(conf) {
    Base.call(this, "short", conf);
    this.a = new BN(conf.a, 16).toRed(this.red);
    this.b = new BN(conf.b, 16).toRed(this.red);
    this.tinv = this.two.redInvm();
    this.zeroA = this.a.fromRed().cmpn(0) === 0;
    this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
    this.endo = this._getEndomorphism(conf);
    this._endoWnafT1 = new Array(4);
    this._endoWnafT2 = new Array(4);
  }
  inherits2(ShortCurve, Base);
  short = ShortCurve;
  ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
    if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
      return;
    var beta;
    var lambda;
    if (conf.beta) {
      beta = new BN(conf.beta, 16).toRed(this.red);
    } else {
      var betas = this._getEndoRoots(this.p);
      beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
      beta = beta.toRed(this.red);
    }
    if (conf.lambda) {
      lambda = new BN(conf.lambda, 16);
    } else {
      var lambdas = this._getEndoRoots(this.n);
      if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
        lambda = lambdas[0];
      } else {
        lambda = lambdas[1];
        assert2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
      }
    }
    var basis;
    if (conf.basis) {
      basis = conf.basis.map(function(vec) {
        return { a: new BN(vec.a, 16), b: new BN(vec.b, 16) };
      });
    } else {
      basis = this._getEndoBasis(lambda);
    }
    return { beta, lambda, basis };
  };
  ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
    var red = num === this.p ? this.red : BN.mont(num);
    var tinv = new BN(2).toRed(red).redInvm();
    var ntinv = tinv.redNeg();
    var s2 = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
    var l1 = ntinv.redAdd(s2).fromRed();
    var l2 = ntinv.redSub(s2).fromRed();
    return [l1, l2];
  };
  ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
    var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
    var u2 = lambda;
    var v2 = this.n.clone();
    var x1 = new BN(1);
    var y1 = new BN(0);
    var x2 = new BN(0);
    var y22 = new BN(1);
    var a0;
    var b0;
    var a1;
    var b1;
    var a2;
    var b22;
    var prevR;
    var i2 = 0;
    var r2;
    var x3;
    while (u2.cmpn(0) !== 0) {
      var q3 = v2.div(u2);
      r2 = v2.sub(q3.mul(u2));
      x3 = x2.sub(q3.mul(x1));
      var y3 = y22.sub(q3.mul(y1));
      if (!a1 && r2.cmp(aprxSqrt) < 0) {
        a0 = prevR.neg();
        b0 = x1;
        a1 = r2.neg();
        b1 = x3;
      } else if (a1 && ++i2 === 2) {
        break;
      }
      prevR = r2;
      v2 = u2;
      u2 = r2;
      x2 = x1;
      x1 = x3;
      y22 = y1;
      y1 = y3;
    }
    a2 = r2.neg();
    b22 = x3;
    var len1 = a1.sqr().add(b1.sqr());
    var len2 = a2.sqr().add(b22.sqr());
    if (len2.cmp(len1) >= 0) {
      a2 = a0;
      b22 = b0;
    }
    if (a1.negative) {
      a1 = a1.neg();
      b1 = b1.neg();
    }
    if (a2.negative) {
      a2 = a2.neg();
      b22 = b22.neg();
    }
    return [{ a: a1, b: b1 }, { a: a2, b: b22 }];
  };
  ShortCurve.prototype._endoSplit = function _endoSplit(k3) {
    var basis = this.endo.basis;
    var v1 = basis[0];
    var v2 = basis[1];
    var c1 = v2.b.mul(k3).divRound(this.n);
    var c22 = v1.b.neg().mul(k3).divRound(this.n);
    var p1 = c1.mul(v1.a);
    var p2 = c22.mul(v2.a);
    var q1 = c1.mul(v1.b);
    var q22 = c22.mul(v2.b);
    var k1 = k3.sub(p1).sub(p2);
    var k22 = q1.add(q22).neg();
    return { k1, k2: k22 };
  };
  ShortCurve.prototype.pointFromX = function pointFromX(x2, odd) {
    x2 = new BN(x2, 16);
    if (!x2.red)
      x2 = x2.toRed(this.red);
    var y22 = x2.redSqr().redMul(x2).redIAdd(x2.redMul(this.a)).redIAdd(this.b);
    var y3 = y22.redSqrt();
    if (y3.redSqr().redSub(y22).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var isOdd = y3.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd)
      y3 = y3.redNeg();
    return this.point(x2, y3);
  };
  ShortCurve.prototype.validate = function validate(point) {
    if (point.inf)
      return true;
    var x2 = point.x;
    var y3 = point.y;
    var ax = this.a.redMul(x2);
    var rhs = x2.redSqr().redMul(x2).redIAdd(ax).redIAdd(this.b);
    return y3.redSqr().redISub(rhs).cmpn(0) === 0;
  };
  ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
    var npoints = this._endoWnafT1;
    var ncoeffs = this._endoWnafT2;
    for (var i2 = 0; i2 < points.length; i2++) {
      var split2 = this._endoSplit(coeffs[i2]);
      var p2 = points[i2];
      var beta = p2._getBeta();
      if (split2.k1.negative) {
        split2.k1.ineg();
        p2 = p2.neg(true);
      }
      if (split2.k2.negative) {
        split2.k2.ineg();
        beta = beta.neg(true);
      }
      npoints[i2 * 2] = p2;
      npoints[i2 * 2 + 1] = beta;
      ncoeffs[i2 * 2] = split2.k1;
      ncoeffs[i2 * 2 + 1] = split2.k2;
    }
    var res = this._wnafMulAdd(1, npoints, ncoeffs, i2 * 2, jacobianResult);
    for (var j3 = 0; j3 < i2 * 2; j3++) {
      npoints[j3] = null;
      ncoeffs[j3] = null;
    }
    return res;
  };
  function Point(curve2, x2, y3, isRed) {
    Base.BasePoint.call(this, curve2, "affine");
    if (x2 === null && y3 === null) {
      this.x = null;
      this.y = null;
      this.inf = true;
    } else {
      this.x = new BN(x2, 16);
      this.y = new BN(y3, 16);
      if (isRed) {
        this.x.forceRed(this.curve.red);
        this.y.forceRed(this.curve.red);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      this.inf = false;
    }
  }
  inherits2(Point, Base.BasePoint);
  ShortCurve.prototype.point = function point(x2, y3, isRed) {
    return new Point(this, x2, y3, isRed);
  };
  ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj2, red) {
    return Point.fromJSON(this, obj2, red);
  };
  Point.prototype._getBeta = function _getBeta() {
    if (!this.curve.endo)
      return;
    var pre = this.precomputed;
    if (pre && pre.beta)
      return pre.beta;
    var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (pre) {
      var curve2 = this.curve;
      var endoMul = function endoMul2(p2) {
        return curve2.point(p2.x.redMul(curve2.endo.beta), p2.y);
      };
      pre.beta = beta;
      beta.precomputed = { beta: null, naf: pre.naf && { wnd: pre.naf.wnd, points: pre.naf.points.map(endoMul) }, doubles: pre.doubles && { step: pre.doubles.step, points: pre.doubles.points.map(endoMul) } };
    }
    return beta;
  };
  Point.prototype.toJSON = function toJSON2() {
    if (!this.precomputed)
      return [this.x, this.y];
    return [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }];
  };
  Point.fromJSON = function fromJSON(curve2, obj2, red) {
    if (typeof obj2 === "string")
      obj2 = JSON.parse(obj2);
    var res = curve2.point(obj2[0], obj2[1], red);
    if (!obj2[2])
      return res;
    function obj2point(obj3) {
      return curve2.point(obj3[0], obj3[1], red);
    }
    var pre = obj2[2];
    res.precomputed = { beta: null, doubles: pre.doubles && { step: pre.doubles.step, points: [res].concat(pre.doubles.points.map(obj2point)) }, naf: pre.naf && { wnd: pre.naf.wnd, points: [res].concat(pre.naf.points.map(obj2point)) } };
    return res;
  };
  Point.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  };
  Point.prototype.isInfinity = function isInfinity() {
    return this.inf;
  };
  Point.prototype.add = function add2(p2) {
    if (this.inf)
      return p2;
    if (p2.inf)
      return this;
    if (this.eq(p2))
      return this.dbl();
    if (this.neg().eq(p2))
      return this.curve.point(null, null);
    if (this.x.cmp(p2.x) === 0)
      return this.curve.point(null, null);
    var c3 = this.y.redSub(p2.y);
    if (c3.cmpn(0) !== 0)
      c3 = c3.redMul(this.x.redSub(p2.x).redInvm());
    var nx = c3.redSqr().redISub(this.x).redISub(p2.x);
    var ny = c3.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
  };
  Point.prototype.dbl = function dbl() {
    if (this.inf)
      return this;
    var ys1 = this.y.redAdd(this.y);
    if (ys1.cmpn(0) === 0)
      return this.curve.point(null, null);
    var a2 = this.curve.a;
    var x2 = this.x.redSqr();
    var dyinv = ys1.redInvm();
    var c3 = x2.redAdd(x2).redIAdd(x2).redIAdd(a2).redMul(dyinv);
    var nx = c3.redSqr().redISub(this.x.redAdd(this.x));
    var ny = c3.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
  };
  Point.prototype.getX = function getX() {
    return this.x.fromRed();
  };
  Point.prototype.getY = function getY() {
    return this.y.fromRed();
  };
  Point.prototype.mul = function mul(k3) {
    k3 = new BN(k3, 16);
    if (this.isInfinity())
      return this;
    else if (this._hasDoubles(k3))
      return this.curve._fixedNafMul(this, k3);
    else if (this.curve.endo)
      return this.curve._endoWnafMulAdd([this], [k3]);
    else
      return this.curve._wnafMul(this, k3);
  };
  Point.prototype.mulAdd = function mulAdd(k1, p2, k22) {
    var points = [this, p2];
    var coeffs = [k1, k22];
    if (this.curve.endo)
      return this.curve._endoWnafMulAdd(points, coeffs);
    else
      return this.curve._wnafMulAdd(1, points, coeffs, 2);
  };
  Point.prototype.jmulAdd = function jmulAdd(k1, p2, k22) {
    var points = [this, p2];
    var coeffs = [k1, k22];
    if (this.curve.endo)
      return this.curve._endoWnafMulAdd(points, coeffs, true);
    else
      return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
  };
  Point.prototype.eq = function eq(p2) {
    return this === p2 || this.inf === p2.inf && (this.inf || this.x.cmp(p2.x) === 0 && this.y.cmp(p2.y) === 0);
  };
  Point.prototype.neg = function neg(_precompute) {
    if (this.inf)
      return this;
    var res = this.curve.point(this.x, this.y.redNeg());
    if (_precompute && this.precomputed) {
      var pre = this.precomputed;
      var negate = function negate2(p2) {
        return p2.neg();
      };
      res.precomputed = { naf: pre.naf && { wnd: pre.naf.wnd, points: pre.naf.points.map(negate) }, doubles: pre.doubles && { step: pre.doubles.step, points: pre.doubles.points.map(negate) } };
    }
    return res;
  };
  Point.prototype.toJ = function toJ() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var res = this.curve.jpoint(this.x, this.y, this.curve.one);
    return res;
  };
  function JPoint(curve2, x2, y3, z2) {
    Base.BasePoint.call(this, curve2, "jacobian");
    if (x2 === null && y3 === null && z2 === null) {
      this.x = this.curve.one;
      this.y = this.curve.one;
      this.z = new BN(0);
    } else {
      this.x = new BN(x2, 16);
      this.y = new BN(y3, 16);
      this.z = new BN(z2, 16);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;
  }
  inherits2(JPoint, Base.BasePoint);
  ShortCurve.prototype.jpoint = function jpoint(x2, y3, z2) {
    return new JPoint(this, x2, y3, z2);
  };
  JPoint.prototype.toP = function toP() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var zinv = this.z.redInvm();
    var zinv2 = zinv.redSqr();
    var ax = this.x.redMul(zinv2);
    var ay = this.y.redMul(zinv2).redMul(zinv);
    return this.curve.point(ax, ay);
  };
  JPoint.prototype.neg = function neg() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  };
  JPoint.prototype.add = function add2(p2) {
    if (this.isInfinity())
      return p2;
    if (p2.isInfinity())
      return this;
    var pz2 = p2.z.redSqr();
    var z2 = this.z.redSqr();
    var u1 = this.x.redMul(pz2);
    var u2 = p2.x.redMul(z2);
    var s1 = this.y.redMul(pz2.redMul(p2.z));
    var s2 = p2.y.redMul(z2.redMul(this.z));
    var h2 = u1.redSub(u2);
    var r2 = s1.redSub(s2);
    if (h2.cmpn(0) === 0) {
      if (r2.cmpn(0) !== 0)
        return this.curve.jpoint(null, null, null);
      else
        return this.dbl();
    }
    var h22 = h2.redSqr();
    var h3 = h22.redMul(h2);
    var v2 = u1.redMul(h22);
    var nx = r2.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
    var ny = r2.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(p2.z).redMul(h2);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.mixedAdd = function mixedAdd(p2) {
    if (this.isInfinity())
      return p2.toJ();
    if (p2.isInfinity())
      return this;
    var z2 = this.z.redSqr();
    var u1 = this.x;
    var u2 = p2.x.redMul(z2);
    var s1 = this.y;
    var s2 = p2.y.redMul(z2).redMul(this.z);
    var h2 = u1.redSub(u2);
    var r2 = s1.redSub(s2);
    if (h2.cmpn(0) === 0) {
      if (r2.cmpn(0) !== 0)
        return this.curve.jpoint(null, null, null);
      else
        return this.dbl();
    }
    var h22 = h2.redSqr();
    var h3 = h22.redMul(h2);
    var v2 = u1.redMul(h22);
    var nx = r2.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
    var ny = r2.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(h2);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.dblp = function dblp(pow) {
    if (pow === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!pow)
      return this.dbl();
    var i2;
    if (this.curve.zeroA || this.curve.threeA) {
      var r2 = this;
      for (i2 = 0; i2 < pow; i2++)
        r2 = r2.dbl();
      return r2;
    }
    var a2 = this.curve.a;
    var tinv = this.curve.tinv;
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    var jyd = jy.redAdd(jy);
    for (i2 = 0; i2 < pow; i2++) {
      var jx2 = jx.redSqr();
      var jyd2 = jyd.redSqr();
      var jyd4 = jyd2.redSqr();
      var c3 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
      var t1 = jx.redMul(jyd2);
      var nx = c3.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var dny = c3.redMul(t2);
      dny = dny.redIAdd(dny).redISub(jyd4);
      var nz = jyd.redMul(jz);
      if (i2 + 1 < pow)
        jz4 = jz4.redMul(jyd4);
      jx = nx;
      jz = nz;
      jyd = dny;
    }
    return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
  };
  JPoint.prototype.dbl = function dbl() {
    if (this.isInfinity())
      return this;
    if (this.curve.zeroA)
      return this._zeroDbl();
    else if (this.curve.threeA)
      return this._threeDbl();
    else
      return this._dbl();
  };
  JPoint.prototype._zeroDbl = function _zeroDbl() {
    var nx;
    var ny;
    var nz;
    if (this.zOne) {
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var yyyy = yy.redSqr();
      var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      s2 = s2.redIAdd(s2);
      var m2 = xx.redAdd(xx).redIAdd(xx);
      var t2 = m2.redSqr().redISub(s2).redISub(s2);
      var yyyy8 = yyyy.redIAdd(yyyy);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      nx = t2;
      ny = m2.redMul(s2.redISub(t2)).redISub(yyyy8);
      nz = this.y.redAdd(this.y);
    } else {
      var a2 = this.x.redSqr();
      var b3 = this.y.redSqr();
      var c3 = b3.redSqr();
      var d2 = this.x.redAdd(b3).redSqr().redISub(a2).redISub(c3);
      d2 = d2.redIAdd(d2);
      var e2 = a2.redAdd(a2).redIAdd(a2);
      var f2 = e2.redSqr();
      var c8 = c3.redIAdd(c3);
      c8 = c8.redIAdd(c8);
      c8 = c8.redIAdd(c8);
      nx = f2.redISub(d2).redISub(d2);
      ny = e2.redMul(d2.redISub(nx)).redISub(c8);
      nz = this.y.redMul(this.z);
      nz = nz.redIAdd(nz);
    }
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype._threeDbl = function _threeDbl() {
    var nx;
    var ny;
    var nz;
    if (this.zOne) {
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var yyyy = yy.redSqr();
      var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      s2 = s2.redIAdd(s2);
      var m2 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
      var t2 = m2.redSqr().redISub(s2).redISub(s2);
      nx = t2;
      var yyyy8 = yyyy.redIAdd(yyyy);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      ny = m2.redMul(s2.redISub(t2)).redISub(yyyy8);
      nz = this.y.redAdd(this.y);
    } else {
      var delta = this.z.redSqr();
      var gamma = this.y.redSqr();
      var beta = this.x.redMul(gamma);
      var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
      alpha = alpha.redAdd(alpha).redIAdd(alpha);
      var beta4 = beta.redIAdd(beta);
      beta4 = beta4.redIAdd(beta4);
      var beta8 = beta4.redAdd(beta4);
      nx = alpha.redSqr().redISub(beta8);
      nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
      var ggamma8 = gamma.redSqr();
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
    }
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype._dbl = function _dbl() {
    var a2 = this.curve.a;
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    var jx2 = jx.redSqr();
    var jy2 = jy.redSqr();
    var c3 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
    var jxd4 = jx.redAdd(jx);
    jxd4 = jxd4.redIAdd(jxd4);
    var t1 = jxd4.redMul(jy2);
    var nx = c3.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var jyd8 = jy2.redSqr();
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    var ny = c3.redMul(t2).redISub(jyd8);
    var nz = jy.redAdd(jy).redMul(jz);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.trpl = function trpl() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var zz = this.z.redSqr();
    var yyyy = yy.redSqr();
    var m2 = xx.redAdd(xx).redIAdd(xx);
    var mm = m2.redSqr();
    var e2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    e2 = e2.redIAdd(e2);
    e2 = e2.redAdd(e2).redIAdd(e2);
    e2 = e2.redISub(mm);
    var ee2 = e2.redSqr();
    var t2 = yyyy.redIAdd(yyyy);
    t2 = t2.redIAdd(t2);
    t2 = t2.redIAdd(t2);
    t2 = t2.redIAdd(t2);
    var u2 = m2.redIAdd(e2).redSqr().redISub(mm).redISub(ee2).redISub(t2);
    var yyu4 = yy.redMul(u2);
    yyu4 = yyu4.redIAdd(yyu4);
    yyu4 = yyu4.redIAdd(yyu4);
    var nx = this.x.redMul(ee2).redISub(yyu4);
    nx = nx.redIAdd(nx);
    nx = nx.redIAdd(nx);
    var ny = this.y.redMul(u2.redMul(t2.redISub(u2)).redISub(e2.redMul(ee2)));
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    var nz = this.z.redAdd(e2).redSqr().redISub(zz).redISub(ee2);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.mul = function mul(k3, kbase) {
    k3 = new BN(k3, kbase);
    return this.curve._wnafMul(this, k3);
  };
  JPoint.prototype.eq = function eq(p2) {
    if (p2.type === "affine")
      return this.eq(p2.toJ());
    if (this === p2)
      return true;
    var z2 = this.z.redSqr();
    var pz2 = p2.z.redSqr();
    if (this.x.redMul(pz2).redISub(p2.x.redMul(z2)).cmpn(0) !== 0)
      return false;
    var z3 = z2.redMul(this.z);
    var pz3 = pz2.redMul(p2.z);
    return this.y.redMul(pz3).redISub(p2.y.redMul(z3)).cmpn(0) === 0;
  };
  JPoint.prototype.eqXToP = function eqXToP(x2) {
    var zs = this.z.redSqr();
    var rx = x2.toRed(this.curve.red).redMul(zs);
    if (this.x.cmp(rx) === 0)
      return true;
    var xc = x2.clone();
    var t2 = this.curve.redN.redMul(zs);
    for (; ; ) {
      xc.iadd(this.curve.n);
      if (xc.cmp(this.curve.p) >= 0)
        return false;
      rx.redIAdd(t2);
      if (this.x.cmp(rx) === 0)
        return true;
    }
  };
  JPoint.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return "<EC JPoint Infinity>";
    return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  };
  JPoint.prototype.isInfinity = function isInfinity() {
    return this.z.cmpn(0) === 0;
  };
  return short;
}
var mont;
var hasRequiredMont;
function requireMont() {
  if (hasRequiredMont)
    return mont;
  hasRequiredMont = 1;
  var BN = bnExports;
  var inherits2 = inherits_browserExports;
  var Base = requireBase();
  var utils2 = requireUtils();
  function MontCurve(conf) {
    Base.call(this, "mont", conf);
    this.a = new BN(conf.a, 16).toRed(this.red);
    this.b = new BN(conf.b, 16).toRed(this.red);
    this.i4 = new BN(4).toRed(this.red).redInvm();
    this.two = new BN(2).toRed(this.red);
    this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  inherits2(MontCurve, Base);
  mont = MontCurve;
  MontCurve.prototype.validate = function validate(point) {
    var x2 = point.normalize().x;
    var x22 = x2.redSqr();
    var rhs = x22.redMul(x2).redAdd(x22.redMul(this.a)).redAdd(x2);
    var y3 = rhs.redSqrt();
    return y3.redSqr().cmp(rhs) === 0;
  };
  function Point(curve2, x2, z2) {
    Base.BasePoint.call(this, curve2, "projective");
    if (x2 === null && z2 === null) {
      this.x = this.curve.one;
      this.z = this.curve.zero;
    } else {
      this.x = new BN(x2, 16);
      this.z = new BN(z2, 16);
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
    }
  }
  inherits2(Point, Base.BasePoint);
  MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
    return this.point(utils2.toArray(bytes, enc), 1);
  };
  MontCurve.prototype.point = function point(x2, z2) {
    return new Point(this, x2, z2);
  };
  MontCurve.prototype.pointFromJSON = function pointFromJSON(obj2) {
    return Point.fromJSON(this, obj2);
  };
  Point.prototype.precompute = function precompute() {
  };
  Point.prototype._encode = function _encode() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  };
  Point.fromJSON = function fromJSON(curve2, obj2) {
    return new Point(curve2, obj2[0], obj2[1] || curve2.one);
  };
  Point.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  };
  Point.prototype.isInfinity = function isInfinity() {
    return this.z.cmpn(0) === 0;
  };
  Point.prototype.dbl = function dbl() {
    var a2 = this.x.redAdd(this.z);
    var aa = a2.redSqr();
    var b3 = this.x.redSub(this.z);
    var bb = b3.redSqr();
    var c3 = aa.redSub(bb);
    var nx = aa.redMul(bb);
    var nz = c3.redMul(bb.redAdd(this.curve.a24.redMul(c3)));
    return this.curve.point(nx, nz);
  };
  Point.prototype.add = function add2() {
    throw new Error("Not supported on Montgomery curve");
  };
  Point.prototype.diffAdd = function diffAdd(p2, diff) {
    var a2 = this.x.redAdd(this.z);
    var b3 = this.x.redSub(this.z);
    var c3 = p2.x.redAdd(p2.z);
    var d2 = p2.x.redSub(p2.z);
    var da = d2.redMul(a2);
    var cb = c3.redMul(b3);
    var nx = diff.z.redMul(da.redAdd(cb).redSqr());
    var nz = diff.x.redMul(da.redISub(cb).redSqr());
    return this.curve.point(nx, nz);
  };
  Point.prototype.mul = function mul(k3) {
    var t2 = k3.clone();
    var a2 = this;
    var b3 = this.curve.point(null, null);
    var c3 = this;
    for (var bits = []; t2.cmpn(0) !== 0; t2.iushrn(1))
      bits.push(t2.andln(1));
    for (var i2 = bits.length - 1; i2 >= 0; i2--) {
      if (bits[i2] === 0) {
        a2 = a2.diffAdd(b3, c3);
        b3 = b3.dbl();
      } else {
        b3 = a2.diffAdd(b3, c3);
        a2 = a2.dbl();
      }
    }
    return b3;
  };
  Point.prototype.mulAdd = function mulAdd() {
    throw new Error("Not supported on Montgomery curve");
  };
  Point.prototype.jumlAdd = function jumlAdd() {
    throw new Error("Not supported on Montgomery curve");
  };
  Point.prototype.eq = function eq(other) {
    return this.getX().cmp(other.getX()) === 0;
  };
  Point.prototype.normalize = function normalize2() {
    this.x = this.x.redMul(this.z.redInvm());
    this.z = this.curve.one;
    return this;
  };
  Point.prototype.getX = function getX() {
    this.normalize();
    return this.x.fromRed();
  };
  return mont;
}
var edwards;
var hasRequiredEdwards;
function requireEdwards() {
  if (hasRequiredEdwards)
    return edwards;
  hasRequiredEdwards = 1;
  var utils2 = requireUtils();
  var BN = bnExports;
  var inherits2 = inherits_browserExports;
  var Base = requireBase();
  var assert2 = utils2.assert;
  function EdwardsCurve(conf) {
    this.twisted = (conf.a | 0) !== 1;
    this.mOneA = this.twisted && (conf.a | 0) === -1;
    this.extended = this.mOneA;
    Base.call(this, "edwards", conf);
    this.a = new BN(conf.a, 16).umod(this.red.m);
    this.a = this.a.toRed(this.red);
    this.c = new BN(conf.c, 16).toRed(this.red);
    this.c2 = this.c.redSqr();
    this.d = new BN(conf.d, 16).toRed(this.red);
    this.dd = this.d.redAdd(this.d);
    assert2(!this.twisted || this.c.fromRed().cmpn(1) === 0);
    this.oneC = (conf.c | 0) === 1;
  }
  inherits2(EdwardsCurve, Base);
  edwards = EdwardsCurve;
  EdwardsCurve.prototype._mulA = function _mulA(num) {
    if (this.mOneA)
      return num.redNeg();
    else
      return this.a.redMul(num);
  };
  EdwardsCurve.prototype._mulC = function _mulC(num) {
    if (this.oneC)
      return num;
    else
      return this.c.redMul(num);
  };
  EdwardsCurve.prototype.jpoint = function jpoint(x2, y3, z2, t2) {
    return this.point(x2, y3, z2, t2);
  };
  EdwardsCurve.prototype.pointFromX = function pointFromX(x2, odd) {
    x2 = new BN(x2, 16);
    if (!x2.red)
      x2 = x2.toRed(this.red);
    var x22 = x2.redSqr();
    var rhs = this.c2.redSub(this.a.redMul(x22));
    var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x22));
    var y22 = rhs.redMul(lhs.redInvm());
    var y3 = y22.redSqrt();
    if (y3.redSqr().redSub(y22).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var isOdd = y3.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd)
      y3 = y3.redNeg();
    return this.point(x2, y3);
  };
  EdwardsCurve.prototype.pointFromY = function pointFromY(y3, odd) {
    y3 = new BN(y3, 16);
    if (!y3.red)
      y3 = y3.toRed(this.red);
    var y22 = y3.redSqr();
    var lhs = y22.redSub(this.c2);
    var rhs = y22.redMul(this.d).redMul(this.c2).redSub(this.a);
    var x2 = lhs.redMul(rhs.redInvm());
    if (x2.cmp(this.zero) === 0) {
      if (odd)
        throw new Error("invalid point");
      else
        return this.point(this.zero, y3);
    }
    var x3 = x2.redSqrt();
    if (x3.redSqr().redSub(x2).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    if (x3.fromRed().isOdd() !== odd)
      x3 = x3.redNeg();
    return this.point(x3, y3);
  };
  EdwardsCurve.prototype.validate = function validate(point) {
    if (point.isInfinity())
      return true;
    point.normalize();
    var x2 = point.x.redSqr();
    var y22 = point.y.redSqr();
    var lhs = x2.redMul(this.a).redAdd(y22);
    var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y22)));
    return lhs.cmp(rhs) === 0;
  };
  function Point(curve2, x2, y3, z2, t2) {
    Base.BasePoint.call(this, curve2, "projective");
    if (x2 === null && y3 === null && z2 === null) {
      this.x = this.curve.zero;
      this.y = this.curve.one;
      this.z = this.curve.one;
      this.t = this.curve.zero;
      this.zOne = true;
    } else {
      this.x = new BN(x2, 16);
      this.y = new BN(y3, 16);
      this.z = z2 ? new BN(z2, 16) : this.curve.one;
      this.t = t2 && new BN(t2, 16);
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      if (this.t && !this.t.red)
        this.t = this.t.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
      if (this.curve.extended && !this.t) {
        this.t = this.x.redMul(this.y);
        if (!this.zOne)
          this.t = this.t.redMul(this.z.redInvm());
      }
    }
  }
  inherits2(Point, Base.BasePoint);
  EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj2) {
    return Point.fromJSON(this, obj2);
  };
  EdwardsCurve.prototype.point = function point(x2, y3, z2, t2) {
    return new Point(this, x2, y3, z2, t2);
  };
  Point.fromJSON = function fromJSON(curve2, obj2) {
    return new Point(curve2, obj2[0], obj2[1], obj2[2]);
  };
  Point.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  };
  Point.prototype.isInfinity = function isInfinity() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  };
  Point.prototype._extDbl = function _extDbl() {
    var a2 = this.x.redSqr();
    var b3 = this.y.redSqr();
    var c3 = this.z.redSqr();
    c3 = c3.redIAdd(c3);
    var d2 = this.curve._mulA(a2);
    var e2 = this.x.redAdd(this.y).redSqr().redISub(a2).redISub(b3);
    var g2 = d2.redAdd(b3);
    var f2 = g2.redSub(c3);
    var h2 = d2.redSub(b3);
    var nx = e2.redMul(f2);
    var ny = g2.redMul(h2);
    var nt2 = e2.redMul(h2);
    var nz = f2.redMul(g2);
    return this.curve.point(nx, ny, nz, nt2);
  };
  Point.prototype._projDbl = function _projDbl() {
    var b3 = this.x.redAdd(this.y).redSqr();
    var c3 = this.x.redSqr();
    var d2 = this.y.redSqr();
    var nx;
    var ny;
    var nz;
    var e2;
    var h2;
    var j3;
    if (this.curve.twisted) {
      e2 = this.curve._mulA(c3);
      var f2 = e2.redAdd(d2);
      if (this.zOne) {
        nx = b3.redSub(c3).redSub(d2).redMul(f2.redSub(this.curve.two));
        ny = f2.redMul(e2.redSub(d2));
        nz = f2.redSqr().redSub(f2).redSub(f2);
      } else {
        h2 = this.z.redSqr();
        j3 = f2.redSub(h2).redISub(h2);
        nx = b3.redSub(c3).redISub(d2).redMul(j3);
        ny = f2.redMul(e2.redSub(d2));
        nz = f2.redMul(j3);
      }
    } else {
      e2 = c3.redAdd(d2);
      h2 = this.curve._mulC(this.z).redSqr();
      j3 = e2.redSub(h2).redSub(h2);
      nx = this.curve._mulC(b3.redISub(e2)).redMul(j3);
      ny = this.curve._mulC(e2).redMul(c3.redISub(d2));
      nz = e2.redMul(j3);
    }
    return this.curve.point(nx, ny, nz);
  };
  Point.prototype.dbl = function dbl() {
    if (this.isInfinity())
      return this;
    if (this.curve.extended)
      return this._extDbl();
    else
      return this._projDbl();
  };
  Point.prototype._extAdd = function _extAdd(p2) {
    var a2 = this.y.redSub(this.x).redMul(p2.y.redSub(p2.x));
    var b3 = this.y.redAdd(this.x).redMul(p2.y.redAdd(p2.x));
    var c3 = this.t.redMul(this.curve.dd).redMul(p2.t);
    var d2 = this.z.redMul(p2.z.redAdd(p2.z));
    var e2 = b3.redSub(a2);
    var f2 = d2.redSub(c3);
    var g2 = d2.redAdd(c3);
    var h2 = b3.redAdd(a2);
    var nx = e2.redMul(f2);
    var ny = g2.redMul(h2);
    var nt2 = e2.redMul(h2);
    var nz = f2.redMul(g2);
    return this.curve.point(nx, ny, nz, nt2);
  };
  Point.prototype._projAdd = function _projAdd(p2) {
    var a2 = this.z.redMul(p2.z);
    var b3 = a2.redSqr();
    var c3 = this.x.redMul(p2.x);
    var d2 = this.y.redMul(p2.y);
    var e2 = this.curve.d.redMul(c3).redMul(d2);
    var f2 = b3.redSub(e2);
    var g2 = b3.redAdd(e2);
    var tmp = this.x.redAdd(this.y).redMul(p2.x.redAdd(p2.y)).redISub(c3).redISub(d2);
    var nx = a2.redMul(f2).redMul(tmp);
    var ny;
    var nz;
    if (this.curve.twisted) {
      ny = a2.redMul(g2).redMul(d2.redSub(this.curve._mulA(c3)));
      nz = f2.redMul(g2);
    } else {
      ny = a2.redMul(g2).redMul(d2.redSub(c3));
      nz = this.curve._mulC(f2).redMul(g2);
    }
    return this.curve.point(nx, ny, nz);
  };
  Point.prototype.add = function add2(p2) {
    if (this.isInfinity())
      return p2;
    if (p2.isInfinity())
      return this;
    if (this.curve.extended)
      return this._extAdd(p2);
    else
      return this._projAdd(p2);
  };
  Point.prototype.mul = function mul(k3) {
    if (this._hasDoubles(k3))
      return this.curve._fixedNafMul(this, k3);
    else
      return this.curve._wnafMul(this, k3);
  };
  Point.prototype.mulAdd = function mulAdd(k1, p2, k22) {
    return this.curve._wnafMulAdd(1, [this, p2], [k1, k22], 2, false);
  };
  Point.prototype.jmulAdd = function jmulAdd(k1, p2, k22) {
    return this.curve._wnafMulAdd(1, [this, p2], [k1, k22], 2, true);
  };
  Point.prototype.normalize = function normalize2() {
    if (this.zOne)
      return this;
    var zi = this.z.redInvm();
    this.x = this.x.redMul(zi);
    this.y = this.y.redMul(zi);
    if (this.t)
      this.t = this.t.redMul(zi);
    this.z = this.curve.one;
    this.zOne = true;
    return this;
  };
  Point.prototype.neg = function neg() {
    return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
  };
  Point.prototype.getX = function getX() {
    this.normalize();
    return this.x.fromRed();
  };
  Point.prototype.getY = function getY() {
    this.normalize();
    return this.y.fromRed();
  };
  Point.prototype.eq = function eq(other) {
    return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
  };
  Point.prototype.eqXToP = function eqXToP(x2) {
    var rx = x2.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(rx) === 0)
      return true;
    var xc = x2.clone();
    var t2 = this.curve.redN.redMul(this.z);
    for (; ; ) {
      xc.iadd(this.curve.n);
      if (xc.cmp(this.curve.p) >= 0)
        return false;
      rx.redIAdd(t2);
      if (this.x.cmp(rx) === 0)
        return true;
    }
  };
  Point.prototype.toP = Point.prototype.normalize;
  Point.prototype.mixedAdd = Point.prototype.add;
  return edwards;
}
var hasRequiredCurve;
function requireCurve() {
  if (hasRequiredCurve)
    return curve;
  hasRequiredCurve = 1;
  (function(exports) {
    var curve2 = exports;
    curve2.base = requireBase();
    curve2.short = requireShort();
    curve2.mont = requireMont();
    curve2.edwards = requireEdwards();
  })(curve);
  return curve;
}
var curves = {};
var secp256k1;
var hasRequiredSecp256k1$1;
function requireSecp256k1$1() {
  if (hasRequiredSecp256k1$1)
    return secp256k1;
  hasRequiredSecp256k1$1 = 1;
  secp256k1 = { doubles: { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, naf: { wnd: 7, points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]] } };
  return secp256k1;
}
var hasRequiredCurves;
function requireCurves() {
  if (hasRequiredCurves)
    return curves;
  hasRequiredCurves = 1;
  (function(exports) {
    var curves2 = exports;
    var hash2 = hash$4;
    var curve2 = requireCurve();
    var utils2 = requireUtils();
    var assert2 = utils2.assert;
    function PresetCurve(options) {
      if (options.type === "short")
        this.curve = new curve2.short(options);
      else if (options.type === "edwards")
        this.curve = new curve2.edwards(options);
      else
        this.curve = new curve2.mont(options);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options.hash;
      assert2(this.g.validate(), "Invalid curve");
      assert2(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves2.PresetCurve = PresetCurve;
    function defineCurve(name2, options) {
      Object.defineProperty(curves2, name2, { configurable: true, enumerable: true, get: function get5() {
        var curve3 = new PresetCurve(options);
        Object.defineProperty(curves2, name2, { configurable: true, enumerable: true, value: curve3 });
        return curve3;
      } });
    }
    defineCurve("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: hash2.sha256, gRed: false, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] });
    defineCurve("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: hash2.sha256, gRed: false, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] });
    defineCurve("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: hash2.sha256, gRed: false, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] });
    defineCurve("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: hash2.sha384, gRed: false, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] });
    defineCurve("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: hash2.sha512, gRed: false, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] });
    defineCurve("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: hash2.sha256, gRed: false, g: ["9"] });
    defineCurve("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var pre;
    try {
      pre = requireSecp256k1$1();
    } catch (e2) {
      pre = void 0;
    }
    defineCurve("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: hash2.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }],
      gRed: false,
      g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", pre]
    });
  })(curves);
  return curves;
}
var key$1;
var hasRequiredKey$1;
function requireKey$1() {
  if (hasRequiredKey$1)
    return key$1;
  hasRequiredKey$1 = 1;
  var BN = bnExports;
  var utils2 = requireUtils();
  var assert2 = utils2.assert;
  function KeyPair(ec2, options) {
    this.ec = ec2;
    this.priv = null;
    this.pub = null;
    if (options.priv)
      this._importPrivate(options.priv, options.privEnc);
    if (options.pub)
      this._importPublic(options.pub, options.pubEnc);
  }
  key$1 = KeyPair;
  KeyPair.fromPublic = function fromPublic(ec2, pub, enc) {
    if (pub instanceof KeyPair)
      return pub;
    return new KeyPair(ec2, { pub, pubEnc: enc });
  };
  KeyPair.fromPrivate = function fromPrivate(ec2, priv, enc) {
    if (priv instanceof KeyPair)
      return priv;
    return new KeyPair(ec2, { priv, privEnc: enc });
  };
  KeyPair.prototype.validate = function validate() {
    var pub = this.getPublic();
    if (pub.isInfinity())
      return { result: false, reason: "Invalid public key" };
    if (!pub.validate())
      return { result: false, reason: "Public key is not a point" };
    if (!pub.mul(this.ec.curve.n).isInfinity())
      return { result: false, reason: "Public key * N != O" };
    return { result: true, reason: null };
  };
  KeyPair.prototype.getPublic = function getPublic(compact, enc) {
    if (typeof compact === "string") {
      enc = compact;
      compact = null;
    }
    if (!this.pub)
      this.pub = this.ec.g.mul(this.priv);
    if (!enc)
      return this.pub;
    return this.pub.encode(enc, compact);
  };
  KeyPair.prototype.getPrivate = function getPrivate(enc) {
    if (enc === "hex")
      return this.priv.toString(16, 2);
    else
      return this.priv;
  };
  KeyPair.prototype._importPrivate = function _importPrivate(key3, enc) {
    this.priv = new BN(key3, enc || 16);
    this.priv = this.priv.umod(this.ec.curve.n);
  };
  KeyPair.prototype._importPublic = function _importPublic(key3, enc) {
    if (key3.x || key3.y) {
      if (this.ec.curve.type === "mont") {
        assert2(key3.x, "Need x coordinate");
      } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
        assert2(key3.x && key3.y, "Need both x and y coordinate");
      }
      this.pub = this.ec.curve.point(key3.x, key3.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(key3, enc);
  };
  KeyPair.prototype.derive = function derive(pub) {
    if (!pub.validate()) {
      assert2(pub.validate(), "public point not validated");
    }
    return pub.mul(this.priv).getX();
  };
  KeyPair.prototype.sign = function sign(msg, enc, options) {
    return this.ec.sign(msg, this, enc, options);
  };
  KeyPair.prototype.verify = function verify(msg, signature2, options) {
    return this.ec.verify(msg, signature2, this, void 0, options);
  };
  KeyPair.prototype.inspect = function inspect() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  };
  return key$1;
}
var signature$1;
var hasRequiredSignature$1;
function requireSignature$1() {
  if (hasRequiredSignature$1)
    return signature$1;
  hasRequiredSignature$1 = 1;
  var BN = bnExports;
  var utils2 = requireUtils();
  var assert2 = utils2.assert;
  function Signature(options, enc) {
    if (options instanceof Signature)
      return options;
    if (this._importDER(options, enc))
      return;
    assert2(options.r && options.s, "Signature without r or s");
    this.r = new BN(options.r, 16);
    this.s = new BN(options.s, 16);
    if (options.recoveryParam === void 0)
      this.recoveryParam = null;
    else
      this.recoveryParam = options.recoveryParam;
  }
  signature$1 = Signature;
  function Position() {
    this.place = 0;
  }
  function getLength(buf, p2) {
    var initial = buf[p2.place++];
    if (!(initial & 128)) {
      return initial;
    }
    var octetLen = initial & 15;
    if (octetLen === 0 || octetLen > 4) {
      return false;
    }
    if (buf[p2.place] === 0) {
      return false;
    }
    var val = 0;
    for (var i2 = 0, off2 = p2.place; i2 < octetLen; i2++, off2++) {
      val <<= 8;
      val |= buf[off2];
      val >>>= 0;
    }
    if (val <= 127) {
      return false;
    }
    p2.place = off2;
    return val;
  }
  function rmPadding(buf) {
    var i2 = 0;
    var len2 = buf.length - 1;
    while (!buf[i2] && !(buf[i2 + 1] & 128) && i2 < len2) {
      i2++;
    }
    if (i2 === 0) {
      return buf;
    }
    return buf.slice(i2);
  }
  Signature.prototype._importDER = function _importDER(data, enc) {
    data = utils2.toArray(data, enc);
    var p2 = new Position();
    if (data[p2.place++] !== 48) {
      return false;
    }
    var len2 = getLength(data, p2);
    if (len2 === false) {
      return false;
    }
    if (len2 + p2.place !== data.length) {
      return false;
    }
    if (data[p2.place++] !== 2) {
      return false;
    }
    var rlen = getLength(data, p2);
    if (rlen === false) {
      return false;
    }
    if ((data[p2.place] & 128) !== 0) {
      return false;
    }
    var r2 = data.slice(p2.place, rlen + p2.place);
    p2.place += rlen;
    if (data[p2.place++] !== 2) {
      return false;
    }
    var slen = getLength(data, p2);
    if (slen === false) {
      return false;
    }
    if (data.length !== slen + p2.place) {
      return false;
    }
    if ((data[p2.place] & 128) !== 0) {
      return false;
    }
    var s2 = data.slice(p2.place, slen + p2.place);
    if (r2[0] === 0) {
      if (r2[1] & 128) {
        r2 = r2.slice(1);
      } else {
        return false;
      }
    }
    if (s2[0] === 0) {
      if (s2[1] & 128) {
        s2 = s2.slice(1);
      } else {
        return false;
      }
    }
    this.r = new BN(r2);
    this.s = new BN(s2);
    this.recoveryParam = null;
    return true;
  };
  function constructLength(arr, len2) {
    if (len2 < 128) {
      arr.push(len2);
      return;
    }
    var octets = 1 + (Math.log(len2) / Math.LN2 >>> 3);
    arr.push(octets | 128);
    while (--octets) {
      arr.push(len2 >>> (octets << 3) & 255);
    }
    arr.push(len2);
  }
  Signature.prototype.toDER = function toDER(enc) {
    var r2 = this.r.toArray();
    var s2 = this.s.toArray();
    if (r2[0] & 128)
      r2 = [0].concat(r2);
    if (s2[0] & 128)
      s2 = [0].concat(s2);
    r2 = rmPadding(r2);
    s2 = rmPadding(s2);
    while (!s2[0] && !(s2[1] & 128)) {
      s2 = s2.slice(1);
    }
    var arr = [2];
    constructLength(arr, r2.length);
    arr = arr.concat(r2);
    arr.push(2);
    constructLength(arr, s2.length);
    var backHalf = arr.concat(s2);
    var res = [48];
    constructLength(res, backHalf.length);
    res = res.concat(backHalf);
    return utils2.encode(res, enc);
  };
  return signature$1;
}
var ec;
var hasRequiredEc;
function requireEc() {
  if (hasRequiredEc)
    return ec;
  hasRequiredEc = 1;
  var BN = bnExports;
  var HmacDRBG2 = hmacDrbg;
  var utils2 = requireUtils();
  var curves2 = requireCurves();
  var rand = requireBrorand();
  var assert2 = utils2.assert;
  var KeyPair = requireKey$1();
  var Signature = requireSignature$1();
  function EC(options) {
    if (!(this instanceof EC))
      return new EC(options);
    if (typeof options === "string") {
      assert2(Object.prototype.hasOwnProperty.call(curves2, options), "Unknown curve " + options);
      options = curves2[options];
    }
    if (options instanceof curves2.PresetCurve)
      options = { curve: options };
    this.curve = options.curve.curve;
    this.n = this.curve.n;
    this.nh = this.n.ushrn(1);
    this.g = this.curve.g;
    this.g = options.curve.g;
    this.g.precompute(options.curve.n.bitLength() + 1);
    this.hash = options.hash || options.curve.hash;
  }
  ec = EC;
  EC.prototype.keyPair = function keyPair(options) {
    return new KeyPair(this, options);
  };
  EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
    return KeyPair.fromPrivate(this, priv, enc);
  };
  EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
    return KeyPair.fromPublic(this, pub, enc);
  };
  EC.prototype.genKeyPair = function genKeyPair(options) {
    if (!options)
      options = {};
    var drbg = new HmacDRBG2({ hash: this.hash, pers: options.pers, persEnc: options.persEnc || "utf8", entropy: options.entropy || rand(this.hash.hmacStrength), entropyEnc: options.entropy && options.entropyEnc || "utf8", nonce: this.n.toArray() });
    var bytes = this.n.byteLength();
    var ns2 = this.n.sub(new BN(2));
    for (; ; ) {
      var priv = new BN(drbg.generate(bytes));
      if (priv.cmp(ns2) > 0)
        continue;
      priv.iaddn(1);
      return this.keyFromPrivate(priv);
    }
  };
  EC.prototype._truncateToN = function _truncateToN(msg, truncOnly, bitLength) {
    var byteLength2;
    if (BN.isBN(msg) || typeof msg === "number") {
      msg = new BN(msg, 16);
      byteLength2 = msg.byteLength();
    } else if (_typeof(msg) === "object") {
      byteLength2 = msg.length;
      msg = new BN(msg, 16);
    } else {
      var str = msg.toString();
      byteLength2 = str.length + 1 >>> 1;
      msg = new BN(str, 16);
    }
    if (typeof bitLength !== "number") {
      bitLength = byteLength2 * 8;
    }
    var delta = bitLength - this.n.bitLength();
    if (delta > 0)
      msg = msg.ushrn(delta);
    if (!truncOnly && msg.cmp(this.n) >= 0)
      return msg.sub(this.n);
    else
      return msg;
  };
  EC.prototype.sign = function sign(msg, key3, enc, options) {
    if (_typeof(enc) === "object") {
      options = enc;
      enc = null;
    }
    if (!options)
      options = {};
    if (typeof msg !== "string" && typeof msg !== "number" && !BN.isBN(msg)) {
      assert2(_typeof(msg) === "object" && msg && typeof msg.length === "number", "Expected message to be an array-like, a hex string, or a BN instance");
      assert2(msg.length >>> 0 === msg.length);
      for (var i2 = 0; i2 < msg.length; i2++)
        assert2((msg[i2] & 255) === msg[i2]);
    }
    key3 = this.keyFromPrivate(key3, enc);
    msg = this._truncateToN(msg, false, options.msgBitLength);
    assert2(!msg.isNeg(), "Can not sign a negative message");
    var bytes = this.n.byteLength();
    var bkey = key3.getPrivate().toArray("be", bytes);
    var nonce = msg.toArray("be", bytes);
    assert2(new BN(nonce).eq(msg), "Can not sign message");
    var drbg = new HmacDRBG2({ hash: this.hash, entropy: bkey, nonce, pers: options.pers, persEnc: options.persEnc || "utf8" });
    var ns1 = this.n.sub(new BN(1));
    for (var iter = 0; ; iter++) {
      var k3 = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
      k3 = this._truncateToN(k3, true);
      if (k3.cmpn(1) <= 0 || k3.cmp(ns1) >= 0)
        continue;
      var kp = this.g.mul(k3);
      if (kp.isInfinity())
        continue;
      var kpX = kp.getX();
      var r2 = kpX.umod(this.n);
      if (r2.cmpn(0) === 0)
        continue;
      var s2 = k3.invm(this.n).mul(r2.mul(key3.getPrivate()).iadd(msg));
      s2 = s2.umod(this.n);
      if (s2.cmpn(0) === 0)
        continue;
      var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r2) !== 0 ? 2 : 0);
      if (options.canonical && s2.cmp(this.nh) > 0) {
        s2 = this.n.sub(s2);
        recoveryParam ^= 1;
      }
      return new Signature({ r: r2, s: s2, recoveryParam });
    }
  };
  EC.prototype.verify = function verify(msg, signature2, key3, enc, options) {
    if (!options)
      options = {};
    msg = this._truncateToN(msg, false, options.msgBitLength);
    key3 = this.keyFromPublic(key3, enc);
    signature2 = new Signature(signature2, "hex");
    var r2 = signature2.r;
    var s2 = signature2.s;
    if (r2.cmpn(1) < 0 || r2.cmp(this.n) >= 0)
      return false;
    if (s2.cmpn(1) < 0 || s2.cmp(this.n) >= 0)
      return false;
    var sinv = s2.invm(this.n);
    var u1 = sinv.mul(msg).umod(this.n);
    var u2 = sinv.mul(r2).umod(this.n);
    var p2;
    if (!this.curve._maxwellTrick) {
      p2 = this.g.mulAdd(u1, key3.getPublic(), u2);
      if (p2.isInfinity())
        return false;
      return p2.getX().umod(this.n).cmp(r2) === 0;
    }
    p2 = this.g.jmulAdd(u1, key3.getPublic(), u2);
    if (p2.isInfinity())
      return false;
    return p2.eqXToP(r2);
  };
  EC.prototype.recoverPubKey = function(msg, signature2, j3, enc) {
    assert2((3 & j3) === j3, "The recovery param is more than two bits");
    signature2 = new Signature(signature2, enc);
    var n2 = this.n;
    var e2 = new BN(msg);
    var r2 = signature2.r;
    var s2 = signature2.s;
    var isYOdd = j3 & 1;
    var isSecondKey = j3 >> 1;
    if (r2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
      throw new Error("Unable to find sencond key candinate");
    if (isSecondKey)
      r2 = this.curve.pointFromX(r2.add(this.curve.n), isYOdd);
    else
      r2 = this.curve.pointFromX(r2, isYOdd);
    var rInv = signature2.r.invm(n2);
    var s1 = n2.sub(e2).mul(rInv).umod(n2);
    var s22 = s2.mul(rInv).umod(n2);
    return this.g.mulAdd(s1, r2, s22);
  };
  EC.prototype.getKeyRecoveryParam = function(e2, signature2, Q2, enc) {
    signature2 = new Signature(signature2, enc);
    if (signature2.recoveryParam !== null)
      return signature2.recoveryParam;
    for (var i2 = 0; i2 < 4; i2++) {
      var Qprime;
      try {
        Qprime = this.recoverPubKey(e2, signature2, i2);
      } catch (e3) {
        continue;
      }
      if (Qprime.eq(Q2))
        return i2;
    }
    throw new Error("Unable to find valid recovery factor");
  };
  return ec;
}
var key;
var hasRequiredKey;
function requireKey() {
  if (hasRequiredKey)
    return key;
  hasRequiredKey = 1;
  var utils2 = requireUtils();
  var assert2 = utils2.assert;
  var parseBytes = utils2.parseBytes;
  var cachedProperty = utils2.cachedProperty;
  function KeyPair(eddsa2, params) {
    this.eddsa = eddsa2;
    this._secret = parseBytes(params.secret);
    if (eddsa2.isPoint(params.pub))
      this._pub = params.pub;
    else
      this._pubBytes = parseBytes(params.pub);
  }
  KeyPair.fromPublic = function fromPublic(eddsa2, pub) {
    if (pub instanceof KeyPair)
      return pub;
    return new KeyPair(eddsa2, { pub });
  };
  KeyPair.fromSecret = function fromSecret(eddsa2, secret) {
    if (secret instanceof KeyPair)
      return secret;
    return new KeyPair(eddsa2, { secret });
  };
  KeyPair.prototype.secret = function secret() {
    return this._secret;
  };
  cachedProperty(KeyPair, "pubBytes", function pubBytes() {
    return this.eddsa.encodePoint(this.pub());
  });
  cachedProperty(KeyPair, "pub", function pub() {
    if (this._pubBytes)
      return this.eddsa.decodePoint(this._pubBytes);
    return this.eddsa.g.mul(this.priv());
  });
  cachedProperty(KeyPair, "privBytes", function privBytes() {
    var eddsa2 = this.eddsa;
    var hash2 = this.hash();
    var lastIx = eddsa2.encodingLength - 1;
    var a2 = hash2.slice(0, eddsa2.encodingLength);
    a2[0] &= 248;
    a2[lastIx] &= 127;
    a2[lastIx] |= 64;
    return a2;
  });
  cachedProperty(KeyPair, "priv", function priv() {
    return this.eddsa.decodeInt(this.privBytes());
  });
  cachedProperty(KeyPair, "hash", function hash2() {
    return this.eddsa.hash().update(this.secret()).digest();
  });
  cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
    return this.hash().slice(this.eddsa.encodingLength);
  });
  KeyPair.prototype.sign = function sign(message) {
    assert2(this._secret, "KeyPair can only verify");
    return this.eddsa.sign(message, this);
  };
  KeyPair.prototype.verify = function verify(message, sig) {
    return this.eddsa.verify(message, sig, this);
  };
  KeyPair.prototype.getSecret = function getSecret(enc) {
    assert2(this._secret, "KeyPair is public only");
    return utils2.encode(this.secret(), enc);
  };
  KeyPair.prototype.getPublic = function getPublic(enc) {
    return utils2.encode(this.pubBytes(), enc);
  };
  key = KeyPair;
  return key;
}
var signature;
var hasRequiredSignature;
function requireSignature() {
  if (hasRequiredSignature)
    return signature;
  hasRequiredSignature = 1;
  var BN = bnExports;
  var utils2 = requireUtils();
  var assert2 = utils2.assert;
  var cachedProperty = utils2.cachedProperty;
  var parseBytes = utils2.parseBytes;
  function Signature(eddsa2, sig) {
    this.eddsa = eddsa2;
    if (_typeof(sig) !== "object")
      sig = parseBytes(sig);
    if (Array.isArray(sig)) {
      assert2(sig.length === eddsa2.encodingLength * 2, "Signature has invalid size");
      sig = { R: sig.slice(0, eddsa2.encodingLength), S: sig.slice(eddsa2.encodingLength) };
    }
    assert2(sig.R && sig.S, "Signature without R or S");
    if (eddsa2.isPoint(sig.R))
      this._R = sig.R;
    if (sig.S instanceof BN)
      this._S = sig.S;
    this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
    this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
  }
  cachedProperty(Signature, "S", function S2() {
    return this.eddsa.decodeInt(this.Sencoded());
  });
  cachedProperty(Signature, "R", function R2() {
    return this.eddsa.decodePoint(this.Rencoded());
  });
  cachedProperty(Signature, "Rencoded", function Rencoded() {
    return this.eddsa.encodePoint(this.R());
  });
  cachedProperty(Signature, "Sencoded", function Sencoded() {
    return this.eddsa.encodeInt(this.S());
  });
  Signature.prototype.toBytes = function toBytes() {
    return this.Rencoded().concat(this.Sencoded());
  };
  Signature.prototype.toHex = function toHex2() {
    return utils2.encode(this.toBytes(), "hex").toUpperCase();
  };
  signature = Signature;
  return signature;
}
var eddsa;
var hasRequiredEddsa;
function requireEddsa() {
  if (hasRequiredEddsa)
    return eddsa;
  hasRequiredEddsa = 1;
  var hash2 = hash$4;
  var curves2 = requireCurves();
  var utils2 = requireUtils();
  var assert2 = utils2.assert;
  var parseBytes = utils2.parseBytes;
  var KeyPair = requireKey();
  var Signature = requireSignature();
  function EDDSA(curve2) {
    assert2(curve2 === "ed25519", "only tested with ed25519 so far");
    if (!(this instanceof EDDSA))
      return new EDDSA(curve2);
    curve2 = curves2[curve2].curve;
    this.curve = curve2;
    this.g = curve2.g;
    this.g.precompute(curve2.n.bitLength() + 1);
    this.pointClass = curve2.point().constructor;
    this.encodingLength = Math.ceil(curve2.n.bitLength() / 8);
    this.hash = hash2.sha512;
  }
  eddsa = EDDSA;
  EDDSA.prototype.sign = function sign(message, secret) {
    message = parseBytes(message);
    var key3 = this.keyFromSecret(secret);
    var r2 = this.hashInt(key3.messagePrefix(), message);
    var R2 = this.g.mul(r2);
    var Rencoded = this.encodePoint(R2);
    var s_ = this.hashInt(Rencoded, key3.pubBytes(), message).mul(key3.priv());
    var S2 = r2.add(s_).umod(this.curve.n);
    return this.makeSignature({ R: R2, S: S2, Rencoded });
  };
  EDDSA.prototype.verify = function verify(message, sig, pub) {
    message = parseBytes(message);
    sig = this.makeSignature(sig);
    if (sig.S().gte(sig.eddsa.curve.n) || sig.S().isNeg()) {
      return false;
    }
    var key3 = this.keyFromPublic(pub);
    var h2 = this.hashInt(sig.Rencoded(), key3.pubBytes(), message);
    var SG = this.g.mul(sig.S());
    var RplusAh = sig.R().add(key3.pub().mul(h2));
    return RplusAh.eq(SG);
  };
  EDDSA.prototype.hashInt = function hashInt() {
    var hash3 = this.hash();
    for (var i2 = 0; i2 < arguments.length; i2++)
      hash3.update(arguments[i2]);
    return utils2.intFromLE(hash3.digest()).umod(this.curve.n);
  };
  EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
    return KeyPair.fromPublic(this, pub);
  };
  EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
    return KeyPair.fromSecret(this, secret);
  };
  EDDSA.prototype.makeSignature = function makeSignature(sig) {
    if (sig instanceof Signature)
      return sig;
    return new Signature(this, sig);
  };
  EDDSA.prototype.encodePoint = function encodePoint(point) {
    var enc = point.getY().toArray("le", this.encodingLength);
    enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
    return enc;
  };
  EDDSA.prototype.decodePoint = function decodePoint(bytes) {
    bytes = utils2.parseBytes(bytes);
    var lastIx = bytes.length - 1;
    var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
    var xIsOdd = (bytes[lastIx] & 128) !== 0;
    var y3 = utils2.intFromLE(normed);
    return this.curve.pointFromY(y3, xIsOdd);
  };
  EDDSA.prototype.encodeInt = function encodeInt2(num) {
    return num.toArray("le", this.encodingLength);
  };
  EDDSA.prototype.decodeInt = function decodeInt2(bytes) {
    return utils2.intFromLE(bytes);
  };
  EDDSA.prototype.isPoint = function isPoint(val) {
    return val instanceof this.pointClass;
  };
  return eddsa;
}
var hasRequiredElliptic$2;
function requireElliptic$2() {
  if (hasRequiredElliptic$2)
    return elliptic$2;
  hasRequiredElliptic$2 = 1;
  (function(exports) {
    var elliptic2 = exports;
    elliptic2.version = require$$0.version;
    elliptic2.utils = requireUtils();
    elliptic2.rand = requireBrorand();
    elliptic2.curve = requireCurve();
    elliptic2.curves = requireCurves();
    elliptic2.ec = requireEc();
    elliptic2.eddsa = requireEddsa();
  })(elliptic$2);
  return elliptic$2;
}
var elliptic$1;
var hasRequiredElliptic$1;
function requireElliptic$1() {
  if (hasRequiredElliptic$1)
    return elliptic$1;
  hasRequiredElliptic$1 = 1;
  var EC = requireElliptic$2().ec;
  var ec2 = new EC("secp256k1");
  var ecparams = ec2.curve;
  var BN = ecparams.n.constructor;
  function loadCompressedPublicKey(first, xbuf) {
    var x2 = new BN(xbuf);
    if (x2.cmp(ecparams.p) >= 0)
      return null;
    x2 = x2.toRed(ecparams.red);
    var y3 = x2.redSqr().redIMul(x2).redIAdd(ecparams.b).redSqrt();
    if (first === 3 !== y3.isOdd())
      y3 = y3.redNeg();
    var x3 = x2.redSqr().redIMul(x2);
    if (!y3.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero())
      return null;
    return ec2.keyPair({ pub: { x: x2, y: y3 } });
  }
  function loadUncompressedPublicKey(first, xbuf, ybuf) {
    var x2 = new BN(xbuf);
    var y3 = new BN(ybuf);
    if (x2.cmp(ecparams.p) >= 0 || y3.cmp(ecparams.p) >= 0)
      return null;
    x2 = x2.toRed(ecparams.red);
    y3 = y3.toRed(ecparams.red);
    if ((first === 6 || first === 7) && y3.isOdd() !== (first === 7))
      return null;
    var x3 = x2.redSqr().redIMul(x2);
    if (!y3.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero())
      return null;
    return ec2.keyPair({ pub: { x: x2, y: y3 } });
  }
  function loadPublicKey(pubkey) {
    var first = pubkey[0];
    switch (first) {
      case 2:
      case 3:
        if (pubkey.length !== 33)
          return null;
        return loadCompressedPublicKey(first, pubkey.subarray(1, 33));
      case 4:
      case 6:
      case 7:
        if (pubkey.length !== 65)
          return null;
        return loadUncompressedPublicKey(first, pubkey.subarray(1, 33), pubkey.subarray(33, 65));
      default:
        return null;
    }
  }
  function savePublicKey(output, point) {
    var pubkey = point.encode(null, output.length === 33);
    for (var _i61 = 0; _i61 < output.length; ++_i61)
      output[_i61] = pubkey[_i61];
  }
  elliptic$1 = {
    contextRandomize: function contextRandomize() {
      return 0;
    },
    privateKeyVerify: function privateKeyVerify(seckey) {
      var bn2 = new BN(seckey);
      return bn2.cmp(ecparams.n) < 0 && !bn2.isZero() ? 0 : 1;
    },
    privateKeyNegate: function privateKeyNegate(seckey) {
      var bn2 = new BN(seckey);
      var negate = ecparams.n.sub(bn2).umod(ecparams.n).toArrayLike(Uint8Array, "be", 32);
      seckey.set(negate);
      return 0;
    },
    privateKeyTweakAdd: function privateKeyTweakAdd(seckey, tweak) {
      var bn2 = new BN(tweak);
      if (bn2.cmp(ecparams.n) >= 0)
        return 1;
      bn2.iadd(new BN(seckey));
      if (bn2.cmp(ecparams.n) >= 0)
        bn2.isub(ecparams.n);
      if (bn2.isZero())
        return 1;
      var tweaked = bn2.toArrayLike(Uint8Array, "be", 32);
      seckey.set(tweaked);
      return 0;
    },
    privateKeyTweakMul: function privateKeyTweakMul(seckey, tweak) {
      var bn2 = new BN(tweak);
      if (bn2.cmp(ecparams.n) >= 0 || bn2.isZero())
        return 1;
      bn2.imul(new BN(seckey));
      if (bn2.cmp(ecparams.n) >= 0)
        bn2 = bn2.umod(ecparams.n);
      var tweaked = bn2.toArrayLike(Uint8Array, "be", 32);
      seckey.set(tweaked);
      return 0;
    },
    publicKeyVerify: function publicKeyVerify(pubkey) {
      var pair = loadPublicKey(pubkey);
      return pair === null ? 1 : 0;
    },
    publicKeyCreate: function publicKeyCreate(output, seckey) {
      var bn2 = new BN(seckey);
      if (bn2.cmp(ecparams.n) >= 0 || bn2.isZero())
        return 1;
      var point = ec2.keyFromPrivate(seckey).getPublic();
      savePublicKey(output, point);
      return 0;
    },
    publicKeyConvert: function publicKeyConvert(output, pubkey) {
      var pair = loadPublicKey(pubkey);
      if (pair === null)
        return 1;
      var point = pair.getPublic();
      savePublicKey(output, point);
      return 0;
    },
    publicKeyNegate: function publicKeyNegate(output, pubkey) {
      var pair = loadPublicKey(pubkey);
      if (pair === null)
        return 1;
      var point = pair.getPublic();
      point.y = point.y.redNeg();
      savePublicKey(output, point);
      return 0;
    },
    publicKeyCombine: function publicKeyCombine(output, pubkeys) {
      var pairs = new Array(pubkeys.length);
      for (var _i62 = 0; _i62 < pubkeys.length; ++_i62) {
        pairs[_i62] = loadPublicKey(pubkeys[_i62]);
        if (pairs[_i62] === null)
          return 1;
      }
      var point = pairs[0].getPublic();
      for (var _i63 = 1; _i63 < pairs.length; ++_i63)
        point = point.add(pairs[_i63].pub);
      if (point.isInfinity())
        return 2;
      savePublicKey(output, point);
      return 0;
    },
    publicKeyTweakAdd: function publicKeyTweakAdd(output, pubkey, tweak) {
      var pair = loadPublicKey(pubkey);
      if (pair === null)
        return 1;
      tweak = new BN(tweak);
      if (tweak.cmp(ecparams.n) >= 0)
        return 2;
      var point = pair.getPublic().add(ecparams.g.mul(tweak));
      if (point.isInfinity())
        return 2;
      savePublicKey(output, point);
      return 0;
    },
    publicKeyTweakMul: function publicKeyTweakMul(output, pubkey, tweak) {
      var pair = loadPublicKey(pubkey);
      if (pair === null)
        return 1;
      tweak = new BN(tweak);
      if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero())
        return 2;
      var point = pair.getPublic().mul(tweak);
      savePublicKey(output, point);
      return 0;
    },
    signatureNormalize: function signatureNormalize(sig) {
      var r2 = new BN(sig.subarray(0, 32));
      var s2 = new BN(sig.subarray(32, 64));
      if (r2.cmp(ecparams.n) >= 0 || s2.cmp(ecparams.n) >= 0)
        return 1;
      if (s2.cmp(ec2.nh) === 1) {
        sig.set(ecparams.n.sub(s2).toArrayLike(Uint8Array, "be", 32), 32);
      }
      return 0;
    },
    // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
    // Adapted for Uint8Array instead Buffer
    signatureExport: function signatureExport(obj2, sig) {
      var sigR = sig.subarray(0, 32);
      var sigS = sig.subarray(32, 64);
      if (new BN(sigR).cmp(ecparams.n) >= 0)
        return 1;
      if (new BN(sigS).cmp(ecparams.n) >= 0)
        return 1;
      var output = obj2.output;
      var r2 = output.subarray(4, 4 + 33);
      r2[0] = 0;
      r2.set(sigR, 1);
      var lenR = 33;
      var posR = 0;
      for (; lenR > 1 && r2[posR] === 0 && !(r2[posR + 1] & 128); --lenR, ++posR)
        ;
      r2 = r2.subarray(posR);
      if (r2[0] & 128)
        return 1;
      if (lenR > 1 && r2[0] === 0 && !(r2[1] & 128))
        return 1;
      var s2 = output.subarray(6 + 33, 6 + 33 + 33);
      s2[0] = 0;
      s2.set(sigS, 1);
      var lenS = 33;
      var posS = 0;
      for (; lenS > 1 && s2[posS] === 0 && !(s2[posS + 1] & 128); --lenS, ++posS)
        ;
      s2 = s2.subarray(posS);
      if (s2[0] & 128)
        return 1;
      if (lenS > 1 && s2[0] === 0 && !(s2[1] & 128))
        return 1;
      obj2.outputlen = 6 + lenR + lenS;
      output[0] = 48;
      output[1] = obj2.outputlen - 2;
      output[2] = 2;
      output[3] = r2.length;
      output.set(r2, 4);
      output[4 + lenR] = 2;
      output[5 + lenR] = s2.length;
      output.set(s2, 6 + lenR);
      return 0;
    },
    // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
    // Adapted for Uint8Array instead Buffer
    signatureImport: function signatureImport(output, sig) {
      if (sig.length < 8)
        return 1;
      if (sig.length > 72)
        return 1;
      if (sig[0] !== 48)
        return 1;
      if (sig[1] !== sig.length - 2)
        return 1;
      if (sig[2] !== 2)
        return 1;
      var lenR = sig[3];
      if (lenR === 0)
        return 1;
      if (5 + lenR >= sig.length)
        return 1;
      if (sig[4 + lenR] !== 2)
        return 1;
      var lenS = sig[5 + lenR];
      if (lenS === 0)
        return 1;
      if (6 + lenR + lenS !== sig.length)
        return 1;
      if (sig[4] & 128)
        return 1;
      if (lenR > 1 && sig[4] === 0 && !(sig[5] & 128))
        return 1;
      if (sig[lenR + 6] & 128)
        return 1;
      if (lenS > 1 && sig[lenR + 6] === 0 && !(sig[lenR + 7] & 128))
        return 1;
      var sigR = sig.subarray(4, 4 + lenR);
      if (sigR.length === 33 && sigR[0] === 0)
        sigR = sigR.subarray(1);
      if (sigR.length > 32)
        return 1;
      var sigS = sig.subarray(6 + lenR);
      if (sigS.length === 33 && sigS[0] === 0)
        sigS = sigS.slice(1);
      if (sigS.length > 32)
        throw new Error("S length is too long");
      var r2 = new BN(sigR);
      if (r2.cmp(ecparams.n) >= 0)
        r2 = new BN(0);
      var s2 = new BN(sig.subarray(6 + lenR));
      if (s2.cmp(ecparams.n) >= 0)
        s2 = new BN(0);
      output.set(r2.toArrayLike(Uint8Array, "be", 32), 0);
      output.set(s2.toArrayLike(Uint8Array, "be", 32), 32);
      return 0;
    },
    ecdsaSign: function ecdsaSign(obj2, message, seckey, data, noncefn) {
      if (noncefn) {
        var _noncefn = noncefn;
        noncefn = function noncefn2(counter) {
          var nonce = _noncefn(message, seckey, null, data, counter);
          var isValid = nonce instanceof Uint8Array && nonce.length === 32;
          if (!isValid)
            throw new Error("This is the way");
          return new BN(nonce);
        };
      }
      var d2 = new BN(seckey);
      if (d2.cmp(ecparams.n) >= 0 || d2.isZero())
        return 1;
      var sig;
      try {
        sig = ec2.sign(message, seckey, { canonical: true, k: noncefn, pers: data });
      } catch (err) {
        return 1;
      }
      obj2.signature.set(sig.r.toArrayLike(Uint8Array, "be", 32), 0);
      obj2.signature.set(sig.s.toArrayLike(Uint8Array, "be", 32), 32);
      obj2.recid = sig.recoveryParam;
      return 0;
    },
    ecdsaVerify: function ecdsaVerify(sig, msg32, pubkey) {
      var sigObj = { r: sig.subarray(0, 32), s: sig.subarray(32, 64) };
      var sigr = new BN(sigObj.r);
      var sigs = new BN(sigObj.s);
      if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0)
        return 1;
      if (sigs.cmp(ec2.nh) === 1 || sigr.isZero() || sigs.isZero())
        return 3;
      var pair = loadPublicKey(pubkey);
      if (pair === null)
        return 2;
      var point = pair.getPublic();
      var isValid = ec2.verify(msg32, sigObj, point);
      return isValid ? 0 : 3;
    },
    ecdsaRecover: function ecdsaRecover(output, sig, recid, msg32) {
      var sigObj = { r: sig.slice(0, 32), s: sig.slice(32, 64) };
      var sigr = new BN(sigObj.r);
      var sigs = new BN(sigObj.s);
      if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0)
        return 1;
      if (sigr.isZero() || sigs.isZero())
        return 2;
      var point;
      try {
        point = ec2.recoverPubKey(msg32, sigObj, recid);
      } catch (err) {
        return 2;
      }
      savePublicKey(output, point);
      return 0;
    },
    ecdh: function ecdh(output, pubkey, seckey, data, hashfn, xbuf, ybuf) {
      var pair = loadPublicKey(pubkey);
      if (pair === null)
        return 1;
      var scalar = new BN(seckey);
      if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero())
        return 2;
      var point = pair.getPublic().mul(scalar);
      if (hashfn === void 0) {
        var _data = point.encode(null, true);
        var _sha = ec2.hash().update(_data).digest();
        for (var _i64 = 0; _i64 < 32; ++_i64)
          output[_i64] = _sha[_i64];
      } else {
        if (!xbuf)
          xbuf = new Uint8Array(32);
        var _x122 = point.getX().toArray("be", 32);
        for (var _i65 = 0; _i65 < 32; ++_i65)
          xbuf[_i65] = _x122[_i65];
        if (!ybuf)
          ybuf = new Uint8Array(32);
        var _y = point.getY().toArray("be", 32);
        for (var _i66 = 0; _i66 < 32; ++_i66)
          ybuf[_i66] = _y[_i66];
        var _hash5 = hashfn(xbuf, ybuf, data);
        var isValid = _hash5 instanceof Uint8Array && _hash5.length === output.length;
        if (!isValid)
          return 2;
        output.set(_hash5);
      }
      return 0;
    }
  };
  return elliptic$1;
}
var elliptic;
var hasRequiredElliptic;
function requireElliptic() {
  if (hasRequiredElliptic)
    return elliptic;
  hasRequiredElliptic = 1;
  elliptic = requireLib()(requireElliptic$1());
  return elliptic;
}
var secp256k1_1;
var hasRequiredSecp256k1;
function requireSecp256k1() {
  if (hasRequiredSecp256k1)
    return secp256k1_1;
  hasRequiredSecp256k1 = 1;
  var secp256k12 = requireElliptic();
  var sha2562 = require$$0$1.sha256;
  secp256k1_1 = function secp256k1_12(randomBytes2) {
    var privateKeyLength = 32;
    function generateKey() {
      var privateKey;
      do {
        privateKey = randomBytes2(32);
      } while (!secp256k12.privateKeyVerify(privateKey));
      return privateKey;
    }
    function hashAndSign(_x123, _x124) {
      return _hashAndSign.apply(this, arguments);
    }
    function _hashAndSign() {
      _hashAndSign = _asyncToGenerator(_regeneratorRuntime().mark(function _callee83(key3, msg) {
        var _yield$sha256$digest, digest11, sig;
        return _regeneratorRuntime().wrap(function _callee83$(_context84) {
          while (1)
            switch (_context84.prev = _context84.next) {
              case 0:
                _context84.next = 2;
                return sha2562.digest(msg);
              case 2:
                _yield$sha256$digest = _context84.sent;
                digest11 = _yield$sha256$digest.digest;
                sig = secp256k12.ecdsaSign(digest11, key3);
                return _context84.abrupt("return", secp256k12.signatureExport(sig.signature));
              case 6:
              case "end":
                return _context84.stop();
            }
        }, _callee83);
      }));
      return _hashAndSign.apply(this, arguments);
    }
    function hashAndVerify(_x125, _x126, _x127) {
      return _hashAndVerify.apply(this, arguments);
    }
    function _hashAndVerify() {
      _hashAndVerify = _asyncToGenerator(_regeneratorRuntime().mark(function _callee84(key3, sig, msg) {
        var _yield$sha256$digest2, digest11;
        return _regeneratorRuntime().wrap(function _callee84$(_context85) {
          while (1)
            switch (_context85.prev = _context85.next) {
              case 0:
                _context85.next = 2;
                return sha2562.digest(msg);
              case 2:
                _yield$sha256$digest2 = _context85.sent;
                digest11 = _yield$sha256$digest2.digest;
                sig = secp256k12.signatureImport(sig);
                return _context85.abrupt("return", secp256k12.ecdsaVerify(sig, digest11, key3));
              case 6:
              case "end":
                return _context85.stop();
            }
        }, _callee84);
      }));
      return _hashAndVerify.apply(this, arguments);
    }
    function compressPublicKey(key3) {
      if (!secp256k12.publicKeyVerify(key3)) {
        throw new Error("Invalid public key");
      }
      return secp256k12.publicKeyConvert(key3, true);
    }
    function decompressPublicKey(key3) {
      return secp256k12.publicKeyConvert(key3, false);
    }
    function validatePrivateKey(key3) {
      if (!secp256k12.privateKeyVerify(key3)) {
        throw new Error("Invalid private key");
      }
    }
    function validatePublicKey(key3) {
      if (!secp256k12.publicKeyVerify(key3)) {
        throw new Error("Invalid public key");
      }
    }
    function computePublicKey(privateKey) {
      validatePrivateKey(privateKey);
      return secp256k12.publicKeyCreate(privateKey);
    }
    return { generateKey, privateKeyLength, hashAndSign, hashAndVerify, compressPublicKey, decompressPublicKey, validatePrivateKey, validatePublicKey, computePublicKey };
  };
  return secp256k1_1;
}
var sha256 = require$$0$1.sha256;
var errcode$2 = errCode;
var uint8ArrayEquals = require$$6.equals;
var uint8ArrayToString = require$$4$1.toString;
var exporter = exporter$3;
var secp256k1Class = function secp256k1Class2(keysProtobuf, randomBytes2, crypto2) {
  crypto2 = crypto2 || requireSecp256k1()(randomBytes2);
  var Secp256k1PublicKey = function() {
    function Secp256k1PublicKey2(key3) {
      _classCallCheck2(this, Secp256k1PublicKey2);
      crypto2.validatePublicKey(key3);
      this._key = key3;
    }
    return _createClass(Secp256k1PublicKey2, [{ key: "verify", value: function verify(data, sig) {
      return crypto2.hashAndVerify(this._key, sig, data);
    } }, { key: "marshal", value: function marshal() {
      return crypto2.compressPublicKey(this._key);
    } }, { key: "bytes", get: function get5() {
      return keysProtobuf.PublicKey.encode({ Type: keysProtobuf.KeyType.Secp256k1, Data: this.marshal() }).finish();
    } }, { key: "equals", value: function equals2(key3) {
      return uint8ArrayEquals(this.bytes, key3.bytes);
    } }, { key: "hash", value: function() {
      var _hash6 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee85() {
        var _yield$sha256$digest3, bytes;
        return _regeneratorRuntime().wrap(function _callee85$(_context86) {
          while (1)
            switch (_context86.prev = _context86.next) {
              case 0:
                _context86.next = 2;
                return sha256.digest(this.bytes);
              case 2:
                _yield$sha256$digest3 = _context86.sent;
                bytes = _yield$sha256$digest3.bytes;
                return _context86.abrupt("return", bytes);
              case 5:
              case "end":
                return _context86.stop();
            }
        }, _callee85, this);
      }));
      function hash2() {
        return _hash6.apply(this, arguments);
      }
      return hash2;
    }() }]);
  }();
  var Secp256k1PrivateKey = function() {
    function Secp256k1PrivateKey2(key3, publicKey) {
      _classCallCheck2(this, Secp256k1PrivateKey2);
      this._key = key3;
      this._publicKey = publicKey || crypto2.computePublicKey(key3);
      crypto2.validatePrivateKey(this._key);
      crypto2.validatePublicKey(this._publicKey);
    }
    return _createClass(Secp256k1PrivateKey2, [{ key: "sign", value: function sign(message) {
      return crypto2.hashAndSign(this._key, message);
    } }, { key: "public", get: function get5() {
      return new Secp256k1PublicKey(this._publicKey);
    } }, { key: "marshal", value: function marshal() {
      return this._key;
    } }, { key: "bytes", get: function get5() {
      return keysProtobuf.PrivateKey.encode({ Type: keysProtobuf.KeyType.Secp256k1, Data: this.marshal() }).finish();
    } }, { key: "equals", value: function equals2(key3) {
      return uint8ArrayEquals(this.bytes, key3.bytes);
    } }, {
      key: "hash",
      value: function() {
        var _hash7 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee86() {
          var _yield$sha256$digest4, bytes;
          return _regeneratorRuntime().wrap(function _callee86$(_context87) {
            while (1)
              switch (_context87.prev = _context87.next) {
                case 0:
                  _context87.next = 2;
                  return sha256.digest(this.bytes);
                case 2:
                  _yield$sha256$digest4 = _context87.sent;
                  bytes = _yield$sha256$digest4.bytes;
                  return _context87.abrupt("return", bytes);
                case 5:
                case "end":
                  return _context87.stop();
              }
          }, _callee86, this);
        }));
        function hash2() {
          return _hash7.apply(this, arguments);
        }
        return hash2;
      }()
      /**
      * Gets the ID of the key.
      *
      * The key id is the base58 encoding of the SHA-256 multihash of its public key.
      * The public key is a protobuf encoding containing a type and the DER encoding
      * of the PKCS SubjectPublicKeyInfo.
      *
      * @returns {Promise<string>}
      */
    }, { key: "id", value: function() {
      var _id3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee87() {
        var hash2;
        return _regeneratorRuntime().wrap(function _callee87$(_context88) {
          while (1)
            switch (_context88.prev = _context88.next) {
              case 0:
                _context88.next = 2;
                return this.public.hash();
              case 2:
                hash2 = _context88.sent;
                return _context88.abrupt("return", uint8ArrayToString(hash2, "base58btc"));
              case 4:
              case "end":
                return _context88.stop();
            }
        }, _callee87, this);
      }));
      function id() {
        return _id3.apply(this, arguments);
      }
      return id;
    }() }, { key: "export", value: function() {
      var _export5 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee88(password) {
        var format, _args5 = arguments;
        return _regeneratorRuntime().wrap(function _callee88$(_context89) {
          while (1)
            switch (_context89.prev = _context89.next) {
              case 0:
                format = _args5.length > 1 && _args5[1] !== void 0 ? _args5[1] : "libp2p-key";
                if (!(format === "libp2p-key")) {
                  _context89.next = 5;
                  break;
                }
                return _context89.abrupt("return", exporter.export(this.bytes, password));
              case 5:
                throw errcode$2(new Error("export format '".concat(format, "' is not supported")), "ERR_INVALID_EXPORT_FORMAT");
              case 6:
              case "end":
                return _context89.stop();
            }
        }, _callee88, this);
      }));
      function _export(_x128) {
        return _export5.apply(this, arguments);
      }
      return _export;
    }() }]);
  }();
  function unmarshalSecp256k1PrivateKey(bytes) {
    return new Secp256k1PrivateKey(bytes);
  }
  function unmarshalSecp256k1PublicKey(bytes) {
    return new Secp256k1PublicKey(bytes);
  }
  function generateKeyPair2() {
    return _generateKeyPair2.apply(this, arguments);
  }
  function _generateKeyPair2() {
    _generateKeyPair2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee89() {
      var privateKeyBytes;
      return _regeneratorRuntime().wrap(function _callee89$(_context90) {
        while (1)
          switch (_context90.prev = _context90.next) {
            case 0:
              _context90.next = 2;
              return crypto2.generateKey();
            case 2:
              privateKeyBytes = _context90.sent;
              return _context90.abrupt("return", new Secp256k1PrivateKey(privateKeyBytes));
            case 4:
            case "end":
              return _context90.stop();
          }
      }, _callee89);
    }));
    return _generateKeyPair2.apply(this, arguments);
  }
  return { Secp256k1PublicKey, Secp256k1PrivateKey, unmarshalSecp256k1PrivateKey, unmarshalSecp256k1PublicKey, generateKeyPair: generateKeyPair2 };
};
var keyStretcher;
var hasRequiredKeyStretcher;
function requireKeyStretcher() {
  if (hasRequiredKeyStretcher)
    return keyStretcher;
  hasRequiredKeyStretcher = 1;
  var errcode2 = errCode;
  var uint8ArrayConcat = require$$5.concat;
  var uint8ArrayFromString2 = require$$5$1.fromString;
  var hmac3 = indexBrowser;
  var cipherMap = { "AES-128": { ivSize: 16, keySize: 16 }, "AES-256": { ivSize: 16, keySize: 32 }, Blowfish: { ivSize: 8, cipherKeySize: 32 } };
  keyStretcher = function() {
    var _ref70 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee90(cipherType, hash2, secret) {
      var cipher, allowed, cipherKeySize, ivSize, hmacKeySize, seed, resultLength, m2, a2, result, j3, _b, todo, half, resultBuffer, r1, r2, createKey;
      return _regeneratorRuntime().wrap(function _callee90$(_context91) {
        while (1)
          switch (_context91.prev = _context91.next) {
            case 0:
              cipher = cipherMap[cipherType];
              if (cipher) {
                _context91.next = 4;
                break;
              }
              allowed = Object.keys(cipherMap).join(" / ");
              throw errcode2(new Error("unknown cipher type '".concat(cipherType, "'. Must be ").concat(allowed)), "ERR_INVALID_CIPHER_TYPE");
            case 4:
              if (hash2) {
                _context91.next = 6;
                break;
              }
              throw errcode2(new Error("missing hash type"), "ERR_MISSING_HASH_TYPE");
            case 6:
              cipherKeySize = cipher.keySize;
              ivSize = cipher.ivSize;
              hmacKeySize = 20;
              seed = uint8ArrayFromString2("key expansion");
              resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize);
              _context91.next = 13;
              return hmac3.create(hash2, secret);
            case 13:
              m2 = _context91.sent;
              _context91.next = 16;
              return m2.digest(seed);
            case 16:
              a2 = _context91.sent;
              result = [];
              j3 = 0;
            case 19:
              if (!(j3 < resultLength)) {
                _context91.next = 32;
                break;
              }
              _context91.next = 22;
              return m2.digest(uint8ArrayConcat([a2, seed]));
            case 22:
              _b = _context91.sent;
              todo = _b.length;
              if (j3 + todo > resultLength) {
                todo = resultLength - j3;
              }
              result.push(_b);
              j3 += todo;
              _context91.next = 29;
              return m2.digest(a2);
            case 29:
              a2 = _context91.sent;
              _context91.next = 19;
              break;
            case 32:
              half = resultLength / 2;
              resultBuffer = uint8ArrayConcat(result);
              r1 = resultBuffer.slice(0, half);
              r2 = resultBuffer.slice(half, resultLength);
              createKey = function createKey2(res) {
                return { iv: res.slice(0, ivSize), cipherKey: res.slice(ivSize, ivSize + cipherKeySize), macKey: res.slice(ivSize + cipherKeySize) };
              };
              return _context91.abrupt("return", { k1: createKey(r1), k2: createKey(r2) });
            case 38:
            case "end":
              return _context91.stop();
          }
      }, _callee90);
    }));
    return function keyStretcher2(_x129, _x130, _x131) {
      return _ref70.apply(this, arguments);
    };
  }();
  return keyStretcher;
}
var ecdhBrowser = {};
var validateCurveType;
var hasRequiredValidateCurveType;
function requireValidateCurveType() {
  if (hasRequiredValidateCurveType)
    return validateCurveType;
  hasRequiredValidateCurveType = 1;
  var errcode2 = errCode;
  validateCurveType = function validateCurveType2(curveTypes, type) {
    if (!curveTypes.includes(type)) {
      var names = curveTypes.join(" / ");
      throw errcode2(new Error("Unknown curve: ".concat(type, ". Must be ").concat(names)), "ERR_INVALID_CURVE");
    }
  };
  return validateCurveType;
}
var hasRequiredEcdhBrowser;
function requireEcdhBrowser() {
  if (hasRequiredEcdhBrowser)
    return ecdhBrowser;
  hasRequiredEcdhBrowser = 1;
  var errcode2 = errCode;
  var webcrypto2 = webcrypto$3;
  var base64urlToBuffer = util.base64urlToBuffer;
  var validateCurveType2 = requireValidateCurveType();
  var uint8ArrayToString2 = require$$4$1.toString;
  var uint8ArrayConcat = require$$5.concat;
  var uint8ArrayEquals2 = require$$6.equals;
  var bits = { "P-256": 256, "P-384": 384, "P-521": 521 };
  ecdhBrowser.generateEphmeralKeyPair = function() {
    var _ref74 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee92(curve2) {
      var pair, genSharedKey, publicKey;
      return _regeneratorRuntime().wrap(function _callee92$(_context93) {
        while (1)
          switch (_context93.prev = _context93.next) {
            case 0:
              validateCurveType2(Object.keys(bits), curve2);
              _context93.next = 3;
              return webcrypto2.get().subtle.generateKey({ name: "ECDH", namedCurve: curve2 }, true, ["deriveBits"]);
            case 3:
              pair = _context93.sent;
              genSharedKey = function() {
                var _ref75 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee91(theirPub, forcePrivate) {
                  var privateKey, keys2, buffer2;
                  return _regeneratorRuntime().wrap(function _callee91$(_context92) {
                    while (1)
                      switch (_context92.prev = _context92.next) {
                        case 0:
                          if (!forcePrivate) {
                            _context92.next = 6;
                            break;
                          }
                          _context92.next = 3;
                          return webcrypto2.get().subtle.importKey("jwk", unmarshalPrivateKey2(curve2, forcePrivate), { name: "ECDH", namedCurve: curve2 }, false, ["deriveBits"]);
                        case 3:
                          privateKey = _context92.sent;
                          _context92.next = 7;
                          break;
                        case 6:
                          privateKey = pair.privateKey;
                        case 7:
                          _context92.next = 9;
                          return webcrypto2.get().subtle.importKey("jwk", unmarshalPublicKey3(curve2, theirPub), { name: "ECDH", namedCurve: curve2 }, false, []);
                        case 9:
                          _context92.t0 = _context92.sent;
                          _context92.t1 = privateKey;
                          keys2 = [_context92.t0, _context92.t1];
                          _context92.next = 14;
                          return webcrypto2.get().subtle.deriveBits({ name: "ECDH", namedCurve: curve2, public: keys2[0] }, keys2[1], bits[curve2]);
                        case 14:
                          buffer2 = _context92.sent;
                          return _context92.abrupt("return", new Uint8Array(buffer2, buffer2.byteOffset, buffer2.byteLength));
                        case 16:
                        case "end":
                          return _context92.stop();
                      }
                  }, _callee91);
                }));
                return function genSharedKey2(_x133, _x134) {
                  return _ref75.apply(this, arguments);
                };
              }();
              _context93.next = 7;
              return webcrypto2.get().subtle.exportKey("jwk", pair.publicKey);
            case 7:
              publicKey = _context93.sent;
              return _context93.abrupt("return", { key: marshalPublicKey3(publicKey), genSharedKey });
            case 9:
            case "end":
              return _context93.stop();
          }
      }, _callee92);
    }));
    return function(_x132) {
      return _ref74.apply(this, arguments);
    };
  }();
  var curveLengths = { "P-256": 32, "P-384": 48, "P-521": 66 };
  function marshalPublicKey3(jwk) {
    var byteLen = curveLengths[jwk.crv];
    return uint8ArrayConcat([
      Uint8Array.from([4]),
      // uncompressed point
      base64urlToBuffer(jwk.x, byteLen),
      base64urlToBuffer(jwk.y, byteLen)
    ], 1 + byteLen * 2);
  }
  function unmarshalPublicKey3(curve2, key3) {
    var byteLen = curveLengths[curve2];
    if (uint8ArrayEquals2(!key3.slice(0, 1), Uint8Array.from([4]))) {
      throw errcode2(new Error("Cannot unmarshal public key - invalid key format"), "ERR_INVALID_KEY_FORMAT");
    }
    return { kty: "EC", crv: curve2, x: uint8ArrayToString2(key3.slice(1, byteLen + 1), "base64url"), y: uint8ArrayToString2(key3.slice(1 + byteLen), "base64url"), ext: true };
  }
  var unmarshalPrivateKey2 = function unmarshalPrivateKey3(curve2, key3) {
    return _objectSpread(_objectSpread({}, unmarshalPublicKey3(curve2, key3.public)), {}, { d: uint8ArrayToString2(key3.private, "base64url") });
  };
  return ecdhBrowser;
}
var ephemeralKeys;
var hasRequiredEphemeralKeys;
function requireEphemeralKeys() {
  if (hasRequiredEphemeralKeys)
    return ephemeralKeys;
  hasRequiredEphemeralKeys = 1;
  var ecdh = requireEcdhBrowser();
  ephemeralKeys = function() {
    var _ref76 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee93(curve2) {
      return _regeneratorRuntime().wrap(function _callee93$(_context94) {
        while (1)
          switch (_context94.prev = _context94.next) {
            case 0:
              return _context94.abrupt("return", ecdh.generateEphmeralKeyPair(curve2));
            case 1:
            case "end":
              return _context94.stop();
          }
      }, _callee93);
    }));
    return function ephemeralKeys2(_x135) {
      return _ref76.apply(this, arguments);
    };
  }();
  return ephemeralKeys;
}
var keysPBM = keys$2;
var forge = forge$t;
var errcode$1 = errCode;
var uint8ArrayFromString = require$$5$1.fromString;
var importer = importer$1;
var supportedKeys = { rsa: rsaClass, ed25519: ed25519Class, secp256k1: secp256k1Class(keysPBM, randomBytes_1) };
var ErrMissingSecp256K1 = { message: "secp256k1 support requires libp2p-crypto-secp256k1 package", code: "ERR_MISSING_PACKAGE" };
function typeToKey(type) {
  var key3 = supportedKeys[type.toLowerCase()];
  if (!key3) {
    var supported = Object.keys(supportedKeys).join(" / ");
    throw errcode$1(new Error("invalid or unsupported key type ".concat(type, ". Must be ").concat(supported)), "ERR_UNSUPPORTED_KEY_TYPE");
  }
  return key3;
}
var generateKeyPair = function() {
  var _ref77 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee94(type, bits) {
    return _regeneratorRuntime().wrap(function _callee94$(_context95) {
      while (1)
        switch (_context95.prev = _context95.next) {
          case 0:
            return _context95.abrupt("return", typeToKey(type).generateKeyPair(bits));
          case 1:
          case "end":
            return _context95.stop();
        }
    }, _callee94);
  }));
  return function generateKeyPair2(_x136, _x137) {
    return _ref77.apply(this, arguments);
  };
}();
var generateKeyPairFromSeed = function() {
  var _ref78 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee95(type, seed, bits) {
    var key3;
    return _regeneratorRuntime().wrap(function _callee95$(_context96) {
      while (1)
        switch (_context96.prev = _context96.next) {
          case 0:
            key3 = typeToKey(type);
            if (!(type.toLowerCase() !== "ed25519")) {
              _context96.next = 3;
              break;
            }
            throw errcode$1(new Error("Seed key derivation is unimplemented for RSA or secp256k1"), "ERR_UNSUPPORTED_KEY_DERIVATION_TYPE");
          case 3:
            return _context96.abrupt("return", key3.generateKeyPairFromSeed(seed, bits));
          case 4:
          case "end":
            return _context96.stop();
        }
    }, _callee95);
  }));
  return function generateKeyPairFromSeed2(_x138, _x139, _x140) {
    return _ref78.apply(this, arguments);
  };
}();
var unmarshalPublicKey = function unmarshalPublicKey2(buf) {
  var decoded = keysPBM.PublicKey.decode(buf);
  var data = decoded.Data;
  switch (decoded.Type) {
    case keysPBM.KeyType.RSA:
      return supportedKeys.rsa.unmarshalRsaPublicKey(data);
    case keysPBM.KeyType.Ed25519:
      return supportedKeys.ed25519.unmarshalEd25519PublicKey(data);
    case keysPBM.KeyType.Secp256k1:
      if (supportedKeys.secp256k1) {
        return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(data);
      } else {
        throw errcode$1(new Error(ErrMissingSecp256K1.message), ErrMissingSecp256K1.code);
      }
    default:
      typeToKey(decoded.Type);
  }
};
var marshalPublicKey = function marshalPublicKey2(key3, type) {
  type = (type || "rsa").toLowerCase();
  typeToKey(type);
  return key3.bytes;
};
var unmarshalPrivateKey = function() {
  var _ref79 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee96(buf) {
    var decoded, data;
    return _regeneratorRuntime().wrap(function _callee96$(_context97) {
      while (1)
        switch (_context97.prev = _context97.next) {
          case 0:
            decoded = keysPBM.PrivateKey.decode(buf);
            data = decoded.Data;
            _context97.t0 = decoded.Type;
            _context97.next = _context97.t0 === keysPBM.KeyType.RSA ? 5 : _context97.t0 === keysPBM.KeyType.Ed25519 ? 6 : _context97.t0 === keysPBM.KeyType.Secp256k1 ? 7 : 12;
            break;
          case 5:
            return _context97.abrupt("return", supportedKeys.rsa.unmarshalRsaPrivateKey(data));
          case 6:
            return _context97.abrupt("return", supportedKeys.ed25519.unmarshalEd25519PrivateKey(data));
          case 7:
            if (!supportedKeys.secp256k1) {
              _context97.next = 11;
              break;
            }
            return _context97.abrupt("return", supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(data));
          case 11:
            throw errcode$1(new Error(ErrMissingSecp256K1.message), ErrMissingSecp256K1.code);
          case 12:
            typeToKey(decoded.Type);
          case 13:
          case "end":
            return _context97.stop();
        }
    }, _callee96);
  }));
  return function unmarshalPrivateKey2(_x141) {
    return _ref79.apply(this, arguments);
  };
}();
var marshalPrivateKey = function marshalPrivateKey2(key3, type) {
  type = (type || "rsa").toLowerCase();
  typeToKey(type);
  return key3.bytes;
};
var importKey = function() {
  var _ref80 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee97(encryptedKey, password) {
    var _key22, key3, der2;
    return _regeneratorRuntime().wrap(function _callee97$(_context98) {
      while (1)
        switch (_context98.prev = _context98.next) {
          case 0:
            _context98.prev = 0;
            _context98.next = 3;
            return importer.import(encryptedKey, password);
          case 3:
            _key22 = _context98.sent;
            return _context98.abrupt("return", unmarshalPrivateKey(_key22));
          case 7:
            _context98.prev = 7;
            _context98.t0 = _context98["catch"](0);
          case 9:
            key3 = forge.pki.decryptRsaPrivateKey(encryptedKey, password);
            if (!(key3 === null)) {
              _context98.next = 12;
              break;
            }
            throw errcode$1(new Error("Cannot read the key, most likely the password is wrong or not a RSA key"), "ERR_CANNOT_DECRYPT_PEM");
          case 12:
            der2 = forge.asn1.toDer(forge.pki.privateKeyToAsn1(key3));
            der2 = uint8ArrayFromString(der2.getBytes(), "ascii");
            return _context98.abrupt("return", supportedKeys.rsa.unmarshalRsaPrivateKey(der2));
          case 15:
          case "end":
            return _context98.stop();
        }
    }, _callee97, null, [[0, 7]]);
  }));
  return function importKey2(_x142, _x143) {
    return _ref80.apply(this, arguments);
  };
}();
var keys$1 = { supportedKeys, keysPBM, keyStretcher: requireKeyStretcher(), generateEphemeralKeyPair: requireEphemeralKeys(), generateKeyPair, generateKeyPairFromSeed, unmarshalPublicKey, marshalPublicKey, unmarshalPrivateKey, marshalPrivateKey, import: importKey };
var forgePbkdf2 = pbkdf2$1;
var forgeUtil = utilExports;
var errcode = errCode;
var hashName = { sha1: "sha1", "sha2-256": "sha256", "sha2-512": "sha512" };
function pbkdf2(password, salt2, iterations, keySize, hash2) {
  var hasher = hashName[hash2];
  if (!hasher) {
    var types = Object.keys(hashName).join(" / ");
    throw errcode(new Error("Hash '".concat(hash2, "' is unknown or not supported. Must be ").concat(types)), "ERR_UNSUPPORTED_HASH_TYPE");
  }
  var dek = forgePbkdf2(password, salt2, iterations, keySize, hasher);
  return forgeUtil.encode64(dek);
}
var pbkdf2_1 = pbkdf2;
var hmac = indexBrowser;
var aes = aes$1;
var keys = keys$1;
src$1.aes = aes;
src$1.hmac = hmac;
src$1.keys = keys;
src$1.randomBytes = randomBytes_1;
src$1.pbkdf2 = pbkdf2_1;
var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(arweaveMnemonicKeys, "__esModule", { value: true });
arweaveMnemonicKeys.getKeyFromMnemonic = arweaveMnemonicKeys.generateMnemonic = void 0;
var human_crypto_keys_1 = require$$0$3;
var libp2p_crypto_1 = __importDefault(src$1);
function generateMnemonic() {
  return __awaiter(this, void 0, void 0, _regeneratorRuntime().mark(function _callee98() {
    var keys2;
    return _regeneratorRuntime().wrap(function _callee98$(_context99) {
      while (1)
        switch (_context99.prev = _context99.next) {
          case 0:
            _context99.next = 2;
            return human_crypto_keys_1.generateKeyPair({ id: "rsa", modulusLength: 4096 }, { privateKeyFormat: "pkcs1-pem" });
          case 2:
            keys2 = _context99.sent;
            return _context99.abrupt("return", keys2.mnemonic);
          case 4:
          case "end":
            return _context99.stop();
        }
    }, _callee98);
  }));
}
arweaveMnemonicKeys.generateMnemonic = generateMnemonic;
function getKeyFromMnemonic(mnemonic) {
  return __awaiter(this, void 0, void 0, _regeneratorRuntime().mark(function _callee99() {
    var keyPair, privateKey;
    return _regeneratorRuntime().wrap(function _callee99$(_context100) {
      while (1)
        switch (_context100.prev = _context100.next) {
          case 0:
            _context100.next = 2;
            return human_crypto_keys_1.getKeyPairFromMnemonic(mnemonic, { id: "rsa", modulusLength: 4096 }, { privateKeyFormat: "pkcs1-pem" });
          case 2:
            keyPair = _context100.sent;
            _context100.next = 5;
            return libp2p_crypto_1.default.keys.import(keyPair.privateKey, "");
          case 5:
            privateKey = _context100.sent._key;
            delete privateKey.alg;
            delete privateKey.key_ops;
            return _context100.abrupt("return", privateKey);
          case 9:
          case "end":
            return _context100.stop();
        }
    }, _callee99);
  }));
}
arweaveMnemonicKeys.getKeyFromMnemonic = getKeyFromMnemonic;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k3, k22) {
    if (k22 === void 0)
      k22 = k3;
    Object.defineProperty(o2, k22, { enumerable: true, get: function get5() {
      return m2[k3];
    } });
  } : function(o2, m2, k3, k22) {
    if (k22 === void 0)
      k22 = k3;
    o2[k22] = m2[k3];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(arweaveMnemonicKeys, exports);
})(dist);
var xr = Object.create;
var it = Object.defineProperty;
var mr = Object.getOwnPropertyDescriptor;
var Br = Object.getOwnPropertyNames;
var Er = Object.getPrototypeOf;
var br = Object.prototype.hasOwnProperty;
var T = function T2(e2, t2) {
  return function() {
    return t2 || e2((t2 = { exports: {} }).exports, t2), t2.exports;
  };
};
var Ar$1 = function Ar$12(e2, t2) {
  for (var r2 in t2)
    it(e2, r2, { get: t2[r2], enumerable: true });
};
var Tr = function Tr2(e2, t2, r2, n2) {
  if (t2 && _typeof(t2) == "object" || typeof t2 == "function") {
    var _iterator10 = _createForOfIteratorHelper(Br(t2)), _step10;
    try {
      var _loop = function _loop2() {
        var i2 = _step10.value;
        !br.call(e2, i2) && i2 !== r2 && it(e2, i2, { get: function get5() {
          return t2[i2];
        }, enumerable: !(n2 = mr(t2, i2)) || n2.enumerable });
      };
      for (_iterator10.s(); !(_step10 = _iterator10.n()).done; ) {
        _loop();
      }
    } catch (err) {
      _iterator10.e(err);
    } finally {
      _iterator10.f();
    }
  }
  return e2;
};
var C = function C2(e2, t2, r2) {
  return r2 = e2 != null ? xr(Er(e2)) : {}, Tr(t2 || !e2 || !e2.__esModule ? it(r2, "default", { value: e2, enumerable: true }) : r2, e2);
};
var Rt = T(function(st) {
  Object.defineProperty(st, "__esModule", { value: true });
  function Ir(e2) {
    var t2 = 4, r2 = e2.length, n2 = r2 % t2;
    if (!n2)
      return e2;
    var i2 = r2, o2 = t2 - n2, s2 = r2 + o2, u2 = Buffer.alloc(s2);
    for (u2.write(e2); o2--; )
      u2.write("=", i2++);
    return u2.toString();
  }
  st.default = Ir;
});
var Dt = T(function(ht) {
  Object.defineProperty(ht, "__esModule", { value: true });
  var Sr = Rt();
  function Ct(e2, t2) {
    return t2 === void 0 && (t2 = "utf8"), Buffer.isBuffer(e2) ? at(e2.toString("base64")) : at(Buffer.from(e2, t2).toString("base64"));
  }
  function Ur(e2, t2) {
    return t2 === void 0 && (t2 = "utf8"), Buffer.from(ut(e2), "base64").toString(t2);
  }
  function ut(e2) {
    return e2 = e2.toString(), Sr.default(e2).replace(/\-/g, "+").replace(/_/g, "/");
  }
  function at(e2) {
    return e2.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function Fr(e2) {
    return Buffer.from(ut(e2), "base64");
  }
  var O2 = Ct;
  O2.encode = Ct;
  O2.decode = Ur;
  O2.toBase64 = ut;
  O2.fromBase64 = at;
  O2.toBuffer = Fr;
  ht.default = O2;
});
var z = T(function(me, V2) {
  V2.exports = Dt().default;
  V2.exports.default = V2.exports;
});
var ct = T(function(J2) {
  J2.byteLength = _r2;
  J2.toByteArray = Cr;
  J2.fromByteArray = Nr;
  var b3 = [], m2 = [], Lr = (typeof Uint8Array === "undefined" ? "undefined" : _typeof(Uint8Array)) < "u" ? Uint8Array : Array, ft = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (D3 = 0, Pt = ft.length; D3 < Pt; ++D3)
    b3[D3] = ft[D3], m2[ft.charCodeAt(D3)] = D3;
  var D3, Pt;
  m2["-".charCodeAt(0)] = 62;
  m2["_".charCodeAt(0)] = 63;
  function Nt(e2) {
    var t2 = e2.length;
    if (t2 % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var r2 = e2.indexOf("=");
    r2 === -1 && (r2 = t2);
    var n2 = r2 === t2 ? 0 : 4 - r2 % 4;
    return [r2, n2];
  }
  function _r2(e2) {
    var t2 = Nt(e2), r2 = t2[0], n2 = t2[1];
    return (r2 + n2) * 3 / 4 - n2;
  }
  function Rr(e2, t2, r2) {
    return (t2 + r2) * 3 / 4 - r2;
  }
  function Cr(e2) {
    var t2, r2 = Nt(e2), n2 = r2[0], i2 = r2[1], o2 = new Lr(Rr(e2, n2, i2)), s2 = 0, u2 = i2 > 0 ? n2 - 4 : n2, h2;
    for (h2 = 0; h2 < u2; h2 += 4)
      t2 = m2[e2.charCodeAt(h2)] << 18 | m2[e2.charCodeAt(h2 + 1)] << 12 | m2[e2.charCodeAt(h2 + 2)] << 6 | m2[e2.charCodeAt(h2 + 3)], o2[s2++] = t2 >> 16 & 255, o2[s2++] = t2 >> 8 & 255, o2[s2++] = t2 & 255;
    return i2 === 2 && (t2 = m2[e2.charCodeAt(h2)] << 2 | m2[e2.charCodeAt(h2 + 1)] >> 4, o2[s2++] = t2 & 255), i2 === 1 && (t2 = m2[e2.charCodeAt(h2)] << 10 | m2[e2.charCodeAt(h2 + 1)] << 4 | m2[e2.charCodeAt(h2 + 2)] >> 2, o2[s2++] = t2 >> 8 & 255, o2[s2++] = t2 & 255), o2;
  }
  function Dr(e2) {
    return b3[e2 >> 18 & 63] + b3[e2 >> 12 & 63] + b3[e2 >> 6 & 63] + b3[e2 & 63];
  }
  function Pr(e2, t2, r2) {
    for (var n2, i2 = [], o2 = t2; o2 < r2; o2 += 3)
      n2 = (e2[o2] << 16 & 16711680) + (e2[o2 + 1] << 8 & 65280) + (e2[o2 + 2] & 255), i2.push(Dr(n2));
    return i2.join("");
  }
  function Nr(e2) {
    for (var t2, r2 = e2.length, n2 = r2 % 3, i2 = [], o2 = 16383, s2 = 0, u2 = r2 - n2; s2 < u2; s2 += o2)
      i2.push(Pr(e2, s2, s2 + o2 > u2 ? u2 : s2 + o2));
    return n2 === 1 ? (t2 = e2[r2 - 1], i2.push(b3[t2 >> 2] + b3[t2 << 4 & 63] + "==")) : n2 === 2 && (t2 = (e2[r2 - 2] << 8) + e2[r2 - 1], i2.push(b3[t2 >> 10] + b3[t2 >> 4 & 63] + b3[t2 << 2 & 63] + "=")), i2.join("");
  }
});
var pt = T(function(g2) {
  Object.defineProperty(g2, "__esModule", { value: true });
  g2.b64UrlDecode = g2.b64UrlEncode = g2.bufferTob64Url = g2.bufferTob64 = g2.b64UrlToBuffer = g2.stringToB64Url = g2.stringToBuffer = g2.bufferToString = g2.b64UrlToString = g2.concatBuffers = void 0;
  var kt = ct();
  function kr(e2) {
    var t2 = 0;
    for (var _i67 = 0; _i67 < e2.length; _i67++)
      t2 += e2[_i67].byteLength;
    var r2 = new Uint8Array(t2), n2 = 0;
    r2.set(new Uint8Array(e2[0]), n2), n2 += e2[0].byteLength;
    for (var _i68 = 1; _i68 < e2.length; _i68++)
      r2.set(new Uint8Array(e2[_i68]), n2), n2 += e2[_i68].byteLength;
    return r2;
  }
  g2.concatBuffers = kr;
  function Mr(e2) {
    var t2 = $t(e2);
    return Mt(t2);
  }
  g2.b64UrlToString = Mr;
  function Mt(e2) {
    return new TextDecoder("utf-8", { fatal: true }).decode(e2);
  }
  g2.bufferToString = Mt;
  function Ot(e2) {
    return new TextEncoder().encode(e2);
  }
  g2.stringToBuffer = Ot;
  function Or(e2) {
    return Ht(Ot(e2));
  }
  g2.stringToB64Url = Or;
  function $t(e2) {
    return new Uint8Array(kt.toByteArray(qt(e2)));
  }
  g2.b64UrlToBuffer = $t;
  function Kt(e2) {
    return kt.fromByteArray(new Uint8Array(e2));
  }
  g2.bufferTob64 = Kt;
  function Ht(e2) {
    return jt(Kt(e2));
  }
  g2.bufferTob64Url = Ht;
  function jt(e2) {
    return e2.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
  }
  g2.b64UrlEncode = jt;
  function qt(e2) {
    e2 = e2.replace(/\-/g, "+").replace(/\_/g, "/");
    var t2;
    return e2.length % 4 == 0 ? t2 = 0 : t2 = 4 - e2.length % 4, e2.concat("=".repeat(t2));
  }
  g2.b64UrlDecode = qt;
});
var Yt = T(function(gt) {
  Object.defineProperty(gt, "__esModule", { value: true });
  var F2 = pt(), lt = function() {
    function lt2() {
      _classCallCheck2(this, lt2);
      _defineProperty(this, "keyLength", 4096);
      _defineProperty(this, "publicExponent", 65537);
      _defineProperty(this, "hashAlgorithm", "sha256");
      _defineProperty(this, "driver", void 0);
      if (!this.detectWebCrypto())
        throw new Error("SubtleCrypto not available!");
      this.driver = crypto.subtle;
    }
    return _createClass(lt2, [{ key: "generateJWK", value: function() {
      var _generateJWK = _asyncToGenerator(_regeneratorRuntime().mark(function _callee100() {
        var t2, r2;
        return _regeneratorRuntime().wrap(function _callee100$(_context101) {
          while (1)
            switch (_context101.prev = _context101.next) {
              case 0:
                _context101.next = 2;
                return this.driver.generateKey({ name: "RSA-PSS", modulusLength: 4096, publicExponent: new Uint8Array([1, 0, 1]), hash: { name: "SHA-256" } }, true, ["sign"]);
              case 2:
                t2 = _context101.sent;
                _context101.next = 5;
                return this.driver.exportKey("jwk", t2.privateKey);
              case 5:
                r2 = _context101.sent;
                return _context101.abrupt("return", { kty: r2.kty, e: r2.e, n: r2.n, d: r2.d, p: r2.p, q: r2.q, dp: r2.dp, dq: r2.dq, qi: r2.qi });
              case 7:
              case "end":
                return _context101.stop();
            }
        }, _callee100, this);
      }));
      function generateJWK() {
        return _generateJWK.apply(this, arguments);
      }
      return generateJWK;
    }() }, { key: "sign", value: function() {
      var _sign3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee101(t2, r2) {
        var _ref81, n2, i2, _args13 = arguments;
        return _regeneratorRuntime().wrap(function _callee101$(_context102) {
          while (1)
            switch (_context102.prev = _context102.next) {
              case 0:
                _ref81 = _args13.length > 2 && _args13[2] !== void 0 ? _args13[2] : {}, n2 = _ref81.saltLength;
                _context102.t0 = this.driver;
                _context102.t1 = { name: "RSA-PSS", saltLength: 32 };
                _context102.next = 5;
                return this.jwkToCryptoKey(t2);
              case 5:
                _context102.t2 = _context102.sent;
                _context102.t3 = r2;
                _context102.next = 9;
                return _context102.t0.sign.call(_context102.t0, _context102.t1, _context102.t2, _context102.t3);
              case 9:
                i2 = _context102.sent;
                return _context102.abrupt("return", new Uint8Array(i2));
              case 11:
              case "end":
                return _context102.stop();
            }
        }, _callee101, this);
      }));
      function sign(_x144, _x145) {
        return _sign3.apply(this, arguments);
      }
      return sign;
    }() }, { key: "hash", value: function() {
      var _hash8 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee102(t2) {
        var r2, n2, _args14 = arguments;
        return _regeneratorRuntime().wrap(function _callee102$(_context103) {
          while (1)
            switch (_context103.prev = _context103.next) {
              case 0:
                r2 = _args14.length > 1 && _args14[1] !== void 0 ? _args14[1] : "SHA-256";
                _context103.next = 3;
                return this.driver.digest(r2, t2);
              case 3:
                n2 = _context103.sent;
                return _context103.abrupt("return", new Uint8Array(n2));
              case 5:
              case "end":
                return _context103.stop();
            }
        }, _callee102, this);
      }));
      function hash2(_x146) {
        return _hash8.apply(this, arguments);
      }
      return hash2;
    }() }, { key: "verify", value: function() {
      var _verify4 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee103(t2, r2, n2) {
        var i2, o2, s2, u2, h2, p2;
        return _regeneratorRuntime().wrap(function _callee103$(_context104) {
          while (1)
            switch (_context104.prev = _context104.next) {
              case 0:
                i2 = { kty: "RSA", e: "AQAB", n: t2 };
                _context104.next = 3;
                return this.jwkToPublicCryptoKey(i2);
              case 3:
                o2 = _context104.sent;
                _context104.next = 6;
                return this.driver.digest("SHA-256", r2);
              case 6:
                s2 = _context104.sent;
                _context104.next = 9;
                return this.driver.verify({ name: "RSA-PSS", saltLength: 0 }, o2, n2, r2);
              case 9:
                u2 = _context104.sent;
                _context104.next = 12;
                return this.driver.verify({ name: "RSA-PSS", saltLength: 32 }, o2, n2, r2);
              case 12:
                h2 = _context104.sent;
                _context104.next = 15;
                return this.driver.verify({ name: "RSA-PSS", saltLength: Math.ceil((o2.algorithm.modulusLength - 1) / 8) - s2.byteLength - 2 }, o2, n2, r2);
              case 15:
                p2 = _context104.sent;
                return _context104.abrupt("return", u2 || h2 || p2);
              case 17:
              case "end":
                return _context104.stop();
            }
        }, _callee103, this);
      }));
      function verify(_x147, _x148, _x149) {
        return _verify4.apply(this, arguments);
      }
      return verify;
    }() }, { key: "jwkToCryptoKey", value: function() {
      var _jwkToCryptoKey = _asyncToGenerator(_regeneratorRuntime().mark(function _callee104(t2) {
        return _regeneratorRuntime().wrap(function _callee104$(_context105) {
          while (1)
            switch (_context105.prev = _context105.next) {
              case 0:
                return _context105.abrupt("return", this.driver.importKey("jwk", t2, { name: "RSA-PSS", hash: { name: "SHA-256" } }, false, ["sign"]));
              case 1:
              case "end":
                return _context105.stop();
            }
        }, _callee104, this);
      }));
      function jwkToCryptoKey(_x150) {
        return _jwkToCryptoKey.apply(this, arguments);
      }
      return jwkToCryptoKey;
    }() }, { key: "jwkToPublicCryptoKey", value: function() {
      var _jwkToPublicCryptoKey = _asyncToGenerator(_regeneratorRuntime().mark(function _callee105(t2) {
        return _regeneratorRuntime().wrap(function _callee105$(_context106) {
          while (1)
            switch (_context106.prev = _context106.next) {
              case 0:
                return _context106.abrupt("return", this.driver.importKey("jwk", t2, { name: "RSA-PSS", hash: { name: "SHA-256" } }, false, ["verify"]));
              case 1:
              case "end":
                return _context106.stop();
            }
        }, _callee105, this);
      }));
      function jwkToPublicCryptoKey(_x151) {
        return _jwkToPublicCryptoKey.apply(this, arguments);
      }
      return jwkToPublicCryptoKey;
    }() }, { key: "detectWebCrypto", value: function detectWebCrypto() {
      var _crypto2;
      if ((typeof crypto === "undefined" ? "undefined" : _typeof(crypto)) > "u")
        return false;
      var t2 = (_crypto2 = crypto) === null || _crypto2 === void 0 ? void 0 : _crypto2.subtle;
      return t2 === void 0 ? false : ["generateKey", "importKey", "exportKey", "digest", "sign"].every(function(n2) {
        return typeof t2[n2] == "function";
      });
    } }, { key: "encrypt", value: function() {
      var _encrypt2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee106(t2, r2, n2) {
        var i2, o2, s2, u2;
        return _regeneratorRuntime().wrap(function _callee106$(_context107) {
          while (1)
            switch (_context107.prev = _context107.next) {
              case 0:
                _context107.next = 2;
                return this.driver.importKey("raw", typeof r2 == "string" ? F2.stringToBuffer(r2) : r2, { name: "PBKDF2", length: 32 }, false, ["deriveKey"]);
              case 2:
                i2 = _context107.sent;
                _context107.next = 5;
                return this.driver.deriveKey({ name: "PBKDF2", salt: n2 ? F2.stringToBuffer(n2) : F2.stringToBuffer("salt"), iterations: 1e5, hash: "SHA-256" }, i2, { name: "AES-CBC", length: 256 }, false, ["encrypt", "decrypt"]);
              case 5:
                o2 = _context107.sent;
                s2 = new Uint8Array(16);
                crypto.getRandomValues(s2);
                _context107.next = 10;
                return this.driver.encrypt({ name: "AES-CBC", iv: s2 }, o2, t2);
              case 10:
                u2 = _context107.sent;
                return _context107.abrupt("return", F2.concatBuffers([s2, u2]));
              case 12:
              case "end":
                return _context107.stop();
            }
        }, _callee106, this);
      }));
      function encrypt(_x152, _x153, _x154) {
        return _encrypt2.apply(this, arguments);
      }
      return encrypt;
    }() }, { key: "decrypt", value: function() {
      var _decrypt2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee107(t2, r2, n2) {
        var i2, o2, s2, u2;
        return _regeneratorRuntime().wrap(function _callee107$(_context108) {
          while (1)
            switch (_context108.prev = _context108.next) {
              case 0:
                _context108.next = 2;
                return this.driver.importKey("raw", typeof r2 == "string" ? F2.stringToBuffer(r2) : r2, { name: "PBKDF2", length: 32 }, false, ["deriveKey"]);
              case 2:
                i2 = _context108.sent;
                _context108.next = 5;
                return this.driver.deriveKey({ name: "PBKDF2", salt: n2 ? F2.stringToBuffer(n2) : F2.stringToBuffer("salt"), iterations: 1e5, hash: "SHA-256" }, i2, { name: "AES-CBC", length: 256 }, false, ["encrypt", "decrypt"]);
              case 5:
                o2 = _context108.sent;
                s2 = t2.slice(0, 16);
                _context108.next = 9;
                return this.driver.decrypt({ name: "AES-CBC", iv: s2 }, o2, t2.slice(16));
              case 9:
                u2 = _context108.sent;
                return _context108.abrupt("return", F2.concatBuffers([u2]));
              case 11:
              case "end":
                return _context108.stop();
            }
        }, _callee107, this);
      }));
      function decrypt(_x155, _x156, _x157) {
        return _decrypt2.apply(this, arguments);
      }
      return decrypt;
    }() }]);
  }();
  gt.default = lt;
});
var zt = T(function(mt) {
  mt.read = function(e2, t2, r2, n2, i2) {
    var o2, s2, u2 = i2 * 8 - n2 - 1, h2 = (1 << u2) - 1, p2 = h2 >> 1, f2 = -7, c3 = r2 ? i2 - 1 : 0, U2 = r2 ? -1 : 1, l2 = e2[t2 + c3];
    for (c3 += U2, o2 = l2 & (1 << -f2) - 1, l2 >>= -f2, f2 += u2; f2 > 0; o2 = o2 * 256 + e2[t2 + c3], c3 += U2, f2 -= 8)
      ;
    for (s2 = o2 & (1 << -f2) - 1, o2 >>= -f2, f2 += n2; f2 > 0; s2 = s2 * 256 + e2[t2 + c3], c3 += U2, f2 -= 8)
      ;
    if (o2 === 0)
      o2 = 1 - p2;
    else {
      if (o2 === h2)
        return s2 ? NaN : (l2 ? -1 : 1) * (1 / 0);
      s2 = s2 + Math.pow(2, n2), o2 = o2 - p2;
    }
    return (l2 ? -1 : 1) * s2 * Math.pow(2, o2 - n2);
  };
  mt.write = function(e2, t2, r2, n2, i2, o2) {
    var s2, u2, h2, p2 = o2 * 8 - i2 - 1, f2 = (1 << p2) - 1, c3 = f2 >> 1, U2 = i2 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, l2 = n2 ? 0 : o2 - 1, R2 = n2 ? 1 : -1, G2 = t2 < 0 || t2 === 0 && 1 / t2 < 0 ? 1 : 0;
    for (t2 = Math.abs(t2), isNaN(t2) || t2 === 1 / 0 ? (u2 = isNaN(t2) ? 1 : 0, s2 = f2) : (s2 = Math.floor(Math.log(t2) / Math.LN2), t2 * (h2 = Math.pow(2, -s2)) < 1 && (s2--, h2 *= 2), s2 + c3 >= 1 ? t2 += U2 / h2 : t2 += U2 * Math.pow(2, 1 - c3), t2 * h2 >= 2 && (s2++, h2 /= 2), s2 + c3 >= f2 ? (u2 = 0, s2 = f2) : s2 + c3 >= 1 ? (u2 = (t2 * h2 - 1) * Math.pow(2, i2), s2 = s2 + c3) : (u2 = t2 * Math.pow(2, c3 - 1) * Math.pow(2, i2), s2 = 0)); i2 >= 8; e2[r2 + l2] = u2 & 255, l2 += R2, u2 /= 256, i2 -= 8)
      ;
    for (s2 = s2 << i2 | u2, p2 += i2; p2 > 0; e2[r2 + l2] = s2 & 255, l2 += R2, s2 /= 256, p2 -= 8)
      ;
    e2[r2 + l2 - R2] |= G2 * 128;
  };
});
var nt = T(function(q3) {
  var Bt = ct(), H2 = zt(), Jt = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  q3.Buffer = a2;
  q3.SlowBuffer = Vr;
  q3.INSPECT_MAX_BYTES = 50;
  var rt = 2147483647;
  q3.kMaxLength = rt;
  a2.TYPED_ARRAY_SUPPORT = qr();
  !a2.TYPED_ARRAY_SUPPORT && (typeof console === "undefined" ? "undefined" : _typeof(console)) < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  function qr() {
    try {
      var _e8 = new Uint8Array(1), _t7 = { foo: function foo() {
        return 42;
      } };
      return Object.setPrototypeOf(_t7, Uint8Array.prototype), Object.setPrototypeOf(_e8, _t7), _e8.foo() === 42;
    } catch (_unused) {
      return false;
    }
  }
  Object.defineProperty(a2.prototype, "parent", { enumerable: true, get: function get5() {
    if (a2.isBuffer(this))
      return this.buffer;
  } });
  Object.defineProperty(a2.prototype, "offset", { enumerable: true, get: function get5() {
    if (a2.isBuffer(this))
      return this.byteOffset;
  } });
  function S2(e2) {
    if (e2 > rt)
      throw new RangeError('The value "' + e2 + '" is invalid for option "size"');
    var t2 = new Uint8Array(e2);
    return Object.setPrototypeOf(t2, a2.prototype), t2;
  }
  function a2(e2, t2, r2) {
    if (typeof e2 == "number") {
      if (typeof t2 == "string")
        throw new TypeError('The "string" argument must be of type string. Received type number');
      return Tt(e2);
    }
    return tr(e2, t2, r2);
  }
  a2.poolSize = 8192;
  function tr(e2, t2, r2) {
    if (typeof e2 == "string")
      return Yr(e2, t2);
    if (ArrayBuffer.isView(e2))
      return vr(e2);
    if (e2 == null)
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + _typeof(e2));
    if (A2(e2, ArrayBuffer) || e2 && A2(e2.buffer, ArrayBuffer) || (typeof SharedArrayBuffer === "undefined" ? "undefined" : _typeof(SharedArrayBuffer)) < "u" && (A2(e2, SharedArrayBuffer) || e2 && A2(e2.buffer, SharedArrayBuffer)))
      return bt(e2, t2, r2);
    if (typeof e2 == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    var n2 = e2.valueOf && e2.valueOf();
    if (n2 != null && n2 !== e2)
      return a2.from(n2, t2, r2);
    var i2 = Wr(e2);
    if (i2)
      return i2;
    if ((typeof Symbol === "undefined" ? "undefined" : _typeof(Symbol)) < "u" && Symbol.toPrimitive != null && typeof e2[Symbol.toPrimitive] == "function")
      return a2.from(e2[Symbol.toPrimitive]("string"), t2, r2);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + _typeof(e2));
  }
  a2.from = function(e2, t2, r2) {
    return tr(e2, t2, r2);
  };
  Object.setPrototypeOf(a2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(a2, Uint8Array);
  function rr2(e2) {
    if (typeof e2 != "number")
      throw new TypeError('"size" argument must be of type number');
    if (e2 < 0)
      throw new RangeError('The value "' + e2 + '" is invalid for option "size"');
  }
  function Gr(e2, t2, r2) {
    return rr2(e2), e2 <= 0 ? S2(e2) : t2 !== void 0 ? typeof r2 == "string" ? S2(e2).fill(t2, r2) : S2(e2).fill(t2) : S2(e2);
  }
  a2.alloc = function(e2, t2, r2) {
    return Gr(e2, t2, r2);
  };
  function Tt(e2) {
    return rr2(e2), S2(e2 < 0 ? 0 : It(e2) | 0);
  }
  a2.allocUnsafe = function(e2) {
    return Tt(e2);
  };
  a2.allocUnsafeSlow = function(e2) {
    return Tt(e2);
  };
  function Yr(e2, t2) {
    if ((typeof t2 != "string" || t2 === "") && (t2 = "utf8"), !a2.isEncoding(t2))
      throw new TypeError("Unknown encoding: " + t2);
    var r2 = er(e2, t2) | 0, n2 = S2(r2), i2 = n2.write(e2, t2);
    return i2 !== r2 && (n2 = n2.slice(0, i2)), n2;
  }
  function Et(e2) {
    var t2 = e2.length < 0 ? 0 : It(e2.length) | 0, r2 = S2(t2);
    for (var _n3 = 0; _n3 < t2; _n3 += 1)
      r2[_n3] = e2[_n3] & 255;
    return r2;
  }
  function vr(e2) {
    if (A2(e2, Uint8Array)) {
      var _t8 = new Uint8Array(e2);
      return bt(_t8.buffer, _t8.byteOffset, _t8.byteLength);
    }
    return Et(e2);
  }
  function bt(e2, t2, r2) {
    if (t2 < 0 || e2.byteLength < t2)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (e2.byteLength < t2 + (r2 || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    var n2;
    return t2 === void 0 && r2 === void 0 ? n2 = new Uint8Array(e2) : r2 === void 0 ? n2 = new Uint8Array(e2, t2) : n2 = new Uint8Array(e2, t2, r2), Object.setPrototypeOf(n2, a2.prototype), n2;
  }
  function Wr(e2) {
    if (a2.isBuffer(e2)) {
      var _t9 = It(e2.length) | 0, _r3 = S2(_t9);
      return _r3.length === 0 || e2.copy(_r3, 0, 0, _t9), _r3;
    }
    if (e2.length !== void 0)
      return typeof e2.length != "number" || Ut(e2.length) ? S2(0) : Et(e2);
    if (e2.type === "Buffer" && Array.isArray(e2.data))
      return Et(e2.data);
  }
  function It(e2) {
    if (e2 >= rt)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + rt.toString(16) + " bytes");
    return e2 | 0;
  }
  function Vr(e2) {
    return +e2 != e2 && (e2 = 0), a2.alloc(+e2);
  }
  a2.isBuffer = function(t2) {
    return t2 != null && t2._isBuffer === true && t2 !== a2.prototype;
  };
  a2.compare = function(t2, r2) {
    if (A2(t2, Uint8Array) && (t2 = a2.from(t2, t2.offset, t2.byteLength)), A2(r2, Uint8Array) && (r2 = a2.from(r2, r2.offset, r2.byteLength)), !a2.isBuffer(t2) || !a2.isBuffer(r2))
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (t2 === r2)
      return 0;
    var n2 = t2.length, i2 = r2.length;
    for (var _o2 = 0, _s3 = Math.min(n2, i2); _o2 < _s3; ++_o2)
      if (t2[_o2] !== r2[_o2]) {
        n2 = t2[_o2], i2 = r2[_o2];
        break;
      }
    return n2 < i2 ? -1 : i2 < n2 ? 1 : 0;
  };
  a2.isEncoding = function(t2) {
    switch (String(t2).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  a2.concat = function(t2, r2) {
    if (!Array.isArray(t2))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (t2.length === 0)
      return a2.alloc(0);
    var n2;
    if (r2 === void 0)
      for (r2 = 0, n2 = 0; n2 < t2.length; ++n2)
        r2 += t2[n2].length;
    var i2 = a2.allocUnsafe(r2), o2 = 0;
    for (n2 = 0; n2 < t2.length; ++n2) {
      var _s4 = t2[n2];
      if (A2(_s4, Uint8Array))
        o2 + _s4.length > i2.length ? (a2.isBuffer(_s4) || (_s4 = a2.from(_s4)), _s4.copy(i2, o2)) : Uint8Array.prototype.set.call(i2, _s4, o2);
      else if (a2.isBuffer(_s4))
        _s4.copy(i2, o2);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      o2 += _s4.length;
    }
    return i2;
  };
  function er(e2, t2) {
    if (a2.isBuffer(e2))
      return e2.length;
    if (ArrayBuffer.isView(e2) || A2(e2, ArrayBuffer))
      return e2.byteLength;
    if (typeof e2 != "string")
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + _typeof(e2));
    var r2 = e2.length, n2 = arguments.length > 2 && arguments[2] === true;
    if (!n2 && r2 === 0)
      return 0;
    var i2 = false;
    for (; ; )
      switch (t2) {
        case "ascii":
        case "latin1":
        case "binary":
          return r2;
        case "utf8":
        case "utf-8":
          return At(e2).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return r2 * 2;
        case "hex":
          return r2 >>> 1;
        case "base64":
          return cr(e2).length;
        default:
          if (i2)
            return n2 ? -1 : At(e2).length;
          t2 = ("" + t2).toLowerCase(), i2 = true;
      }
  }
  a2.byteLength = er;
  function zr(e2, t2, r2) {
    var n2 = false;
    if ((t2 === void 0 || t2 < 0) && (t2 = 0), t2 > this.length || ((r2 === void 0 || r2 > this.length) && (r2 = this.length), r2 <= 0) || (r2 >>>= 0, t2 >>>= 0, r2 <= t2))
      return "";
    for (e2 || (e2 = "utf8"); ; )
      switch (e2) {
        case "hex":
          return oe2(this, t2, r2);
        case "utf8":
        case "utf-8":
          return ir(this, t2, r2);
        case "ascii":
          return ne(this, t2, r2);
        case "latin1":
        case "binary":
          return ie(this, t2, r2);
        case "base64":
          return re(this, t2, r2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return se(this, t2, r2);
        default:
          if (n2)
            throw new TypeError("Unknown encoding: " + e2);
          e2 = (e2 + "").toLowerCase(), n2 = true;
      }
  }
  a2.prototype._isBuffer = true;
  function k3(e2, t2, r2) {
    var n2 = e2[t2];
    e2[t2] = e2[r2], e2[r2] = n2;
  }
  a2.prototype.swap16 = function() {
    var t2 = this.length;
    if (t2 % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (var _r4 = 0; _r4 < t2; _r4 += 2)
      k3(this, _r4, _r4 + 1);
    return this;
  };
  a2.prototype.swap32 = function() {
    var t2 = this.length;
    if (t2 % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (var _r5 = 0; _r5 < t2; _r5 += 4)
      k3(this, _r5, _r5 + 3), k3(this, _r5 + 1, _r5 + 2);
    return this;
  };
  a2.prototype.swap64 = function() {
    var t2 = this.length;
    if (t2 % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (var _r6 = 0; _r6 < t2; _r6 += 8)
      k3(this, _r6, _r6 + 7), k3(this, _r6 + 1, _r6 + 6), k3(this, _r6 + 2, _r6 + 5), k3(this, _r6 + 3, _r6 + 4);
    return this;
  };
  a2.prototype.toString = function() {
    var t2 = this.length;
    return t2 === 0 ? "" : arguments.length === 0 ? ir(this, 0, t2) : zr.apply(this, arguments);
  };
  a2.prototype.toLocaleString = a2.prototype.toString;
  a2.prototype.equals = function(t2) {
    if (!a2.isBuffer(t2))
      throw new TypeError("Argument must be a Buffer");
    return this === t2 ? true : a2.compare(this, t2) === 0;
  };
  a2.prototype.inspect = function() {
    var t2 = "", r2 = q3.INSPECT_MAX_BYTES;
    return t2 = this.toString("hex", 0, r2).replace(/(.{2})/g, "$1 ").trim(), this.length > r2 && (t2 += " ... "), "<Buffer " + t2 + ">";
  };
  Jt && (a2.prototype[Jt] = a2.prototype.inspect);
  a2.prototype.compare = function(t2, r2, n2, i2, o2) {
    if (A2(t2, Uint8Array) && (t2 = a2.from(t2, t2.offset, t2.byteLength)), !a2.isBuffer(t2))
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + _typeof(t2));
    if (r2 === void 0 && (r2 = 0), n2 === void 0 && (n2 = t2 ? t2.length : 0), i2 === void 0 && (i2 = 0), o2 === void 0 && (o2 = this.length), r2 < 0 || n2 > t2.length || i2 < 0 || o2 > this.length)
      throw new RangeError("out of range index");
    if (i2 >= o2 && r2 >= n2)
      return 0;
    if (i2 >= o2)
      return -1;
    if (r2 >= n2)
      return 1;
    if (r2 >>>= 0, n2 >>>= 0, i2 >>>= 0, o2 >>>= 0, this === t2)
      return 0;
    var s2 = o2 - i2, u2 = n2 - r2, h2 = Math.min(s2, u2), p2 = this.slice(i2, o2), f2 = t2.slice(r2, n2);
    for (var _c = 0; _c < h2; ++_c)
      if (p2[_c] !== f2[_c]) {
        s2 = p2[_c], u2 = f2[_c];
        break;
      }
    return s2 < u2 ? -1 : u2 < s2 ? 1 : 0;
  };
  function nr(e2, t2, r2, n2, i2) {
    if (e2.length === 0)
      return -1;
    if (typeof r2 == "string" ? (n2 = r2, r2 = 0) : r2 > 2147483647 ? r2 = 2147483647 : r2 < -2147483648 && (r2 = -2147483648), r2 = +r2, Ut(r2) && (r2 = i2 ? 0 : e2.length - 1), r2 < 0 && (r2 = e2.length + r2), r2 >= e2.length) {
      if (i2)
        return -1;
      r2 = e2.length - 1;
    } else if (r2 < 0)
      if (i2)
        r2 = 0;
      else
        return -1;
    if (typeof t2 == "string" && (t2 = a2.from(t2, n2)), a2.isBuffer(t2))
      return t2.length === 0 ? -1 : Xt(e2, t2, r2, n2, i2);
    if (typeof t2 == "number")
      return t2 = t2 & 255, typeof Uint8Array.prototype.indexOf == "function" ? i2 ? Uint8Array.prototype.indexOf.call(e2, t2, r2) : Uint8Array.prototype.lastIndexOf.call(e2, t2, r2) : Xt(e2, [t2], r2, n2, i2);
    throw new TypeError("val must be string, number or Buffer");
  }
  function Xt(e2, t2, r2, n2, i2) {
    var o2 = 1, s2 = e2.length, u2 = t2.length;
    if (n2 !== void 0 && (n2 = String(n2).toLowerCase(), n2 === "ucs2" || n2 === "ucs-2" || n2 === "utf16le" || n2 === "utf-16le")) {
      if (e2.length < 2 || t2.length < 2)
        return -1;
      o2 = 2, s2 /= 2, u2 /= 2, r2 /= 2;
    }
    function h2(f2, c3) {
      return o2 === 1 ? f2[c3] : f2.readUInt16BE(c3 * o2);
    }
    var p2;
    if (i2) {
      var _f = -1;
      for (p2 = r2; p2 < s2; p2++)
        if (h2(e2, p2) === h2(t2, _f === -1 ? 0 : p2 - _f)) {
          if (_f === -1 && (_f = p2), p2 - _f + 1 === u2)
            return _f * o2;
        } else
          _f !== -1 && (p2 -= p2 - _f), _f = -1;
    } else
      for (r2 + u2 > s2 && (r2 = s2 - u2), p2 = r2; p2 >= 0; p2--) {
        var _f2 = true;
        for (var _c2 = 0; _c2 < u2; _c2++)
          if (h2(e2, p2 + _c2) !== h2(t2, _c2)) {
            _f2 = false;
            break;
          }
        if (_f2)
          return p2;
      }
    return -1;
  }
  a2.prototype.includes = function(t2, r2, n2) {
    return this.indexOf(t2, r2, n2) !== -1;
  };
  a2.prototype.indexOf = function(t2, r2, n2) {
    return nr(this, t2, r2, n2, true);
  };
  a2.prototype.lastIndexOf = function(t2, r2, n2) {
    return nr(this, t2, r2, n2, false);
  };
  function Jr(e2, t2, r2, n2) {
    r2 = Number(r2) || 0;
    var i2 = e2.length - r2;
    n2 ? (n2 = Number(n2), n2 > i2 && (n2 = i2)) : n2 = i2;
    var o2 = t2.length;
    n2 > o2 / 2 && (n2 = o2 / 2);
    var s2;
    for (s2 = 0; s2 < n2; ++s2) {
      var _u = parseInt(t2.substr(s2 * 2, 2), 16);
      if (Ut(_u))
        return s2;
      e2[r2 + s2] = _u;
    }
    return s2;
  }
  function Xr(e2, t2, r2, n2) {
    return et(At(t2, e2.length - r2), e2, r2, n2);
  }
  function Zr(e2, t2, r2, n2) {
    return et(fe(t2), e2, r2, n2);
  }
  function Qr(e2, t2, r2, n2) {
    return et(cr(t2), e2, r2, n2);
  }
  function te2(e2, t2, r2, n2) {
    return et(ce(t2, e2.length - r2), e2, r2, n2);
  }
  a2.prototype.write = function(t2, r2, n2, i2) {
    if (r2 === void 0)
      i2 = "utf8", n2 = this.length, r2 = 0;
    else if (n2 === void 0 && typeof r2 == "string")
      i2 = r2, n2 = this.length, r2 = 0;
    else if (isFinite(r2))
      r2 = r2 >>> 0, isFinite(n2) ? (n2 = n2 >>> 0, i2 === void 0 && (i2 = "utf8")) : (i2 = n2, n2 = void 0);
    else
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    var o2 = this.length - r2;
    if ((n2 === void 0 || n2 > o2) && (n2 = o2), t2.length > 0 && (n2 < 0 || r2 < 0) || r2 > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    i2 || (i2 = "utf8");
    var s2 = false;
    for (; ; )
      switch (i2) {
        case "hex":
          return Jr(this, t2, r2, n2);
        case "utf8":
        case "utf-8":
          return Xr(this, t2, r2, n2);
        case "ascii":
        case "latin1":
        case "binary":
          return Zr(this, t2, r2, n2);
        case "base64":
          return Qr(this, t2, r2, n2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return te2(this, t2, r2, n2);
        default:
          if (s2)
            throw new TypeError("Unknown encoding: " + i2);
          i2 = ("" + i2).toLowerCase(), s2 = true;
      }
  };
  a2.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  function re(e2, t2, r2) {
    return t2 === 0 && r2 === e2.length ? Bt.fromByteArray(e2) : Bt.fromByteArray(e2.slice(t2, r2));
  }
  function ir(e2, t2, r2) {
    r2 = Math.min(e2.length, r2);
    var n2 = [], i2 = t2;
    for (; i2 < r2; ) {
      var _o3 = e2[i2], _s5 = null, _u2 = _o3 > 239 ? 4 : _o3 > 223 ? 3 : _o3 > 191 ? 2 : 1;
      if (i2 + _u2 <= r2) {
        var _h4 = void 0, _p2 = void 0, _f3 = void 0, _c3 = void 0;
        switch (_u2) {
          case 1:
            _o3 < 128 && (_s5 = _o3);
            break;
          case 2:
            _h4 = e2[i2 + 1], (_h4 & 192) === 128 && (_c3 = (_o3 & 31) << 6 | _h4 & 63, _c3 > 127 && (_s5 = _c3));
            break;
          case 3:
            _h4 = e2[i2 + 1], _p2 = e2[i2 + 2], (_h4 & 192) === 128 && (_p2 & 192) === 128 && (_c3 = (_o3 & 15) << 12 | (_h4 & 63) << 6 | _p2 & 63, _c3 > 2047 && (_c3 < 55296 || _c3 > 57343) && (_s5 = _c3));
            break;
          case 4:
            _h4 = e2[i2 + 1], _p2 = e2[i2 + 2], _f3 = e2[i2 + 3], (_h4 & 192) === 128 && (_p2 & 192) === 128 && (_f3 & 192) === 128 && (_c3 = (_o3 & 15) << 18 | (_h4 & 63) << 12 | (_p2 & 63) << 6 | _f3 & 63, _c3 > 65535 && _c3 < 1114112 && (_s5 = _c3));
        }
      }
      _s5 === null ? (_s5 = 65533, _u2 = 1) : _s5 > 65535 && (_s5 -= 65536, n2.push(_s5 >>> 10 & 1023 | 55296), _s5 = 56320 | _s5 & 1023), n2.push(_s5), i2 += _u2;
    }
    return ee2(n2);
  }
  var Zt = 4096;
  function ee2(e2) {
    var t2 = e2.length;
    if (t2 <= Zt)
      return String.fromCharCode.apply(String, e2);
    var r2 = "", n2 = 0;
    for (; n2 < t2; )
      r2 += String.fromCharCode.apply(String, e2.slice(n2, n2 += Zt));
    return r2;
  }
  function ne(e2, t2, r2) {
    var n2 = "";
    r2 = Math.min(e2.length, r2);
    for (var _i69 = t2; _i69 < r2; ++_i69)
      n2 += String.fromCharCode(e2[_i69] & 127);
    return n2;
  }
  function ie(e2, t2, r2) {
    var n2 = "";
    r2 = Math.min(e2.length, r2);
    for (var _i70 = t2; _i70 < r2; ++_i70)
      n2 += String.fromCharCode(e2[_i70]);
    return n2;
  }
  function oe2(e2, t2, r2) {
    var n2 = e2.length;
    (!t2 || t2 < 0) && (t2 = 0), (!r2 || r2 < 0 || r2 > n2) && (r2 = n2);
    var i2 = "";
    for (var _o4 = t2; _o4 < r2; ++_o4)
      i2 += pe[e2[_o4]];
    return i2;
  }
  function se(e2, t2, r2) {
    var n2 = e2.slice(t2, r2), i2 = "";
    for (var _o5 = 0; _o5 < n2.length - 1; _o5 += 2)
      i2 += String.fromCharCode(n2[_o5] + n2[_o5 + 1] * 256);
    return i2;
  }
  a2.prototype.slice = function(t2, r2) {
    var n2 = this.length;
    t2 = ~~t2, r2 = r2 === void 0 ? n2 : ~~r2, t2 < 0 ? (t2 += n2, t2 < 0 && (t2 = 0)) : t2 > n2 && (t2 = n2), r2 < 0 ? (r2 += n2, r2 < 0 && (r2 = 0)) : r2 > n2 && (r2 = n2), r2 < t2 && (r2 = t2);
    var i2 = this.subarray(t2, r2);
    return Object.setPrototypeOf(i2, a2.prototype), i2;
  };
  function y3(e2, t2, r2) {
    if (e2 % 1 !== 0 || e2 < 0)
      throw new RangeError("offset is not uint");
    if (e2 + t2 > r2)
      throw new RangeError("Trying to access beyond buffer length");
  }
  a2.prototype.readUintLE = a2.prototype.readUIntLE = function(t2, r2, n2) {
    t2 = t2 >>> 0, r2 = r2 >>> 0, n2 || y3(t2, r2, this.length);
    var i2 = this[t2], o2 = 1, s2 = 0;
    for (; ++s2 < r2 && (o2 *= 256); )
      i2 += this[t2 + s2] * o2;
    return i2;
  };
  a2.prototype.readUintBE = a2.prototype.readUIntBE = function(t2, r2, n2) {
    t2 = t2 >>> 0, r2 = r2 >>> 0, n2 || y3(t2, r2, this.length);
    var i2 = this[t2 + --r2], o2 = 1;
    for (; r2 > 0 && (o2 *= 256); )
      i2 += this[t2 + --r2] * o2;
    return i2;
  };
  a2.prototype.readUint8 = a2.prototype.readUInt8 = function(t2, r2) {
    return t2 = t2 >>> 0, r2 || y3(t2, 1, this.length), this[t2];
  };
  a2.prototype.readUint16LE = a2.prototype.readUInt16LE = function(t2, r2) {
    return t2 = t2 >>> 0, r2 || y3(t2, 2, this.length), this[t2] | this[t2 + 1] << 8;
  };
  a2.prototype.readUint16BE = a2.prototype.readUInt16BE = function(t2, r2) {
    return t2 = t2 >>> 0, r2 || y3(t2, 2, this.length), this[t2] << 8 | this[t2 + 1];
  };
  a2.prototype.readUint32LE = a2.prototype.readUInt32LE = function(t2, r2) {
    return t2 = t2 >>> 0, r2 || y3(t2, 4, this.length), (this[t2] | this[t2 + 1] << 8 | this[t2 + 2] << 16) + this[t2 + 3] * 16777216;
  };
  a2.prototype.readUint32BE = a2.prototype.readUInt32BE = function(t2, r2) {
    return t2 = t2 >>> 0, r2 || y3(t2, 4, this.length), this[t2] * 16777216 + (this[t2 + 1] << 16 | this[t2 + 2] << 8 | this[t2 + 3]);
  };
  a2.prototype.readBigUInt64LE = L2(function(t2) {
    t2 = t2 >>> 0, j3(t2, "offset");
    var r2 = this[t2], n2 = this[t2 + 7];
    (r2 === void 0 || n2 === void 0) && W2(t2, this.length - 8);
    var i2 = r2 + this[++t2] * Math.pow(2, 8) + this[++t2] * Math.pow(2, 16) + this[++t2] * Math.pow(2, 24), o2 = this[++t2] + this[++t2] * Math.pow(2, 8) + this[++t2] * Math.pow(2, 16) + n2 * Math.pow(2, 24);
    return BigInt(i2) + (BigInt(o2) << BigInt(32));
  });
  a2.prototype.readBigUInt64BE = L2(function(t2) {
    t2 = t2 >>> 0, j3(t2, "offset");
    var r2 = this[t2], n2 = this[t2 + 7];
    (r2 === void 0 || n2 === void 0) && W2(t2, this.length - 8);
    var i2 = r2 * Math.pow(2, 24) + this[++t2] * Math.pow(2, 16) + this[++t2] * Math.pow(2, 8) + this[++t2], o2 = this[++t2] * Math.pow(2, 24) + this[++t2] * Math.pow(2, 16) + this[++t2] * Math.pow(2, 8) + n2;
    return (BigInt(i2) << BigInt(32)) + BigInt(o2);
  });
  a2.prototype.readIntLE = function(t2, r2, n2) {
    t2 = t2 >>> 0, r2 = r2 >>> 0, n2 || y3(t2, r2, this.length);
    var i2 = this[t2], o2 = 1, s2 = 0;
    for (; ++s2 < r2 && (o2 *= 256); )
      i2 += this[t2 + s2] * o2;
    return o2 *= 128, i2 >= o2 && (i2 -= Math.pow(2, 8 * r2)), i2;
  };
  a2.prototype.readIntBE = function(t2, r2, n2) {
    t2 = t2 >>> 0, r2 = r2 >>> 0, n2 || y3(t2, r2, this.length);
    var i2 = r2, o2 = 1, s2 = this[t2 + --i2];
    for (; i2 > 0 && (o2 *= 256); )
      s2 += this[t2 + --i2] * o2;
    return o2 *= 128, s2 >= o2 && (s2 -= Math.pow(2, 8 * r2)), s2;
  };
  a2.prototype.readInt8 = function(t2, r2) {
    return t2 = t2 >>> 0, r2 || y3(t2, 1, this.length), this[t2] & 128 ? (255 - this[t2] + 1) * -1 : this[t2];
  };
  a2.prototype.readInt16LE = function(t2, r2) {
    t2 = t2 >>> 0, r2 || y3(t2, 2, this.length);
    var n2 = this[t2] | this[t2 + 1] << 8;
    return n2 & 32768 ? n2 | 4294901760 : n2;
  };
  a2.prototype.readInt16BE = function(t2, r2) {
    t2 = t2 >>> 0, r2 || y3(t2, 2, this.length);
    var n2 = this[t2 + 1] | this[t2] << 8;
    return n2 & 32768 ? n2 | 4294901760 : n2;
  };
  a2.prototype.readInt32LE = function(t2, r2) {
    return t2 = t2 >>> 0, r2 || y3(t2, 4, this.length), this[t2] | this[t2 + 1] << 8 | this[t2 + 2] << 16 | this[t2 + 3] << 24;
  };
  a2.prototype.readInt32BE = function(t2, r2) {
    return t2 = t2 >>> 0, r2 || y3(t2, 4, this.length), this[t2] << 24 | this[t2 + 1] << 16 | this[t2 + 2] << 8 | this[t2 + 3];
  };
  a2.prototype.readBigInt64LE = L2(function(t2) {
    t2 = t2 >>> 0, j3(t2, "offset");
    var r2 = this[t2], n2 = this[t2 + 7];
    (r2 === void 0 || n2 === void 0) && W2(t2, this.length - 8);
    var i2 = this[t2 + 4] + this[t2 + 5] * Math.pow(2, 8) + this[t2 + 6] * Math.pow(2, 16) + (n2 << 24);
    return (BigInt(i2) << BigInt(32)) + BigInt(r2 + this[++t2] * Math.pow(2, 8) + this[++t2] * Math.pow(2, 16) + this[++t2] * Math.pow(2, 24));
  });
  a2.prototype.readBigInt64BE = L2(function(t2) {
    t2 = t2 >>> 0, j3(t2, "offset");
    var r2 = this[t2], n2 = this[t2 + 7];
    (r2 === void 0 || n2 === void 0) && W2(t2, this.length - 8);
    var i2 = (r2 << 24) + this[++t2] * Math.pow(2, 16) + this[++t2] * Math.pow(2, 8) + this[++t2];
    return (BigInt(i2) << BigInt(32)) + BigInt(this[++t2] * Math.pow(2, 24) + this[++t2] * Math.pow(2, 16) + this[++t2] * Math.pow(2, 8) + n2);
  });
  a2.prototype.readFloatLE = function(t2, r2) {
    return t2 = t2 >>> 0, r2 || y3(t2, 4, this.length), H2.read(this, t2, true, 23, 4);
  };
  a2.prototype.readFloatBE = function(t2, r2) {
    return t2 = t2 >>> 0, r2 || y3(t2, 4, this.length), H2.read(this, t2, false, 23, 4);
  };
  a2.prototype.readDoubleLE = function(t2, r2) {
    return t2 = t2 >>> 0, r2 || y3(t2, 8, this.length), H2.read(this, t2, true, 52, 8);
  };
  a2.prototype.readDoubleBE = function(t2, r2) {
    return t2 = t2 >>> 0, r2 || y3(t2, 8, this.length), H2.read(this, t2, false, 52, 8);
  };
  function d2(e2, t2, r2, n2, i2, o2) {
    if (!a2.isBuffer(e2))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (t2 > i2 || t2 < o2)
      throw new RangeError('"value" argument is out of bounds');
    if (r2 + n2 > e2.length)
      throw new RangeError("Index out of range");
  }
  a2.prototype.writeUintLE = a2.prototype.writeUIntLE = function(t2, r2, n2, i2) {
    if (t2 = +t2, r2 = r2 >>> 0, n2 = n2 >>> 0, !i2) {
      var _u3 = Math.pow(2, 8 * n2) - 1;
      d2(this, t2, r2, n2, _u3, 0);
    }
    var o2 = 1, s2 = 0;
    for (this[r2] = t2 & 255; ++s2 < n2 && (o2 *= 256); )
      this[r2 + s2] = t2 / o2 & 255;
    return r2 + n2;
  };
  a2.prototype.writeUintBE = a2.prototype.writeUIntBE = function(t2, r2, n2, i2) {
    if (t2 = +t2, r2 = r2 >>> 0, n2 = n2 >>> 0, !i2) {
      var _u4 = Math.pow(2, 8 * n2) - 1;
      d2(this, t2, r2, n2, _u4, 0);
    }
    var o2 = n2 - 1, s2 = 1;
    for (this[r2 + o2] = t2 & 255; --o2 >= 0 && (s2 *= 256); )
      this[r2 + o2] = t2 / s2 & 255;
    return r2 + n2;
  };
  a2.prototype.writeUint8 = a2.prototype.writeUInt8 = function(t2, r2, n2) {
    return t2 = +t2, r2 = r2 >>> 0, n2 || d2(this, t2, r2, 1, 255, 0), this[r2] = t2 & 255, r2 + 1;
  };
  a2.prototype.writeUint16LE = a2.prototype.writeUInt16LE = function(t2, r2, n2) {
    return t2 = +t2, r2 = r2 >>> 0, n2 || d2(this, t2, r2, 2, 65535, 0), this[r2] = t2 & 255, this[r2 + 1] = t2 >>> 8, r2 + 2;
  };
  a2.prototype.writeUint16BE = a2.prototype.writeUInt16BE = function(t2, r2, n2) {
    return t2 = +t2, r2 = r2 >>> 0, n2 || d2(this, t2, r2, 2, 65535, 0), this[r2] = t2 >>> 8, this[r2 + 1] = t2 & 255, r2 + 2;
  };
  a2.prototype.writeUint32LE = a2.prototype.writeUInt32LE = function(t2, r2, n2) {
    return t2 = +t2, r2 = r2 >>> 0, n2 || d2(this, t2, r2, 4, 4294967295, 0), this[r2 + 3] = t2 >>> 24, this[r2 + 2] = t2 >>> 16, this[r2 + 1] = t2 >>> 8, this[r2] = t2 & 255, r2 + 4;
  };
  a2.prototype.writeUint32BE = a2.prototype.writeUInt32BE = function(t2, r2, n2) {
    return t2 = +t2, r2 = r2 >>> 0, n2 || d2(this, t2, r2, 4, 4294967295, 0), this[r2] = t2 >>> 24, this[r2 + 1] = t2 >>> 16, this[r2 + 2] = t2 >>> 8, this[r2 + 3] = t2 & 255, r2 + 4;
  };
  function or(e2, t2, r2, n2, i2) {
    fr(t2, n2, i2, e2, r2, 7);
    var o2 = Number(t2 & BigInt(4294967295));
    e2[r2++] = o2, o2 = o2 >> 8, e2[r2++] = o2, o2 = o2 >> 8, e2[r2++] = o2, o2 = o2 >> 8, e2[r2++] = o2;
    var s2 = Number(t2 >> BigInt(32) & BigInt(4294967295));
    return e2[r2++] = s2, s2 = s2 >> 8, e2[r2++] = s2, s2 = s2 >> 8, e2[r2++] = s2, s2 = s2 >> 8, e2[r2++] = s2, r2;
  }
  function sr(e2, t2, r2, n2, i2) {
    fr(t2, n2, i2, e2, r2, 7);
    var o2 = Number(t2 & BigInt(4294967295));
    e2[r2 + 7] = o2, o2 = o2 >> 8, e2[r2 + 6] = o2, o2 = o2 >> 8, e2[r2 + 5] = o2, o2 = o2 >> 8, e2[r2 + 4] = o2;
    var s2 = Number(t2 >> BigInt(32) & BigInt(4294967295));
    return e2[r2 + 3] = s2, s2 = s2 >> 8, e2[r2 + 2] = s2, s2 = s2 >> 8, e2[r2 + 1] = s2, s2 = s2 >> 8, e2[r2] = s2, r2 + 8;
  }
  a2.prototype.writeBigUInt64LE = L2(function(t2) {
    var r2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return or(this, t2, r2, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  a2.prototype.writeBigUInt64BE = L2(function(t2) {
    var r2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return sr(this, t2, r2, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  a2.prototype.writeIntLE = function(t2, r2, n2, i2) {
    if (t2 = +t2, r2 = r2 >>> 0, !i2) {
      var _h5 = Math.pow(2, 8 * n2 - 1);
      d2(this, t2, r2, n2, _h5 - 1, -_h5);
    }
    var o2 = 0, s2 = 1, u2 = 0;
    for (this[r2] = t2 & 255; ++o2 < n2 && (s2 *= 256); )
      t2 < 0 && u2 === 0 && this[r2 + o2 - 1] !== 0 && (u2 = 1), this[r2 + o2] = (t2 / s2 >> 0) - u2 & 255;
    return r2 + n2;
  };
  a2.prototype.writeIntBE = function(t2, r2, n2, i2) {
    if (t2 = +t2, r2 = r2 >>> 0, !i2) {
      var _h6 = Math.pow(2, 8 * n2 - 1);
      d2(this, t2, r2, n2, _h6 - 1, -_h6);
    }
    var o2 = n2 - 1, s2 = 1, u2 = 0;
    for (this[r2 + o2] = t2 & 255; --o2 >= 0 && (s2 *= 256); )
      t2 < 0 && u2 === 0 && this[r2 + o2 + 1] !== 0 && (u2 = 1), this[r2 + o2] = (t2 / s2 >> 0) - u2 & 255;
    return r2 + n2;
  };
  a2.prototype.writeInt8 = function(t2, r2, n2) {
    return t2 = +t2, r2 = r2 >>> 0, n2 || d2(this, t2, r2, 1, 127, -128), t2 < 0 && (t2 = 255 + t2 + 1), this[r2] = t2 & 255, r2 + 1;
  };
  a2.prototype.writeInt16LE = function(t2, r2, n2) {
    return t2 = +t2, r2 = r2 >>> 0, n2 || d2(this, t2, r2, 2, 32767, -32768), this[r2] = t2 & 255, this[r2 + 1] = t2 >>> 8, r2 + 2;
  };
  a2.prototype.writeInt16BE = function(t2, r2, n2) {
    return t2 = +t2, r2 = r2 >>> 0, n2 || d2(this, t2, r2, 2, 32767, -32768), this[r2] = t2 >>> 8, this[r2 + 1] = t2 & 255, r2 + 2;
  };
  a2.prototype.writeInt32LE = function(t2, r2, n2) {
    return t2 = +t2, r2 = r2 >>> 0, n2 || d2(this, t2, r2, 4, 2147483647, -2147483648), this[r2] = t2 & 255, this[r2 + 1] = t2 >>> 8, this[r2 + 2] = t2 >>> 16, this[r2 + 3] = t2 >>> 24, r2 + 4;
  };
  a2.prototype.writeInt32BE = function(t2, r2, n2) {
    return t2 = +t2, r2 = r2 >>> 0, n2 || d2(this, t2, r2, 4, 2147483647, -2147483648), t2 < 0 && (t2 = 4294967295 + t2 + 1), this[r2] = t2 >>> 24, this[r2 + 1] = t2 >>> 16, this[r2 + 2] = t2 >>> 8, this[r2 + 3] = t2 & 255, r2 + 4;
  };
  a2.prototype.writeBigInt64LE = L2(function(t2) {
    var r2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return or(this, t2, r2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  a2.prototype.writeBigInt64BE = L2(function(t2) {
    var r2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return sr(this, t2, r2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function ar2(e2, t2, r2, n2, i2, o2) {
    if (r2 + n2 > e2.length)
      throw new RangeError("Index out of range");
    if (r2 < 0)
      throw new RangeError("Index out of range");
  }
  function ur(e2, t2, r2, n2, i2) {
    return t2 = +t2, r2 = r2 >>> 0, i2 || ar2(e2, t2, r2, 4), H2.write(e2, t2, r2, n2, 23, 4), r2 + 4;
  }
  a2.prototype.writeFloatLE = function(t2, r2, n2) {
    return ur(this, t2, r2, true, n2);
  };
  a2.prototype.writeFloatBE = function(t2, r2, n2) {
    return ur(this, t2, r2, false, n2);
  };
  function hr(e2, t2, r2, n2, i2) {
    return t2 = +t2, r2 = r2 >>> 0, i2 || ar2(e2, t2, r2, 8), H2.write(e2, t2, r2, n2, 52, 8), r2 + 8;
  }
  a2.prototype.writeDoubleLE = function(t2, r2, n2) {
    return hr(this, t2, r2, true, n2);
  };
  a2.prototype.writeDoubleBE = function(t2, r2, n2) {
    return hr(this, t2, r2, false, n2);
  };
  a2.prototype.copy = function(t2, r2, n2, i2) {
    if (!a2.isBuffer(t2))
      throw new TypeError("argument should be a Buffer");
    if (n2 || (n2 = 0), !i2 && i2 !== 0 && (i2 = this.length), r2 >= t2.length && (r2 = t2.length), r2 || (r2 = 0), i2 > 0 && i2 < n2 && (i2 = n2), i2 === n2 || t2.length === 0 || this.length === 0)
      return 0;
    if (r2 < 0)
      throw new RangeError("targetStart out of bounds");
    if (n2 < 0 || n2 >= this.length)
      throw new RangeError("Index out of range");
    if (i2 < 0)
      throw new RangeError("sourceEnd out of bounds");
    i2 > this.length && (i2 = this.length), t2.length - r2 < i2 - n2 && (i2 = t2.length - r2 + n2);
    var o2 = i2 - n2;
    return this === t2 && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(r2, n2, i2) : Uint8Array.prototype.set.call(t2, this.subarray(n2, i2), r2), o2;
  };
  a2.prototype.fill = function(t2, r2, n2, i2) {
    if (typeof t2 == "string") {
      if (typeof r2 == "string" ? (i2 = r2, r2 = 0, n2 = this.length) : typeof n2 == "string" && (i2 = n2, n2 = this.length), i2 !== void 0 && typeof i2 != "string")
        throw new TypeError("encoding must be a string");
      if (typeof i2 == "string" && !a2.isEncoding(i2))
        throw new TypeError("Unknown encoding: " + i2);
      if (t2.length === 1) {
        var _s6 = t2.charCodeAt(0);
        (i2 === "utf8" && _s6 < 128 || i2 === "latin1") && (t2 = _s6);
      }
    } else
      typeof t2 == "number" ? t2 = t2 & 255 : typeof t2 == "boolean" && (t2 = Number(t2));
    if (r2 < 0 || this.length < r2 || this.length < n2)
      throw new RangeError("Out of range index");
    if (n2 <= r2)
      return this;
    r2 = r2 >>> 0, n2 = n2 === void 0 ? this.length : n2 >>> 0, t2 || (t2 = 0);
    var o2;
    if (typeof t2 == "number")
      for (o2 = r2; o2 < n2; ++o2)
        this[o2] = t2;
    else {
      var _s7 = a2.isBuffer(t2) ? t2 : a2.from(t2, i2), _u5 = _s7.length;
      if (_u5 === 0)
        throw new TypeError('The value "' + t2 + '" is invalid for argument "value"');
      for (o2 = 0; o2 < n2 - r2; ++o2)
        this[o2 + r2] = _s7[o2 % _u5];
    }
    return this;
  };
  var K2 = {};
  function St(e2, t2, r2) {
    K2[e2] = function(_r7) {
      function _class() {
        var _this27;
        _classCallCheck2(this, _class);
        _this27 = _callSuper(this, _class), Object.defineProperty(_assertThisInitialized(_this27), "message", { value: t2.apply(_assertThisInitialized(_this27), arguments), writable: true, configurable: true }), _this27.name = "".concat(_this27.name, " [").concat(e2, "]"), _this27.stack, delete _this27.name;
        return _this27;
      }
      _inherits2(_class, _r7);
      return _createClass(_class, [{ key: "code", get: function get5() {
        return e2;
      }, set: function set(i2) {
        Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: i2, writable: true });
      } }, { key: "toString", value: function toString3() {
        return "".concat(this.name, " [").concat(e2, "]: ").concat(this.message);
      } }]);
    }(r2);
  }
  St("ERR_BUFFER_OUT_OF_BOUNDS", function(e2) {
    return e2 ? "".concat(e2, " is outside of buffer bounds") : "Attempt to access memory outside buffer bounds";
  }, RangeError);
  St("ERR_INVALID_ARG_TYPE", function(e2, t2) {
    return 'The "'.concat(e2, '" argument must be of type number. Received type ').concat(_typeof(t2));
  }, TypeError);
  St("ERR_OUT_OF_RANGE", function(e2, t2, r2) {
    var n2 = 'The value of "'.concat(e2, '" is out of range.'), i2 = r2;
    return Number.isInteger(r2) && Math.abs(r2) > Math.pow(2, 32) ? i2 = Qt(String(r2)) : typeof r2 == "bigint" && (i2 = String(r2), (r2 > Math.pow(BigInt(2), BigInt(32)) || r2 < -Math.pow(BigInt(2), BigInt(32))) && (i2 = Qt(i2)), i2 += "n"), n2 += " It must be ".concat(t2, ". Received ").concat(i2), n2;
  }, RangeError);
  function Qt(e2) {
    var t2 = "", r2 = e2.length, n2 = e2[0] === "-" ? 1 : 0;
    for (; r2 >= n2 + 4; r2 -= 3)
      t2 = "_".concat(e2.slice(r2 - 3, r2)).concat(t2);
    return "".concat(e2.slice(0, r2)).concat(t2);
  }
  function ae(e2, t2, r2) {
    j3(t2, "offset"), (e2[t2] === void 0 || e2[t2 + r2] === void 0) && W2(t2, e2.length - (r2 + 1));
  }
  function fr(e2, t2, r2, n2, i2, o2) {
    if (e2 > r2 || e2 < t2) {
      var _s8 = typeof t2 == "bigint" ? "n" : "", _u6;
      throw o2 > 3 ? t2 === 0 || t2 === BigInt(0) ? _u6 = ">= 0".concat(_s8, " and < 2").concat(_s8, " ** ").concat((o2 + 1) * 8).concat(_s8) : _u6 = ">= -(2".concat(_s8, " ** ").concat((o2 + 1) * 8 - 1).concat(_s8, ") and < 2 ** ").concat((o2 + 1) * 8 - 1).concat(_s8) : _u6 = ">= ".concat(t2).concat(_s8, " and <= ").concat(r2).concat(_s8), new K2.ERR_OUT_OF_RANGE("value", _u6, e2);
    }
    ae(n2, i2, o2);
  }
  function j3(e2, t2) {
    if (typeof e2 != "number")
      throw new K2.ERR_INVALID_ARG_TYPE(t2, "number", e2);
  }
  function W2(e2, t2, r2) {
    throw Math.floor(e2) !== e2 ? (j3(e2, r2), new K2.ERR_OUT_OF_RANGE(r2 || "offset", "an integer", e2)) : t2 < 0 ? new K2.ERR_BUFFER_OUT_OF_BOUNDS() : new K2.ERR_OUT_OF_RANGE(r2 || "offset", ">= ".concat(r2 ? 1 : 0, " and <= ").concat(t2), e2);
  }
  var ue = /[^+/0-9A-Za-z-_]/g;
  function he(e2) {
    if (e2 = e2.split("=")[0], e2 = e2.trim().replace(ue, ""), e2.length < 2)
      return "";
    for (; e2.length % 4 !== 0; )
      e2 = e2 + "=";
    return e2;
  }
  function At(e2, t2) {
    t2 = t2 || 1 / 0;
    var r2, n2 = e2.length, i2 = null, o2 = [];
    for (var _s9 = 0; _s9 < n2; ++_s9) {
      if (r2 = e2.charCodeAt(_s9), r2 > 55295 && r2 < 57344) {
        if (!i2) {
          if (r2 > 56319) {
            (t2 -= 3) > -1 && o2.push(239, 191, 189);
            continue;
          } else if (_s9 + 1 === n2) {
            (t2 -= 3) > -1 && o2.push(239, 191, 189);
            continue;
          }
          i2 = r2;
          continue;
        }
        if (r2 < 56320) {
          (t2 -= 3) > -1 && o2.push(239, 191, 189), i2 = r2;
          continue;
        }
        r2 = (i2 - 55296 << 10 | r2 - 56320) + 65536;
      } else
        i2 && (t2 -= 3) > -1 && o2.push(239, 191, 189);
      if (i2 = null, r2 < 128) {
        if ((t2 -= 1) < 0)
          break;
        o2.push(r2);
      } else if (r2 < 2048) {
        if ((t2 -= 2) < 0)
          break;
        o2.push(r2 >> 6 | 192, r2 & 63 | 128);
      } else if (r2 < 65536) {
        if ((t2 -= 3) < 0)
          break;
        o2.push(r2 >> 12 | 224, r2 >> 6 & 63 | 128, r2 & 63 | 128);
      } else if (r2 < 1114112) {
        if ((t2 -= 4) < 0)
          break;
        o2.push(r2 >> 18 | 240, r2 >> 12 & 63 | 128, r2 >> 6 & 63 | 128, r2 & 63 | 128);
      } else
        throw new Error("Invalid code point");
    }
    return o2;
  }
  function fe(e2) {
    var t2 = [];
    for (var _r8 = 0; _r8 < e2.length; ++_r8)
      t2.push(e2.charCodeAt(_r8) & 255);
    return t2;
  }
  function ce(e2, t2) {
    var r2, n2, i2, o2 = [];
    for (var _s10 = 0; _s10 < e2.length && !((t2 -= 2) < 0); ++_s10)
      r2 = e2.charCodeAt(_s10), n2 = r2 >> 8, i2 = r2 % 256, o2.push(i2), o2.push(n2);
    return o2;
  }
  function cr(e2) {
    return Bt.toByteArray(he(e2));
  }
  function et(e2, t2, r2, n2) {
    var i2;
    for (i2 = 0; i2 < n2 && !(i2 + r2 >= t2.length || i2 >= e2.length); ++i2)
      t2[i2 + r2] = e2[i2];
    return i2;
  }
  function A2(e2, t2) {
    return e2 instanceof t2 || e2 != null && e2.constructor != null && e2.constructor.name != null && e2.constructor.name === t2.name;
  }
  function Ut(e2) {
    return e2 !== e2;
  }
  var pe = function() {
    var e2 = "0123456789abcdef", t2 = new Array(256);
    for (var _r9 = 0; _r9 < 16; ++_r9) {
      var _n4 = _r9 * 16;
      for (var _i71 = 0; _i71 < 16; ++_i71)
        t2[_n4 + _i71] = e2[_r9] + e2[_i71];
    }
    return t2;
  }();
  function L2(e2) {
    return (typeof BigInt === "undefined" ? "undefined" : _typeof(BigInt)) > "u" ? le : e2;
  }
  function le() {
    throw new Error("BigInt not supported");
  }
});
var pr = T(function(Je, Ft) {
  (typeof window === "undefined" ? "undefined" : _typeof(window)) < "u" ? (window.global = window, global.fetch = window.fetch, Ft.exports = { Buffer: nt().Buffer, Crypto: window.crypto }) : Ft.exports = { Buffer: nt().Buffer, Crypto: crypto };
});
var Lt = {};
Ar$1(Lt, { AVSCTap: function AVSCTap() {
  return $;
}, ArweaveSigner: function ArweaveSigner() {
  return N;
}, DataItem: function DataItem() {
  return _2;
}, MAX_TAG_BYTES: function MAX_TAG_BYTES() {
  return tt;
}, MIN_BINARY_SIZE: function MIN_BINARY_SIZE() {
  return gr;
}, SIG_CONFIG: function SIG_CONFIG() {
  return P;
}, SignatureConfig: function SignatureConfig() {
  return B;
}, Signer: function Signer() {
  return ot;
}, createData: function createData() {
  return ge;
}, deserializeTags: function deserializeTags() {
  return Q;
}, indexToType: function indexToType() {
  return wt;
}, serializeTags: function serializeTags() {
  return dt;
}, tagsExceedLimit: function tagsExceedLimit() {
  return jr;
} });
var ot = function() {
  function ot2() {
    _classCallCheck2(this, ot2);
    _defineProperty(this, "signer", void 0);
    _defineProperty(this, "publicKey", void 0);
    _defineProperty(this, "signatureType", void 0);
    _defineProperty(this, "signatureLength", void 0);
    _defineProperty(this, "ownerLength", void 0);
    _defineProperty(this, "pem", void 0);
  }
  return _createClass(ot2, null, [{ key: "verify", value: function verify(t2, r2, n2, i2) {
    throw new Error("You must implement verify method on child");
  } }]);
}();
var vt = C(z(), 1);
var w = C(pt(), 1);
function X(_x158) {
  return _X.apply(this, arguments);
}
function _X() {
  _X = _asyncToGenerator(_regeneratorRuntime().mark(function _callee223(e2) {
    var _i79, t2, r2, n2;
    return _regeneratorRuntime().wrap(function _callee223$(_context225) {
      while (1)
        switch (_context225.prev = _context225.next) {
          case 0:
            if (!Array.isArray(e2)) {
              _context225.next = 10;
              break;
            }
            _i79 = (0, w.concatBuffers)([(0, w.stringToBuffer)("list"), (0, w.stringToBuffer)(e2.length.toString())]);
            _context225.t0 = Gt;
            _context225.t1 = e2;
            _context225.next = 6;
            return x().hash(_i79, "SHA-384");
          case 6:
            _context225.t2 = _context225.sent;
            _context225.next = 9;
            return (0, _context225.t0)(_context225.t1, _context225.t2);
          case 9:
            return _context225.abrupt("return", _context225.sent);
          case 10:
            t2 = e2;
            r2 = (0, w.concatBuffers)([(0, w.stringToBuffer)("blob"), (0, w.stringToBuffer)(t2.byteLength.toString())]);
            _context225.t3 = (0, w.concatBuffers);
            _context225.next = 15;
            return x().hash(r2, "SHA-384");
          case 15:
            _context225.t4 = _context225.sent;
            _context225.next = 18;
            return x().hash(t2, "SHA-384");
          case 18:
            _context225.t5 = _context225.sent;
            _context225.t6 = [_context225.t4, _context225.t5];
            n2 = (0, _context225.t3)(_context225.t6);
            _context225.next = 23;
            return x().hash(n2, "SHA-384");
          case 23:
            return _context225.abrupt("return", _context225.sent);
          case 24:
          case "end":
            return _context225.stop();
        }
    }, _callee223);
  }));
  return _X.apply(this, arguments);
}
function Gt(_x159, _x160) {
  return _Gt.apply(this, arguments);
}
function _Gt() {
  _Gt = _asyncToGenerator(_regeneratorRuntime().mark(function _callee224(e2, t2) {
    var r2, n2;
    return _regeneratorRuntime().wrap(function _callee224$(_context226) {
      while (1)
        switch (_context226.prev = _context226.next) {
          case 0:
            if (!(e2.length < 1)) {
              _context226.next = 2;
              break;
            }
            return _context226.abrupt("return", t2);
          case 2:
            _context226.t0 = (0, w.concatBuffers);
            _context226.t1 = t2;
            _context226.next = 6;
            return X(e2[0]);
          case 6:
            _context226.t2 = _context226.sent;
            _context226.t3 = [_context226.t1, _context226.t2];
            r2 = (0, _context226.t0)(_context226.t3);
            _context226.next = 11;
            return x().hash(r2, "SHA-384");
          case 11:
            n2 = _context226.sent;
            _context226.next = 14;
            return Gt(e2.slice(1), n2);
          case 14:
            return _context226.abrupt("return", _context226.sent);
          case 15:
          case "end":
            return _context226.stop();
        }
    }, _callee224);
  }));
  return _Gt.apply(this, arguments);
}
var Z = C(Yt(), 1);
var $r = Z.default.default ? Z.default.default : Z.default;
var yt = function(_$r) {
  function yt2() {
    _classCallCheck2(this, yt2);
    return _callSuper(this, yt2, arguments);
  }
  _inherits2(yt2, _$r);
  return _createClass(yt2, [{ key: "getPublicKey", value: function getPublicKey(t2) {
    throw new Error("Unimplemented");
  } }]);
}($r);
var Kr;
function x() {
  return Kr !== null && Kr !== void 0 ? Kr : Kr = new yt();
}
var B;
(function(e2) {
  e2[e2.ARWEAVE = 1] = "ARWEAVE", e2[e2.ED25519 = 2] = "ED25519", e2[e2.ETHEREUM = 3] = "ETHEREUM", e2[e2.SOLANA = 4] = "SOLANA", e2[e2.INJECTEDAPTOS = 5] = "INJECTEDAPTOS", e2[e2.MULTIAPTOS = 6] = "MULTIAPTOS", e2[e2.TYPEDETHEREUM = 7] = "TYPEDETHEREUM";
})(B || (B = {}));
var P = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, B.ARWEAVE, { sigLength: 512, pubLength: 512, sigName: "arweave" }), B.ED25519, { sigLength: 64, pubLength: 32, sigName: "ed25519" }), B.ETHEREUM, { sigLength: 65, pubLength: 65, sigName: "ethereum" }), B.SOLANA, { sigLength: 64, pubLength: 32, sigName: "solana" }), B.INJECTEDAPTOS, { sigLength: 64, pubLength: 32, sigName: "injectedAptos" }), B.MULTIAPTOS, { sigLength: 64 * 32 + 4, pubLength: 32 * 32 + 1, sigName: "multiAptos" }), B.TYPEDETHEREUM, { sigLength: 65, pubLength: 42, sigName: "typedEthereum" });
var N = function() {
  function N10(t2) {
    _classCallCheck2(this, N10);
    _defineProperty(this, "signatureType", 1);
    _defineProperty(this, "ownerLength", P[1].pubLength);
    _defineProperty(this, "signatureLength", P[1].sigLength);
    _defineProperty(this, "jwk", void 0);
    _defineProperty(this, "pk", void 0);
    this.pk = t2.n, this.jwk = t2;
  }
  return _createClass(N10, [{ key: "publicKey", get: function get5() {
    return vt.default.toBuffer(this.pk);
  } }, { key: "sign", value: function sign(t2) {
    return x().sign(this.jwk, t2);
  } }], [{ key: "verify", value: function() {
    var _verify5 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee108(t2, r2, n2) {
      return _regeneratorRuntime().wrap(function _callee108$(_context109) {
        while (1)
          switch (_context109.prev = _context109.next) {
            case 0:
              _context109.next = 2;
              return x().verify(t2, r2, n2);
            case 2:
              return _context109.abrupt("return", _context109.sent);
            case 3:
            case "end":
              return _context109.stop();
          }
      }, _callee108);
    }));
    function verify(_x161, _x162, _x163) {
      return _verify5.apply(this, arguments);
    }
    return verify;
  }() }]);
}();
var wt = { 1: N };
var E = C(z(), 1);
function v(_x164) {
  return _v.apply(this, arguments);
}
function _v() {
  _v = _asyncToGenerator(_regeneratorRuntime().mark(function _callee225(e2) {
    return _regeneratorRuntime().wrap(function _callee225$(_context227) {
      while (1)
        switch (_context227.prev = _context227.next) {
          case 0:
            return _context227.abrupt("return", X([(0, w.stringToBuffer)("dataitem"), (0, w.stringToBuffer)("1"), (0, w.stringToBuffer)(e2.signatureType.toString()), e2.rawOwner, e2.rawTarget, e2.rawAnchor, e2.rawTags, e2.rawData]));
          case 1:
          case "end":
            return _context227.stop();
        }
    }, _callee225);
  }));
  return _v.apply(this, arguments);
}
function Hr(_x165, _x166) {
  return _Hr.apply(this, arguments);
}
function _Hr() {
  _Hr = _asyncToGenerator(_regeneratorRuntime().mark(function _callee226(e2, t2) {
    var r2, n2, i2;
    return _regeneratorRuntime().wrap(function _callee226$(_context228) {
      while (1)
        switch (_context228.prev = _context228.next) {
          case 0:
            _context228.next = 2;
            return v(e2);
          case 2:
            r2 = _context228.sent;
            _context228.next = 5;
            return t2.sign(r2);
          case 5:
            n2 = _context228.sent;
            _context228.next = 8;
            return x().hash(n2);
          case 8:
            i2 = _context228.sent;
            return _context228.abrupt("return", { signature: Buffer.from(n2), id: Buffer.from(i2) });
          case 10:
          case "end":
            return _context228.stop();
        }
    }, _callee226);
  }));
  return _Hr.apply(this, arguments);
}
function Wt(_x167, _x168) {
  return _Wt.apply(this, arguments);
}
function _Wt() {
  _Wt = _asyncToGenerator(_regeneratorRuntime().mark(function _callee227(e2, t2) {
    var _yield$Hr, r2, n2;
    return _regeneratorRuntime().wrap(function _callee227$(_context229) {
      while (1)
        switch (_context229.prev = _context229.next) {
          case 0:
            _context229.next = 2;
            return Hr(e2, t2);
          case 2:
            _yield$Hr = _context229.sent;
            r2 = _yield$Hr.signature;
            n2 = _yield$Hr.id;
            return _context229.abrupt("return", (e2.getRaw().set(r2, 2), n2));
          case 6:
          case "end":
            return _context229.stop();
        }
    }, _callee227);
  }));
  return _Wt.apply(this, arguments);
}
var $ = function() {
  function $2() {
    var t2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Buffer.alloc(tt);
    var r2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    _classCallCheck2(this, $2);
    _defineProperty(this, "buf", void 0);
    _defineProperty(this, "pos", void 0);
    this.buf = t2, this.pos = r2;
  }
  return _createClass($2, [{ key: "writeTags", value: function writeTags(t2) {
    if (!Array.isArray(t2))
      throw new Error("input must be array");
    var r2 = t2.length, n2;
    if (r2)
      for (this.writeLong(r2), n2 = 0; n2 < r2; n2++) {
        var _i72 = t2[n2];
        if ((_i72 === null || _i72 === void 0 ? void 0 : _i72.name) === void 0 || (_i72 === null || _i72 === void 0 ? void 0 : _i72.value) === void 0)
          throw new Error("Invalid tag format for ".concat(_i72, ", expected {name:string, value: string}"));
        this.writeString(_i72.name), this.writeString(_i72.value);
      }
    this.writeLong(0);
  } }, { key: "toBuffer", value: function toBuffer2() {
    var t2 = Buffer.alloc(this.pos);
    if (this.pos > this.buf.length)
      throw new Error("Too many tag bytes (".concat(this.pos, " > ").concat(this.buf.length, ")"));
    return this.buf.copy(t2, 0, 0, this.pos), t2;
  } }, { key: "tagsExceedLimit", value: function tagsExceedLimit2() {
    return this.pos > this.buf.length;
  } }, { key: "writeLong", value: function writeLong(t2) {
    var r2 = this.buf, n2, i2;
    if (t2 >= -1073741824 && t2 < 1073741824) {
      i2 = t2 >= 0 ? t2 << 1 : ~t2 << 1 | 1;
      do
        r2[this.pos] = i2 & 127, i2 >>= 7;
      while (i2 && (r2[this.pos++] |= 128));
    } else {
      n2 = t2 >= 0 ? t2 * 2 : -t2 * 2 - 1;
      do
        r2[this.pos] = n2 & 127, n2 /= 128;
      while (n2 >= 1 && (r2[this.pos++] |= 128));
    }
    this.pos++, this.buf = r2;
  } }, { key: "writeString", value: function writeString(t2) {
    var r2 = Buffer.byteLength(t2), n2 = this.buf;
    this.writeLong(r2);
    var i2 = this.pos;
    if (this.pos += r2, !(this.pos > n2.length)) {
      if (r2 > 64)
        this.buf.write(t2, this.pos - r2, r2, "utf8");
      else {
        var _o6, _s11, _u7, _h7;
        for (_o6 = 0, _s11 = r2; _o6 < _s11; _o6++)
          _u7 = t2.charCodeAt(_o6), _u7 < 128 ? n2[i2++] = _u7 : _u7 < 2048 ? (n2[i2++] = _u7 >> 6 | 192, n2[i2++] = _u7 & 63 | 128) : (_u7 & 64512) === 55296 && ((_h7 = t2.charCodeAt(_o6 + 1)) & 64512) === 56320 ? (_u7 = 65536 + ((_u7 & 1023) << 10) + (_h7 & 1023), _o6++, n2[i2++] = _u7 >> 18 | 240, n2[i2++] = _u7 >> 12 & 63 | 128, n2[i2++] = _u7 >> 6 & 63 | 128, n2[i2++] = _u7 & 63 | 128) : (n2[i2++] = _u7 >> 12 | 224, n2[i2++] = _u7 >> 6 & 63 | 128, n2[i2++] = _u7 & 63 | 128);
      }
      this.buf = n2;
    }
  } }, { key: "readLong", value: function readLong() {
    var t2 = 0, r2 = 0, n2 = this.buf, i2, o2, s2, u2;
    do
      i2 = n2[this.pos++], o2 = i2 & 128, t2 |= (i2 & 127) << r2, r2 += 7;
    while (o2 && r2 < 28);
    if (o2) {
      s2 = t2, u2 = 268435456;
      do
        i2 = n2[this.pos++], s2 += (i2 & 127) * u2, u2 *= 128;
      while (i2 & 128);
      return (s2 % 2 ? -(s2 + 1) : s2) / 2;
    }
    return t2 >> 1 ^ -(t2 & 1);
  } }, { key: "skipLong", value: function skipLong() {
    var t2 = this.buf;
    for (; t2[this.pos++] & 128; )
      ;
  } }, { key: "readTags", value: function readTags() {
    var t2 = [], r2;
    for (; r2 = this.readLong(); )
      for (r2 < 0 && (r2 = -r2, this.skipLong()); r2--; ) {
        var _n5 = this.readString(), _i73 = this.readString();
        t2.push({ name: _n5, value: _i73 });
      }
    return t2;
  } }, { key: "readString", value: function readString() {
    var t2 = this.readLong(), r2 = this.pos, n2 = this.buf;
    if (this.pos += t2, !(this.pos > n2.length))
      return this.buf.slice(r2, r2 + t2).toString();
  } }]);
}();
function dt(e2) {
  var t2 = new $();
  return t2.writeTags(e2), t2.toBuffer();
}
function jr(e2) {
  var t2 = new $();
  return t2.writeTags(e2), t2.tagsExceedLimit();
}
function Q(e2) {
  return new $(e2).readTags();
}
function I(e2) {
  var t2 = 0;
  for (var _r10 = e2.length - 1; _r10 >= 0; _r10--)
    t2 = t2 * 256 + e2[_r10];
  return t2;
}
function Vt(e2) {
  if (e2 > (2 ^ 32 - 1))
    throw new Error("Short too long");
  var t2 = [0, 0];
  for (var _r11 = 0; _r11 < t2.length; _r11++) {
    var _n6 = e2 & 255;
    t2[_r11] = _n6, e2 = (e2 - _n6) / 256;
  }
  return Uint8Array.from(t2);
}
function xt(e2) {
  var t2 = [0, 0, 0, 0, 0, 0, 0, 0];
  for (var _r12 = 0; _r12 < t2.length; _r12++) {
    var _n7 = e2 & 255;
    t2[_r12] = _n7, e2 = (e2 - _n7) / 256;
  }
  return Uint8Array.from(t2);
}
var lr = C(pr(), 1);
var M = C(nt(), 1);
var tt = 4096;
var gr = 80;
var _2 = function() {
  function _(t2) {
    _classCallCheck2(this, _);
    _defineProperty(this, "binary", void 0);
    _defineProperty(this, "_id", void 0);
    this.binary = t2;
  }
  return _createClass(_, [{ key: "signatureType", get: function get5() {
    var _B;
    var t2 = I(this.binary.subarray(0, 2));
    if (((_B = B) === null || _B === void 0 ? void 0 : _B[t2]) !== void 0)
      return t2;
    throw new Error("Unknown signature type: " + t2);
  } }, { key: "isValid", value: function() {
    var _isValid = _asyncToGenerator(_regeneratorRuntime().mark(function _callee109() {
      return _regeneratorRuntime().wrap(function _callee109$(_context110) {
        while (1)
          switch (_context110.prev = _context110.next) {
            case 0:
              return _context110.abrupt("return", _2.verify(this.binary));
            case 1:
            case "end":
              return _context110.stop();
          }
      }, _callee109, this);
    }));
    function isValid() {
      return _isValid.apply(this, arguments);
    }
    return isValid;
  }() }, { key: "id", get: function get5() {
    var _this28 = this;
    return _asyncToGenerator(_regeneratorRuntime().mark(function _callee110() {
      return _regeneratorRuntime().wrap(function _callee110$(_context111) {
        while (1)
          switch (_context111.prev = _context111.next) {
            case 0:
              _context111.t0 = E.default;
              _context111.next = 3;
              return _this28.rawId;
            case 3:
              _context111.t1 = _context111.sent;
              return _context111.abrupt("return", _context111.t0.encode.call(_context111.t0, _context111.t1));
            case 5:
            case "end":
              return _context111.stop();
          }
      }, _callee110);
    }))();
  }, set: function set(t2) {
    this._id = E.default.toBuffer(t2);
  } }, { key: "rawId", get: function get5() {
    var _this29 = this;
    return _asyncToGenerator(_regeneratorRuntime().mark(function _callee111() {
      return _regeneratorRuntime().wrap(function _callee111$(_context112) {
        while (1)
          switch (_context112.prev = _context112.next) {
            case 0:
              _context112.t0 = M.Buffer;
              _context112.next = 3;
              return lr.Crypto.subtle.digest("SHA-256", _this29.rawSignature);
            case 3:
              _context112.t1 = _context112.sent;
              return _context112.abrupt("return", _context112.t0.from.call(_context112.t0, _context112.t1));
            case 5:
            case "end":
              return _context112.stop();
          }
      }, _callee111);
    }))();
  }, set: function set(t2) {
    this._id = t2;
  } }, { key: "rawSignature", get: function get5() {
    return this.binary.subarray(2, 2 + this.signatureLength);
  } }, { key: "signature", get: function get5() {
    return E.default.encode(this.rawSignature);
  } }, { key: "rawOwner", get: function get5() {
    return this.binary.subarray(2 + this.signatureLength, 2 + this.signatureLength + this.ownerLength);
  }, set: function set(t2) {
    if (t2.byteLength != this.ownerLength)
      throw new Error("Expected raw owner (pubkey) to be ".concat(this.ownerLength, " bytes, got ").concat(t2.byteLength, " bytes."));
    this.binary.set(t2, 2 + this.signatureLength);
  } }, { key: "signatureLength", get: function get5() {
    return P[this.signatureType].sigLength;
  } }, { key: "owner", get: function get5() {
    return E.default.encode(this.rawOwner);
  } }, { key: "ownerLength", get: function get5() {
    return P[this.signatureType].pubLength;
  } }, { key: "rawTarget", get: function get5() {
    var t2 = this.getTargetStart();
    return this.binary[t2] == 1 ? this.binary.subarray(t2 + 1, t2 + 33) : M.Buffer.alloc(0);
  } }, { key: "target", get: function get5() {
    return E.default.encode(this.rawTarget);
  } }, { key: "rawAnchor", get: function get5() {
    var t2 = this.getAnchorStart();
    return this.binary[t2] == 1 ? this.binary.subarray(t2 + 1, t2 + 33) : M.Buffer.alloc(0);
  } }, { key: "anchor", get: function get5() {
    return this.rawAnchor.toString();
  } }, { key: "rawTags", get: function get5() {
    var t2 = this.getTagsStart(), r2 = I(this.binary.subarray(t2 + 8, t2 + 16));
    return this.binary.subarray(t2 + 16, t2 + 16 + r2);
  } }, { key: "tags", get: function get5() {
    var t2 = this.getTagsStart();
    if (I(this.binary.subarray(t2, t2 + 8)) == 0)
      return [];
    var n2 = I(this.binary.subarray(t2 + 8, t2 + 16));
    return Q(M.Buffer.from(this.binary.subarray(t2 + 16, t2 + 16 + n2)));
  } }, { key: "tagsB64Url", get: function get5() {
    return this.tags.map(function(r2) {
      return { name: E.default.encode(r2.name), value: E.default.encode(r2.value) };
    });
  } }, { key: "getStartOfData", value: function getStartOfData() {
    var t2 = this.getTagsStart(), r2 = this.binary.subarray(t2 + 8, t2 + 16), n2 = I(r2);
    return t2 + 16 + n2;
  } }, { key: "rawData", get: function get5() {
    var t2 = this.getTagsStart(), r2 = this.binary.subarray(t2 + 8, t2 + 16), n2 = I(r2), i2 = t2 + 16 + n2;
    return this.binary.subarray(i2, this.binary.length);
  } }, { key: "data", get: function get5() {
    return E.default.encode(this.rawData);
  } }, { key: "getRaw", value: function getRaw() {
    return this.binary;
  } }, { key: "sign", value: function() {
    var _sign4 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee112(t2) {
      return _regeneratorRuntime().wrap(function _callee112$(_context113) {
        while (1)
          switch (_context113.prev = _context113.next) {
            case 0:
              _context113.next = 2;
              return Wt(this, t2);
            case 2:
              this._id = _context113.sent;
              return _context113.abrupt("return", this.rawId);
            case 4:
            case "end":
              return _context113.stop();
          }
      }, _callee112, this);
    }));
    function sign(_x169) {
      return _sign4.apply(this, arguments);
    }
    return sign;
  }() }, { key: "setSignature", value: function() {
    var _setSignature = _asyncToGenerator(_regeneratorRuntime().mark(function _callee113(t2) {
      return _regeneratorRuntime().wrap(function _callee113$(_context114) {
        while (1)
          switch (_context114.prev = _context114.next) {
            case 0:
              this.binary.set(t2, 2);
              _context114.t0 = M.Buffer;
              _context114.next = 4;
              return x().hash(t2);
            case 4:
              _context114.t1 = _context114.sent;
              this._id = _context114.t0.from.call(_context114.t0, _context114.t1);
            case 6:
            case "end":
              return _context114.stop();
          }
      }, _callee113, this);
    }));
    function setSignature(_x170) {
      return _setSignature.apply(this, arguments);
    }
    return setSignature;
  }() }, { key: "isSigned", value: function isSigned() {
    var _this$_id$length, _this$_id;
    return ((_this$_id$length = (_this$_id = this._id) === null || _this$_id === void 0 ? void 0 : _this$_id.length) !== null && _this$_id$length !== void 0 ? _this$_id$length : 0) > 0;
  } }, { key: "toJSON", value: function toJSON2() {
    return { signature: this.signature, owner: this.owner, target: this.target, tags: this.tags.map(function(t2) {
      return { name: E.default.encode(t2.name), value: E.default.encode(t2.value) };
    }), data: this.data };
  } }, { key: "getSignatureData", value: function() {
    var _getSignatureData = _asyncToGenerator(_regeneratorRuntime().mark(function _callee114() {
      return _regeneratorRuntime().wrap(function _callee114$(_context115) {
        while (1)
          switch (_context115.prev = _context115.next) {
            case 0:
              return _context115.abrupt("return", v(this));
            case 1:
            case "end":
              return _context115.stop();
          }
      }, _callee114, this);
    }));
    function getSignatureData() {
      return _getSignatureData.apply(this, arguments);
    }
    return getSignatureData;
  }() }, { key: "getTagsStart", value: function getTagsStart() {
    var t2 = this.getTargetStart(), r2 = this.binary[t2] == 1, n2 = t2 + (r2 ? 33 : 1), i2 = this.binary[n2] == 1;
    return n2 += i2 ? 33 : 1, n2;
  } }, { key: "getTargetStart", value: function getTargetStart() {
    return 2 + this.signatureLength + this.ownerLength;
  } }, { key: "getAnchorStart", value: function getAnchorStart() {
    var t2 = this.getTargetStart() + 1, r2 = this.binary[this.getTargetStart()] == 1;
    return t2 += r2 ? 32 : 0, t2;
  } }], [{ key: "isDataItem", value: function isDataItem(t2) {
    return t2.binary !== void 0;
  } }, { key: "verify", value: function() {
    var _verify6 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee115(t2) {
      var r2, n2, i2, o2, s2, u2, h2, p2;
      return _regeneratorRuntime().wrap(function _callee115$(_context116) {
        while (1)
          switch (_context116.prev = _context116.next) {
            case 0:
              if (!(t2.byteLength < gr)) {
                _context116.next = 2;
                break;
              }
              return _context116.abrupt("return", false);
            case 2:
              r2 = new _2(t2), n2 = r2.signatureType, i2 = r2.getTagsStart(), o2 = I(t2.subarray(i2, i2 + 8)), s2 = t2.subarray(i2 + 8, i2 + 16), u2 = I(s2);
              if (!(u2 > tt)) {
                _context116.next = 5;
                break;
              }
              return _context116.abrupt("return", false);
            case 5:
              if (!(o2 > 0)) {
                _context116.next = 14;
                break;
              }
              _context116.prev = 6;
              if (!(Q(M.Buffer.from(t2.subarray(i2 + 16, i2 + 16 + u2))).length !== o2)) {
                _context116.next = 9;
                break;
              }
              return _context116.abrupt("return", false);
            case 9:
              _context116.next = 14;
              break;
            case 11:
              _context116.prev = 11;
              _context116.t0 = _context116["catch"](6);
              return _context116.abrupt("return", false);
            case 14:
              h2 = wt[n2];
              _context116.next = 17;
              return v(r2);
            case 17:
              p2 = _context116.sent;
              _context116.next = 20;
              return h2.verify(r2.rawOwner, p2, r2.rawSignature);
            case 20:
              return _context116.abrupt("return", _context116.sent);
            case 21:
            case "end":
              return _context116.stop();
          }
      }, _callee115, null, [[6, 11]]);
    }));
    function verify(_x171) {
      return _verify6.apply(this, arguments);
    }
    return verify;
  }() }]);
}();
var yr = C(z(), 1);
function ge(e2, t2, r2) {
  var _i$byteLength, _s$byteLength, _r$tags$length, _r$tags, _r$tags$length2, _r$tags2, _h$byteLength;
  var n2 = t2.publicKey, i2 = r2 !== null && r2 !== void 0 && r2.target ? yr.default.toBuffer(r2.target) : null, o2 = 1 + ((_i$byteLength = i2 === null || i2 === void 0 ? void 0 : i2.byteLength) !== null && _i$byteLength !== void 0 ? _i$byteLength : 0), s2 = r2 !== null && r2 !== void 0 && r2.anchor ? Buffer.from(r2.anchor) : null, u2 = 1 + ((_s$byteLength = s2 === null || s2 === void 0 ? void 0 : s2.byteLength) !== null && _s$byteLength !== void 0 ? _s$byteLength : 0), h2 = ((_r$tags$length = r2 === null || r2 === void 0 || (_r$tags = r2.tags) === null || _r$tags === void 0 ? void 0 : _r$tags.length) !== null && _r$tags$length !== void 0 ? _r$tags$length : 0) > 0 ? dt(r2.tags) : null, p2 = 16 + (h2 ? h2.byteLength : 0), f2 = Buffer.from(e2), c3 = f2.byteLength, U2 = 2 + t2.signatureLength + t2.ownerLength + o2 + u2 + p2 + c3, l2 = Buffer.alloc(U2);
  if (l2.set(Vt(t2.signatureType), 0), l2.set(new Uint8Array(t2.signatureLength).fill(0), 2), n2.byteLength !== t2.ownerLength)
    throw new Error("Owner must be ".concat(t2.ownerLength, " bytes, but was incorrectly ").concat(n2.byteLength));
  l2.set(n2, 2 + t2.signatureLength);
  var R2 = 2 + t2.signatureLength + t2.ownerLength;
  if (l2[R2] = i2 ? 1 : 0, i2) {
    if (i2.byteLength !== 32)
      throw new Error("Target must be 32 bytes but was incorrectly ".concat(i2.byteLength));
    l2.set(i2, R2 + 1);
  }
  var G2 = R2 + o2, Y2 = G2 + 1;
  if (l2[G2] = s2 ? 1 : 0, s2) {
    if (Y2 += s2.byteLength, s2.byteLength !== 32)
      throw new Error("Anchor must be 32 bytes");
    l2.set(s2, G2 + 1);
  }
  l2.set(xt((_r$tags$length2 = r2 === null || r2 === void 0 || (_r$tags2 = r2.tags) === null || _r$tags2 === void 0 ? void 0 : _r$tags2.length) !== null && _r$tags$length2 !== void 0 ? _r$tags$length2 : 0), Y2);
  var wr = xt((_h$byteLength = h2 === null || h2 === void 0 ? void 0 : h2.byteLength) !== null && _h$byteLength !== void 0 ? _h$byteLength : 0);
  l2.set(wr, Y2 + 8), h2 && l2.set(h2, Y2 + 16);
  var dr = Y2 + p2;
  return l2.set(f2, dr), new _2(l2);
}
var _t = _objectSpread({}, Lt);
(_globalThis$arbundles = globalThis.arbundles) !== null && _globalThis$arbundles !== void 0 ? _globalThis$arbundles : globalThis.arbundles = _t;
var web = {};
var common = {};
var ar = {};
var bignumber = { exports: {} };
(function(module) {
  (function(globalObject) {
    var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER2 = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
    function clone3(configObject) {
      var div, convertBase, parseNumeric, P3 = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
        prefix: "",
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ",",
        decimalSeparator: ".",
        fractionGroupSize: 0,
        fractionGroupSeparator: "",
        // non-breaking space
        suffix: ""
      }, ALPHABET2 = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
      function BigNumber2(v2, b3) {
        var alphabet2, c3, caseChanged, e2, i2, isNum, len2, str, x2 = this;
        if (!(x2 instanceof BigNumber2))
          return new BigNumber2(v2, b3);
        if (b3 == null) {
          if (v2 && v2._isBigNumber === true) {
            x2.s = v2.s;
            if (!v2.c || v2.e > MAX_EXP) {
              x2.c = x2.e = null;
            } else if (v2.e < MIN_EXP) {
              x2.c = [x2.e = 0];
            } else {
              x2.e = v2.e;
              x2.c = v2.c.slice();
            }
            return;
          }
          if ((isNum = typeof v2 == "number") && v2 * 0 == 0) {
            x2.s = 1 / v2 < 0 ? (v2 = -v2, -1) : 1;
            if (v2 === ~~v2) {
              for (e2 = 0, i2 = v2; i2 >= 10; i2 /= 10, e2++)
                ;
              if (e2 > MAX_EXP) {
                x2.c = x2.e = null;
              } else {
                x2.e = e2;
                x2.c = [v2];
              }
              return;
            }
            str = String(v2);
          } else {
            if (!isNumeric.test(str = String(v2)))
              return parseNumeric(x2, str, isNum);
            x2.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
          }
          if ((e2 = str.indexOf(".")) > -1)
            str = str.replace(".", "");
          if ((i2 = str.search(/e/i)) > 0) {
            if (e2 < 0)
              e2 = i2;
            e2 += +str.slice(i2 + 1);
            str = str.substring(0, i2);
          } else if (e2 < 0) {
            e2 = str.length;
          }
        } else {
          intCheck(b3, 2, ALPHABET2.length, "Base");
          if (b3 == 10 && alphabetHasNormalDecimalDigits) {
            x2 = new BigNumber2(v2);
            return round(x2, DECIMAL_PLACES + x2.e + 1, ROUNDING_MODE);
          }
          str = String(v2);
          if (isNum = typeof v2 == "number") {
            if (v2 * 0 != 0)
              return parseNumeric(x2, str, isNum, b3);
            x2.s = 1 / v2 < 0 ? (str = str.slice(1), -1) : 1;
            if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
              throw Error(tooManyDigits + v2);
            }
          } else {
            x2.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
          }
          alphabet2 = ALPHABET2.slice(0, b3);
          e2 = i2 = 0;
          for (len2 = str.length; i2 < len2; i2++) {
            if (alphabet2.indexOf(c3 = str.charAt(i2)) < 0) {
              if (c3 == ".") {
                if (i2 > e2) {
                  e2 = len2;
                  continue;
                }
              } else if (!caseChanged) {
                if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                  caseChanged = true;
                  i2 = -1;
                  e2 = 0;
                  continue;
                }
              }
              return parseNumeric(x2, String(v2), isNum, b3);
            }
          }
          isNum = false;
          str = convertBase(str, b3, 10, x2.s);
          if ((e2 = str.indexOf(".")) > -1)
            str = str.replace(".", "");
          else
            e2 = str.length;
        }
        for (i2 = 0; str.charCodeAt(i2) === 48; i2++)
          ;
        for (len2 = str.length; str.charCodeAt(--len2) === 48; )
          ;
        if (str = str.slice(i2, ++len2)) {
          len2 -= i2;
          if (isNum && BigNumber2.DEBUG && len2 > 15 && (v2 > MAX_SAFE_INTEGER2 || v2 !== mathfloor(v2))) {
            throw Error(tooManyDigits + x2.s * v2);
          }
          if ((e2 = e2 - i2 - 1) > MAX_EXP) {
            x2.c = x2.e = null;
          } else if (e2 < MIN_EXP) {
            x2.c = [x2.e = 0];
          } else {
            x2.e = e2;
            x2.c = [];
            i2 = (e2 + 1) % LOG_BASE;
            if (e2 < 0)
              i2 += LOG_BASE;
            if (i2 < len2) {
              if (i2)
                x2.c.push(+str.slice(0, i2));
              for (len2 -= LOG_BASE; i2 < len2; ) {
                x2.c.push(+str.slice(i2, i2 += LOG_BASE));
              }
              i2 = LOG_BASE - (str = str.slice(i2)).length;
            } else {
              i2 -= len2;
            }
            for (; i2--; str += "0")
              ;
            x2.c.push(+str);
          }
        } else {
          x2.c = [x2.e = 0];
        }
      }
      BigNumber2.clone = clone3;
      BigNumber2.ROUND_UP = 0;
      BigNumber2.ROUND_DOWN = 1;
      BigNumber2.ROUND_CEIL = 2;
      BigNumber2.ROUND_FLOOR = 3;
      BigNumber2.ROUND_HALF_UP = 4;
      BigNumber2.ROUND_HALF_DOWN = 5;
      BigNumber2.ROUND_HALF_EVEN = 6;
      BigNumber2.ROUND_HALF_CEIL = 7;
      BigNumber2.ROUND_HALF_FLOOR = 8;
      BigNumber2.EUCLID = 9;
      BigNumber2.config = BigNumber2.set = function(obj2) {
        var p2, v2;
        if (obj2 != null) {
          if (_typeof(obj2) == "object") {
            if (obj2.hasOwnProperty(p2 = "DECIMAL_PLACES")) {
              v2 = obj2[p2];
              intCheck(v2, 0, MAX, p2);
              DECIMAL_PLACES = v2;
            }
            if (obj2.hasOwnProperty(p2 = "ROUNDING_MODE")) {
              v2 = obj2[p2];
              intCheck(v2, 0, 8, p2);
              ROUNDING_MODE = v2;
            }
            if (obj2.hasOwnProperty(p2 = "EXPONENTIAL_AT")) {
              v2 = obj2[p2];
              if (v2 && v2.pop) {
                intCheck(v2[0], -MAX, 0, p2);
                intCheck(v2[1], 0, MAX, p2);
                TO_EXP_NEG = v2[0];
                TO_EXP_POS = v2[1];
              } else {
                intCheck(v2, -MAX, MAX, p2);
                TO_EXP_NEG = -(TO_EXP_POS = v2 < 0 ? -v2 : v2);
              }
            }
            if (obj2.hasOwnProperty(p2 = "RANGE")) {
              v2 = obj2[p2];
              if (v2 && v2.pop) {
                intCheck(v2[0], -MAX, -1, p2);
                intCheck(v2[1], 1, MAX, p2);
                MIN_EXP = v2[0];
                MAX_EXP = v2[1];
              } else {
                intCheck(v2, -MAX, MAX, p2);
                if (v2) {
                  MIN_EXP = -(MAX_EXP = v2 < 0 ? -v2 : v2);
                } else {
                  throw Error(bignumberError + p2 + " cannot be zero: " + v2);
                }
              }
            }
            if (obj2.hasOwnProperty(p2 = "CRYPTO")) {
              v2 = obj2[p2];
              if (v2 === !!v2) {
                if (v2) {
                  if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                    CRYPTO = v2;
                  } else {
                    CRYPTO = !v2;
                    throw Error(bignumberError + "crypto unavailable");
                  }
                } else {
                  CRYPTO = v2;
                }
              } else {
                throw Error(bignumberError + p2 + " not true or false: " + v2);
              }
            }
            if (obj2.hasOwnProperty(p2 = "MODULO_MODE")) {
              v2 = obj2[p2];
              intCheck(v2, 0, 9, p2);
              MODULO_MODE = v2;
            }
            if (obj2.hasOwnProperty(p2 = "POW_PRECISION")) {
              v2 = obj2[p2];
              intCheck(v2, 0, MAX, p2);
              POW_PRECISION = v2;
            }
            if (obj2.hasOwnProperty(p2 = "FORMAT")) {
              v2 = obj2[p2];
              if (_typeof(v2) == "object")
                FORMAT = v2;
              else
                throw Error(bignumberError + p2 + " not an object: " + v2);
            }
            if (obj2.hasOwnProperty(p2 = "ALPHABET")) {
              v2 = obj2[p2];
              if (typeof v2 == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v2)) {
                alphabetHasNormalDecimalDigits = v2.slice(0, 10) == "0123456789";
                ALPHABET2 = v2;
              } else {
                throw Error(bignumberError + p2 + " invalid: " + v2);
              }
            }
          } else {
            throw Error(bignumberError + "Object expected: " + obj2);
          }
        }
        return { DECIMAL_PLACES, ROUNDING_MODE, EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS], RANGE: [MIN_EXP, MAX_EXP], CRYPTO, MODULO_MODE, POW_PRECISION, FORMAT, ALPHABET: ALPHABET2 };
      };
      BigNumber2.isBigNumber = function(v2) {
        if (!v2 || v2._isBigNumber !== true)
          return false;
        if (!BigNumber2.DEBUG)
          return true;
        var i2, n2, c3 = v2.c, e2 = v2.e, s2 = v2.s;
        out:
          if ({}.toString.call(c3) == "[object Array]") {
            if ((s2 === 1 || s2 === -1) && e2 >= -MAX && e2 <= MAX && e2 === mathfloor(e2)) {
              if (c3[0] === 0) {
                if (e2 === 0 && c3.length === 1)
                  return true;
                break out;
              }
              i2 = (e2 + 1) % LOG_BASE;
              if (i2 < 1)
                i2 += LOG_BASE;
              if (String(c3[0]).length == i2) {
                for (i2 = 0; i2 < c3.length; i2++) {
                  n2 = c3[i2];
                  if (n2 < 0 || n2 >= BASE || n2 !== mathfloor(n2))
                    break out;
                }
                if (n2 !== 0)
                  return true;
              }
            }
          } else if (c3 === null && e2 === null && (s2 === null || s2 === 1 || s2 === -1)) {
            return true;
          }
        throw Error(bignumberError + "Invalid BigNumber: " + v2);
      };
      BigNumber2.maximum = BigNumber2.max = function() {
        return maxOrMin(arguments, -1);
      };
      BigNumber2.minimum = BigNumber2.min = function() {
        return maxOrMin(arguments, 1);
      };
      BigNumber2.random = function() {
        var pow2_53 = 9007199254740992;
        var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
          return mathfloor(Math.random() * pow2_53);
        } : function() {
          return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
        };
        return function(dp) {
          var a2, b3, e2, k3, v2, i2 = 0, c3 = [], rand = new BigNumber2(ONE);
          if (dp == null)
            dp = DECIMAL_PLACES;
          else
            intCheck(dp, 0, MAX);
          k3 = mathceil(dp / LOG_BASE);
          if (CRYPTO) {
            if (crypto.getRandomValues) {
              a2 = crypto.getRandomValues(new Uint32Array(k3 *= 2));
              for (; i2 < k3; ) {
                v2 = a2[i2] * 131072 + (a2[i2 + 1] >>> 11);
                if (v2 >= 9e15) {
                  b3 = crypto.getRandomValues(new Uint32Array(2));
                  a2[i2] = b3[0];
                  a2[i2 + 1] = b3[1];
                } else {
                  c3.push(v2 % 1e14);
                  i2 += 2;
                }
              }
              i2 = k3 / 2;
            } else if (crypto.randomBytes) {
              a2 = crypto.randomBytes(k3 *= 7);
              for (; i2 < k3; ) {
                v2 = (a2[i2] & 31) * 281474976710656 + a2[i2 + 1] * 1099511627776 + a2[i2 + 2] * 4294967296 + a2[i2 + 3] * 16777216 + (a2[i2 + 4] << 16) + (a2[i2 + 5] << 8) + a2[i2 + 6];
                if (v2 >= 9e15) {
                  crypto.randomBytes(7).copy(a2, i2);
                } else {
                  c3.push(v2 % 1e14);
                  i2 += 7;
                }
              }
              i2 = k3 / 7;
            } else {
              CRYPTO = false;
              throw Error(bignumberError + "crypto unavailable");
            }
          }
          if (!CRYPTO) {
            for (; i2 < k3; ) {
              v2 = random53bitInt();
              if (v2 < 9e15)
                c3[i2++] = v2 % 1e14;
            }
          }
          k3 = c3[--i2];
          dp %= LOG_BASE;
          if (k3 && dp) {
            v2 = POWS_TEN[LOG_BASE - dp];
            c3[i2] = mathfloor(k3 / v2) * v2;
          }
          for (; c3[i2] === 0; c3.pop(), i2--)
            ;
          if (i2 < 0) {
            c3 = [e2 = 0];
          } else {
            for (e2 = -1; c3[0] === 0; c3.splice(0, 1), e2 -= LOG_BASE)
              ;
            for (i2 = 1, v2 = c3[0]; v2 >= 10; v2 /= 10, i2++)
              ;
            if (i2 < LOG_BASE)
              e2 -= LOG_BASE - i2;
          }
          rand.e = e2;
          rand.c = c3;
          return rand;
        };
      }();
      BigNumber2.sum = function() {
        var i2 = 1, args = arguments, sum = new BigNumber2(args[0]);
        for (; i2 < args.length; )
          sum = sum.plus(args[i2++]);
        return sum;
      };
      convertBase = /* @__PURE__ */ function() {
        var decimal = "0123456789";
        function toBaseOut(str, baseIn, baseOut, alphabet2) {
          var j3, arr = [0], arrL, i2 = 0, len2 = str.length;
          for (; i2 < len2; ) {
            for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
              ;
            arr[0] += alphabet2.indexOf(str.charAt(i2++));
            for (j3 = 0; j3 < arr.length; j3++) {
              if (arr[j3] > baseOut - 1) {
                if (arr[j3 + 1] == null)
                  arr[j3 + 1] = 0;
                arr[j3 + 1] += arr[j3] / baseOut | 0;
                arr[j3] %= baseOut;
              }
            }
          }
          return arr.reverse();
        }
        return function(str, baseIn, baseOut, sign, callerIsToString) {
          var alphabet2, d2, e2, k3, r2, x2, xc, y3, i2 = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
          if (i2 >= 0) {
            k3 = POW_PRECISION;
            POW_PRECISION = 0;
            str = str.replace(".", "");
            y3 = new BigNumber2(baseIn);
            x2 = y3.pow(str.length - i2);
            POW_PRECISION = k3;
            y3.c = toBaseOut(toFixedPoint(coeffToString(x2.c), x2.e, "0"), 10, baseOut, decimal);
            y3.e = y3.c.length;
          }
          xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet2 = ALPHABET2, decimal) : (alphabet2 = decimal, ALPHABET2));
          e2 = k3 = xc.length;
          for (; xc[--k3] == 0; xc.pop())
            ;
          if (!xc[0])
            return alphabet2.charAt(0);
          if (i2 < 0) {
            --e2;
          } else {
            x2.c = xc;
            x2.e = e2;
            x2.s = sign;
            x2 = div(x2, y3, dp, rm, baseOut);
            xc = x2.c;
            r2 = x2.r;
            e2 = x2.e;
          }
          d2 = e2 + dp + 1;
          i2 = xc[d2];
          k3 = baseOut / 2;
          r2 = r2 || d2 < 0 || xc[d2 + 1] != null;
          r2 = rm < 4 ? (i2 != null || r2) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : i2 > k3 || i2 == k3 && (rm == 4 || r2 || rm == 6 && xc[d2 - 1] & 1 || rm == (x2.s < 0 ? 8 : 7));
          if (d2 < 1 || !xc[0]) {
            str = r2 ? toFixedPoint(alphabet2.charAt(1), -dp, alphabet2.charAt(0)) : alphabet2.charAt(0);
          } else {
            xc.length = d2;
            if (r2) {
              for (--baseOut; ++xc[--d2] > baseOut; ) {
                xc[d2] = 0;
                if (!d2) {
                  ++e2;
                  xc = [1].concat(xc);
                }
              }
            }
            for (k3 = xc.length; !xc[--k3]; )
              ;
            for (i2 = 0, str = ""; i2 <= k3; str += alphabet2.charAt(xc[i2++]))
              ;
            str = toFixedPoint(str, e2, alphabet2.charAt(0));
          }
          return str;
        };
      }();
      div = /* @__PURE__ */ function() {
        function multiply(x2, k3, base3) {
          var m2, temp, xlo, xhi, carry = 0, i2 = x2.length, klo = k3 % SQRT_BASE, khi = k3 / SQRT_BASE | 0;
          for (x2 = x2.slice(); i2--; ) {
            xlo = x2[i2] % SQRT_BASE;
            xhi = x2[i2] / SQRT_BASE | 0;
            m2 = khi * xlo + xhi * klo;
            temp = klo * xlo + m2 % SQRT_BASE * SQRT_BASE + carry;
            carry = (temp / base3 | 0) + (m2 / SQRT_BASE | 0) + khi * xhi;
            x2[i2] = temp % base3;
          }
          if (carry)
            x2 = [carry].concat(x2);
          return x2;
        }
        function compare2(a2, b3, aL, bL) {
          var i2, cmp;
          if (aL != bL) {
            cmp = aL > bL ? 1 : -1;
          } else {
            for (i2 = cmp = 0; i2 < aL; i2++) {
              if (a2[i2] != b3[i2]) {
                cmp = a2[i2] > b3[i2] ? 1 : -1;
                break;
              }
            }
          }
          return cmp;
        }
        function subtract(a2, b3, aL, base3) {
          var i2 = 0;
          for (; aL--; ) {
            a2[aL] -= i2;
            i2 = a2[aL] < b3[aL] ? 1 : 0;
            a2[aL] = i2 * base3 + a2[aL] - b3[aL];
          }
          for (; !a2[0] && a2.length > 1; a2.splice(0, 1))
            ;
        }
        return function(x2, y3, dp, rm, base3) {
          var cmp, e2, i2, more, n2, prod, prodL, q3, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s2 = x2.s == y3.s ? 1 : -1, xc = x2.c, yc = y3.c;
          if (!xc || !xc[0] || !yc || !yc[0]) {
            return new BigNumber2(
              // Return NaN if either NaN, or both Infinity or 0.
              !x2.s || !y3.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
                // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                xc && xc[0] == 0 || !yc ? s2 * 0 : s2 / 0
              )
            );
          }
          q3 = new BigNumber2(s2);
          qc = q3.c = [];
          e2 = x2.e - y3.e;
          s2 = dp + e2 + 1;
          if (!base3) {
            base3 = BASE;
            e2 = bitFloor(x2.e / LOG_BASE) - bitFloor(y3.e / LOG_BASE);
            s2 = s2 / LOG_BASE | 0;
          }
          for (i2 = 0; yc[i2] == (xc[i2] || 0); i2++)
            ;
          if (yc[i2] > (xc[i2] || 0))
            e2--;
          if (s2 < 0) {
            qc.push(1);
            more = true;
          } else {
            xL = xc.length;
            yL = yc.length;
            i2 = 0;
            s2 += 2;
            n2 = mathfloor(base3 / (yc[0] + 1));
            if (n2 > 1) {
              yc = multiply(yc, n2, base3);
              xc = multiply(xc, n2, base3);
              yL = yc.length;
              xL = xc.length;
            }
            xi = yL;
            rem = xc.slice(0, yL);
            remL = rem.length;
            for (; remL < yL; rem[remL++] = 0)
              ;
            yz = yc.slice();
            yz = [0].concat(yz);
            yc0 = yc[0];
            if (yc[1] >= base3 / 2)
              yc0++;
            do {
              n2 = 0;
              cmp = compare2(yc, rem, yL, remL);
              if (cmp < 0) {
                rem0 = rem[0];
                if (yL != remL)
                  rem0 = rem0 * base3 + (rem[1] || 0);
                n2 = mathfloor(rem0 / yc0);
                if (n2 > 1) {
                  if (n2 >= base3)
                    n2 = base3 - 1;
                  prod = multiply(yc, n2, base3);
                  prodL = prod.length;
                  remL = rem.length;
                  while (compare2(prod, rem, prodL, remL) == 1) {
                    n2--;
                    subtract(prod, yL < prodL ? yz : yc, prodL, base3);
                    prodL = prod.length;
                    cmp = 1;
                  }
                } else {
                  if (n2 == 0) {
                    cmp = n2 = 1;
                  }
                  prod = yc.slice();
                  prodL = prod.length;
                }
                if (prodL < remL)
                  prod = [0].concat(prod);
                subtract(rem, prod, remL, base3);
                remL = rem.length;
                if (cmp == -1) {
                  while (compare2(yc, rem, yL, remL) < 1) {
                    n2++;
                    subtract(rem, yL < remL ? yz : yc, remL, base3);
                    remL = rem.length;
                  }
                }
              } else if (cmp === 0) {
                n2++;
                rem = [0];
              }
              qc[i2++] = n2;
              if (rem[0]) {
                rem[remL++] = xc[xi] || 0;
              } else {
                rem = [xc[xi]];
                remL = 1;
              }
            } while ((xi++ < xL || rem[0] != null) && s2--);
            more = rem[0] != null;
            if (!qc[0])
              qc.splice(0, 1);
          }
          if (base3 == BASE) {
            for (i2 = 1, s2 = qc[0]; s2 >= 10; s2 /= 10, i2++)
              ;
            round(q3, dp + (q3.e = i2 + e2 * LOG_BASE - 1) + 1, rm, more);
          } else {
            q3.e = e2;
            q3.r = +more;
          }
          return q3;
        };
      }();
      function format(n2, i2, rm, id) {
        var c0, e2, ne, len2, str;
        if (rm == null)
          rm = ROUNDING_MODE;
        else
          intCheck(rm, 0, 8);
        if (!n2.c)
          return n2.toString();
        c0 = n2.c[0];
        ne = n2.e;
        if (i2 == null) {
          str = coeffToString(n2.c);
          str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
        } else {
          n2 = round(new BigNumber2(n2), i2, rm);
          e2 = n2.e;
          str = coeffToString(n2.c);
          len2 = str.length;
          if (id == 1 || id == 2 && (i2 <= e2 || e2 <= TO_EXP_NEG)) {
            for (; len2 < i2; str += "0", len2++)
              ;
            str = toExponential(str, e2);
          } else {
            i2 -= ne;
            str = toFixedPoint(str, e2, "0");
            if (e2 + 1 > len2) {
              if (--i2 > 0)
                for (str += "."; i2--; str += "0")
                  ;
            } else {
              i2 += e2 - len2;
              if (i2 > 0) {
                if (e2 + 1 == len2)
                  str += ".";
                for (; i2--; str += "0")
                  ;
              }
            }
          }
        }
        return n2.s < 0 && c0 ? "-" + str : str;
      }
      function maxOrMin(args, n2) {
        var k3, y3, i2 = 1, x2 = new BigNumber2(args[0]);
        for (; i2 < args.length; i2++) {
          y3 = new BigNumber2(args[i2]);
          if (!y3.s || (k3 = compare(x2, y3)) === n2 || k3 === 0 && x2.s === n2) {
            x2 = y3;
          }
        }
        return x2;
      }
      function normalise(n2, c3, e2) {
        var i2 = 1, j3 = c3.length;
        for (; !c3[--j3]; c3.pop())
          ;
        for (j3 = c3[0]; j3 >= 10; j3 /= 10, i2++)
          ;
        if ((e2 = i2 + e2 * LOG_BASE - 1) > MAX_EXP) {
          n2.c = n2.e = null;
        } else if (e2 < MIN_EXP) {
          n2.c = [n2.e = 0];
        } else {
          n2.e = e2;
          n2.c = c3;
        }
        return n2;
      }
      parseNumeric = /* @__PURE__ */ function() {
        var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
        return function(x2, str, isNum, b3) {
          var base3, s2 = isNum ? str : str.replace(whitespaceOrPlus, "");
          if (isInfinityOrNaN.test(s2)) {
            x2.s = isNaN(s2) ? null : s2 < 0 ? -1 : 1;
          } else {
            if (!isNum) {
              s2 = s2.replace(basePrefix, function(m2, p1, p2) {
                base3 = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                return !b3 || b3 == base3 ? p1 : m2;
              });
              if (b3) {
                base3 = b3;
                s2 = s2.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
              }
              if (str != s2)
                return new BigNumber2(s2, base3);
            }
            if (BigNumber2.DEBUG) {
              throw Error(bignumberError + "Not a" + (b3 ? " base " + b3 : "") + " number: " + str);
            }
            x2.s = null;
          }
          x2.c = x2.e = null;
        };
      }();
      function round(x2, sd, rm, r2) {
        var d2, i2, j3, k3, n2, ni, rd, xc = x2.c, pows10 = POWS_TEN;
        if (xc) {
          out: {
            for (d2 = 1, k3 = xc[0]; k3 >= 10; k3 /= 10, d2++)
              ;
            i2 = sd - d2;
            if (i2 < 0) {
              i2 += LOG_BASE;
              j3 = sd;
              n2 = xc[ni = 0];
              rd = mathfloor(n2 / pows10[d2 - j3 - 1] % 10);
            } else {
              ni = mathceil((i2 + 1) / LOG_BASE);
              if (ni >= xc.length) {
                if (r2) {
                  for (; xc.length <= ni; xc.push(0))
                    ;
                  n2 = rd = 0;
                  d2 = 1;
                  i2 %= LOG_BASE;
                  j3 = i2 - LOG_BASE + 1;
                } else {
                  break out;
                }
              } else {
                n2 = k3 = xc[ni];
                for (d2 = 1; k3 >= 10; k3 /= 10, d2++)
                  ;
                i2 %= LOG_BASE;
                j3 = i2 - LOG_BASE + d2;
                rd = j3 < 0 ? 0 : mathfloor(n2 / pows10[d2 - j3 - 1] % 10);
              }
            }
            r2 = r2 || sd < 0 || // Are there any non-zero digits after the rounding digit?
            // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
            // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
            xc[ni + 1] != null || (j3 < 0 ? n2 : n2 % pows10[d2 - j3 - 1]);
            r2 = rm < 4 ? (rd || r2) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r2 || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
            (i2 > 0 ? j3 > 0 ? n2 / pows10[d2 - j3] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x2.s < 0 ? 8 : 7));
            if (sd < 1 || !xc[0]) {
              xc.length = 0;
              if (r2) {
                sd -= x2.e + 1;
                xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                x2.e = -sd || 0;
              } else {
                xc[0] = x2.e = 0;
              }
              return x2;
            }
            if (i2 == 0) {
              xc.length = ni;
              k3 = 1;
              ni--;
            } else {
              xc.length = ni + 1;
              k3 = pows10[LOG_BASE - i2];
              xc[ni] = j3 > 0 ? mathfloor(n2 / pows10[d2 - j3] % pows10[j3]) * k3 : 0;
            }
            if (r2) {
              for (; ; ) {
                if (ni == 0) {
                  for (i2 = 1, j3 = xc[0]; j3 >= 10; j3 /= 10, i2++)
                    ;
                  j3 = xc[0] += k3;
                  for (k3 = 1; j3 >= 10; j3 /= 10, k3++)
                    ;
                  if (i2 != k3) {
                    x2.e++;
                    if (xc[0] == BASE)
                      xc[0] = 1;
                  }
                  break;
                } else {
                  xc[ni] += k3;
                  if (xc[ni] != BASE)
                    break;
                  xc[ni--] = 0;
                  k3 = 1;
                }
              }
            }
            for (i2 = xc.length; xc[--i2] === 0; xc.pop())
              ;
          }
          if (x2.e > MAX_EXP) {
            x2.c = x2.e = null;
          } else if (x2.e < MIN_EXP) {
            x2.c = [x2.e = 0];
          }
        }
        return x2;
      }
      function valueOf2(n2) {
        var str, e2 = n2.e;
        if (e2 === null)
          return n2.toString();
        str = coeffToString(n2.c);
        str = e2 <= TO_EXP_NEG || e2 >= TO_EXP_POS ? toExponential(str, e2) : toFixedPoint(str, e2, "0");
        return n2.s < 0 ? "-" + str : str;
      }
      P3.absoluteValue = P3.abs = function() {
        var x2 = new BigNumber2(this);
        if (x2.s < 0)
          x2.s = 1;
        return x2;
      };
      P3.comparedTo = function(y3, b3) {
        return compare(this, new BigNumber2(y3, b3));
      };
      P3.decimalPlaces = P3.dp = function(dp, rm) {
        var c3, n2, v2, x2 = this;
        if (dp != null) {
          intCheck(dp, 0, MAX);
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          return round(new BigNumber2(x2), dp + x2.e + 1, rm);
        }
        if (!(c3 = x2.c))
          return null;
        n2 = ((v2 = c3.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
        if (v2 = c3[v2])
          for (; v2 % 10 == 0; v2 /= 10, n2--)
            ;
        if (n2 < 0)
          n2 = 0;
        return n2;
      };
      P3.dividedBy = P3.div = function(y3, b3) {
        return div(this, new BigNumber2(y3, b3), DECIMAL_PLACES, ROUNDING_MODE);
      };
      P3.dividedToIntegerBy = P3.idiv = function(y3, b3) {
        return div(this, new BigNumber2(y3, b3), 0, 1);
      };
      P3.exponentiatedBy = P3.pow = function(n2, m2) {
        var half, isModExp, i2, k3, more, nIsBig, nIsNeg, nIsOdd, y3, x2 = this;
        n2 = new BigNumber2(n2);
        if (n2.c && !n2.isInteger()) {
          throw Error(bignumberError + "Exponent not an integer: " + valueOf2(n2));
        }
        if (m2 != null)
          m2 = new BigNumber2(m2);
        nIsBig = n2.e > 14;
        if (!x2.c || !x2.c[0] || x2.c[0] == 1 && !x2.e && x2.c.length == 1 || !n2.c || !n2.c[0]) {
          y3 = new BigNumber2(Math.pow(+valueOf2(x2), nIsBig ? n2.s * (2 - isOdd(n2)) : +valueOf2(n2)));
          return m2 ? y3.mod(m2) : y3;
        }
        nIsNeg = n2.s < 0;
        if (m2) {
          if (m2.c ? !m2.c[0] : !m2.s)
            return new BigNumber2(NaN);
          isModExp = !nIsNeg && x2.isInteger() && m2.isInteger();
          if (isModExp)
            x2 = x2.mod(m2);
        } else if (n2.e > 9 && (x2.e > 0 || x2.e < -1 || (x2.e == 0 ? x2.c[0] > 1 || nIsBig && x2.c[1] >= 24e7 : x2.c[0] < 8e13 || nIsBig && x2.c[0] <= 9999975e7))) {
          k3 = x2.s < 0 && isOdd(n2) ? -0 : 0;
          if (x2.e > -1)
            k3 = 1 / k3;
          return new BigNumber2(nIsNeg ? 1 / k3 : k3);
        } else if (POW_PRECISION) {
          k3 = mathceil(POW_PRECISION / LOG_BASE + 2);
        }
        if (nIsBig) {
          half = new BigNumber2(0.5);
          if (nIsNeg)
            n2.s = 1;
          nIsOdd = isOdd(n2);
        } else {
          i2 = Math.abs(+valueOf2(n2));
          nIsOdd = i2 % 2;
        }
        y3 = new BigNumber2(ONE);
        for (; ; ) {
          if (nIsOdd) {
            y3 = y3.times(x2);
            if (!y3.c)
              break;
            if (k3) {
              if (y3.c.length > k3)
                y3.c.length = k3;
            } else if (isModExp) {
              y3 = y3.mod(m2);
            }
          }
          if (i2) {
            i2 = mathfloor(i2 / 2);
            if (i2 === 0)
              break;
            nIsOdd = i2 % 2;
          } else {
            n2 = n2.times(half);
            round(n2, n2.e + 1, 1);
            if (n2.e > 14) {
              nIsOdd = isOdd(n2);
            } else {
              i2 = +valueOf2(n2);
              if (i2 === 0)
                break;
              nIsOdd = i2 % 2;
            }
          }
          x2 = x2.times(x2);
          if (k3) {
            if (x2.c && x2.c.length > k3)
              x2.c.length = k3;
          } else if (isModExp) {
            x2 = x2.mod(m2);
          }
        }
        if (isModExp)
          return y3;
        if (nIsNeg)
          y3 = ONE.div(y3);
        return m2 ? y3.mod(m2) : k3 ? round(y3, POW_PRECISION, ROUNDING_MODE, more) : y3;
      };
      P3.integerValue = function(rm) {
        var n2 = new BigNumber2(this);
        if (rm == null)
          rm = ROUNDING_MODE;
        else
          intCheck(rm, 0, 8);
        return round(n2, n2.e + 1, rm);
      };
      P3.isEqualTo = P3.eq = function(y3, b3) {
        return compare(this, new BigNumber2(y3, b3)) === 0;
      };
      P3.isFinite = function() {
        return !!this.c;
      };
      P3.isGreaterThan = P3.gt = function(y3, b3) {
        return compare(this, new BigNumber2(y3, b3)) > 0;
      };
      P3.isGreaterThanOrEqualTo = P3.gte = function(y3, b3) {
        return (b3 = compare(this, new BigNumber2(y3, b3))) === 1 || b3 === 0;
      };
      P3.isInteger = function() {
        return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
      };
      P3.isLessThan = P3.lt = function(y3, b3) {
        return compare(this, new BigNumber2(y3, b3)) < 0;
      };
      P3.isLessThanOrEqualTo = P3.lte = function(y3, b3) {
        return (b3 = compare(this, new BigNumber2(y3, b3))) === -1 || b3 === 0;
      };
      P3.isNaN = function() {
        return !this.s;
      };
      P3.isNegative = function() {
        return this.s < 0;
      };
      P3.isPositive = function() {
        return this.s > 0;
      };
      P3.isZero = function() {
        return !!this.c && this.c[0] == 0;
      };
      P3.minus = function(y3, b3) {
        var i2, j3, t2, xLTy, x2 = this, a2 = x2.s;
        y3 = new BigNumber2(y3, b3);
        b3 = y3.s;
        if (!a2 || !b3)
          return new BigNumber2(NaN);
        if (a2 != b3) {
          y3.s = -b3;
          return x2.plus(y3);
        }
        var xe = x2.e / LOG_BASE, ye = y3.e / LOG_BASE, xc = x2.c, yc = y3.c;
        if (!xe || !ye) {
          if (!xc || !yc)
            return xc ? (y3.s = -b3, y3) : new BigNumber2(yc ? x2 : NaN);
          if (!xc[0] || !yc[0]) {
            return yc[0] ? (y3.s = -b3, y3) : new BigNumber2(xc[0] ? x2 : (
              // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
              ROUNDING_MODE == 3 ? -0 : 0
            ));
          }
        }
        xe = bitFloor(xe);
        ye = bitFloor(ye);
        xc = xc.slice();
        if (a2 = xe - ye) {
          if (xLTy = a2 < 0) {
            a2 = -a2;
            t2 = xc;
          } else {
            ye = xe;
            t2 = yc;
          }
          t2.reverse();
          for (b3 = a2; b3--; t2.push(0))
            ;
          t2.reverse();
        } else {
          j3 = (xLTy = (a2 = xc.length) < (b3 = yc.length)) ? a2 : b3;
          for (a2 = b3 = 0; b3 < j3; b3++) {
            if (xc[b3] != yc[b3]) {
              xLTy = xc[b3] < yc[b3];
              break;
            }
          }
        }
        if (xLTy) {
          t2 = xc;
          xc = yc;
          yc = t2;
          y3.s = -y3.s;
        }
        b3 = (j3 = yc.length) - (i2 = xc.length);
        if (b3 > 0)
          for (; b3--; xc[i2++] = 0)
            ;
        b3 = BASE - 1;
        for (; j3 > a2; ) {
          if (xc[--j3] < yc[j3]) {
            for (i2 = j3; i2 && !xc[--i2]; xc[i2] = b3)
              ;
            --xc[i2];
            xc[j3] += BASE;
          }
          xc[j3] -= yc[j3];
        }
        for (; xc[0] == 0; xc.splice(0, 1), --ye)
          ;
        if (!xc[0]) {
          y3.s = ROUNDING_MODE == 3 ? -1 : 1;
          y3.c = [y3.e = 0];
          return y3;
        }
        return normalise(y3, xc, ye);
      };
      P3.modulo = P3.mod = function(y3, b3) {
        var q3, s2, x2 = this;
        y3 = new BigNumber2(y3, b3);
        if (!x2.c || !y3.s || y3.c && !y3.c[0]) {
          return new BigNumber2(NaN);
        } else if (!y3.c || x2.c && !x2.c[0]) {
          return new BigNumber2(x2);
        }
        if (MODULO_MODE == 9) {
          s2 = y3.s;
          y3.s = 1;
          q3 = div(x2, y3, 0, 3);
          y3.s = s2;
          q3.s *= s2;
        } else {
          q3 = div(x2, y3, 0, MODULO_MODE);
        }
        y3 = x2.minus(q3.times(y3));
        if (!y3.c[0] && MODULO_MODE == 1)
          y3.s = x2.s;
        return y3;
      };
      P3.multipliedBy = P3.times = function(y3, b3) {
        var c3, e2, i2, j3, k3, m2, xcL, xlo, xhi, ycL, ylo, yhi, zc, base3, sqrtBase, x2 = this, xc = x2.c, yc = (y3 = new BigNumber2(y3, b3)).c;
        if (!xc || !yc || !xc[0] || !yc[0]) {
          if (!x2.s || !y3.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
            y3.c = y3.e = y3.s = null;
          } else {
            y3.s *= x2.s;
            if (!xc || !yc) {
              y3.c = y3.e = null;
            } else {
              y3.c = [0];
              y3.e = 0;
            }
          }
          return y3;
        }
        e2 = bitFloor(x2.e / LOG_BASE) + bitFloor(y3.e / LOG_BASE);
        y3.s *= x2.s;
        xcL = xc.length;
        ycL = yc.length;
        if (xcL < ycL) {
          zc = xc;
          xc = yc;
          yc = zc;
          i2 = xcL;
          xcL = ycL;
          ycL = i2;
        }
        for (i2 = xcL + ycL, zc = []; i2--; zc.push(0))
          ;
        base3 = BASE;
        sqrtBase = SQRT_BASE;
        for (i2 = ycL; --i2 >= 0; ) {
          c3 = 0;
          ylo = yc[i2] % sqrtBase;
          yhi = yc[i2] / sqrtBase | 0;
          for (k3 = xcL, j3 = i2 + k3; j3 > i2; ) {
            xlo = xc[--k3] % sqrtBase;
            xhi = xc[k3] / sqrtBase | 0;
            m2 = yhi * xlo + xhi * ylo;
            xlo = ylo * xlo + m2 % sqrtBase * sqrtBase + zc[j3] + c3;
            c3 = (xlo / base3 | 0) + (m2 / sqrtBase | 0) + yhi * xhi;
            zc[j3--] = xlo % base3;
          }
          zc[j3] = c3;
        }
        if (c3) {
          ++e2;
        } else {
          zc.splice(0, 1);
        }
        return normalise(y3, zc, e2);
      };
      P3.negated = function() {
        var x2 = new BigNumber2(this);
        x2.s = -x2.s || null;
        return x2;
      };
      P3.plus = function(y3, b3) {
        var t2, x2 = this, a2 = x2.s;
        y3 = new BigNumber2(y3, b3);
        b3 = y3.s;
        if (!a2 || !b3)
          return new BigNumber2(NaN);
        if (a2 != b3) {
          y3.s = -b3;
          return x2.minus(y3);
        }
        var xe = x2.e / LOG_BASE, ye = y3.e / LOG_BASE, xc = x2.c, yc = y3.c;
        if (!xe || !ye) {
          if (!xc || !yc)
            return new BigNumber2(a2 / 0);
          if (!xc[0] || !yc[0])
            return yc[0] ? y3 : new BigNumber2(xc[0] ? x2 : a2 * 0);
        }
        xe = bitFloor(xe);
        ye = bitFloor(ye);
        xc = xc.slice();
        if (a2 = xe - ye) {
          if (a2 > 0) {
            ye = xe;
            t2 = yc;
          } else {
            a2 = -a2;
            t2 = xc;
          }
          t2.reverse();
          for (; a2--; t2.push(0))
            ;
          t2.reverse();
        }
        a2 = xc.length;
        b3 = yc.length;
        if (a2 - b3 < 0) {
          t2 = yc;
          yc = xc;
          xc = t2;
          b3 = a2;
        }
        for (a2 = 0; b3; ) {
          a2 = (xc[--b3] = xc[b3] + yc[b3] + a2) / BASE | 0;
          xc[b3] = BASE === xc[b3] ? 0 : xc[b3] % BASE;
        }
        if (a2) {
          xc = [a2].concat(xc);
          ++ye;
        }
        return normalise(y3, xc, ye);
      };
      P3.precision = P3.sd = function(sd, rm) {
        var c3, n2, v2, x2 = this;
        if (sd != null && sd !== !!sd) {
          intCheck(sd, 1, MAX);
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          return round(new BigNumber2(x2), sd, rm);
        }
        if (!(c3 = x2.c))
          return null;
        v2 = c3.length - 1;
        n2 = v2 * LOG_BASE + 1;
        if (v2 = c3[v2]) {
          for (; v2 % 10 == 0; v2 /= 10, n2--)
            ;
          for (v2 = c3[0]; v2 >= 10; v2 /= 10, n2++)
            ;
        }
        if (sd && x2.e + 1 > n2)
          n2 = x2.e + 1;
        return n2;
      };
      P3.shiftedBy = function(k3) {
        intCheck(k3, -MAX_SAFE_INTEGER2, MAX_SAFE_INTEGER2);
        return this.times("1e" + k3);
      };
      P3.squareRoot = P3.sqrt = function() {
        var m2, n2, r2, rep, t2, x2 = this, c3 = x2.c, s2 = x2.s, e2 = x2.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
        if (s2 !== 1 || !c3 || !c3[0]) {
          return new BigNumber2(!s2 || s2 < 0 && (!c3 || c3[0]) ? NaN : c3 ? x2 : 1 / 0);
        }
        s2 = Math.sqrt(+valueOf2(x2));
        if (s2 == 0 || s2 == 1 / 0) {
          n2 = coeffToString(c3);
          if ((n2.length + e2) % 2 == 0)
            n2 += "0";
          s2 = Math.sqrt(+n2);
          e2 = bitFloor((e2 + 1) / 2) - (e2 < 0 || e2 % 2);
          if (s2 == 1 / 0) {
            n2 = "5e" + e2;
          } else {
            n2 = s2.toExponential();
            n2 = n2.slice(0, n2.indexOf("e") + 1) + e2;
          }
          r2 = new BigNumber2(n2);
        } else {
          r2 = new BigNumber2(s2 + "");
        }
        if (r2.c[0]) {
          e2 = r2.e;
          s2 = e2 + dp;
          if (s2 < 3)
            s2 = 0;
          for (; ; ) {
            t2 = r2;
            r2 = half.times(t2.plus(div(x2, t2, dp, 1)));
            if (coeffToString(t2.c).slice(0, s2) === (n2 = coeffToString(r2.c)).slice(0, s2)) {
              if (r2.e < e2)
                --s2;
              n2 = n2.slice(s2 - 3, s2 + 1);
              if (n2 == "9999" || !rep && n2 == "4999") {
                if (!rep) {
                  round(t2, t2.e + DECIMAL_PLACES + 2, 0);
                  if (t2.times(t2).eq(x2)) {
                    r2 = t2;
                    break;
                  }
                }
                dp += 4;
                s2 += 4;
                rep = 1;
              } else {
                if (!+n2 || !+n2.slice(1) && n2.charAt(0) == "5") {
                  round(r2, r2.e + DECIMAL_PLACES + 2, 1);
                  m2 = !r2.times(r2).eq(x2);
                }
                break;
              }
            }
          }
        }
        return round(r2, r2.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m2);
      };
      P3.toExponential = function(dp, rm) {
        if (dp != null) {
          intCheck(dp, 0, MAX);
          dp++;
        }
        return format(this, dp, rm, 1);
      };
      P3.toFixed = function(dp, rm) {
        if (dp != null) {
          intCheck(dp, 0, MAX);
          dp = dp + this.e + 1;
        }
        return format(this, dp, rm);
      };
      P3.toFormat = function(dp, rm, format2) {
        var str, x2 = this;
        if (format2 == null) {
          if (dp != null && rm && _typeof(rm) == "object") {
            format2 = rm;
            rm = null;
          } else if (dp && _typeof(dp) == "object") {
            format2 = dp;
            dp = rm = null;
          } else {
            format2 = FORMAT;
          }
        } else if (_typeof(format2) != "object") {
          throw Error(bignumberError + "Argument not an object: " + format2);
        }
        str = x2.toFixed(dp, rm);
        if (x2.c) {
          var i2, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x2.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len2 = intDigits.length;
          if (g2) {
            i2 = g1;
            g1 = g2;
            g2 = i2;
            len2 -= i2;
          }
          if (g1 > 0 && len2 > 0) {
            i2 = len2 % g1 || g1;
            intPart = intDigits.substr(0, i2);
            for (; i2 < len2; i2 += g1)
              intPart += groupSeparator + intDigits.substr(i2, g1);
            if (g2 > 0)
              intPart += groupSeparator + intDigits.slice(i2);
            if (isNeg)
              intPart = "-" + intPart;
          }
          str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(new RegExp("\\d{" + g2 + "}\\B", "g"), "$&" + (format2.fractionGroupSeparator || "")) : fractionPart) : intPart;
        }
        return (format2.prefix || "") + str + (format2.suffix || "");
      };
      P3.toFraction = function(md) {
        var d2, d0, d1, d22, e2, exp, n2, n0, n1, q3, r2, s2, x2 = this, xc = x2.c;
        if (md != null) {
          n2 = new BigNumber2(md);
          if (!n2.isInteger() && (n2.c || n2.s !== 1) || n2.lt(ONE)) {
            throw Error(bignumberError + "Argument " + (n2.isInteger() ? "out of range: " : "not an integer: ") + valueOf2(n2));
          }
        }
        if (!xc)
          return new BigNumber2(x2);
        d2 = new BigNumber2(ONE);
        n1 = d0 = new BigNumber2(ONE);
        d1 = n0 = new BigNumber2(ONE);
        s2 = coeffToString(xc);
        e2 = d2.e = s2.length - x2.e - 1;
        d2.c[0] = POWS_TEN[(exp = e2 % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
        md = !md || n2.comparedTo(d2) > 0 ? e2 > 0 ? d2 : n1 : n2;
        exp = MAX_EXP;
        MAX_EXP = 1 / 0;
        n2 = new BigNumber2(s2);
        n0.c[0] = 0;
        for (; ; ) {
          q3 = div(n2, d2, 0, 1);
          d22 = d0.plus(q3.times(d1));
          if (d22.comparedTo(md) == 1)
            break;
          d0 = d1;
          d1 = d22;
          n1 = n0.plus(q3.times(d22 = n1));
          n0 = d22;
          d2 = n2.minus(q3.times(d22 = d2));
          n2 = d22;
        }
        d22 = div(md.minus(d0), d1, 0, 1);
        n0 = n0.plus(d22.times(n1));
        d0 = d0.plus(d22.times(d1));
        n0.s = n1.s = x2.s;
        e2 = e2 * 2;
        r2 = div(n1, d1, e2, ROUNDING_MODE).minus(x2).abs().comparedTo(div(n0, d0, e2, ROUNDING_MODE).minus(x2).abs()) < 1 ? [n1, d1] : [n0, d0];
        MAX_EXP = exp;
        return r2;
      };
      P3.toNumber = function() {
        return +valueOf2(this);
      };
      P3.toPrecision = function(sd, rm) {
        if (sd != null)
          intCheck(sd, 1, MAX);
        return format(this, sd, rm, 2);
      };
      P3.toString = function(b3) {
        var str, n2 = this, s2 = n2.s, e2 = n2.e;
        if (e2 === null) {
          if (s2) {
            str = "Infinity";
            if (s2 < 0)
              str = "-" + str;
          } else {
            str = "NaN";
          }
        } else {
          if (b3 == null) {
            str = e2 <= TO_EXP_NEG || e2 >= TO_EXP_POS ? toExponential(coeffToString(n2.c), e2) : toFixedPoint(coeffToString(n2.c), e2, "0");
          } else if (b3 === 10 && alphabetHasNormalDecimalDigits) {
            n2 = round(new BigNumber2(n2), DECIMAL_PLACES + e2 + 1, ROUNDING_MODE);
            str = toFixedPoint(coeffToString(n2.c), n2.e, "0");
          } else {
            intCheck(b3, 2, ALPHABET2.length, "Base");
            str = convertBase(toFixedPoint(coeffToString(n2.c), e2, "0"), 10, b3, s2, true);
          }
          if (s2 < 0 && n2.c[0])
            str = "-" + str;
        }
        return str;
      };
      P3.valueOf = P3.toJSON = function() {
        return valueOf2(this);
      };
      P3._isBigNumber = true;
      if (configObject != null)
        BigNumber2.set(configObject);
      return BigNumber2;
    }
    function bitFloor(n2) {
      var i2 = n2 | 0;
      return n2 > 0 || n2 === i2 ? i2 : i2 - 1;
    }
    function coeffToString(a2) {
      var s2, z2, i2 = 1, j3 = a2.length, r2 = a2[0] + "";
      for (; i2 < j3; ) {
        s2 = a2[i2++] + "";
        z2 = LOG_BASE - s2.length;
        for (; z2--; s2 = "0" + s2)
          ;
        r2 += s2;
      }
      for (j3 = r2.length; r2.charCodeAt(--j3) === 48; )
        ;
      return r2.slice(0, j3 + 1 || 1);
    }
    function compare(x2, y3) {
      var a2, b3, xc = x2.c, yc = y3.c, i2 = x2.s, j3 = y3.s, k3 = x2.e, l2 = y3.e;
      if (!i2 || !j3)
        return null;
      a2 = xc && !xc[0];
      b3 = yc && !yc[0];
      if (a2 || b3)
        return a2 ? b3 ? 0 : -j3 : i2;
      if (i2 != j3)
        return i2;
      a2 = i2 < 0;
      b3 = k3 == l2;
      if (!xc || !yc)
        return b3 ? 0 : !xc ^ a2 ? 1 : -1;
      if (!b3)
        return k3 > l2 ^ a2 ? 1 : -1;
      j3 = (k3 = xc.length) < (l2 = yc.length) ? k3 : l2;
      for (i2 = 0; i2 < j3; i2++)
        if (xc[i2] != yc[i2])
          return xc[i2] > yc[i2] ^ a2 ? 1 : -1;
      return k3 == l2 ? 0 : k3 > l2 ^ a2 ? 1 : -1;
    }
    function intCheck(n2, min, max, name2) {
      if (n2 < min || n2 > max || n2 !== mathfloor(n2)) {
        throw Error(bignumberError + (name2 || "Argument") + (typeof n2 == "number" ? n2 < min || n2 > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n2));
      }
    }
    function isOdd(n2) {
      var k3 = n2.c.length - 1;
      return bitFloor(n2.e / LOG_BASE) == k3 && n2.c[k3] % 2 != 0;
    }
    function toExponential(str, e2) {
      return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e2 < 0 ? "e" : "e+") + e2;
    }
    function toFixedPoint(str, e2, z2) {
      var len2, zs;
      if (e2 < 0) {
        for (zs = z2 + "."; ++e2; zs += z2)
          ;
        str = zs + str;
      } else {
        len2 = str.length;
        if (++e2 > len2) {
          for (zs = z2, e2 -= len2; --e2; zs += z2)
            ;
          str += zs;
        } else if (e2 < len2) {
          str = str.slice(0, e2) + "." + str.slice(e2);
        }
      }
      return str;
    }
    BigNumber = clone3();
    BigNumber["default"] = BigNumber.BigNumber = BigNumber;
    if (module.exports) {
      module.exports = BigNumber;
    } else {
      if (!globalObject) {
        globalObject = typeof self != "undefined" && self ? self : window;
      }
      globalObject.BigNumber = BigNumber;
    }
  })(commonjsGlobal);
})(bignumber);
var bignumberExports = bignumber.exports;
Object.defineProperty(ar, "__esModule", { value: true });
var bignumber_js_1 = bignumberExports;
var Ar = function() {
  function Ar2() {
    _classCallCheck2(this, Ar2);
    _defineProperty(this, "BigNum", void 0);
    this.BigNum = function(value, decimals) {
      var instance = bignumber_js_1.BigNumber.clone({ DECIMAL_PLACES: decimals });
      return new instance(value);
    };
  }
  return _createClass(Ar2, [{ key: "winstonToAr", value: function winstonToAr(winstonString) {
    var _ref84 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref84$formatted = _ref84.formatted, formatted = _ref84$formatted === void 0 ? false : _ref84$formatted, _ref84$decimals = _ref84.decimals, decimals = _ref84$decimals === void 0 ? 12 : _ref84$decimals, _ref84$trim = _ref84.trim, trim3 = _ref84$trim === void 0 ? true : _ref84$trim;
    var number = this.stringToBigNum(winstonString, decimals).shiftedBy(-12);
    return formatted ? number.toFormat(decimals) : number.toFixed(decimals);
  } }, { key: "arToWinston", value: function arToWinston(arString) {
    var _ref85 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref85$formatted = _ref85.formatted, formatted = _ref85$formatted === void 0 ? false : _ref85$formatted;
    var number = this.stringToBigNum(arString).shiftedBy(12);
    return formatted ? number.toFormat() : number.toFixed(0);
  } }, { key: "compare", value: function compare(winstonStringA, winstonStringB) {
    var a2 = this.stringToBigNum(winstonStringA);
    var b3 = this.stringToBigNum(winstonStringB);
    return a2.comparedTo(b3);
  } }, { key: "isEqual", value: function isEqual(winstonStringA, winstonStringB) {
    return this.compare(winstonStringA, winstonStringB) === 0;
  } }, { key: "isLessThan", value: function isLessThan(winstonStringA, winstonStringB) {
    var a2 = this.stringToBigNum(winstonStringA);
    var b3 = this.stringToBigNum(winstonStringB);
    return a2.isLessThan(b3);
  } }, { key: "isGreaterThan", value: function isGreaterThan(winstonStringA, winstonStringB) {
    var a2 = this.stringToBigNum(winstonStringA);
    var b3 = this.stringToBigNum(winstonStringB);
    return a2.isGreaterThan(b3);
  } }, { key: "add", value: function add2(winstonStringA, winstonStringB) {
    var a2 = this.stringToBigNum(winstonStringA);
    this.stringToBigNum(winstonStringB);
    return a2.plus(winstonStringB).toFixed(0);
  } }, { key: "sub", value: function sub(winstonStringA, winstonStringB) {
    var a2 = this.stringToBigNum(winstonStringA);
    this.stringToBigNum(winstonStringB);
    return a2.minus(winstonStringB).toFixed(0);
  } }, { key: "stringToBigNum", value: function stringToBigNum(stringValue) {
    var decimalPlaces = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 12;
    return this.BigNum(stringValue, decimalPlaces);
  } }]);
}();
ar.default = Ar;
var api = {};
Object.defineProperty(api, "__esModule", { value: true });
var Api = function() {
  function Api2(config) {
    _classCallCheck2(this, Api2);
    _defineProperty(this, "METHOD_GET", "GET");
    _defineProperty(this, "METHOD_POST", "POST");
    _defineProperty(this, "config", void 0);
    this.applyConfig(config);
  }
  return _createClass(Api2, [{ key: "applyConfig", value: function applyConfig(config) {
    this.config = this.mergeDefaults(config);
  } }, { key: "getConfig", value: function getConfig() {
    return this.config;
  } }, { key: "mergeDefaults", value: function mergeDefaults(config) {
    var protocol = config.protocol || "http";
    var port = config.port || (protocol === "https" ? 443 : 80);
    return { host: config.host || "127.0.0.1", protocol, port, timeout: config.timeout || 2e4, logging: config.logging || false, logger: config.logger || console.log, network: config.network };
  } }, { key: "get", value: function() {
    var _get2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee116(endpoint, config) {
      return _regeneratorRuntime().wrap(function _callee116$(_context117) {
        while (1)
          switch (_context117.prev = _context117.next) {
            case 0:
              _context117.next = 2;
              return this.request(endpoint, _objectSpread(_objectSpread({}, config), {}, { method: this.METHOD_GET }));
            case 2:
              return _context117.abrupt("return", _context117.sent);
            case 3:
            case "end":
              return _context117.stop();
          }
      }, _callee116, this);
    }));
    function get5(_x172, _x173) {
      return _get2.apply(this, arguments);
    }
    return get5;
  }() }, { key: "post", value: function() {
    var _post = _asyncToGenerator(_regeneratorRuntime().mark(function _callee117(endpoint, body, config) {
      var _headers$get;
      var headers;
      return _regeneratorRuntime().wrap(function _callee117$(_context118) {
        while (1)
          switch (_context118.prev = _context118.next) {
            case 0:
              headers = new Headers((config === null || config === void 0 ? void 0 : config.headers) || {});
              if (!((_headers$get = headers.get("content-type")) !== null && _headers$get !== void 0 && _headers$get.includes("application/json"))) {
                headers.append("content-type", "application/json");
              }
              headers.append("accept", "application/json, text/plain, */*");
              _context118.next = 5;
              return this.request(endpoint, _objectSpread(_objectSpread({}, config), {}, { method: this.METHOD_POST, body: typeof body !== "string" ? JSON.stringify(body) : body, headers }));
            case 5:
              return _context118.abrupt("return", _context118.sent);
            case 6:
            case "end":
              return _context118.stop();
          }
      }, _callee117, this);
    }));
    function post(_x174, _x175, _x176) {
      return _post.apply(this, arguments);
    }
    return post;
  }() }, { key: "request", value: function() {
    var _request3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee119(endpoint, init5) {
      var _contentType$match;
      var headers, baseURL, responseType, res, contentType, charset, response, decodeText, _test;
      return _regeneratorRuntime().wrap(function _callee119$(_context120) {
        while (1)
          switch (_context120.prev = _context120.next) {
            case 0:
              headers = new Headers((init5 === null || init5 === void 0 ? void 0 : init5.headers) || {});
              baseURL = "".concat(this.config.protocol, "://").concat(this.config.host, ":").concat(this.config.port);
              responseType = init5 === null || init5 === void 0 ? void 0 : init5.responseType;
              init5 === null || init5 === void 0 || delete init5.responseType;
              if (endpoint.startsWith("/")) {
                endpoint = endpoint.slice(1);
              }
              if (this.config.network) {
                headers.append("x-network", this.config.network);
              }
              if (this.config.logging) {
                this.config.logger("Requesting: ".concat(baseURL, "/").concat(endpoint));
              }
              _context120.next = 9;
              return fetch("".concat(baseURL, "/").concat(endpoint), _objectSpread(_objectSpread({}, init5 || {}), {}, { headers }));
            case 9:
              res = _context120.sent;
              if (this.config.logging) {
                this.config.logger("Response:   ".concat(res.url, " - ").concat(res.status));
              }
              contentType = res.headers.get("content-type");
              charset = contentType === null || contentType === void 0 || (_contentType$match = contentType.match(/charset=([^()<>@,;:\"/[\]?.=\s]*)/i)) === null || _contentType$match === void 0 ? void 0 : _contentType$match[1];
              response = res;
              decodeText = function() {
                var _ref86 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee118() {
                  return _regeneratorRuntime().wrap(function _callee118$(_context119) {
                    while (1)
                      switch (_context119.prev = _context119.next) {
                        case 0:
                          if (!charset) {
                            _context119.next = 16;
                            break;
                          }
                          _context119.prev = 1;
                          _context119.t0 = new TextDecoder(charset);
                          _context119.next = 5;
                          return res.arrayBuffer();
                        case 5:
                          _context119.t1 = _context119.sent;
                          response.data = _context119.t0.decode.call(_context119.t0, _context119.t1);
                          _context119.next = 14;
                          break;
                        case 9:
                          _context119.prev = 9;
                          _context119.t2 = _context119["catch"](1);
                          _context119.next = 13;
                          return res.text();
                        case 13:
                          response.data = _context119.sent;
                        case 14:
                          _context119.next = 19;
                          break;
                        case 16:
                          _context119.next = 18;
                          return res.text();
                        case 18:
                          response.data = _context119.sent;
                        case 19:
                        case "end":
                          return _context119.stop();
                      }
                  }, _callee118, null, [[1, 9]]);
                }));
                return function decodeText2() {
                  return _ref86.apply(this, arguments);
                };
              }();
              if (!(responseType === "arraybuffer")) {
                _context120.next = 21;
                break;
              }
              _context120.next = 18;
              return res.arrayBuffer();
            case 18:
              response.data = _context120.sent;
              _context120.next = 49;
              break;
            case 21:
              if (!(responseType === "text")) {
                _context120.next = 26;
                break;
              }
              _context120.next = 24;
              return decodeText();
            case 24:
              _context120.next = 49;
              break;
            case 26:
              if (!(responseType === "webstream")) {
                _context120.next = 30;
                break;
              }
              response.data = addAsyncIterator(res.body);
              _context120.next = 49;
              break;
            case 30:
              _context120.prev = 30;
              _context120.next = 33;
              return res.clone().json();
            case 33:
              _test = _context120.sent;
              if (!(_typeof(_test) !== "object")) {
                _context120.next = 39;
                break;
              }
              _context120.next = 37;
              return decodeText();
            case 37:
              _context120.next = 42;
              break;
            case 39:
              _context120.next = 41;
              return res.json();
            case 41:
              response.data = _context120.sent;
            case 42:
              _test = null;
              _context120.next = 49;
              break;
            case 45:
              _context120.prev = 45;
              _context120.t0 = _context120["catch"](30);
              _context120.next = 49;
              return decodeText();
            case 49:
              return _context120.abrupt("return", response);
            case 50:
            case "end":
              return _context120.stop();
          }
      }, _callee119, this, [[30, 45]]);
    }));
    function request(_x177, _x178) {
      return _request3.apply(this, arguments);
    }
    return request;
  }() }]);
}();
api.default = Api;
var addAsyncIterator = function addAsyncIterator2(body) {
  var bodyWithIter = body;
  if (typeof bodyWithIter[Symbol.asyncIterator] === "undefined") {
    bodyWithIter[Symbol.asyncIterator] = webIiterator(body);
  }
  return bodyWithIter;
};
var webIiterator = function webIiterator2(stream) {
  return function() {
    var _iteratorGenerator = _wrapAsyncGenerator(_regeneratorRuntime().mark(function _callee120() {
      var reader2, _yield$_awaitAsyncGen2, done, value;
      return _regeneratorRuntime().wrap(function _callee120$(_context121) {
        while (1)
          switch (_context121.prev = _context121.next) {
            case 0:
              reader2 = stream.getReader();
              _context121.prev = 1;
            case 2:
              if (false) {
                _context121.next = 14;
                break;
              }
              _context121.next = 5;
              return _awaitAsyncGenerator(reader2.read());
            case 5:
              _yield$_awaitAsyncGen2 = _context121.sent;
              done = _yield$_awaitAsyncGen2.done;
              value = _yield$_awaitAsyncGen2.value;
              if (!done) {
                _context121.next = 10;
                break;
              }
              return _context121.abrupt("return");
            case 10:
              _context121.next = 12;
              return value;
            case 12:
              _context121.next = 2;
              break;
            case 14:
              _context121.prev = 14;
              reader2.releaseLock();
              return _context121.finish(14);
            case 17:
            case "end":
              return _context121.stop();
          }
      }, _callee120, null, [[1, , 14, 17]]);
    }));
    function iteratorGenerator() {
      return _iteratorGenerator.apply(this, arguments);
    }
    return iteratorGenerator;
  }();
};
var webcryptoDriver = {};
var utils = {};
Object.defineProperty(utils, "__esModule", { value: true });
utils.concatBuffers = concatBuffers;
utils.b64UrlToString = b64UrlToString;
utils.bufferToString = bufferToString;
utils.stringToBuffer = stringToBuffer;
utils.stringToB64Url = stringToB64Url;
utils.b64UrlToBuffer = b64UrlToBuffer;
utils.bufferTob64 = bufferTob64;
utils.bufferTob64Url = bufferTob64Url;
utils.b64UrlEncode = b64UrlEncode$1;
utils.b64UrlDecode = b64UrlDecode$1;
var B64js = base64Js;
function concatBuffers(buffers) {
  var total_length = 0;
  for (var _i74 = 0; _i74 < buffers.length; _i74++) {
    total_length += buffers[_i74].byteLength;
  }
  var temp = new Uint8Array(total_length);
  var offset = 0;
  temp.set(new Uint8Array(buffers[0]), offset);
  offset += buffers[0].byteLength;
  for (var _i75 = 1; _i75 < buffers.length; _i75++) {
    temp.set(new Uint8Array(buffers[_i75]), offset);
    offset += buffers[_i75].byteLength;
  }
  return temp;
}
function b64UrlToString(b64UrlString) {
  var buffer2 = b64UrlToBuffer(b64UrlString);
  return bufferToString(buffer2);
}
function bufferToString(buffer2) {
  return new TextDecoder("utf-8", { fatal: true }).decode(buffer2);
}
function stringToBuffer(string2) {
  return new TextEncoder().encode(string2);
}
function stringToB64Url(string2) {
  return bufferTob64Url(stringToBuffer(string2));
}
function b64UrlToBuffer(b64UrlString) {
  return new Uint8Array(B64js.toByteArray(b64UrlDecode$1(b64UrlString)));
}
function bufferTob64(buffer2) {
  return B64js.fromByteArray(new Uint8Array(buffer2));
}
function bufferTob64Url(buffer2) {
  return b64UrlEncode$1(bufferTob64(buffer2));
}
function b64UrlEncode$1(b64UrlString) {
  try {
    return b64UrlString.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
  } catch (error3) {
    throw new Error("Failed to encode string", { cause: error3 });
  }
}
function b64UrlDecode$1(b64UrlString) {
  try {
    b64UrlString = b64UrlString.replace(/\-/g, "+").replace(/\_/g, "/");
    var padding;
    b64UrlString.length % 4 == 0 ? padding = 0 : padding = 4 - b64UrlString.length % 4;
    return b64UrlString.concat("=".repeat(padding));
  } catch (error3) {
    throw new Error("Failed to decode string", { cause: error3 });
  }
}
Object.defineProperty(webcryptoDriver, "__esModule", { value: true });
var ArweaveUtils$3 = utils;
var WebCryptoDriver = function() {
  function WebCryptoDriver2() {
    _classCallCheck2(this, WebCryptoDriver2);
    _defineProperty(this, "keyLength", 4096);
    _defineProperty(this, "publicExponent", 65537);
    _defineProperty(this, "hashAlgorithm", "sha256");
    _defineProperty(this, "driver", void 0);
    if (!this.detectWebCrypto()) {
      throw new Error("SubtleCrypto not available!");
    }
    this.driver = crypto.subtle;
  }
  return _createClass(WebCryptoDriver2, [{ key: "generateJWK", value: function() {
    var _generateJWK2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee121() {
      var cryptoKey, jwk;
      return _regeneratorRuntime().wrap(function _callee121$(_context122) {
        while (1)
          switch (_context122.prev = _context122.next) {
            case 0:
              _context122.next = 2;
              return this.driver.generateKey({ name: "RSA-PSS", modulusLength: 4096, publicExponent: new Uint8Array([1, 0, 1]), hash: { name: "SHA-256" } }, true, ["sign"]);
            case 2:
              cryptoKey = _context122.sent;
              _context122.next = 5;
              return this.driver.exportKey("jwk", cryptoKey.privateKey);
            case 5:
              jwk = _context122.sent;
              return _context122.abrupt("return", { kty: jwk.kty, e: jwk.e, n: jwk.n, d: jwk.d, p: jwk.p, q: jwk.q, dp: jwk.dp, dq: jwk.dq, qi: jwk.qi });
            case 7:
            case "end":
              return _context122.stop();
          }
      }, _callee121, this);
    }));
    function generateJWK() {
      return _generateJWK2.apply(this, arguments);
    }
    return generateJWK;
  }() }, { key: "sign", value: function() {
    var _sign5 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee122(jwk, data) {
      var _ref87, saltLength, signature2, _args40 = arguments;
      return _regeneratorRuntime().wrap(function _callee122$(_context123) {
        while (1)
          switch (_context123.prev = _context123.next) {
            case 0:
              _ref87 = _args40.length > 2 && _args40[2] !== void 0 ? _args40[2] : {}, saltLength = _ref87.saltLength;
              _context123.t0 = this.driver;
              _context123.t1 = { name: "RSA-PSS", saltLength: 32 };
              _context123.next = 5;
              return this.jwkToCryptoKey(jwk);
            case 5:
              _context123.t2 = _context123.sent;
              _context123.t3 = data;
              _context123.next = 9;
              return _context123.t0.sign.call(_context123.t0, _context123.t1, _context123.t2, _context123.t3);
            case 9:
              signature2 = _context123.sent;
              return _context123.abrupt("return", new Uint8Array(signature2));
            case 11:
            case "end":
              return _context123.stop();
          }
      }, _callee122, this);
    }));
    function sign(_x179, _x180) {
      return _sign5.apply(this, arguments);
    }
    return sign;
  }() }, { key: "hash", value: function() {
    var _hash9 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee123(data) {
      var algorithm, digest11, _args41 = arguments;
      return _regeneratorRuntime().wrap(function _callee123$(_context124) {
        while (1)
          switch (_context124.prev = _context124.next) {
            case 0:
              algorithm = _args41.length > 1 && _args41[1] !== void 0 ? _args41[1] : "SHA-256";
              _context124.next = 3;
              return this.driver.digest(algorithm, data);
            case 3:
              digest11 = _context124.sent;
              return _context124.abrupt("return", new Uint8Array(digest11));
            case 5:
            case "end":
              return _context124.stop();
          }
      }, _callee123, this);
    }));
    function hash2(_x181) {
      return _hash9.apply(this, arguments);
    }
    return hash2;
  }() }, { key: "verify", value: function() {
    var _verify7 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee124(publicModulus, data, signature2) {
      var publicKey, key3, digest11, salt0, salt32, saltLengthN, saltN, result, details;
      return _regeneratorRuntime().wrap(function _callee124$(_context125) {
        while (1)
          switch (_context125.prev = _context125.next) {
            case 0:
              publicKey = { kty: "RSA", e: "AQAB", n: publicModulus };
              _context125.next = 3;
              return this.jwkToPublicCryptoKey(publicKey);
            case 3:
              key3 = _context125.sent;
              _context125.next = 6;
              return this.driver.digest("SHA-256", data);
            case 6:
              digest11 = _context125.sent;
              _context125.next = 9;
              return this.driver.verify({ name: "RSA-PSS", saltLength: 0 }, key3, signature2, data);
            case 9:
              salt0 = _context125.sent;
              _context125.next = 12;
              return this.driver.verify({ name: "RSA-PSS", saltLength: 32 }, key3, signature2, data);
            case 12:
              salt32 = _context125.sent;
              saltLengthN = Math.ceil((key3.algorithm.modulusLength - 1) / 8) - digest11.byteLength - 2;
              _context125.next = 16;
              return this.driver.verify({ name: "RSA-PSS", saltLength: saltLengthN }, key3, signature2, data);
            case 16:
              saltN = _context125.sent;
              result = salt0 || salt32 || saltN;
              if (!result) {
                details = { algorithm: key3.algorithm.name, modulusLength: key3.algorithm.modulusLength, keyUsages: key3.usages, saltLengthsAttempted: "0, 32, ".concat(saltLengthN) };
                console.warn("Transaction Verification Failed! \n", "Details: ".concat(JSON.stringify(details, null, 2), " \n"), "N.B. ArweaveJS is only guaranteed to verify txs created using ArweaveJS.");
              }
              return _context125.abrupt("return", result);
            case 20:
            case "end":
              return _context125.stop();
          }
      }, _callee124, this);
    }));
    function verify(_x182, _x183, _x184) {
      return _verify7.apply(this, arguments);
    }
    return verify;
  }() }, { key: "jwkToCryptoKey", value: function() {
    var _jwkToCryptoKey2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee125(jwk) {
      return _regeneratorRuntime().wrap(function _callee125$(_context126) {
        while (1)
          switch (_context126.prev = _context126.next) {
            case 0:
              return _context126.abrupt("return", this.driver.importKey("jwk", jwk, { name: "RSA-PSS", hash: { name: "SHA-256" } }, false, ["sign"]));
            case 1:
            case "end":
              return _context126.stop();
          }
      }, _callee125, this);
    }));
    function jwkToCryptoKey(_x185) {
      return _jwkToCryptoKey2.apply(this, arguments);
    }
    return jwkToCryptoKey;
  }() }, { key: "jwkToPublicCryptoKey", value: function() {
    var _jwkToPublicCryptoKey2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee126(publicJwk) {
      return _regeneratorRuntime().wrap(function _callee126$(_context127) {
        while (1)
          switch (_context127.prev = _context127.next) {
            case 0:
              return _context127.abrupt("return", this.driver.importKey("jwk", publicJwk, { name: "RSA-PSS", hash: { name: "SHA-256" } }, false, ["verify"]));
            case 1:
            case "end":
              return _context127.stop();
          }
      }, _callee126, this);
    }));
    function jwkToPublicCryptoKey(_x186) {
      return _jwkToPublicCryptoKey2.apply(this, arguments);
    }
    return jwkToPublicCryptoKey;
  }() }, { key: "detectWebCrypto", value: function detectWebCrypto() {
    var _crypto3;
    if (typeof crypto === "undefined") {
      return false;
    }
    var subtle = (_crypto3 = crypto) === null || _crypto3 === void 0 ? void 0 : _crypto3.subtle;
    if (subtle === void 0) {
      return false;
    }
    var names = ["generateKey", "importKey", "exportKey", "digest", "sign"];
    return names.every(function(name2) {
      return typeof subtle[name2] === "function";
    });
  } }, { key: "encrypt", value: function() {
    var _encrypt3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee127(data, key3, salt2) {
      var initialKey, derivedkey, iv, encryptedData;
      return _regeneratorRuntime().wrap(function _callee127$(_context128) {
        while (1)
          switch (_context128.prev = _context128.next) {
            case 0:
              _context128.next = 2;
              return this.driver.importKey("raw", typeof key3 == "string" ? ArweaveUtils$3.stringToBuffer(key3) : key3, { name: "PBKDF2", length: 32 }, false, ["deriveKey"]);
            case 2:
              initialKey = _context128.sent;
              _context128.next = 5;
              return this.driver.deriveKey({ name: "PBKDF2", salt: salt2 ? ArweaveUtils$3.stringToBuffer(salt2) : ArweaveUtils$3.stringToBuffer("salt"), iterations: 1e5, hash: "SHA-256" }, initialKey, { name: "AES-CBC", length: 256 }, false, ["encrypt", "decrypt"]);
            case 5:
              derivedkey = _context128.sent;
              iv = new Uint8Array(16);
              crypto.getRandomValues(iv);
              _context128.next = 10;
              return this.driver.encrypt({ name: "AES-CBC", iv }, derivedkey, data);
            case 10:
              encryptedData = _context128.sent;
              return _context128.abrupt("return", ArweaveUtils$3.concatBuffers([iv, encryptedData]));
            case 12:
            case "end":
              return _context128.stop();
          }
      }, _callee127, this);
    }));
    function encrypt(_x187, _x188, _x189) {
      return _encrypt3.apply(this, arguments);
    }
    return encrypt;
  }() }, { key: "decrypt", value: function() {
    var _decrypt3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee128(encrypted, key3, salt2) {
      var initialKey, derivedkey, iv, data;
      return _regeneratorRuntime().wrap(function _callee128$(_context129) {
        while (1)
          switch (_context129.prev = _context129.next) {
            case 0:
              _context129.next = 2;
              return this.driver.importKey("raw", typeof key3 == "string" ? ArweaveUtils$3.stringToBuffer(key3) : key3, { name: "PBKDF2", length: 32 }, false, ["deriveKey"]);
            case 2:
              initialKey = _context129.sent;
              _context129.next = 5;
              return this.driver.deriveKey({ name: "PBKDF2", salt: salt2 ? ArweaveUtils$3.stringToBuffer(salt2) : ArweaveUtils$3.stringToBuffer("salt"), iterations: 1e5, hash: "SHA-256" }, initialKey, { name: "AES-CBC", length: 256 }, false, ["encrypt", "decrypt"]);
            case 5:
              derivedkey = _context129.sent;
              iv = encrypted.slice(0, 16);
              _context129.next = 9;
              return this.driver.decrypt({ name: "AES-CBC", iv }, derivedkey, encrypted.slice(16));
            case 9:
              data = _context129.sent;
              return _context129.abrupt("return", ArweaveUtils$3.concatBuffers([data]));
            case 11:
            case "end":
              return _context129.stop();
          }
      }, _callee128, this);
    }));
    function decrypt(_x190, _x191, _x192) {
      return _decrypt3.apply(this, arguments);
    }
    return decrypt;
  }() }]);
}();
webcryptoDriver.default = WebCryptoDriver;
var network = {};
Object.defineProperty(network, "__esModule", { value: true });
var Network = function() {
  function Network2(api2) {
    _classCallCheck2(this, Network2);
    _defineProperty(this, "api", void 0);
    this.api = api2;
  }
  return _createClass(Network2, [{ key: "getInfo", value: function getInfo() {
    return this.api.get("info").then(function(response) {
      return response.data;
    });
  } }, { key: "getPeers", value: function getPeers() {
    return this.api.get("peers").then(function(response) {
      return response.data;
    });
  } }]);
}();
network.default = Network;
var transactions = {};
var error = {};
Object.defineProperty(error, "__esModule", { value: true });
error.getError = getError;
var ArweaveError = function(_Error3) {
  function ArweaveError2(type) {
    var _this30;
    var optional2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck2(this, ArweaveError2);
    if (optional2.message) {
      _this30 = _callSuper(this, ArweaveError2, [optional2.message]);
      _defineProperty(_assertThisInitialized(_this30), "type", void 0);
      _defineProperty(_assertThisInitialized(_this30), "response", void 0);
    } else {
      _this30 = _callSuper(this, ArweaveError2);
      _defineProperty(_assertThisInitialized(_this30), "type", void 0);
      _defineProperty(_assertThisInitialized(_this30), "response", void 0);
    }
    _this30.type = type;
    _this30.response = optional2.response;
    return _assertThisInitialized(_this30);
  }
  _inherits2(ArweaveError2, _Error3);
  return _createClass(ArweaveError2, [{ key: "getType", value: function getType() {
    return this.type;
  } }]);
}(_wrapNativeSuper(Error));
error.default = ArweaveError;
function getError(resp) {
  var data = resp.data;
  if (typeof resp.data === "string") {
    try {
      data = JSON.parse(resp.data);
    } catch (e2) {
    }
  }
  if (resp.data instanceof ArrayBuffer || resp.data instanceof Uint8Array) {
    try {
      data = JSON.parse(data.toString());
    } catch (e2) {
    }
  }
  return data ? data.error || data : resp.statusText || "unknown";
}
var transaction = {};
var deepHash = {};
var hasRequiredDeepHash;
function requireDeepHash() {
  if (hasRequiredDeepHash)
    return deepHash;
  hasRequiredDeepHash = 1;
  Object.defineProperty(deepHash, "__esModule", { value: true });
  deepHash.default = deepHash$1;
  var common_1 = requireCommon();
  function deepHash$1(_x193) {
    return _deepHash$.apply(this, arguments);
  }
  function _deepHash$() {
    _deepHash$ = _asyncToGenerator(_regeneratorRuntime().mark(function _callee129(data) {
      var _tag, tag, taggedHash;
      return _regeneratorRuntime().wrap(function _callee129$(_context130) {
        while (1)
          switch (_context130.prev = _context130.next) {
            case 0:
              if (!Array.isArray(data)) {
                _context130.next = 10;
                break;
              }
              _tag = common_1.default.utils.concatBuffers([common_1.default.utils.stringToBuffer("list"), common_1.default.utils.stringToBuffer(data.length.toString())]);
              _context130.t0 = deepHashChunks;
              _context130.t1 = data;
              _context130.next = 6;
              return common_1.default.crypto.hash(_tag, "SHA-384");
            case 6:
              _context130.t2 = _context130.sent;
              _context130.next = 9;
              return (0, _context130.t0)(_context130.t1, _context130.t2);
            case 9:
              return _context130.abrupt("return", _context130.sent);
            case 10:
              tag = common_1.default.utils.concatBuffers([common_1.default.utils.stringToBuffer("blob"), common_1.default.utils.stringToBuffer(data.byteLength.toString())]);
              _context130.t3 = common_1.default.utils;
              _context130.next = 14;
              return common_1.default.crypto.hash(tag, "SHA-384");
            case 14:
              _context130.t4 = _context130.sent;
              _context130.next = 17;
              return common_1.default.crypto.hash(data, "SHA-384");
            case 17:
              _context130.t5 = _context130.sent;
              _context130.t6 = [_context130.t4, _context130.t5];
              taggedHash = _context130.t3.concatBuffers.call(_context130.t3, _context130.t6);
              _context130.next = 22;
              return common_1.default.crypto.hash(taggedHash, "SHA-384");
            case 22:
              return _context130.abrupt("return", _context130.sent);
            case 23:
            case "end":
              return _context130.stop();
          }
      }, _callee129);
    }));
    return _deepHash$.apply(this, arguments);
  }
  function deepHashChunks(_x194, _x195) {
    return _deepHashChunks.apply(this, arguments);
  }
  function _deepHashChunks() {
    _deepHashChunks = _asyncToGenerator(_regeneratorRuntime().mark(function _callee130(chunks2, acc) {
      var hashPair, newAcc;
      return _regeneratorRuntime().wrap(function _callee130$(_context131) {
        while (1)
          switch (_context131.prev = _context131.next) {
            case 0:
              if (!(chunks2.length < 1)) {
                _context131.next = 2;
                break;
              }
              return _context131.abrupt("return", acc);
            case 2:
              _context131.t0 = common_1.default.utils;
              _context131.t1 = acc;
              _context131.next = 6;
              return deepHash$1(chunks2[0]);
            case 6:
              _context131.t2 = _context131.sent;
              _context131.t3 = [_context131.t1, _context131.t2];
              hashPair = _context131.t0.concatBuffers.call(_context131.t0, _context131.t3);
              _context131.next = 11;
              return common_1.default.crypto.hash(hashPair, "SHA-384");
            case 11:
              newAcc = _context131.sent;
              _context131.next = 14;
              return deepHashChunks(chunks2.slice(1), newAcc);
            case 14:
              return _context131.abrupt("return", _context131.sent);
            case 15:
            case "end":
              return _context131.stop();
          }
      }, _callee130);
    }));
    return _deepHashChunks.apply(this, arguments);
  }
  return deepHash;
}
var merkle = {};
var hasRequiredMerkle;
function requireMerkle() {
  if (hasRequiredMerkle)
    return merkle;
  hasRequiredMerkle = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.arrayCompare = exports.MIN_CHUNK_SIZE = exports.MAX_CHUNK_SIZE = void 0;
    exports.chunkData = chunkData;
    exports.generateLeaves = generateLeaves;
    exports.computeRootHash = computeRootHash;
    exports.generateTree = generateTree;
    exports.generateTransactionChunks = generateTransactionChunks;
    exports.buildLayers = buildLayers;
    exports.generateProofs = generateProofs;
    exports.arrayFlatten = arrayFlatten;
    exports.intToBuffer = intToBuffer;
    exports.bufferToInt = bufferToInt;
    exports.validatePath = validatePath;
    exports.debug = debug;
    var common_1 = requireCommon();
    var utils_12 = utils;
    exports.MAX_CHUNK_SIZE = 256 * 1024;
    exports.MIN_CHUNK_SIZE = 32 * 1024;
    var NOTE_SIZE = 32;
    var HASH_SIZE = 32;
    function chunkData(_x196) {
      return _chunkData.apply(this, arguments);
    }
    function _chunkData() {
      _chunkData = _asyncToGenerator(_regeneratorRuntime().mark(function _callee131(data) {
        var chunks2, rest, cursor, chunkSize, nextChunkSize, chunk, dataHash;
        return _regeneratorRuntime().wrap(function _callee131$(_context132) {
          while (1)
            switch (_context132.prev = _context132.next) {
              case 0:
                chunks2 = [];
                rest = data;
                cursor = 0;
              case 3:
                if (!(rest.byteLength >= exports.MAX_CHUNK_SIZE)) {
                  _context132.next = 16;
                  break;
                }
                chunkSize = exports.MAX_CHUNK_SIZE;
                nextChunkSize = rest.byteLength - exports.MAX_CHUNK_SIZE;
                if (nextChunkSize > 0 && nextChunkSize < exports.MIN_CHUNK_SIZE) {
                  chunkSize = Math.ceil(rest.byteLength / 2);
                }
                chunk = rest.slice(0, chunkSize);
                _context132.next = 10;
                return common_1.default.crypto.hash(chunk);
              case 10:
                dataHash = _context132.sent;
                cursor += chunk.byteLength;
                chunks2.push({ dataHash, minByteRange: cursor - chunk.byteLength, maxByteRange: cursor });
                rest = rest.slice(chunkSize);
                _context132.next = 3;
                break;
              case 16:
                _context132.t0 = chunks2;
                _context132.next = 19;
                return common_1.default.crypto.hash(rest);
              case 19:
                _context132.t1 = _context132.sent;
                _context132.t2 = cursor;
                _context132.t3 = cursor + rest.byteLength;
                _context132.t4 = { dataHash: _context132.t1, minByteRange: _context132.t2, maxByteRange: _context132.t3 };
                _context132.t0.push.call(_context132.t0, _context132.t4);
                return _context132.abrupt("return", chunks2);
              case 25:
              case "end":
                return _context132.stop();
            }
        }, _callee131);
      }));
      return _chunkData.apply(this, arguments);
    }
    function generateLeaves(_x197) {
      return _generateLeaves.apply(this, arguments);
    }
    function _generateLeaves() {
      _generateLeaves = _asyncToGenerator(_regeneratorRuntime().mark(function _callee133(chunks2) {
        return _regeneratorRuntime().wrap(function _callee133$(_context134) {
          while (1)
            switch (_context134.prev = _context134.next) {
              case 0:
                return _context134.abrupt("return", Promise.all(chunks2.map(function() {
                  var _ref89 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee132(_ref88) {
                    var dataHash, minByteRange, maxByteRange;
                    return _regeneratorRuntime().wrap(function _callee132$(_context133) {
                      while (1)
                        switch (_context133.prev = _context133.next) {
                          case 0:
                            dataHash = _ref88.dataHash, minByteRange = _ref88.minByteRange, maxByteRange = _ref88.maxByteRange;
                            _context133.t0 = hash2;
                            _context133.next = 4;
                            return Promise.all([hash2(dataHash), hash2(intToBuffer(maxByteRange))]);
                          case 4:
                            _context133.t1 = _context133.sent;
                            _context133.next = 7;
                            return (0, _context133.t0)(_context133.t1);
                          case 7:
                            _context133.t2 = _context133.sent;
                            _context133.t3 = dataHash;
                            _context133.t4 = minByteRange;
                            _context133.t5 = maxByteRange;
                            return _context133.abrupt("return", { type: "leaf", id: _context133.t2, dataHash: _context133.t3, minByteRange: _context133.t4, maxByteRange: _context133.t5 });
                          case 12:
                          case "end":
                            return _context133.stop();
                        }
                    }, _callee132);
                  }));
                  return function(_x211) {
                    return _ref89.apply(this, arguments);
                  };
                }())));
              case 1:
              case "end":
                return _context134.stop();
            }
        }, _callee133);
      }));
      return _generateLeaves.apply(this, arguments);
    }
    function computeRootHash(_x198) {
      return _computeRootHash.apply(this, arguments);
    }
    function _computeRootHash() {
      _computeRootHash = _asyncToGenerator(_regeneratorRuntime().mark(function _callee134(data) {
        var rootNode;
        return _regeneratorRuntime().wrap(function _callee134$(_context135) {
          while (1)
            switch (_context135.prev = _context135.next) {
              case 0:
                _context135.next = 2;
                return generateTree(data);
              case 2:
                rootNode = _context135.sent;
                return _context135.abrupt("return", rootNode.id);
              case 4:
              case "end":
                return _context135.stop();
            }
        }, _callee134);
      }));
      return _computeRootHash.apply(this, arguments);
    }
    function generateTree(_x199) {
      return _generateTree.apply(this, arguments);
    }
    function _generateTree() {
      _generateTree = _asyncToGenerator(_regeneratorRuntime().mark(function _callee135(data) {
        var rootNode;
        return _regeneratorRuntime().wrap(function _callee135$(_context136) {
          while (1)
            switch (_context136.prev = _context136.next) {
              case 0:
                _context136.t0 = buildLayers;
                _context136.t1 = generateLeaves;
                _context136.next = 4;
                return chunkData(data);
              case 4:
                _context136.t2 = _context136.sent;
                _context136.next = 7;
                return (0, _context136.t1)(_context136.t2);
              case 7:
                _context136.t3 = _context136.sent;
                _context136.next = 10;
                return (0, _context136.t0)(_context136.t3);
              case 10:
                rootNode = _context136.sent;
                return _context136.abrupt("return", rootNode);
              case 12:
              case "end":
                return _context136.stop();
            }
        }, _callee135);
      }));
      return _generateTree.apply(this, arguments);
    }
    function generateTransactionChunks(_x200) {
      return _generateTransactionChunks.apply(this, arguments);
    }
    function _generateTransactionChunks() {
      _generateTransactionChunks = _asyncToGenerator(_regeneratorRuntime().mark(function _callee136(data) {
        var chunks2, leaves, root2, proofs, lastChunk;
        return _regeneratorRuntime().wrap(function _callee136$(_context137) {
          while (1)
            switch (_context137.prev = _context137.next) {
              case 0:
                _context137.next = 2;
                return chunkData(data);
              case 2:
                chunks2 = _context137.sent;
                _context137.next = 5;
                return generateLeaves(chunks2);
              case 5:
                leaves = _context137.sent;
                _context137.next = 8;
                return buildLayers(leaves);
              case 8:
                root2 = _context137.sent;
                _context137.next = 11;
                return generateProofs(root2);
              case 11:
                proofs = _context137.sent;
                lastChunk = chunks2.slice(-1)[0];
                if (lastChunk.maxByteRange - lastChunk.minByteRange === 0) {
                  chunks2.splice(chunks2.length - 1, 1);
                  proofs.splice(proofs.length - 1, 1);
                }
                return _context137.abrupt("return", { data_root: root2.id, chunks: chunks2, proofs });
              case 15:
              case "end":
                return _context137.stop();
            }
        }, _callee136);
      }));
      return _generateTransactionChunks.apply(this, arguments);
    }
    function buildLayers(_x201) {
      return _buildLayers.apply(this, arguments);
    }
    function _buildLayers() {
      _buildLayers = _asyncToGenerator(_regeneratorRuntime().mark(function _callee137(nodes) {
        var level, _root2, nextLayer, _i76, _args55 = arguments;
        return _regeneratorRuntime().wrap(function _callee137$(_context138) {
          while (1)
            switch (_context138.prev = _context138.next) {
              case 0:
                level = _args55.length > 1 && _args55[1] !== void 0 ? _args55[1] : 0;
                if (!(nodes.length < 2)) {
                  _context138.next = 4;
                  break;
                }
                _root2 = nodes[0];
                return _context138.abrupt("return", _root2);
              case 4:
                nextLayer = [];
                _i76 = 0;
              case 6:
                if (!(_i76 < nodes.length)) {
                  _context138.next = 15;
                  break;
                }
                _context138.t0 = nextLayer;
                _context138.next = 10;
                return hashBranch(nodes[_i76], nodes[_i76 + 1]);
              case 10:
                _context138.t1 = _context138.sent;
                _context138.t0.push.call(_context138.t0, _context138.t1);
              case 12:
                _i76 += 2;
                _context138.next = 6;
                break;
              case 15:
                return _context138.abrupt("return", buildLayers(nextLayer, level + 1));
              case 16:
              case "end":
                return _context138.stop();
            }
        }, _callee137);
      }));
      return _buildLayers.apply(this, arguments);
    }
    function generateProofs(root2) {
      var proofs = resolveBranchProofs(root2);
      if (!Array.isArray(proofs)) {
        return [proofs];
      }
      return arrayFlatten(proofs);
    }
    function resolveBranchProofs(node2) {
      var proof = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new Uint8Array();
      var depth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      if (node2.type == "leaf") {
        return { offset: node2.maxByteRange - 1, proof: (0, utils_12.concatBuffers)([proof, node2.dataHash, intToBuffer(node2.maxByteRange)]) };
      }
      if (node2.type == "branch") {
        var partialProof = (0, utils_12.concatBuffers)([proof, node2.leftChild.id, node2.rightChild.id, intToBuffer(node2.byteRange)]);
        return [resolveBranchProofs(node2.leftChild, partialProof, depth + 1), resolveBranchProofs(node2.rightChild, partialProof, depth + 1)];
      }
      throw new Error("Unexpected node type");
    }
    function arrayFlatten(input) {
      var flat = [];
      input.forEach(function(item) {
        if (Array.isArray(item)) {
          flat.push.apply(flat, _toConsumableArray(arrayFlatten(item)));
        } else {
          flat.push(item);
        }
      });
      return flat;
    }
    function hashBranch(_x202, _x203) {
      return _hashBranch.apply(this, arguments);
    }
    function _hashBranch() {
      _hashBranch = _asyncToGenerator(_regeneratorRuntime().mark(function _callee138(left, right) {
        var branch;
        return _regeneratorRuntime().wrap(function _callee138$(_context139) {
          while (1)
            switch (_context139.prev = _context139.next) {
              case 0:
                if (right) {
                  _context139.next = 2;
                  break;
                }
                return _context139.abrupt("return", left);
              case 2:
                _context139.t0 = hash2;
                _context139.next = 5;
                return hash2(left.id);
              case 5:
                _context139.t1 = _context139.sent;
                _context139.next = 8;
                return hash2(right.id);
              case 8:
                _context139.t2 = _context139.sent;
                _context139.next = 11;
                return hash2(intToBuffer(left.maxByteRange));
              case 11:
                _context139.t3 = _context139.sent;
                _context139.t4 = [_context139.t1, _context139.t2, _context139.t3];
                _context139.next = 15;
                return (0, _context139.t0)(_context139.t4);
              case 15:
                _context139.t5 = _context139.sent;
                _context139.t6 = left.maxByteRange;
                _context139.t7 = right.maxByteRange;
                _context139.t8 = left;
                _context139.t9 = right;
                branch = { type: "branch", id: _context139.t5, byteRange: _context139.t6, maxByteRange: _context139.t7, leftChild: _context139.t8, rightChild: _context139.t9 };
                return _context139.abrupt("return", branch);
              case 22:
              case "end":
                return _context139.stop();
            }
        }, _callee138);
      }));
      return _hashBranch.apply(this, arguments);
    }
    function hash2(_x204) {
      return _hash10.apply(this, arguments);
    }
    function _hash10() {
      _hash10 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee139(data) {
        return _regeneratorRuntime().wrap(function _callee139$(_context140) {
          while (1)
            switch (_context140.prev = _context140.next) {
              case 0:
                if (Array.isArray(data)) {
                  data = common_1.default.utils.concatBuffers(data);
                }
                _context140.t0 = Uint8Array;
                _context140.next = 4;
                return common_1.default.crypto.hash(data);
              case 4:
                _context140.t1 = _context140.sent;
                return _context140.abrupt("return", new _context140.t0(_context140.t1));
              case 6:
              case "end":
                return _context140.stop();
            }
        }, _callee139);
      }));
      return _hash10.apply(this, arguments);
    }
    function intToBuffer(note) {
      var buffer2 = new Uint8Array(NOTE_SIZE);
      for (var i2 = buffer2.length - 1; i2 >= 0; i2--) {
        var byte = note % 256;
        buffer2[i2] = byte;
        note = (note - byte) / 256;
      }
      return buffer2;
    }
    function bufferToInt(buffer2) {
      var value = 0;
      for (var i2 = 0; i2 < buffer2.length; i2++) {
        value *= 256;
        value += buffer2[i2];
      }
      return value;
    }
    var arrayCompare = function arrayCompare2(a2, b3) {
      return a2.every(function(value, index) {
        return b3[index] === value;
      });
    };
    exports.arrayCompare = arrayCompare;
    function validatePath(_x205, _x206, _x207, _x208, _x209) {
      return _validatePath.apply(this, arguments);
    }
    function _validatePath() {
      _validatePath = _asyncToGenerator(_regeneratorRuntime().mark(function _callee140(id, dest, leftBound, rightBound, path2) {
        var pathData, endOffsetBuffer, pathDataHash, result, left, right, offsetBuffer, offset, remainder, pathHash;
        return _regeneratorRuntime().wrap(function _callee140$(_context141) {
          while (1)
            switch (_context141.prev = _context141.next) {
              case 0:
                if (!(rightBound <= 0)) {
                  _context141.next = 2;
                  break;
                }
                return _context141.abrupt("return", false);
              case 2:
                if (!(dest >= rightBound)) {
                  _context141.next = 4;
                  break;
                }
                return _context141.abrupt("return", validatePath(id, 0, rightBound - 1, rightBound, path2));
              case 4:
                if (!(dest < 0)) {
                  _context141.next = 6;
                  break;
                }
                return _context141.abrupt("return", validatePath(id, 0, 0, rightBound, path2));
              case 6:
                if (!(path2.length == HASH_SIZE + NOTE_SIZE)) {
                  _context141.next = 24;
                  break;
                }
                pathData = path2.slice(0, HASH_SIZE);
                endOffsetBuffer = path2.slice(pathData.length, pathData.length + NOTE_SIZE);
                _context141.t0 = hash2;
                _context141.next = 12;
                return hash2(pathData);
              case 12:
                _context141.t1 = _context141.sent;
                _context141.next = 15;
                return hash2(endOffsetBuffer);
              case 15:
                _context141.t2 = _context141.sent;
                _context141.t3 = [_context141.t1, _context141.t2];
                _context141.next = 19;
                return (0, _context141.t0)(_context141.t3);
              case 19:
                pathDataHash = _context141.sent;
                result = (0, exports.arrayCompare)(id, pathDataHash);
                if (!result) {
                  _context141.next = 23;
                  break;
                }
                return _context141.abrupt("return", { offset: rightBound - 1, leftBound, rightBound, chunkSize: rightBound - leftBound });
              case 23:
                return _context141.abrupt("return", false);
              case 24:
                left = path2.slice(0, HASH_SIZE);
                right = path2.slice(left.length, left.length + HASH_SIZE);
                offsetBuffer = path2.slice(left.length + right.length, left.length + right.length + NOTE_SIZE);
                offset = bufferToInt(offsetBuffer);
                remainder = path2.slice(left.length + right.length + offsetBuffer.length);
                _context141.t4 = hash2;
                _context141.next = 32;
                return hash2(left);
              case 32:
                _context141.t5 = _context141.sent;
                _context141.next = 35;
                return hash2(right);
              case 35:
                _context141.t6 = _context141.sent;
                _context141.next = 38;
                return hash2(offsetBuffer);
              case 38:
                _context141.t7 = _context141.sent;
                _context141.t8 = [_context141.t5, _context141.t6, _context141.t7];
                _context141.next = 42;
                return (0, _context141.t4)(_context141.t8);
              case 42:
                pathHash = _context141.sent;
                if (!(0, exports.arrayCompare)(id, pathHash)) {
                  _context141.next = 51;
                  break;
                }
                if (!(dest < offset)) {
                  _context141.next = 48;
                  break;
                }
                _context141.next = 47;
                return validatePath(left, dest, leftBound, Math.min(rightBound, offset), remainder);
              case 47:
                return _context141.abrupt("return", _context141.sent);
              case 48:
                _context141.next = 50;
                return validatePath(right, dest, Math.max(leftBound, offset), rightBound, remainder);
              case 50:
                return _context141.abrupt("return", _context141.sent);
              case 51:
                return _context141.abrupt("return", false);
              case 52:
              case "end":
                return _context141.stop();
            }
        }, _callee140);
      }));
      return _validatePath.apply(this, arguments);
    }
    function debug(_x210) {
      return _debug.apply(this, arguments);
    }
    function _debug() {
      _debug = _asyncToGenerator(_regeneratorRuntime().mark(function _callee141(proof) {
        var output, left, right, offsetBuffer, offset, remainder, pathHash, updatedOutput, _args59 = arguments;
        return _regeneratorRuntime().wrap(function _callee141$(_context142) {
          while (1)
            switch (_context142.prev = _context142.next) {
              case 0:
                output = _args59.length > 1 && _args59[1] !== void 0 ? _args59[1] : "";
                if (!(proof.byteLength < 1)) {
                  _context142.next = 3;
                  break;
                }
                return _context142.abrupt("return", output);
              case 3:
                left = proof.slice(0, HASH_SIZE);
                right = proof.slice(left.length, left.length + HASH_SIZE);
                offsetBuffer = proof.slice(left.length + right.length, left.length + right.length + NOTE_SIZE);
                offset = bufferToInt(offsetBuffer);
                remainder = proof.slice(left.length + right.length + offsetBuffer.length);
                _context142.t0 = hash2;
                _context142.next = 11;
                return hash2(left);
              case 11:
                _context142.t1 = _context142.sent;
                _context142.next = 14;
                return hash2(right);
              case 14:
                _context142.t2 = _context142.sent;
                _context142.next = 17;
                return hash2(offsetBuffer);
              case 17:
                _context142.t3 = _context142.sent;
                _context142.t4 = [_context142.t1, _context142.t2, _context142.t3];
                _context142.next = 21;
                return (0, _context142.t0)(_context142.t4);
              case 21:
                pathHash = _context142.sent;
                updatedOutput = "".concat(output, "\n").concat(JSON.stringify(Buffer.from(left)), ",").concat(JSON.stringify(Buffer.from(right)), ",").concat(offset, " => ").concat(JSON.stringify(pathHash));
                return _context142.abrupt("return", debug(remainder, updatedOutput));
              case 24:
              case "end":
                return _context142.stop();
            }
        }, _callee141);
      }));
      return _debug.apply(this, arguments);
    }
  })(merkle);
  return merkle;
}
var hasRequiredTransaction;
function requireTransaction() {
  if (hasRequiredTransaction)
    return transaction;
  hasRequiredTransaction = 1;
  Object.defineProperty(transaction, "__esModule", { value: true });
  transaction.Tag = void 0;
  var ArweaveUtils2 = utils;
  var deepHash_1 = requireDeepHash();
  var merkle_1 = requireMerkle();
  var BaseObject = function() {
    function BaseObject2() {
      _classCallCheck2(this, BaseObject2);
    }
    return _createClass(BaseObject2, [{ key: "get", value: function get5(field, options) {
      if (!Object.getOwnPropertyNames(this).includes(field)) {
        throw new Error('Field "'.concat(field, '" is not a property of the Arweave Transaction class.'));
      }
      if (this[field] instanceof Uint8Array) {
        if (options && options.decode && options.string) {
          return ArweaveUtils2.bufferToString(this[field]);
        }
        if (options && options.decode && !options.string) {
          return this[field];
        }
        return ArweaveUtils2.bufferTob64Url(this[field]);
      }
      if (this[field] instanceof Array) {
        if ((options === null || options === void 0 ? void 0 : options.decode) !== void 0 || (options === null || options === void 0 ? void 0 : options.string) !== void 0) {
          if (field === "tags") {
            console.warn(`Did you mean to use 'transaction["tags"]' ?`);
          }
          throw new Error("Cannot decode or stringify an array.");
        }
        return this[field];
      }
      if (options && options.decode == true) {
        if (options && options.string) {
          return ArweaveUtils2.b64UrlToString(this[field]);
        }
        return ArweaveUtils2.b64UrlToBuffer(this[field]);
      }
      return this[field];
    } }]);
  }();
  var Tag = function(_BaseObject) {
    function Tag2(name2, value) {
      var _this31;
      var decode6 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      _classCallCheck2(this, Tag2);
      _this31 = _callSuper(this, Tag2);
      _defineProperty(_this31, "name", void 0);
      _defineProperty(_this31, "value", void 0);
      _this31.name = name2;
      _this31.value = value;
      return _this31;
    }
    _inherits2(Tag2, _BaseObject);
    return _createClass(Tag2);
  }(BaseObject);
  transaction.Tag = Tag;
  var Transaction = function(_BaseObject2) {
    function Transaction2() {
      var _this32;
      var attributes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _classCallCheck2(this, Transaction2);
      _this32 = _callSuper(this, Transaction2);
      _defineProperty(_this32, "format", 2);
      _defineProperty(_this32, "id", "");
      _defineProperty(_this32, "last_tx", "");
      _defineProperty(_this32, "owner", "");
      _defineProperty(_this32, "tags", []);
      _defineProperty(_this32, "target", "");
      _defineProperty(_this32, "quantity", "0");
      _defineProperty(_this32, "data_size", "0");
      _defineProperty(_this32, "data", new Uint8Array());
      _defineProperty(_this32, "data_root", "");
      _defineProperty(_this32, "reward", "0");
      _defineProperty(_this32, "signature", "");
      _defineProperty(_this32, "chunks", void 0);
      Object.assign(_this32, attributes);
      if (typeof _this32.data === "string") {
        _this32.data = ArweaveUtils2.b64UrlToBuffer(_this32.data);
      }
      if (attributes.tags) {
        _this32.tags = attributes.tags.map(function(tag) {
          return new Tag(tag.name, tag.value);
        });
      }
      return _this32;
    }
    _inherits2(Transaction2, _BaseObject2);
    return _createClass(Transaction2, [{ key: "addTag", value: function addTag(name2, value) {
      this.tags.push(new Tag(ArweaveUtils2.stringToB64Url(name2), ArweaveUtils2.stringToB64Url(value)));
    } }, { key: "toJSON", value: function toJSON2() {
      return { format: this.format, id: this.id, last_tx: this.last_tx, owner: this.owner, tags: this.tags, target: this.target, quantity: this.quantity, data: ArweaveUtils2.bufferTob64Url(this.data), data_size: this.data_size, data_root: this.data_root, data_tree: this.data_tree, reward: this.reward, signature: this.signature };
    } }, { key: "setOwner", value: function setOwner(owner) {
      this.owner = owner;
    } }, { key: "setSignature", value: function setSignature(_ref90) {
      var id = _ref90.id, owner = _ref90.owner, reward = _ref90.reward, tags2 = _ref90.tags, signature2 = _ref90.signature;
      this.id = id;
      this.owner = owner;
      if (reward)
        this.reward = reward;
      if (tags2)
        this.tags = tags2;
      this.signature = signature2;
    } }, {
      key: "prepareChunks",
      value: function() {
        var _prepareChunks = _asyncToGenerator(_regeneratorRuntime().mark(function _callee142(data) {
          return _regeneratorRuntime().wrap(function _callee142$(_context143) {
            while (1)
              switch (_context143.prev = _context143.next) {
                case 0:
                  if (!(!this.chunks && data.byteLength > 0)) {
                    _context143.next = 5;
                    break;
                  }
                  _context143.next = 3;
                  return (0, merkle_1.generateTransactionChunks)(data);
                case 3:
                  this.chunks = _context143.sent;
                  this.data_root = ArweaveUtils2.bufferTob64Url(this.chunks.data_root);
                case 5:
                  if (!this.chunks && data.byteLength === 0) {
                    this.chunks = { chunks: [], data_root: new Uint8Array(), proofs: [] };
                    this.data_root = "";
                  }
                case 6:
                case "end":
                  return _context143.stop();
              }
          }, _callee142, this);
        }));
        function prepareChunks(_x212) {
          return _prepareChunks.apply(this, arguments);
        }
        return prepareChunks;
      }()
      // Returns a chunk in a format suitable for posting to /chunk.
      // Similar to `prepareChunks()` this does not operate `this.data`,
      // instead using the data passed in.
    }, { key: "getChunk", value: function getChunk(idx, data) {
      if (!this.chunks) {
        throw new Error("Chunks have not been prepared");
      }
      var proof = this.chunks.proofs[idx];
      var chunk = this.chunks.chunks[idx];
      return { data_root: this.data_root, data_size: this.data_size, data_path: ArweaveUtils2.bufferTob64Url(proof.proof), offset: proof.offset.toString(), chunk: ArweaveUtils2.bufferTob64Url(data.slice(chunk.minByteRange, chunk.maxByteRange)) };
    } }, { key: "getSignatureData", value: function() {
      var _getSignatureData2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee143() {
        var _tags, tagList;
        return _regeneratorRuntime().wrap(function _callee143$(_context144) {
          while (1)
            switch (_context144.prev = _context144.next) {
              case 0:
                _context144.t0 = this.format;
                _context144.next = _context144.t0 === 1 ? 3 : _context144.t0 === 2 ? 5 : 12;
                break;
              case 3:
                _tags = this.tags.reduce(function(accumulator, tag) {
                  return ArweaveUtils2.concatBuffers([accumulator, tag.get("name", { decode: true, string: false }), tag.get("value", { decode: true, string: false })]);
                }, new Uint8Array());
                return _context144.abrupt("return", ArweaveUtils2.concatBuffers([this.get("owner", { decode: true, string: false }), this.get("target", { decode: true, string: false }), this.get("data", { decode: true, string: false }), ArweaveUtils2.stringToBuffer(this.quantity), ArweaveUtils2.stringToBuffer(this.reward), this.get("last_tx", { decode: true, string: false }), _tags]));
              case 5:
                if (this.data_root) {
                  _context144.next = 8;
                  break;
                }
                _context144.next = 8;
                return this.prepareChunks(this.data);
              case 8:
                tagList = this.tags.map(function(tag) {
                  return [tag.get("name", { decode: true, string: false }), tag.get("value", { decode: true, string: false })];
                });
                _context144.next = 11;
                return (0, deepHash_1.default)([ArweaveUtils2.stringToBuffer(this.format.toString()), this.get("owner", { decode: true, string: false }), this.get("target", { decode: true, string: false }), ArweaveUtils2.stringToBuffer(this.quantity), ArweaveUtils2.stringToBuffer(this.reward), this.get("last_tx", { decode: true, string: false }), tagList, ArweaveUtils2.stringToBuffer(this.data_size), this.get("data_root", { decode: true, string: false })]);
              case 11:
                return _context144.abrupt("return", _context144.sent);
              case 12:
                throw new Error("Unexpected transaction format: ".concat(this.format));
              case 13:
              case "end":
                return _context144.stop();
            }
        }, _callee143, this);
      }));
      function getSignatureData() {
        return _getSignatureData2.apply(this, arguments);
      }
      return getSignatureData;
    }() }]);
  }(BaseObject);
  transaction.default = Transaction;
  return transaction;
}
var transactionUploader = {};
var hasRequiredTransactionUploader;
function requireTransactionUploader() {
  if (hasRequiredTransactionUploader)
    return transactionUploader;
  hasRequiredTransactionUploader = 1;
  Object.defineProperty(transactionUploader, "__esModule", { value: true });
  transactionUploader.TransactionUploader = void 0;
  var transaction_1 = requireTransaction();
  var ArweaveUtils2 = utils;
  var error_12 = error;
  var merkle_1 = requireMerkle();
  var MAX_CHUNKS_IN_BODY = 1;
  var FATAL_CHUNK_UPLOAD_ERRORS = ["invalid_json", "chunk_too_big", "data_path_too_big", "offset_too_big", "data_size_too_big", "chunk_proof_ratio_not_attractive", "invalid_proof"];
  var ERROR_DELAY = 1e3 * 40;
  var TransactionUploader = function() {
    function TransactionUploader2(api2, transaction2) {
      _classCallCheck2(this, TransactionUploader2);
      _defineProperty(this, "api", void 0);
      _defineProperty(this, "chunkIndex", 0);
      _defineProperty(this, "txPosted", false);
      _defineProperty(this, "transaction", void 0);
      _defineProperty(this, "lastRequestTimeEnd", 0);
      _defineProperty(this, "totalErrors", 0);
      _defineProperty(this, "data", void 0);
      _defineProperty(this, "lastResponseStatus", 0);
      _defineProperty(this, "lastResponseError", "");
      this.api = api2;
      if (!transaction2.id) {
        throw new Error("Transaction is not signed");
      }
      if (!transaction2.chunks) {
        throw new Error("Transaction chunks not prepared");
      }
      this.data = transaction2.data;
      this.transaction = new transaction_1.default(Object.assign({}, transaction2, { data: new Uint8Array(0) }));
    }
    return _createClass(TransactionUploader2, [{ key: "isComplete", get: function get5() {
      return this.txPosted && this.chunkIndex === this.transaction.chunks.chunks.length;
    } }, { key: "totalChunks", get: function get5() {
      return this.transaction.chunks.chunks.length;
    } }, { key: "uploadedChunks", get: function get5() {
      return this.chunkIndex;
    } }, { key: "pctComplete", get: function get5() {
      return Math.trunc(this.uploadedChunks / this.totalChunks * 100);
    } }, { key: "uploadChunk", value: function() {
      var _uploadChunk = _asyncToGenerator(_regeneratorRuntime().mark(function _callee144(chunkIndex_) {
        var delay, chunk, chunkOk, resp;
        return _regeneratorRuntime().wrap(function _callee144$(_context145) {
          while (1)
            switch (_context145.prev = _context145.next) {
              case 0:
                if (!this.isComplete) {
                  _context145.next = 2;
                  break;
                }
                throw new Error("Upload is already complete");
              case 2:
                if (this.lastResponseError !== "") {
                  this.totalErrors++;
                } else {
                  this.totalErrors = 0;
                }
                if (!(this.totalErrors === 100)) {
                  _context145.next = 5;
                  break;
                }
                throw new Error("Unable to complete upload: ".concat(this.lastResponseStatus, ": ").concat(this.lastResponseError));
              case 5:
                delay = this.lastResponseError === "" ? 0 : Math.max(this.lastRequestTimeEnd + ERROR_DELAY - Date.now(), ERROR_DELAY);
                if (!(delay > 0)) {
                  _context145.next = 10;
                  break;
                }
                delay = delay - delay * Math.random() * 0.3;
                _context145.next = 10;
                return new Promise(function(res) {
                  return setTimeout(res, delay);
                });
              case 10:
                this.lastResponseError = "";
                if (this.txPosted) {
                  _context145.next = 15;
                  break;
                }
                _context145.next = 14;
                return this.postTransaction();
              case 14:
                return _context145.abrupt("return");
              case 15:
                if (chunkIndex_) {
                  this.chunkIndex = chunkIndex_;
                }
                chunk = this.transaction.getChunk(chunkIndex_ || this.chunkIndex, this.data);
                _context145.next = 19;
                return (0, merkle_1.validatePath)(this.transaction.chunks.data_root, parseInt(chunk.offset), 0, parseInt(chunk.data_size), ArweaveUtils2.b64UrlToBuffer(chunk.data_path));
              case 19:
                chunkOk = _context145.sent;
                if (chunkOk) {
                  _context145.next = 22;
                  break;
                }
                throw new Error("Unable to validate chunk ".concat(this.chunkIndex));
              case 22:
                _context145.next = 24;
                return this.api.post("chunk", this.transaction.getChunk(this.chunkIndex, this.data)).catch(function(e2) {
                  console.error(e2.message);
                  return { status: -1, data: { error: e2.message } };
                });
              case 24:
                resp = _context145.sent;
                this.lastRequestTimeEnd = Date.now();
                this.lastResponseStatus = resp.status;
                if (!(this.lastResponseStatus == 200)) {
                  _context145.next = 31;
                  break;
                }
                this.chunkIndex++;
                _context145.next = 34;
                break;
              case 31:
                this.lastResponseError = (0, error_12.getError)(resp);
                if (!FATAL_CHUNK_UPLOAD_ERRORS.includes(this.lastResponseError)) {
                  _context145.next = 34;
                  break;
                }
                throw new Error("Fatal error uploading chunk ".concat(this.chunkIndex, ": ").concat(this.lastResponseError));
              case 34:
              case "end":
                return _context145.stop();
            }
        }, _callee144, this);
      }));
      function uploadChunk(_x213) {
        return _uploadChunk.apply(this, arguments);
      }
      return uploadChunk;
    }() }, {
      key: "toJSON",
      value: function toJSON2() {
        return { chunkIndex: this.chunkIndex, transaction: this.transaction, lastRequestTimeEnd: this.lastRequestTimeEnd, lastResponseStatus: this.lastResponseStatus, lastResponseError: this.lastResponseError, txPosted: this.txPosted };
      }
      // POST to /tx
    }, { key: "postTransaction", value: function() {
      var _postTransaction = _asyncToGenerator(_regeneratorRuntime().mark(function _callee145() {
        var uploadInBody, _resp, resp;
        return _regeneratorRuntime().wrap(function _callee145$(_context146) {
          while (1)
            switch (_context146.prev = _context146.next) {
              case 0:
                uploadInBody = this.totalChunks <= MAX_CHUNKS_IN_BODY;
                if (!uploadInBody) {
                  _context146.next = 15;
                  break;
                }
                this.transaction.data = this.data;
                _context146.next = 5;
                return this.api.post("tx", this.transaction).catch(function(e2) {
                  console.error(e2);
                  return { status: -1, data: { error: e2.message } };
                });
              case 5:
                _resp = _context146.sent;
                this.lastRequestTimeEnd = Date.now();
                this.lastResponseStatus = _resp.status;
                this.transaction.data = new Uint8Array(0);
                if (!(_resp.status >= 200 && _resp.status < 300)) {
                  _context146.next = 13;
                  break;
                }
                this.txPosted = true;
                this.chunkIndex = MAX_CHUNKS_IN_BODY;
                return _context146.abrupt("return");
              case 13:
                this.lastResponseError = (0, error_12.getError)(_resp);
                throw new Error("Unable to upload transaction: ".concat(_resp.status, ", ").concat(this.lastResponseError));
              case 15:
                _context146.next = 17;
                return this.api.post("tx", this.transaction);
              case 17:
                resp = _context146.sent;
                this.lastRequestTimeEnd = Date.now();
                this.lastResponseStatus = resp.status;
                if (resp.status >= 200 && resp.status < 300) {
                  _context146.next = 23;
                  break;
                }
                this.lastResponseError = (0, error_12.getError)(resp);
                throw new Error("Unable to upload transaction: ".concat(resp.status, ", ").concat(this.lastResponseError));
              case 23:
                this.txPosted = true;
              case 24:
              case "end":
                return _context146.stop();
            }
        }, _callee145, this);
      }));
      function postTransaction() {
        return _postTransaction.apply(this, arguments);
      }
      return postTransaction;
    }() }], [{ key: "fromSerialized", value: function() {
      var _fromSerialized = _asyncToGenerator(_regeneratorRuntime().mark(function _callee146(api2, serialized, data) {
        var transaction2, upload;
        return _regeneratorRuntime().wrap(function _callee146$(_context147) {
          while (1)
            switch (_context147.prev = _context147.next) {
              case 0:
                if (!(!serialized || typeof serialized.chunkIndex !== "number" || _typeof(serialized.transaction) !== "object")) {
                  _context147.next = 2;
                  break;
                }
                throw new Error("Serialized object does not match expected format.");
              case 2:
                transaction2 = new transaction_1.default(serialized.transaction);
                if (transaction2.chunks) {
                  _context147.next = 6;
                  break;
                }
                _context147.next = 6;
                return transaction2.prepareChunks(data);
              case 6:
                upload = new TransactionUploader2(api2, transaction2);
                upload.chunkIndex = serialized.chunkIndex;
                upload.lastRequestTimeEnd = serialized.lastRequestTimeEnd;
                upload.lastResponseError = serialized.lastResponseError;
                upload.lastResponseStatus = serialized.lastResponseStatus;
                upload.txPosted = serialized.txPosted;
                upload.data = data;
                if (!(upload.transaction.data_root !== serialized.transaction.data_root)) {
                  _context147.next = 15;
                  break;
                }
                throw new Error("Data mismatch: Uploader doesn't match provided data.");
              case 15:
                return _context147.abrupt("return", upload);
              case 16:
              case "end":
                return _context147.stop();
            }
        }, _callee146);
      }));
      function fromSerialized(_x214, _x215, _x216) {
        return _fromSerialized.apply(this, arguments);
      }
      return fromSerialized;
    }() }, { key: "fromTransactionId", value: function() {
      var _fromTransactionId = _asyncToGenerator(_regeneratorRuntime().mark(function _callee147(api2, id) {
        var resp, transaction2, serialized;
        return _regeneratorRuntime().wrap(function _callee147$(_context148) {
          while (1)
            switch (_context148.prev = _context148.next) {
              case 0:
                _context148.next = 2;
                return api2.get("tx/".concat(id));
              case 2:
                resp = _context148.sent;
                if (!(resp.status !== 200)) {
                  _context148.next = 5;
                  break;
                }
                throw new Error("Tx ".concat(id, " not found: ").concat(resp.status));
              case 5:
                transaction2 = resp.data;
                transaction2.data = new Uint8Array(0);
                serialized = { txPosted: true, chunkIndex: 0, lastResponseError: "", lastRequestTimeEnd: 0, lastResponseStatus: 0, transaction: transaction2 };
                return _context148.abrupt("return", serialized);
              case 9:
              case "end":
                return _context148.stop();
            }
        }, _callee147);
      }));
      function fromTransactionId(_x217, _x218) {
        return _fromTransactionId.apply(this, arguments);
      }
      return fromTransactionId;
    }() }]);
  }();
  transactionUploader.TransactionUploader = TransactionUploader;
  return transactionUploader;
}
var hasRequiredTransactions;
function requireTransactions() {
  if (hasRequiredTransactions)
    return transactions;
  hasRequiredTransactions = 1;
  Object.defineProperty(transactions, "__esModule", { value: true });
  var error_12 = error;
  var transaction_1 = requireTransaction();
  var ArweaveUtils2 = utils;
  var transaction_uploader_1 = requireTransactionUploader();
  var Transactions = function() {
    function Transactions2(api2, crypto2, chunks2) {
      _classCallCheck2(this, Transactions2);
      _defineProperty(this, "api", void 0);
      _defineProperty(this, "crypto", void 0);
      _defineProperty(this, "chunks", void 0);
      this.api = api2;
      this.crypto = crypto2;
      this.chunks = chunks2;
    }
    return _createClass(Transactions2, [{ key: "getTransactionAnchor", value: function() {
      var _getTransactionAnchor = _asyncToGenerator(_regeneratorRuntime().mark(function _callee148() {
        var res;
        return _regeneratorRuntime().wrap(function _callee148$(_context149) {
          while (1)
            switch (_context149.prev = _context149.next) {
              case 0:
                _context149.next = 2;
                return this.api.get("tx_anchor");
              case 2:
                res = _context149.sent;
                if (!(!res.data.match(/^[a-z0-9_-]{43,}/i) || !res.ok)) {
                  _context149.next = 5;
                  break;
                }
                throw new Error("Could not getTransactionAnchor. Received: ".concat(res.data, ". Status: ").concat(res.status, ", ").concat(res.statusText));
              case 5:
                return _context149.abrupt("return", res.data);
              case 6:
              case "end":
                return _context149.stop();
            }
        }, _callee148, this);
      }));
      function getTransactionAnchor() {
        return _getTransactionAnchor.apply(this, arguments);
      }
      return getTransactionAnchor;
    }() }, { key: "getPrice", value: function() {
      var _getPrice = _asyncToGenerator(_regeneratorRuntime().mark(function _callee149(byteSize, targetAddress) {
        var endpoint, res;
        return _regeneratorRuntime().wrap(function _callee149$(_context150) {
          while (1)
            switch (_context150.prev = _context150.next) {
              case 0:
                endpoint = targetAddress ? "price/".concat(byteSize, "/").concat(targetAddress) : "price/".concat(byteSize);
                _context150.next = 3;
                return this.api.get(endpoint);
              case 3:
                res = _context150.sent;
                if (!(!/^\d+$/.test(res.data) || !res.ok)) {
                  _context150.next = 6;
                  break;
                }
                throw new Error("Could not getPrice. Received: ".concat(res.data, ". Status: ").concat(res.status, ", ").concat(res.statusText));
              case 6:
                return _context150.abrupt("return", res.data);
              case 7:
              case "end":
                return _context150.stop();
            }
        }, _callee149, this);
      }));
      function getPrice(_x219, _x220) {
        return _getPrice.apply(this, arguments);
      }
      return getPrice;
    }() }, { key: "get", value: function() {
      var _get3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee150(id) {
        var response, data_size, data;
        return _regeneratorRuntime().wrap(function _callee150$(_context151) {
          while (1)
            switch (_context151.prev = _context151.next) {
              case 0:
                _context151.next = 2;
                return this.api.get("tx/".concat(id));
              case 2:
                response = _context151.sent;
                if (!(response.status == 200)) {
                  _context151.next = 11;
                  break;
                }
                data_size = parseInt(response.data.data_size);
                if (!(response.data.format >= 2 && data_size > 0 && data_size <= 1024 * 1024 * 12)) {
                  _context151.next = 10;
                  break;
                }
                _context151.next = 8;
                return this.getData(id);
              case 8:
                data = _context151.sent;
                return _context151.abrupt("return", new transaction_1.default(_objectSpread(_objectSpread({}, response.data), {}, { data })));
              case 10:
                return _context151.abrupt("return", new transaction_1.default(_objectSpread(_objectSpread({}, response.data), {}, { format: response.data.format || 1 })));
              case 11:
                if (!(response.status == 404)) {
                  _context151.next = 13;
                  break;
                }
                throw new error_12.default(
                  "TX_NOT_FOUND"
                  /* ArweaveErrorType.TX_NOT_FOUND */
                );
              case 13:
                if (!(response.status == 410)) {
                  _context151.next = 15;
                  break;
                }
                throw new error_12.default(
                  "TX_FAILED"
                  /* ArweaveErrorType.TX_FAILED */
                );
              case 15:
                throw new error_12.default(
                  "TX_INVALID"
                  /* ArweaveErrorType.TX_INVALID */
                );
              case 16:
              case "end":
                return _context151.stop();
            }
        }, _callee150, this);
      }));
      function get5(_x221) {
        return _get3.apply(this, arguments);
      }
      return get5;
    }() }, {
      key: "fromRaw",
      value: function fromRaw(attributes) {
        return new transaction_1.default(attributes);
      }
      /** @deprecated use GQL https://gql-guide.arweave.net */
    }, { key: "search", value: function() {
      var _search = _asyncToGenerator(_regeneratorRuntime().mark(function _callee151(tagName, tagValue) {
        return _regeneratorRuntime().wrap(function _callee151$(_context152) {
          while (1)
            switch (_context152.prev = _context152.next) {
              case 0:
                return _context152.abrupt("return", this.api.post("arql", { op: "equals", expr1: tagName, expr2: tagValue }).then(function(response) {
                  if (!response.data) {
                    return [];
                  }
                  return response.data;
                }));
              case 1:
              case "end":
                return _context152.stop();
            }
        }, _callee151, this);
      }));
      function search(_x222, _x223) {
        return _search.apply(this, arguments);
      }
      return search;
    }() }, { key: "getStatus", value: function getStatus(id) {
      return this.api.get("tx/".concat(id, "/status")).then(function(response) {
        if (response.status == 200) {
          return { status: 200, confirmed: response.data };
        }
        return { status: response.status, confirmed: null };
      });
    } }, { key: "getData", value: function() {
      var _getData = _asyncToGenerator(_regeneratorRuntime().mark(function _callee152(id, options) {
        var data, _yield$this$api$get, resData, ok, status, statusText;
        return _regeneratorRuntime().wrap(function _callee152$(_context153) {
          while (1)
            switch (_context153.prev = _context153.next) {
              case 0:
                data = void 0;
                _context153.prev = 1;
                _context153.next = 4;
                return this.chunks.downloadChunkedData(id);
              case 4:
                data = _context153.sent;
                _context153.next = 11;
                break;
              case 7:
                _context153.prev = 7;
                _context153.t0 = _context153["catch"](1);
                console.error("Error while trying to download chunked data for ".concat(id));
                console.error(_context153.t0);
              case 11:
                if (data) {
                  _context153.next = 30;
                  break;
                }
                console.warn("Falling back to gateway cache for ".concat(id));
                _context153.prev = 13;
                _context153.next = 16;
                return this.api.get("/".concat(id), { responseType: "arraybuffer" });
              case 16:
                _yield$this$api$get = _context153.sent;
                resData = _yield$this$api$get.data;
                ok = _yield$this$api$get.ok;
                status = _yield$this$api$get.status;
                statusText = _yield$this$api$get.statusText;
                if (ok) {
                  _context153.next = 23;
                  break;
                }
                throw new Error("Bad http status code", { cause: { status, statusText } });
              case 23:
                data = resData;
                _context153.next = 30;
                break;
              case 26:
                _context153.prev = 26;
                _context153.t1 = _context153["catch"](13);
                console.error("Error while trying to download contiguous data from gateway cache for ".concat(id));
                console.error(_context153.t1);
              case 30:
                if (data) {
                  _context153.next = 32;
                  break;
                }
                throw new Error("".concat(id, " data was not found!"));
              case 32:
                if (!(options && options.decode && !options.string)) {
                  _context153.next = 34;
                  break;
                }
                return _context153.abrupt("return", data);
              case 34:
                if (!(options && options.decode && options.string)) {
                  _context153.next = 36;
                  break;
                }
                return _context153.abrupt("return", ArweaveUtils2.bufferToString(data));
              case 36:
                return _context153.abrupt("return", ArweaveUtils2.bufferTob64Url(data));
              case 37:
              case "end":
                return _context153.stop();
            }
        }, _callee152, this, [[1, 7], [13, 26]]);
      }));
      function getData(_x224, _x225) {
        return _getData.apply(this, arguments);
      }
      return getData;
    }() }, { key: "sign", value: function() {
      var _sign6 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee153(transaction2, jwk, options) {
        var isJwk, validJwk, externalWallet, dataToSign, rawSignature, id, existingPermissions, signedTransaction;
        return _regeneratorRuntime().wrap(function _callee153$(_context154) {
          while (1)
            switch (_context154.prev = _context154.next) {
              case 0:
                isJwk = function isJwk2(obj2) {
                  var valid = true;
                  ["n", "e", "d", "p", "q", "dp", "dq", "qi"].map(function(key3) {
                    return !(key3 in obj2) && (valid = false);
                  });
                  return valid;
                };
                validJwk = _typeof(jwk) === "object" && isJwk(jwk);
                externalWallet = (typeof arweaveWallet === "undefined" ? "undefined" : _typeof(arweaveWallet)) === "object";
                if (!(!validJwk && !externalWallet)) {
                  _context154.next = 7;
                  break;
                }
                throw new Error("No valid JWK or external wallet found to sign transaction.");
              case 7:
                if (!validJwk) {
                  _context154.next = 21;
                  break;
                }
                transaction2.setOwner(jwk.n);
                _context154.next = 11;
                return transaction2.getSignatureData();
              case 11:
                dataToSign = _context154.sent;
                _context154.next = 14;
                return this.crypto.sign(jwk, dataToSign, options);
              case 14:
                rawSignature = _context154.sent;
                _context154.next = 17;
                return this.crypto.hash(rawSignature);
              case 17:
                id = _context154.sent;
                transaction2.setSignature({ id: ArweaveUtils2.bufferTob64Url(id), owner: jwk.n, signature: ArweaveUtils2.bufferTob64Url(rawSignature) });
                _context154.next = 40;
                break;
              case 21:
                if (!externalWallet) {
                  _context154.next = 39;
                  break;
                }
                _context154.prev = 22;
                _context154.next = 25;
                return arweaveWallet.getPermissions();
              case 25:
                existingPermissions = _context154.sent;
                if (existingPermissions.includes("SIGN_TRANSACTION")) {
                  _context154.next = 29;
                  break;
                }
                _context154.next = 29;
                return arweaveWallet.connect(["SIGN_TRANSACTION"]);
              case 29:
                _context154.next = 33;
                break;
              case 31:
                _context154.prev = 31;
                _context154.t0 = _context154["catch"](22);
              case 33:
                _context154.next = 35;
                return arweaveWallet.sign(transaction2, options);
              case 35:
                signedTransaction = _context154.sent;
                transaction2.setSignature({ id: signedTransaction.id, owner: signedTransaction.owner, reward: signedTransaction.reward, tags: signedTransaction.tags, signature: signedTransaction.signature });
                _context154.next = 40;
                break;
              case 39:
                throw new Error("An error occurred while signing. Check wallet is valid");
              case 40:
              case "end":
                return _context154.stop();
            }
        }, _callee153, this, [[22, 31]]);
      }));
      function sign(_x226, _x227, _x228) {
        return _sign6.apply(this, arguments);
      }
      return sign;
    }() }, { key: "verify", value: function() {
      var _verify8 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee154(transaction2) {
        var signaturePayload, rawSignature, expectedId;
        return _regeneratorRuntime().wrap(function _callee154$(_context155) {
          while (1)
            switch (_context155.prev = _context155.next) {
              case 0:
                _context155.next = 2;
                return transaction2.getSignatureData();
              case 2:
                signaturePayload = _context155.sent;
                rawSignature = transaction2.get("signature", { decode: true, string: false });
                _context155.t0 = ArweaveUtils2;
                _context155.next = 7;
                return this.crypto.hash(rawSignature);
              case 7:
                _context155.t1 = _context155.sent;
                expectedId = _context155.t0.bufferTob64Url.call(_context155.t0, _context155.t1);
                if (!(transaction2.id !== expectedId)) {
                  _context155.next = 11;
                  break;
                }
                throw new Error("Invalid transaction signature or ID! The transaction ID doesn't match the expected SHA-256 hash of the signature.");
              case 11:
                return _context155.abrupt("return", this.crypto.verify(transaction2.owner, signaturePayload, rawSignature));
              case 12:
              case "end":
                return _context155.stop();
            }
        }, _callee154, this);
      }));
      function verify(_x229) {
        return _verify8.apply(this, arguments);
      }
      return verify;
    }() }, {
      key: "post",
      value: function() {
        var _post2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee155(transaction2) {
          var uploader;
          return _regeneratorRuntime().wrap(function _callee155$(_context156) {
            while (1)
              switch (_context156.prev = _context156.next) {
                case 0:
                  if (typeof transaction2 === "string") {
                    transaction2 = new transaction_1.default(JSON.parse(transaction2));
                  } else if (typeof transaction2.readInt32BE === "function") {
                    transaction2 = new transaction_1.default(JSON.parse(transaction2.toString()));
                  } else if (_typeof(transaction2) === "object" && !(transaction2 instanceof transaction_1.default)) {
                    transaction2 = new transaction_1.default(transaction2);
                  }
                  if (transaction2 instanceof transaction_1.default) {
                    _context156.next = 3;
                    break;
                  }
                  throw new Error("Must be Transaction object");
                case 3:
                  if (transaction2.chunks) {
                    _context156.next = 6;
                    break;
                  }
                  _context156.next = 6;
                  return transaction2.prepareChunks(transaction2.data);
                case 6:
                  _context156.next = 8;
                  return this.getUploader(transaction2, transaction2.data);
                case 8:
                  uploader = _context156.sent;
                  _context156.prev = 9;
                case 10:
                  if (uploader.isComplete) {
                    _context156.next = 15;
                    break;
                  }
                  _context156.next = 13;
                  return uploader.uploadChunk();
                case 13:
                  _context156.next = 10;
                  break;
                case 15:
                  _context156.next = 22;
                  break;
                case 17:
                  _context156.prev = 17;
                  _context156.t0 = _context156["catch"](9);
                  if (!(uploader.lastResponseStatus > 0)) {
                    _context156.next = 21;
                    break;
                  }
                  return _context156.abrupt("return", { status: uploader.lastResponseStatus, statusText: uploader.lastResponseError, data: { error: uploader.lastResponseError } });
                case 21:
                  throw _context156.t0;
                case 22:
                  return _context156.abrupt("return", { status: 200, statusText: "OK", data: {} });
                case 23:
                case "end":
                  return _context156.stop();
              }
          }, _callee155, this, [[9, 17]]);
        }));
        function post(_x230) {
          return _post2.apply(this, arguments);
        }
        return post;
      }()
      /**
      * Gets an uploader than can be used to upload a transaction chunk by chunk, giving progress
      * and the ability to resume.
      *
      * Usage example:
      *
      * ```
      * const uploader = arweave.transactions.getUploader(transaction);
      * while (!uploader.isComplete) {
      *   await uploader.uploadChunk();
      *   console.log(`${uploader.pctComplete}%`);
      * }
      * ```
      *
      * @param upload a Transaction object, a previously save progress object, or a transaction id.
      * @param data the data of the transaction. Required when resuming an upload.
      */
    }, { key: "getUploader", value: function() {
      var _getUploader = _asyncToGenerator(_regeneratorRuntime().mark(function _callee156(upload, data) {
        var uploader;
        return _regeneratorRuntime().wrap(function _callee156$(_context157) {
          while (1)
            switch (_context157.prev = _context157.next) {
              case 0:
                if (data instanceof ArrayBuffer) {
                  data = new Uint8Array(data);
                }
                if (!(upload instanceof transaction_1.default)) {
                  _context157.next = 12;
                  break;
                }
                if (!data) {
                  data = upload.data;
                }
                if (data instanceof Uint8Array) {
                  _context157.next = 5;
                  break;
                }
                throw new Error("Data format is invalid");
              case 5:
                if (upload.chunks) {
                  _context157.next = 8;
                  break;
                }
                _context157.next = 8;
                return upload.prepareChunks(data);
              case 8:
                uploader = new transaction_uploader_1.TransactionUploader(this.api, upload);
                if (!uploader.data || uploader.data.length === 0) {
                  uploader.data = data;
                }
                _context157.next = 21;
                break;
              case 12:
                if (!(typeof upload === "string")) {
                  _context157.next = 16;
                  break;
                }
                _context157.next = 15;
                return transaction_uploader_1.TransactionUploader.fromTransactionId(this.api, upload);
              case 15:
                upload = _context157.sent;
              case 16:
                if (!(!data || !(data instanceof Uint8Array))) {
                  _context157.next = 18;
                  break;
                }
                throw new Error("Must provide data when resuming upload");
              case 18:
                _context157.next = 20;
                return transaction_uploader_1.TransactionUploader.fromSerialized(this.api, upload, data);
              case 20:
                uploader = _context157.sent;
              case 21:
                return _context157.abrupt("return", uploader);
              case 22:
              case "end":
                return _context157.stop();
            }
        }, _callee156, this);
      }));
      function getUploader(_x231, _x232) {
        return _getUploader.apply(this, arguments);
      }
      return getUploader;
    }() }, { key: "upload", value: function upload(_upload, data) {
      var _this2 = this;
      return _wrapAsyncGenerator(_regeneratorRuntime().mark(function _callee157() {
        var uploader;
        return _regeneratorRuntime().wrap(function _callee157$(_context158) {
          while (1)
            switch (_context158.prev = _context158.next) {
              case 0:
                _context158.next = 2;
                return _awaitAsyncGenerator(_this2.getUploader(_upload, data));
              case 2:
                uploader = _context158.sent;
              case 3:
                if (uploader.isComplete) {
                  _context158.next = 10;
                  break;
                }
                _context158.next = 6;
                return _awaitAsyncGenerator(uploader.uploadChunk());
              case 6:
                _context158.next = 8;
                return uploader;
              case 8:
                _context158.next = 3;
                break;
              case 10:
                return _context158.abrupt("return", uploader);
              case 11:
              case "end":
                return _context158.stop();
            }
        }, _callee157);
      }))();
    } }]);
  }();
  transactions.default = Transactions;
  return transactions;
}
var wallets = {};
Object.defineProperty(wallets, "__esModule", { value: true });
var ArweaveUtils$2 = utils;
var Wallets = function() {
  function Wallets2(api2, crypto2) {
    _classCallCheck2(this, Wallets2);
    _defineProperty(this, "api", void 0);
    _defineProperty(this, "crypto", void 0);
    this.api = api2;
    this.crypto = crypto2;
  }
  return _createClass(Wallets2, [{
    key: "getBalance",
    value: function getBalance(address) {
      return this.api.get("wallet/".concat(address, "/balance")).then(function(response) {
        return response.data;
      });
    }
    /**
    * Get the last transaction ID for the given wallet address.
    *
    * @param {string} address - The arweave address to get the transaction for.
    *
    * @returns {Promise<string>} - Promise which resolves with a transaction ID.
    */
  }, { key: "getLastTransactionID", value: function getLastTransactionID(address) {
    return this.api.get("wallet/".concat(address, "/last_tx")).then(function(response) {
      return response.data;
    });
  } }, { key: "generate", value: function generate2() {
    return this.crypto.generateJWK();
  } }, { key: "jwkToAddress", value: function() {
    var _jwkToAddress = _asyncToGenerator(_regeneratorRuntime().mark(function _callee158(jwk) {
      return _regeneratorRuntime().wrap(function _callee158$(_context159) {
        while (1)
          switch (_context159.prev = _context159.next) {
            case 0:
              if (!(!jwk || jwk === "use_wallet")) {
                _context159.next = 4;
                break;
              }
              return _context159.abrupt("return", this.getAddress());
            case 4:
              return _context159.abrupt("return", this.getAddress(jwk));
            case 5:
            case "end":
              return _context159.stop();
          }
      }, _callee158, this);
    }));
    function jwkToAddress(_x233) {
      return _jwkToAddress.apply(this, arguments);
    }
    return jwkToAddress;
  }() }, { key: "getAddress", value: function() {
    var _getAddress = _asyncToGenerator(_regeneratorRuntime().mark(function _callee159(jwk) {
      return _regeneratorRuntime().wrap(function _callee159$(_context160) {
        while (1)
          switch (_context160.prev = _context160.next) {
            case 0:
              if (!(!jwk || jwk === "use_wallet")) {
                _context160.next = 11;
                break;
              }
              _context160.prev = 1;
              _context160.next = 4;
              return arweaveWallet.connect(["ACCESS_ADDRESS"]);
            case 4:
              _context160.next = 8;
              break;
            case 6:
              _context160.prev = 6;
              _context160.t0 = _context160["catch"](1);
            case 8:
              return _context160.abrupt("return", arweaveWallet.getActiveAddress());
            case 11:
              return _context160.abrupt("return", this.ownerToAddress(jwk.n));
            case 12:
            case "end":
              return _context160.stop();
          }
      }, _callee159, this, [[1, 6]]);
    }));
    function getAddress(_x234) {
      return _getAddress.apply(this, arguments);
    }
    return getAddress;
  }() }, { key: "ownerToAddress", value: function() {
    var _ownerToAddress = _asyncToGenerator(_regeneratorRuntime().mark(function _callee160(owner) {
      return _regeneratorRuntime().wrap(function _callee160$(_context161) {
        while (1)
          switch (_context161.prev = _context161.next) {
            case 0:
              _context161.t0 = ArweaveUtils$2;
              _context161.next = 3;
              return this.crypto.hash(ArweaveUtils$2.b64UrlToBuffer(owner));
            case 3:
              _context161.t1 = _context161.sent;
              return _context161.abrupt("return", _context161.t0.bufferTob64Url.call(_context161.t0, _context161.t1));
            case 5:
            case "end":
              return _context161.stop();
          }
      }, _callee160, this);
    }));
    function ownerToAddress(_x235) {
      return _ownerToAddress.apply(this, arguments);
    }
    return ownerToAddress;
  }() }]);
}();
wallets.default = Wallets;
var silo = {};
Object.defineProperty(silo, "__esModule", { value: true });
silo.SiloResource = void 0;
var ArweaveUtils$1 = utils;
var Silo = function() {
  function Silo2(api2, crypto2, transactions2) {
    _classCallCheck2(this, Silo2);
    _defineProperty(this, "api", void 0);
    _defineProperty(this, "crypto", void 0);
    _defineProperty(this, "transactions", void 0);
    this.api = api2;
    this.crypto = crypto2;
    this.transactions = transactions2;
  }
  return _createClass(Silo2, [{ key: "get", value: function() {
    var _get4 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee161(siloURI) {
      var resource, ids, transaction2, encrypted;
      return _regeneratorRuntime().wrap(function _callee161$(_context162) {
        while (1)
          switch (_context162.prev = _context162.next) {
            case 0:
              if (siloURI) {
                _context162.next = 2;
                break;
              }
              throw new Error("No Silo URI specified");
            case 2:
              _context162.next = 4;
              return this.parseUri(siloURI);
            case 4:
              resource = _context162.sent;
              _context162.next = 7;
              return this.transactions.search("Silo-Name", resource.getAccessKey());
            case 7:
              ids = _context162.sent;
              if (!(ids.length == 0)) {
                _context162.next = 10;
                break;
              }
              throw new Error("No data could be found for the Silo URI: ".concat(siloURI));
            case 10:
              _context162.next = 12;
              return this.transactions.get(ids[0]);
            case 12:
              transaction2 = _context162.sent;
              if (transaction2) {
                _context162.next = 15;
                break;
              }
              throw new Error("No data could be found for the Silo URI: ".concat(siloURI));
            case 15:
              encrypted = transaction2.get("data", { decode: true, string: false });
              return _context162.abrupt("return", this.crypto.decrypt(encrypted, resource.getEncryptionKey()));
            case 17:
            case "end":
              return _context162.stop();
          }
      }, _callee161, this);
    }));
    function get5(_x236) {
      return _get4.apply(this, arguments);
    }
    return get5;
  }() }, { key: "readTransactionData", value: function() {
    var _readTransactionData = _asyncToGenerator(_regeneratorRuntime().mark(function _callee162(transaction2, siloURI) {
      var resource, encrypted;
      return _regeneratorRuntime().wrap(function _callee162$(_context163) {
        while (1)
          switch (_context163.prev = _context163.next) {
            case 0:
              if (siloURI) {
                _context163.next = 2;
                break;
              }
              throw new Error("No Silo URI specified");
            case 2:
              _context163.next = 4;
              return this.parseUri(siloURI);
            case 4:
              resource = _context163.sent;
              encrypted = transaction2.get("data", { decode: true, string: false });
              return _context163.abrupt("return", this.crypto.decrypt(encrypted, resource.getEncryptionKey()));
            case 7:
            case "end":
              return _context163.stop();
          }
      }, _callee162, this);
    }));
    function readTransactionData(_x237, _x238) {
      return _readTransactionData.apply(this, arguments);
    }
    return readTransactionData;
  }() }, { key: "parseUri", value: function() {
    var _parseUri = _asyncToGenerator(_regeneratorRuntime().mark(function _callee163(siloURI) {
      var parsed, siloName, hashIterations, digest11, accessKey, encryptionkey;
      return _regeneratorRuntime().wrap(function _callee163$(_context164) {
        while (1)
          switch (_context164.prev = _context164.next) {
            case 0:
              parsed = siloURI.match(/^([a-z0-9-_]+)\.([0-9]+)/i);
              if (parsed) {
                _context164.next = 3;
                break;
              }
              throw new Error("Invalid Silo name, must be a name in the format of [a-z0-9]+.[0-9]+, e.g. 'bubble.7'");
            case 3:
              siloName = parsed[1];
              hashIterations = Math.pow(2, parseInt(parsed[2]));
              _context164.next = 7;
              return this.hash(ArweaveUtils$1.stringToBuffer(siloName), hashIterations);
            case 7:
              digest11 = _context164.sent;
              accessKey = ArweaveUtils$1.bufferTob64(digest11.slice(0, 15));
              _context164.next = 11;
              return this.hash(digest11.slice(16, 31), 1);
            case 11:
              encryptionkey = _context164.sent;
              return _context164.abrupt("return", new SiloResource(siloURI, accessKey, encryptionkey));
            case 13:
            case "end":
              return _context164.stop();
          }
      }, _callee163, this);
    }));
    function parseUri(_x239) {
      return _parseUri.apply(this, arguments);
    }
    return parseUri;
  }() }, { key: "hash", value: function() {
    var _hash11 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee164(input, iterations) {
      var digest11, count;
      return _regeneratorRuntime().wrap(function _callee164$(_context165) {
        while (1)
          switch (_context165.prev = _context165.next) {
            case 0:
              _context165.next = 2;
              return this.crypto.hash(input);
            case 2:
              digest11 = _context165.sent;
              count = 0;
            case 4:
              if (!(count < iterations - 1)) {
                _context165.next = 11;
                break;
              }
              _context165.next = 7;
              return this.crypto.hash(digest11);
            case 7:
              digest11 = _context165.sent;
            case 8:
              count++;
              _context165.next = 4;
              break;
            case 11:
              return _context165.abrupt("return", digest11);
            case 12:
            case "end":
              return _context165.stop();
          }
      }, _callee164, this);
    }));
    function hash2(_x240, _x241) {
      return _hash11.apply(this, arguments);
    }
    return hash2;
  }() }]);
}();
silo.default = Silo;
var SiloResource = function() {
  function SiloResource2(uri, accessKey, encryptionKey) {
    _classCallCheck2(this, SiloResource2);
    _defineProperty(this, "uri", void 0);
    _defineProperty(this, "accessKey", void 0);
    _defineProperty(this, "encryptionKey", void 0);
    this.uri = uri;
    this.accessKey = accessKey;
    this.encryptionKey = encryptionKey;
  }
  return _createClass(SiloResource2, [{ key: "getUri", value: function getUri() {
    return this.uri;
  } }, { key: "getAccessKey", value: function getAccessKey() {
    return this.accessKey;
  } }, { key: "getEncryptionKey", value: function getEncryptionKey() {
    return this.encryptionKey;
  } }]);
}();
silo.SiloResource = SiloResource;
var chunks = {};
Object.defineProperty(chunks, "__esModule", { value: true });
var error_1$1 = error;
var ArweaveUtils = utils;
var Chunks = function() {
  function Chunks2(api2) {
    _classCallCheck2(this, Chunks2);
    _defineProperty(this, "api", void 0);
    this.api = api2;
  }
  return _createClass(Chunks2, [{ key: "getTransactionOffset", value: function() {
    var _getTransactionOffset = _asyncToGenerator(_regeneratorRuntime().mark(function _callee165(id) {
      var resp;
      return _regeneratorRuntime().wrap(function _callee165$(_context166) {
        while (1)
          switch (_context166.prev = _context166.next) {
            case 0:
              _context166.next = 2;
              return this.api.get("tx/".concat(id, "/offset"));
            case 2:
              resp = _context166.sent;
              if (!(resp.status === 200)) {
                _context166.next = 5;
                break;
              }
              return _context166.abrupt("return", resp.data);
            case 5:
              throw new Error("Unable to get transaction offset: ".concat((0, error_1$1.getError)(resp)));
            case 6:
            case "end":
              return _context166.stop();
          }
      }, _callee165, this);
    }));
    function getTransactionOffset(_x242) {
      return _getTransactionOffset.apply(this, arguments);
    }
    return getTransactionOffset;
  }() }, { key: "getChunk", value: function() {
    var _getChunk = _asyncToGenerator(_regeneratorRuntime().mark(function _callee166(offset) {
      var resp;
      return _regeneratorRuntime().wrap(function _callee166$(_context167) {
        while (1)
          switch (_context167.prev = _context167.next) {
            case 0:
              _context167.next = 2;
              return this.api.get("chunk/".concat(offset));
            case 2:
              resp = _context167.sent;
              if (!(resp.status === 200)) {
                _context167.next = 5;
                break;
              }
              return _context167.abrupt("return", resp.data);
            case 5:
              throw new Error("Unable to get chunk: ".concat((0, error_1$1.getError)(resp)));
            case 6:
            case "end":
              return _context167.stop();
          }
      }, _callee166, this);
    }));
    function getChunk(_x243) {
      return _getChunk.apply(this, arguments);
    }
    return getChunk;
  }() }, { key: "getChunkData", value: function() {
    var _getChunkData = _asyncToGenerator(_regeneratorRuntime().mark(function _callee167(offset) {
      var chunk, buf;
      return _regeneratorRuntime().wrap(function _callee167$(_context168) {
        while (1)
          switch (_context168.prev = _context168.next) {
            case 0:
              _context168.next = 2;
              return this.getChunk(offset);
            case 2:
              chunk = _context168.sent;
              buf = ArweaveUtils.b64UrlToBuffer(chunk.chunk);
              return _context168.abrupt("return", buf);
            case 5:
            case "end":
              return _context168.stop();
          }
      }, _callee167, this);
    }));
    function getChunkData(_x244) {
      return _getChunkData.apply(this, arguments);
    }
    return getChunkData;
  }() }, { key: "firstChunkOffset", value: function firstChunkOffset(offsetResponse) {
    return parseInt(offsetResponse.offset) - parseInt(offsetResponse.size) + 1;
  } }, { key: "downloadChunkedData", value: function() {
    var _downloadChunkedData = _asyncToGenerator(_regeneratorRuntime().mark(function _callee168(id) {
      var offsetResponse, size, endOffset, startOffset, data, byte, chunkData;
      return _regeneratorRuntime().wrap(function _callee168$(_context169) {
        while (1)
          switch (_context169.prev = _context169.next) {
            case 0:
              _context169.next = 2;
              return this.getTransactionOffset(id);
            case 2:
              offsetResponse = _context169.sent;
              size = parseInt(offsetResponse.size);
              endOffset = parseInt(offsetResponse.offset);
              startOffset = endOffset - size + 1;
              data = new Uint8Array(size);
              byte = 0;
            case 8:
              if (!(byte < size)) {
                _context169.next = 29;
                break;
              }
              if (this.api.config.logging) {
                console.log("[chunk] ".concat(byte, "/").concat(size));
              }
              chunkData = void 0;
              _context169.prev = 11;
              _context169.next = 14;
              return this.getChunkData(startOffset + byte);
            case 14:
              chunkData = _context169.sent;
              _context169.next = 21;
              break;
            case 17:
              _context169.prev = 17;
              _context169.t0 = _context169["catch"](11);
              console.error("[chunk] Failed to fetch chunk at offset ".concat(startOffset + byte));
              console.error("[chunk] This could indicate that the chunk wasn't uploaded or hasn't yet seeded properly to a particular gateway/node");
            case 21:
              if (!chunkData) {
                _context169.next = 26;
                break;
              }
              data.set(chunkData, byte);
              byte += chunkData.length;
              _context169.next = 27;
              break;
            case 26:
              throw new Error("Couldn't complete data download at ".concat(byte, "/").concat(size));
            case 27:
              _context169.next = 8;
              break;
            case 29:
              return _context169.abrupt("return", data);
            case 30:
            case "end":
              return _context169.stop();
          }
      }, _callee168, this, [[11, 17]]);
    }));
    function downloadChunkedData(_x245) {
      return _downloadChunkedData.apply(this, arguments);
    }
    return downloadChunkedData;
  }() }]);
}();
chunks.default = Chunks;
var blocks = {};
Object.defineProperty(blocks, "__esModule", { value: true });
var error_1 = error;
var Blocks = function() {
  function Blocks2(api2, network2) {
    _classCallCheck2(this, Blocks2);
    _defineProperty(this, "api", void 0);
    _defineProperty(this, "network", void 0);
    this.api = api2;
    this.network = network2;
  }
  return _createClass(Blocks2, [{ key: "get", value: function() {
    var _get5 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee169(indepHash) {
      var response;
      return _regeneratorRuntime().wrap(function _callee169$(_context170) {
        while (1)
          switch (_context170.prev = _context170.next) {
            case 0:
              _context170.next = 2;
              return this.api.get("".concat(Blocks2.HASH_ENDPOINT).concat(indepHash));
            case 2:
              response = _context170.sent;
              if (!(response.status === 200)) {
                _context170.next = 7;
                break;
              }
              return _context170.abrupt("return", response.data);
            case 7:
              if (!(response.status === 404)) {
                _context170.next = 11;
                break;
              }
              throw new error_1.default(
                "BLOCK_NOT_FOUND"
                /* ArweaveErrorType.BLOCK_NOT_FOUND */
              );
            case 11:
              throw new Error("Error while loading block data: ".concat(response));
            case 12:
            case "end":
              return _context170.stop();
          }
      }, _callee169, this);
    }));
    function get5(_x246) {
      return _get5.apply(this, arguments);
    }
    return get5;
  }() }, { key: "getByHeight", value: function() {
    var _getByHeight = _asyncToGenerator(_regeneratorRuntime().mark(function _callee170(height) {
      var response;
      return _regeneratorRuntime().wrap(function _callee170$(_context171) {
        while (1)
          switch (_context171.prev = _context171.next) {
            case 0:
              _context171.next = 2;
              return this.api.get("".concat(Blocks2.HEIGHT_ENDPOINT).concat(height));
            case 2:
              response = _context171.sent;
              if (!(response.status === 200)) {
                _context171.next = 7;
                break;
              }
              return _context171.abrupt("return", response.data);
            case 7:
              if (!(response.status === 404)) {
                _context171.next = 11;
                break;
              }
              throw new error_1.default(
                "BLOCK_NOT_FOUND"
                /* ArweaveErrorType.BLOCK_NOT_FOUND */
              );
            case 11:
              throw new Error("Error while loading block data: ".concat(response));
            case 12:
            case "end":
              return _context171.stop();
          }
      }, _callee170, this);
    }));
    function getByHeight(_x247) {
      return _getByHeight.apply(this, arguments);
    }
    return getByHeight;
  }() }, { key: "getCurrent", value: function() {
    var _getCurrent = _asyncToGenerator(_regeneratorRuntime().mark(function _callee171() {
      var _yield$this$network$g, current;
      return _regeneratorRuntime().wrap(function _callee171$(_context172) {
        while (1)
          switch (_context172.prev = _context172.next) {
            case 0:
              _context172.next = 2;
              return this.network.getInfo();
            case 2:
              _yield$this$network$g = _context172.sent;
              current = _yield$this$network$g.current;
              _context172.next = 6;
              return this.get(current);
            case 6:
              return _context172.abrupt("return", _context172.sent);
            case 7:
            case "end":
              return _context172.stop();
          }
      }, _callee171, this);
    }));
    function getCurrent() {
      return _getCurrent.apply(this, arguments);
    }
    return getCurrent;
  }() }]);
}();
_defineProperty(Blocks, "HASH_ENDPOINT", "block/hash/");
_defineProperty(Blocks, "HEIGHT_ENDPOINT", "block/height/");
blocks.default = Blocks;
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon)
    return common;
  hasRequiredCommon = 1;
  Object.defineProperty(common, "__esModule", { value: true });
  var ar_1 = ar;
  var api_1 = api;
  var node_driver_1 = webcryptoDriver;
  var network_1 = network;
  var transactions_1 = requireTransactions();
  var wallets_1 = wallets;
  var transaction_1 = requireTransaction();
  var ArweaveUtils2 = utils;
  var silo_1 = silo;
  var chunks_1 = chunks;
  var blocks_1 = blocks;
  var Arweave = function() {
    function Arweave2(apiConfig) {
      _classCallCheck2(this, Arweave2);
      _defineProperty(this, "api", void 0);
      _defineProperty(this, "wallets", void 0);
      _defineProperty(this, "transactions", void 0);
      _defineProperty(this, "network", void 0);
      _defineProperty(this, "blocks", void 0);
      _defineProperty(this, "ar", void 0);
      _defineProperty(this, "silo", void 0);
      _defineProperty(this, "chunks", void 0);
      this.api = new api_1.default(apiConfig);
      this.wallets = new wallets_1.default(this.api, Arweave2.crypto);
      this.chunks = new chunks_1.default(this.api);
      this.transactions = new transactions_1.default(this.api, Arweave2.crypto, this.chunks);
      this.silo = new silo_1.default(this.api, this.crypto, this.transactions);
      this.network = new network_1.default(this.api);
      this.blocks = new blocks_1.default(this.api, this.network);
      this.ar = new ar_1.default();
    }
    return _createClass(Arweave2, [{
      key: "crypto",
      get: function get5() {
        return Arweave2.crypto;
      }
      /** @deprecated */
    }, { key: "utils", get: function get5() {
      return Arweave2.utils;
    } }, { key: "getConfig", value: function getConfig() {
      return { api: this.api.getConfig(), crypto: null };
    } }, { key: "createTransaction", value: function() {
      var _createTransaction = _asyncToGenerator(_regeneratorRuntime().mark(function _callee172(attributes, jwk) {
        var transaction2, _length2, createdTransaction;
        return _regeneratorRuntime().wrap(function _callee172$(_context173) {
          while (1)
            switch (_context173.prev = _context173.next) {
              case 0:
                transaction2 = {};
                Object.assign(transaction2, attributes);
                if (!(!attributes.data && !(attributes.target && attributes.quantity))) {
                  _context173.next = 4;
                  break;
                }
                throw new Error("A new Arweave transaction must have a 'data' value, or 'target' and 'quantity' values.");
              case 4:
                if (attributes.owner == void 0) {
                  if (jwk && jwk !== "use_wallet") {
                    transaction2.owner = jwk.n;
                  }
                }
                if (!(attributes.last_tx == void 0)) {
                  _context173.next = 9;
                  break;
                }
                _context173.next = 8;
                return this.transactions.getTransactionAnchor();
              case 8:
                transaction2.last_tx = _context173.sent;
              case 9:
                if (typeof attributes.data === "string") {
                  attributes.data = ArweaveUtils2.stringToBuffer(attributes.data);
                }
                if (attributes.data instanceof ArrayBuffer) {
                  attributes.data = new Uint8Array(attributes.data);
                }
                if (!(attributes.data && !(attributes.data instanceof Uint8Array))) {
                  _context173.next = 13;
                  break;
                }
                throw new Error("Expected data to be a string, Uint8Array or ArrayBuffer");
              case 13:
                if (!(attributes.reward == void 0)) {
                  _context173.next = 18;
                  break;
                }
                _length2 = attributes.data ? attributes.data.byteLength : 0;
                _context173.next = 17;
                return this.transactions.getPrice(_length2, transaction2.target);
              case 17:
                transaction2.reward = _context173.sent;
              case 18:
                transaction2.data_root = "";
                transaction2.data_size = attributes.data ? attributes.data.byteLength.toString() : "0";
                transaction2.data = attributes.data || new Uint8Array(0);
                createdTransaction = new transaction_1.default(transaction2);
                _context173.next = 24;
                return createdTransaction.getSignatureData();
              case 24:
                return _context173.abrupt("return", createdTransaction);
              case 25:
              case "end":
                return _context173.stop();
            }
        }, _callee172, this);
      }));
      function createTransaction(_x248, _x249) {
        return _createTransaction.apply(this, arguments);
      }
      return createTransaction;
    }() }, { key: "createSiloTransaction", value: function() {
      var _createSiloTransaction = _asyncToGenerator(_regeneratorRuntime().mark(function _callee173(attributes, jwk, siloUri) {
        var transaction2, siloResource, encrypted, _encrypted, siloTransaction;
        return _regeneratorRuntime().wrap(function _callee173$(_context174) {
          while (1)
            switch (_context174.prev = _context174.next) {
              case 0:
                transaction2 = {};
                Object.assign(transaction2, attributes);
                if (attributes.data) {
                  _context174.next = 4;
                  break;
                }
                throw new Error("Silo transactions must have a 'data' value");
              case 4:
                if (siloUri) {
                  _context174.next = 6;
                  break;
                }
                throw new Error("No Silo URI specified.");
              case 6:
                if (!(attributes.target || attributes.quantity)) {
                  _context174.next = 8;
                  break;
                }
                throw new Error("Silo transactions can only be used for storing data, sending AR to other wallets isn't supported.");
              case 8:
                if (!(attributes.owner == void 0)) {
                  _context174.next = 12;
                  break;
                }
                if (!(!jwk || !jwk.n)) {
                  _context174.next = 11;
                  break;
                }
                throw new Error("A new Arweave transaction must either have an 'owner' attribute, or you must provide the jwk parameter.");
              case 11:
                transaction2.owner = jwk.n;
              case 12:
                if (!(attributes.last_tx == void 0)) {
                  _context174.next = 16;
                  break;
                }
                _context174.next = 15;
                return this.transactions.getTransactionAnchor();
              case 15:
                transaction2.last_tx = _context174.sent;
              case 16:
                _context174.next = 18;
                return this.silo.parseUri(siloUri);
              case 18:
                siloResource = _context174.sent;
                if (!(typeof attributes.data == "string")) {
                  _context174.next = 27;
                  break;
                }
                _context174.next = 22;
                return this.crypto.encrypt(ArweaveUtils2.stringToBuffer(attributes.data), siloResource.getEncryptionKey());
              case 22:
                encrypted = _context174.sent;
                _context174.next = 25;
                return this.transactions.getPrice(encrypted.byteLength);
              case 25:
                transaction2.reward = _context174.sent;
                transaction2.data = ArweaveUtils2.bufferTob64Url(encrypted);
              case 27:
                if (!(attributes.data instanceof Uint8Array)) {
                  _context174.next = 35;
                  break;
                }
                _context174.next = 30;
                return this.crypto.encrypt(attributes.data, siloResource.getEncryptionKey());
              case 30:
                _encrypted = _context174.sent;
                _context174.next = 33;
                return this.transactions.getPrice(_encrypted.byteLength);
              case 33:
                transaction2.reward = _context174.sent;
                transaction2.data = ArweaveUtils2.bufferTob64Url(_encrypted);
              case 35:
                siloTransaction = new transaction_1.default(transaction2);
                siloTransaction.addTag("Silo-Name", siloResource.getAccessKey());
                siloTransaction.addTag("Silo-Version", "0.1.0");
                return _context174.abrupt("return", siloTransaction);
              case 39:
              case "end":
                return _context174.stop();
            }
        }, _callee173, this);
      }));
      function createSiloTransaction(_x250, _x251, _x252) {
        return _createSiloTransaction.apply(this, arguments);
      }
      return createSiloTransaction;
    }() }, { key: "arql", value: function arql(query) {
      return this.api.post("/arql", query).then(function(response) {
        return response.data || [];
      });
    } }]);
  }();
  _defineProperty(Arweave, "init", void 0);
  _defineProperty(Arweave, "crypto", new node_driver_1.default());
  _defineProperty(Arweave, "utils", ArweaveUtils2);
  common.default = Arweave;
  return common;
}
var netConfig = {};
Object.defineProperty(netConfig, "__esModule", { value: true });
netConfig.getDefaultConfig = void 0;
var isLocal = function isLocal2(protocol, hostname) {
  var regexLocalIp = /^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/;
  var split2 = hostname.split(".");
  var tld = split2[split2.length - 1];
  var localStrings = ["localhost", "[::1]"];
  return localStrings.includes(hostname) || protocol == "file" || localStrings.includes(tld) || !!hostname.match(regexLocalIp) || !!tld.match(regexLocalIp);
};
var isIpAdress = function isIpAdress2(host) {
  var isIpv6 = host.charAt(0) === "[";
  var regexMatchIpv4 = /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/;
  return !!host.match(regexMatchIpv4) || isIpv6;
};
var getDefaultConfig = function getDefaultConfig2(protocol, host) {
  if (isLocal(protocol, host)) {
    return { protocol: "https", host: "arweave.net", port: 443 };
  }
  if (!isIpAdress(host)) {
    var _split = host.split(".");
    if (_split.length >= 3) {
      _split.shift();
      var parentDomain = _split.join(".");
      return { protocol, host: parentDomain };
    }
  }
  return { protocol, host };
};
netConfig.getDefaultConfig = getDefaultConfig;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k3, k22) {
    if (k22 === void 0)
      k22 = k3;
    var desc = Object.getOwnPropertyDescriptor(m2, k3);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function get5() {
        return m2[k3];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k3, k22) {
    if (k22 === void 0)
      k22 = k3;
    o2[k22] = m2[k3];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var common_1 = requireCommon();
  var net_config_1 = netConfig;
  common_1.default.init = function() {
    var apiConfig = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var defaults2 = { host: "arweave.net", port: 443, protocol: "https" };
    if ((typeof location === "undefined" ? "undefined" : _typeof(location)) !== "object" || !location.protocol || !location.hostname) {
      return new common_1.default(_objectSpread(_objectSpread({}, apiConfig), defaults2));
    }
    var locationProtocol = location.protocol.replace(":", "");
    var locationHost = location.hostname;
    var locationPort = location.port ? parseInt(location.port) : locationProtocol == "https" ? 443 : 80;
    var defaultConfig = (0, net_config_1.getDefaultConfig)(locationProtocol, locationHost);
    var protocol = apiConfig.protocol || defaultConfig.protocol;
    var host = apiConfig.host || defaultConfig.host;
    var port = apiConfig.port || defaultConfig.port || locationPort;
    return new common_1.default(_objectSpread(_objectSpread({}, apiConfig), {}, { host, protocol, port }));
  };
  if ((typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) === "object") {
    globalThis.Arweave = common_1.default;
  } else if ((typeof self === "undefined" ? "undefined" : _typeof(self)) === "object") {
    self.Arweave = common_1.default;
  }
  __exportStar(requireCommon(), exports);
  exports.default = common_1.default;
})(web);
var ArweaveModule = getDefaultExportFromCjs(web);
var DEFAULT_OTHENT_CONFIG = {
  debug: false,
  inject: false,
  auth0Domain: "auth.othent.io",
  auth0ClientId: "uXkRmJoIa0NfzYgYEDAgj6Rss4wR1tIc",
  auth0Strategy: "refresh-tokens",
  auth0Cache: "memory",
  auth0RefreshTokenExpirationMs: 1296e6,
  // 2 weeks
  auth0LogInMethod: "popup",
  auth0RedirectURI: null,
  auth0ReturnToURI: null,
  serverBaseURL: "https://kms-server.othent.io",
  autoConnect: "lazy",
  cookieKey: null,
  localStorageKey: null,
  throwErrors: true,
  tags: []
};
var DEFAULT_APP_INFO = { name: "", version: "", env: typeof location === "undefined" ? "production" : location.hostname === "localhost" ? "development" : "production" };
var DEFAULT_GATEWAY_CONFIG = { host: "arweave.net", protocol: "https", port: 443 };
var DEFAULT_OTHENT_OPTIONS = _objectSpread(_objectSpread({}, DEFAULT_OTHENT_CONFIG), {}, { appInfo: DEFAULT_APP_INFO, gatewayConfig: DEFAULT_GATEWAY_CONFIG, persistCookie: false, persistLocalStorage: false, auth0Cache: "memory" });
var DEFAULT_DISPATCH_NODE = "https://turbo.ardrive.io";
var DEFAULT_COOKIE_KEY = "othentUserDetails";
var CLIENT_NAME = "Othent KMS";
var CLIENT_VERSION = "2.1.1";
var ANALYTICS_TAGS = [{ name: "Client", value: CLIENT_NAME }, { name: "Client-Version", value: CLIENT_VERSION }];
var EventListenersHandler = function() {
  function EventListenersHandler2(options) {
    _classCallCheck2(this, EventListenersHandler2);
    this.listeners = /* @__PURE__ */ new Set();
    this.initializedListeners = /* @__PURE__ */ new Set();
    this.lastEmittedUpdateId = "";
    this.lastEmittedParams = null;
    this.options = { diffParams: false, replyOnListen: false };
    this.options = _objectSpread(_objectSpread({}, this.options), options);
  }
  return _createClass(EventListenersHandler2, [{ key: "getUpdateId", value: function getUpdateId(parameters) {
    var serializer = function serializer2(_, value) {
      return value && value === "oject" && !Array.isArray(value) ? Object.entries(value).sort(function(a2, b3) {
        return a2[0].localeCompare(b3[0]);
      }) : value;
    };
    var getUpdateIdTransform = this.options.getUpdateIdTransform;
    var transformedParameters = getUpdateIdTransform ? getUpdateIdTransform(parameters) : parameters;
    return JSON.stringify(transformedParameters, serializer);
  } }, { key: "hasListeners", get: function get5() {
    return this.listeners.size > 0;
  } }, { key: "add", value: function add2(listener) {
    this.listeners.add(listener);
    if (this.options.replyOnListen && this.lastEmittedParams)
      this.emit.apply(this, _toConsumableArray(this.lastEmittedParams));
  } }, { key: "delete", value: function _delete(listener) {
    this.listeners.add(listener);
  } }, { key: "emit", value: function emit2() {
    for (var _len17 = arguments.length, parameters = new Array(_len17), _key23 = 0; _key23 < _len17; _key23++) {
      parameters[_key23] = arguments[_key23];
    }
    var initializedListeners = this.initializedListeners, lastEmittedUpdateId = this.lastEmittedUpdateId;
    var updateId = this.getUpdateId(parameters);
    var updatedAlreadyEmitted = lastEmittedUpdateId === updateId;
    this.lastEmittedUpdateId = updateId;
    this.lastEmittedParams = parameters;
    this.listeners.forEach(function(listenerFn) {
      if (updatedAlreadyEmitted && initializedListeners.has(listenerFn))
        return;
      initializedListeners.add(listenerFn);
      try {
        listenerFn.apply(void 0, parameters);
      } catch (err) {
      }
    });
    return updatedAlreadyEmitted;
  } }]);
}();
function mergeOptions(options, defaults2) {
  return extend$2(true, {}, defaults2, options);
}
var DEFAULT_COOKIE_OPTIONS = { secure: true, domain: true, ttlHours: 360 };
var _CookieStorage = function() {
  function _CookieStorage2() {
    var cookieOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DEFAULT_COOKIE_OPTIONS;
    _classCallCheck2(this, _CookieStorage2);
    this.secureParam = null;
    this.domainParam = null;
    this.ttlMs = 1296e6;
    var _this$parseCookieOpti = this.parseCookieOptions(mergeOptions(cookieOptions, DEFAULT_COOKIE_OPTIONS)), secureParam = _this$parseCookieOpti.secureParam, domainParam = _this$parseCookieOpti.domainParam, ttlMs = _this$parseCookieOpti.ttlMs;
    this.secureParam = secureParam;
    this.domainParam = domainParam;
    this.ttlMs = ttlMs;
    return new Proxy(this, { get: function get5(target, prop) {
      return prop in target || typeof prop !== "string" ? target[prop] : target.getItem(prop);
    }, ownKeys: function ownKeys2(target) {
      return document.cookie.split(_CookieStorage2.COOKIE_SEPARATOR).map(function(cookieStr) {
        return cookieStr.split(_CookieStorage2.COOKIE_VALUE_SEPARATOR)[0];
      });
    }, getOwnPropertyDescriptor: function getOwnPropertyDescriptor() {
      return { enumerable: true, configurable: true };
    } });
  }
  return _createClass(_CookieStorage2, [{ key: "parseCookieOptions", value: function parseCookieOptions() {
    var _ref91 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, secure = _ref91.secure, domain = _ref91.domain, ttlHours = _ref91.ttlHours;
    var secureParam = secure ? "secure" : secure === void 0 ? this.secureParam : null;
    var domainParam = domain ? "domain=".concat(domain === true ? location.host : domain) : domain === void 0 ? this.domainParam : null;
    var ttlMs = ttlHours ? ttlHours * 36e5 : ttlHours === void 0 ? this.ttlMs : 0;
    return { secureParam, domainParam, ttlMs };
  } }, { key: "getCookieParams", value: function getCookieParams(cookieOptions) {
    var _this$parseCookieOpti2 = this.parseCookieOptions(cookieOptions), secureParam = _this$parseCookieOpti2.secureParam, domainParam = _this$parseCookieOpti2.domainParam, ttlMs = _this$parseCookieOpti2.ttlMs;
    var expirationDate = new Date(Date.now() + ttlMs);
    var expiresParam = "expires=".concat(expirationDate.toUTCString());
    var pathParam = "path=/";
    var cookieParams = [expiresParam, secureParam, domainParam, pathParam].filter(Boolean).join("; ");
    return cookieParams ? " ".concat(cookieParams, ";") : "";
  } }, { key: "length", get: function get5() {
    return document.cookie ? document.cookie.split(_CookieStorage2.COOKIE_SEPARATOR).length : 0;
  } }, { key: "key", value: function key3(index) {
    var cookieStrAtIndex = document.cookie.split(_CookieStorage2.COOKIE_SEPARATOR)[index] || "";
    var cookieKey = cookieStrAtIndex.split(_CookieStorage2.COOKIE_VALUE_SEPARATOR)[0];
    return cookieKey || null;
  } }, { key: "getItem", value: function getItem(name2) {
    var targetCookie = document.cookie.split(_CookieStorage2.COOKIE_SEPARATOR).find(function(item) {
      return item.split(_CookieStorage2.COOKIE_VALUE_SEPARATOR)[0] === name2;
    });
    return targetCookie && targetCookie.split(_CookieStorage2.COOKIE_VALUE_SEPARATOR)[1] || null;
  } }, { key: "setItem", value: function setItem(key3, value, cookieOptions) {
    var serializedValue = typeof value === "string" ? value : JSON.stringify(value);
    var cookieParams = this.getCookieParams(cookieOptions);
    if (true) {
      var actionLabel = ((cookieOptions == null ? void 0 : cookieOptions.ttlHours) || 1) < 0 ? "Removing" : "Setting";
      console.info("".concat(actionLabel, " cookie ").concat(key3, "=<VALUE>;").concat(cookieParams));
    }
    var cookieStr = "".concat(key3, "=").concat(serializedValue, ";").concat(cookieParams);
    document.cookie = cookieStr;
    return cookieStr;
  } }, { key: "removeItem", value: function removeItem(key3, cookieOptions) {
    return this.setItem(key3, "", _objectSpread(_objectSpread({}, cookieOptions), {}, { ttlHours: -1 }));
  } }, { key: "clear", value: function clear() {
    var _this33 = this;
    document.cookie.split(_CookieStorage2.COOKIE_SEPARATOR).forEach(function(item) {
      _this33.removeItem(item.split(_CookieStorage2.COOKIE_VALUE_SEPARATOR)[0]);
    });
  } }]);
}();
_CookieStorage.COOKIE_SEPARATOR = /\s*;\s*/;
_CookieStorage.COOKIE_VALUE_SEPARATOR = /\s*=\s*/;
var CookieStorage = _CookieStorage;
var cookieStorage = null;
function getCookieStorage() {
  if (!cookieStorage) {
    var hostname = typeof location === "undefined" ? "" : location.hostname;
    var isDevelopment = hostname === "localhost";
    cookieStorage = new CookieStorage({ secure: !isDevelopment, domain: isDevelopment ? void 0 : hostname });
  }
  return cookieStorage;
}
function getAnsProfile(_x253) {
  return _getAnsProfile.apply(this, arguments);
}
function _getAnsProfile() {
  _getAnsProfile = _asyncToGenerator(_regeneratorRuntime().mark(function _callee228(address) {
    var response, balances, balanceMatch, domain;
    return _regeneratorRuntime().wrap(function _callee228$(_context230) {
      while (1)
        switch (_context230.prev = _context230.next) {
          case 0:
            _context230.prev = 0;
            _context230.next = 3;
            return axios3.get("https://api.mem.tech/api/state/Tih8T1uESATJNzdwBIY3rpe25kWTzjw8uNiMRYe9I5M", {
              // Because this will return the whole contract's state, it could get quite large in the future. Therefore, we set
              // a timeout of 2 seconds to make sure this request doesn't slow down the SDK due to the big download size.
              timeout: 2e3
            });
          case 3:
            response = _context230.sent;
            balances = response.data.balances || [];
            balanceMatch = balances.find(function(balance) {
              return balance.address === address;
            });
            domain = balanceMatch ? balanceMatch.primary_domain || balanceMatch.ownedDomains[0].domain || null : null;
            return _context230.abrupt("return", domain ? "".concat(domain, ".ar") : null);
          case 10:
            _context230.prev = 10;
            _context230.t0 = _context230["catch"](0);
            console.warn("Error resolving ANS domain for ".concat(address, " =\n"), _context230.t0);
            return _context230.abrupt("return", null);
          case 14:
          case "end":
            return _context230.stop();
        }
    }, _callee228, null, [[0, 10]]);
  }));
  return _getAnsProfile.apply(this, arguments);
}
var PROVIDER_LABELS = {
  apple: "Apple",
  auth0: "E-Mail",
  "google-oauth2": "Google",
  // TODO: Complete these values:
  "<Twitch>": "Twitch",
  twitter: "X",
  "<Meta>": "Meta",
  "<LinkedIn>": "LinkedIn",
  github: "GitHub"
};
var CRYPTO_OPERATION_BINARY_DATA_KEYS = ["wrappedSignKey", "wrappedEncryptDecryptKey", "data", "plaintext", "ciphertext"];
function binaryDataTypeToUint8Array(buffer2) {
  if (buffer2 instanceof Buffer || buffer2 instanceof DataView || ArrayBuffer.isView(buffer2)) {
    return new Uint8Array(buffer2.buffer);
  } else if (buffer2 instanceof ArrayBuffer) {
    return new Uint8Array(buffer2);
  }
  throw new Error("Unknown buffer type.");
}
function binaryDataTypeTob64Url(buffer2) {
  return uint8ArrayTob64Url(binaryDataTypeToUint8Array(buffer2));
}
function binaryDataTypeOrStringTob64String(source) {
  return typeof source === "string" ? stringTob64Url(source) : binaryDataTypeTob64Url(source);
}
function binaryDataTypeOrStringToBinaryDataType(source) {
  return typeof source === "string" ? stringToUint8Array(source) : source;
}
function stringTob64Url(str) {
  return uint8ArrayTob64Url(stringToUint8Array(str));
}
function stringToUint8Array(str) {
  return new TextEncoder().encode(str);
}
function uint8ArrayTob64(buffer2) {
  return fromByteArray_1(new Uint8Array(buffer2));
}
function uint8ArrayTob64Url(buffer2) {
  return b64UrlEncode(uint8ArrayTob64(buffer2));
}
function b64ToUint8Array(str) {
  return toByteArray_1(b64UrlDecode(str));
}
function b64UrlEncode(str) {
  return str.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
}
function b64UrlDecode(str) {
  var padding = str.length % 4 == 0 ? 0 : 4 - str.length % 4;
  return str.replace(/\-/g, "+").replace(/\_/g, "/").concat("=".repeat(padding));
}
function hash(_x254) {
  return _hash12.apply(this, arguments);
}
function _hash12() {
  _hash12 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee229(data) {
    var algorithm, digest11, _args148 = arguments;
    return _regeneratorRuntime().wrap(function _callee229$(_context231) {
      while (1)
        switch (_context231.prev = _context231.next) {
          case 0:
            algorithm = _args148.length > 1 && _args148[1] !== void 0 ? _args148[1] : "SHA-256";
            _context231.next = 3;
            return crypto.subtle.digest(algorithm, data);
          case 3:
            digest11 = _context231.sent;
            return _context231.abrupt("return", new Uint8Array(digest11));
          case 5:
          case "end":
            return _context231.stop();
        }
    }, _callee229);
  }));
  return _hash12.apply(this, arguments);
}
function transactionInputReplacer(key3, value) {
  if (!CRYPTO_OPERATION_BINARY_DATA_KEYS.includes(key3))
    return value;
  if (key3 === "data" && value.hasOwnProperty("path"))
    return value;
  return binaryDataTypeOrStringTob64String(value);
}
var OthentErrorID = function(OthentErrorID2) {
  OthentErrorID2["Unexpected"] = "Unexpected";
  OthentErrorID2["Validation"] = "Validation";
  OthentErrorID2["UserCreation"] = "UserCreation";
  OthentErrorID2["Encryption"] = "Encryption";
  OthentErrorID2["Decryption"] = "Decryption";
  OthentErrorID2["Signing"] = "Signing";
  OthentErrorID2["PublicKey"] = "PublicKey";
  return OthentErrorID2;
}(OthentErrorID || {});
var OthentError = function(_Error4) {
  function OthentError2(id, developerMessage, error3) {
    var _this34;
    var fromServer = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    _classCallCheck2(this, OthentError2);
    _this34 = _callSuper(this, OthentError2);
    _this34.name = id;
    _this34.message = developerMessage || "";
    if (fromServer) {
      _this34.stack = "".concat(id, " (from server): ").concat(developerMessage, "\n");
    } else {
      Error.captureStackTrace(_this34);
    }
    _this34.id = id;
    _this34.developerMessage = developerMessage;
    if (error3 instanceof Error) {
      _this34.cause = error3;
    } else if (typeof error3 === "string" || typeof error3 === "number") {
      _this34.cause = new Error("".concat(error3));
    }
    return _this34;
  }
  _inherits2(OthentError2, _Error4);
  return _createClass(OthentError2);
}(_wrapNativeSuper(Error));
function isErrorResponseData(data) {
  return _typeof(data) === "object" && data.error === true && !!data.id && !!OthentErrorID[data.id];
}
function parseErrorResponse(error3) {
  var _a;
  if (isAxiosError(error3)) {
    var data = (_a = error3.response) == null ? void 0 : _a.data;
    if (!isErrorResponseData(data)) {
      return error3;
    }
    var id = data.id, developerMessage = data.developerMessage, cause = data.cause;
    var causeError;
    if (cause) {
      causeError = new Error(cause.message);
      causeError.name = cause.name;
      causeError.stack = cause.stack;
    }
    return new OthentError(id, developerMessage || "", causeError, true);
  }
  if (error3 instanceof Error) {
    return error3;
  }
  return new Error("Unknown error");
}
function isPromise(obj2) {
  return !!obj2 && (_typeof(obj2) === "object" || typeof obj2 === "function") && typeof obj2.then === "function";
}
function pemToUint8Array(pem2) {
  var pemBufferString = pem2.replaceAll("\n", "").replace("-----BEGIN PUBLIC KEY-----", "").replace("-----END PUBLIC KEY-----", "");
  return b64ToUint8Array(pemBufferString);
}
var OthentAuth0Client = function() {
  function _OthentAuth0Client(_ref92) {
    var _this35 = this;
    var debug = _ref92.debug, domain = _ref92.domain, clientId = _ref92.clientId, strategy = _ref92.strategy, cache = _ref92.cache, loginMethod = _ref92.loginMethod, redirectURI = _ref92.redirectURI, returnToURI = _ref92.returnToURI, refreshTokenExpirationMs = _ref92.refreshTokenExpirationMs, appInfo = _ref92.appInfo, initialUserDetails = _ref92.initialUserDetails, cookieKey = _ref92.cookieKey, localStorageKey = _ref92.localStorageKey;
    _classCallCheck2(this, _OthentAuth0Client);
    this.debug = false;
    this.overriddenPublicKey = null;
    this.auth0ClientPromise = Promise.resolve(null);
    this.authEventListenerHandler = new EventListenersHandler({ diffParams: true, replyOnListen: true });
    this.userDetails = null;
    this.userDetailsExpirationTimeoutID = 0;
    this.cookieKey = null;
    this.localStorageKey = null;
    this.refreshTokenExpirationMs = +DEFAULT_OTHENT_CONFIG.auth0RefreshTokenExpirationMs;
    this.appInfo = DEFAULT_APP_INFO;
    this.isReady = false;
    this.isAuthenticated = false;
    this.debug = debug;
    this.loginMethod = loginMethod;
    this.redirectURI = redirectURI;
    this.returnToURI = returnToURI;
    this.auth0ClientPromise = oe({ domain, clientId, useRefreshTokens: strategy === "refresh-tokens", cacheLocation: typeof cache === "string" ? cache : void 0, cache: _typeof(cache) === "object" ? cache : void 0, authorizationParams: {
      redirect_uri: this.redirectURI
      // scope: "openid profile email offline_access"
      // audience
    } }).then(function(Auth0Client2) {
      _this35.isReady = true;
      return Auth0Client2;
    });
    this.cookieKey = cookieKey;
    this.localStorageKey = localStorageKey;
    this.refreshTokenExpirationMs = refreshTokenExpirationMs;
    this.appInfo = appInfo;
    this.restoreUserDetails(initialUserDetails || null);
    this.handleStorage = this.handleStorage.bind(this);
  }
  return _createClass(_OthentAuth0Client, [{
    key: "getUserDetails",
    value: function() {
      var _getUserDetails = _asyncToGenerator(_regeneratorRuntime().mark(function _callee174(idToken) {
        var _idToken$email, email, _idToken$nickname, nickname, walletAddress, sub, authProvider, walletAddressLabel, providerLabel;
        return _regeneratorRuntime().wrap(function _callee174$(_context175) {
          while (1)
            switch (_context175.prev = _context175.next) {
              case 0:
                _idToken$email = idToken.email, email = _idToken$email === void 0 ? "" : _idToken$email, _idToken$nickname = idToken.nickname, nickname = _idToken$nickname === void 0 ? "" : _idToken$nickname, walletAddress = idToken.walletAddress;
                sub = idToken.sub || "";
                authProvider = sub.split("|")[0];
                _context175.next = 5;
                return getAnsProfile(walletAddress);
              case 5:
                walletAddressLabel = _context175.sent;
                if (!walletAddressLabel) {
                  providerLabel = PROVIDER_LABELS[authProvider] || "Unknown Provider";
                  walletAddressLabel = "".concat(providerLabel, " (").concat(email || (nickname ? "@".concat(nickname) : ""), ")");
                }
                return _context175.abrupt("return", { sub, name: idToken.name || "", givenName: idToken.given_name || "", middleName: idToken.middle_name || "", familyName: idToken.family_name || "", nickname: idToken.nickname || "", preferredUsername: idToken.preferred_username || "", profile: idToken.profile || "", picture: idToken.picture || "", website: idToken.website || "", locale: idToken.locale || "", updatedAt: idToken.updated_at || "", email, emailVerified: !!idToken.email_verified, owner: this.overriddenPublicKey || idToken.owner, walletAddress: idToken.walletAddress, walletAddressLabel, authSystem: idToken.authSystem, authProvider });
              case 8:
              case "end":
                return _context175.stop();
            }
        }, _callee174, this);
      }));
      function getUserDetails(_x255) {
        return _getUserDetails.apply(this, arguments);
      }
      return getUserDetails;
    }()
    // Getters / Setters:
  }, { key: "getAuthEventListenerHandler", value: function getAuthEventListenerHandler() {
    return this.authEventListenerHandler;
  } }, {
    key: "setAppInfo",
    value: function setAppInfo(appInfo) {
      this.appInfo = appInfo;
    }
    // Storage listeners:
  }, { key: "initStorageSyncing", value: function initStorageSyncing() {
    if (!this.localStorageKey || typeof window === "undefined")
      return;
    window.addEventListener("storage", this.handleStorage);
  } }, { key: "stopStorageSyncing", value: function stopStorageSyncing() {
    if (typeof window === "undefined")
      return;
    window.removeEventListener("storage", this.handleStorage);
  } }, { key: "handleStorage", value: function handleStorage(event) {
    if (event.key !== this.localStorageKey)
      return;
    if (event.newValue) {
      this.restoreUserDetails();
    } else {
      this.logOut();
    }
  } }, {
    key: "persistUserDetails",
    value: function persistUserDetails(userDetails) {
      var cookieKey = this.cookieKey, localStorageKey = this.localStorageKey;
      if (cookieKey) {
        var cookieStorage2 = getCookieStorage();
        if (userDetails) {
          cookieStorage2.setItem(cookieKey, JSON.stringify(userDetails), { ttlHours: this.refreshTokenExpirationMs / 36e5 });
        } else if (cookieStorage2.getItem(cookieKey) !== null) {
          cookieStorage2.removeItem(cookieKey);
        }
      }
      if (localStorageKey) {
        if (userDetails) {
          var now = /* @__PURE__ */ new Date();
          var serializedUserDetails = JSON.stringify({ userDetails, createdAt: now.toUTCString(), expiredBy: new Date(now.getTime() + this.refreshTokenExpirationMs).toUTCString() });
          localStorage.setItem(localStorageKey, serializedUserDetails);
        } else {
          this.clearStoredUserDetails();
        }
      }
    }
    // `userDetails` setters:
  }, { key: "setUserDetails", value: function setUserDetails(userDetails) {
    var updateAuth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    if (typeof window !== "undefined") {
      window.clearTimeout(this.userDetailsExpirationTimeoutID);
      if (userDetails) {
        this.userDetailsExpirationTimeoutID = window.setTimeout(this.logOut, this.refreshTokenExpirationMs);
      }
    }
    var updatedAlreadyEmitted = this.authEventListenerHandler.emit(userDetails, updateAuth ? !!userDetails : this.isAuthenticated);
    if (!updatedAlreadyEmitted) {
      this.userDetails = userDetails;
    }
    if (updateAuth) {
      this.isAuthenticated = !!userDetails;
      this.persistUserDetails(userDetails);
    }
    return userDetails;
  } }, { key: "restoreUserDetails", value: function restoreUserDetails(userDetails) {
    var initialUserDetails = userDetails || null;
    if (!initialUserDetails && this.localStorageKey) {
      try {
        var storedUserDetails = JSON.parse(localStorage.getItem(this.localStorageKey) || "null");
        if (storedUserDetails) {
          var expiredBy = new Date(storedUserDetails.expiredBy).getTime();
          if (!isNaN(expiredBy) && expiredBy > Date.now()) {
            initialUserDetails = storedUserDetails.userDetails;
          } else {
            this.clearStoredUserDetails();
          }
        }
      } catch (err) {
      }
    }
    this.setUserDetails(initialUserDetails, false);
  } }, { key: "clearStoredUserDetails", value: function clearStoredUserDetails() {
    Object.keys(localStorage).forEach(function(key3) {
      if (key3.startsWith("othent"))
        localStorage.removeItem(key3);
    });
  } }, { key: "updateUserDetails", value: function() {
    var _updateUserDetails = _asyncToGenerator(_regeneratorRuntime().mark(function _callee175(idToken) {
      var nextUserDetails;
      return _regeneratorRuntime().wrap(function _callee175$(_context176) {
        while (1)
          switch (_context176.prev = _context176.next) {
            case 0:
              if (!(idToken && _OthentAuth0Client.isIdTokenValidUser(idToken))) {
                _context176.next = 6;
                break;
              }
              _context176.next = 3;
              return this.getUserDetails(idToken);
            case 3:
              _context176.t0 = _context176.sent;
              _context176.next = 7;
              break;
            case 6:
              _context176.t0 = null;
            case 7:
              nextUserDetails = _context176.t0;
              return _context176.abrupt("return", this.setUserDetails(nextUserDetails));
            case 9:
            case "end":
              return _context176.stop();
          }
      }, _callee175, this);
    }));
    function updateUserDetails(_x256) {
      return _updateUserDetails.apply(this, arguments);
    }
    return updateUserDetails;
  }() }, {
    key: "getAuthorizationParams",
    value: function getAuthorizationParams() {
      var authorizationParamsOrData = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var _ref93 = authorizationParamsOrData.hasOwnProperty("path") ? { authorizationParams: null, data: authorizationParamsOrData } : { authorizationParams: authorizationParamsOrData, data: null }, authorizationParams = _ref93.authorizationParams, data = _ref93.data;
      var appInfo = this.appInfo;
      var transactionInput = { othentFunction: "KMS", othentSDKVersion: CLIENT_NAME, othentAPIVersion: CLIENT_VERSION, appName: appInfo.name, appVersion: appInfo.version, appEnv: appInfo.env };
      if (data) {
        transactionInput.data = data;
      }
      return _objectSpread(_objectSpread({}, authorizationParams), {}, { transaction_input: JSON.stringify(transactionInput, transactionInputReplacer) });
    }
    // Wrappers around Auth0's native client with some additional functionality:
  }, { key: "getTokenSilently", value: function() {
    var _getTokenSilently4 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee176(data) {
      var auth0Client, authorizationParams, parsedTransactionInput, getTokenSilentlyResponse, idToken, userDetails;
      return _regeneratorRuntime().wrap(function _callee176$(_context177) {
        while (1)
          switch (_context177.prev = _context177.next) {
            case 0:
              _context177.next = 2;
              return this.auth0ClientPromise;
            case 2:
              auth0Client = _context177.sent;
              if (auth0Client) {
                _context177.next = 5;
                break;
              }
              throw new Error("Missing Auth0 Client");
            case 5:
              authorizationParams = this.getAuthorizationParams(data);
              if (this.debug) {
                try {
                  parsedTransactionInput = JSON.parse(authorizationParams.transaction_input);
                  if (Object.keys(authorizationParams).length === 1 && Object.keys(authorizationParams)[0] === "transaction_input") {
                    console.log("getTokenSilently().transaction_input =", parsedTransactionInput);
                  } else {
                    console.log("getTokenSilently() =", _objectSpread(_objectSpread({}, authorizationParams), {}, { transaction_input: parsedTransactionInput }));
                  }
                } catch (err) {
                  console.error("Error logging/parsing `authorizationParams`:", err);
                }
              }
              _context177.prev = 7;
              _context177.next = 10;
              return auth0Client.getTokenSilently({
                detailedResponse: true,
                authorizationParams,
                cacheMode: "off"
                // Forces the client to get a new token, as we actually include data in them, it cannot be done any other way.
              });
            case 10:
              getTokenSilentlyResponse = _context177.sent;
              _context177.next = 13;
              return auth0Client.getUser();
            case 13:
              idToken = _context177.sent;
              if (idToken) {
                _context177.next = 16;
                break;
              }
              throw new Error("Could not get the user's details");
            case 16:
              _context177.next = 18;
              return this.updateUserDetails(idToken);
            case 18:
              userDetails = _context177.sent;
              return _context177.abrupt("return", _objectSpread(_objectSpread({}, getTokenSilentlyResponse), {}, { idToken, userDetails }));
            case 22:
              _context177.prev = 22;
              _context177.t0 = _context177["catch"](7);
              throw _context177.t0;
            case 25:
            case "end":
              return _context177.stop();
          }
      }, _callee176, this, [[7, 22]]);
    }));
    function getTokenSilently(_x257) {
      return _getTokenSilently4.apply(this, arguments);
    }
    return getTokenSilently;
  }() }, { key: "logIn", value: function() {
    var _logIn = _asyncToGenerator(_regeneratorRuntime().mark(function _callee177() {
      var auth0Client, isAuthenticated, authorizationParams;
      return _regeneratorRuntime().wrap(function _callee177$(_context178) {
        while (1)
          switch (_context178.prev = _context178.next) {
            case 0:
              _context178.next = 2;
              return this.auth0ClientPromise;
            case 2:
              auth0Client = _context178.sent;
              if (auth0Client) {
                _context178.next = 5;
                break;
              }
              throw new Error("Missing Auth0 Client");
            case 5:
              if (this.debug)
                console.log("logIn()");
              _context178.next = 8;
              return auth0Client.isAuthenticated();
            case 8:
              isAuthenticated = _context178.sent;
              if (!isAuthenticated) {
                _context178.next = 11;
                break;
              }
              throw new Error("Already logged in");
            case 11:
              authorizationParams = this.getAuthorizationParams({
                redirect_uri: this.redirectURI
                // TODO: This doesn't seem to change anything. It could be used to remember the last provider the user used.
                // connection: "auth0",
              });
              if (!(this.loginMethod === "popup")) {
                _context178.next = 17;
                break;
              }
              _context178.next = 15;
              return auth0Client.loginWithPopup({ authorizationParams }, {
                // { popup: <POPUP> } // This might be useful to provide an already-created popup in platforms like iOS.
              });
            case 15:
              _context178.next = 19;
              break;
            case 17:
              auth0Client.loginWithRedirect({
                authorizationParams
                // openUrl(url) { }, // This might be useful to control the redirect in mobile platforms.
              });
              throw new Error("Redirecting...");
            case 19:
              return _context178.abrupt("return", this.getTokenSilently());
            case 20:
            case "end":
              return _context178.stop();
          }
      }, _callee177, this);
    }));
    function logIn() {
      return _logIn.apply(this, arguments);
    }
    return logIn;
  }() }, { key: "handleRedirectCallback", value: function() {
    var _handleRedirectCallback2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee178(callbackUrlWithParams) {
      var auth0Client, idToken, userDetails;
      return _regeneratorRuntime().wrap(function _callee178$(_context179) {
        while (1)
          switch (_context179.prev = _context179.next) {
            case 0:
              if (this.debug)
                console.log("handleRedirectCallback(".concat(callbackUrlWithParams, ")"));
              _context179.next = 3;
              return this.auth0ClientPromise;
            case 3:
              auth0Client = _context179.sent;
              if (auth0Client) {
                _context179.next = 6;
                break;
              }
              throw new Error("Missing Auth0 Client");
            case 6:
              _context179.next = 8;
              return auth0Client.handleRedirectCallback(callbackUrlWithParams);
            case 8:
              _context179.next = 10;
              return auth0Client.getUser();
            case 10:
              _context179.t0 = _context179.sent;
              if (_context179.t0) {
                _context179.next = 13;
                break;
              }
              _context179.t0 = null;
            case 13:
              idToken = _context179.t0;
              _context179.next = 16;
              return this.updateUserDetails(idToken);
            case 16:
              userDetails = _context179.sent;
              return _context179.abrupt("return", { idToken, userDetails });
            case 18:
            case "end":
              return _context179.stop();
          }
      }, _callee178, this);
    }));
    function handleRedirectCallback(_x258) {
      return _handleRedirectCallback2.apply(this, arguments);
    }
    return handleRedirectCallback;
  }() }, { key: "logOut", value: function() {
    var _logOut = _asyncToGenerator(_regeneratorRuntime().mark(function _callee179() {
      var auth0Client;
      return _regeneratorRuntime().wrap(function _callee179$(_context180) {
        while (1)
          switch (_context180.prev = _context180.next) {
            case 0:
              this.setUserDetails(null);
              _context180.next = 3;
              return this.auth0ClientPromise;
            case 3:
              auth0Client = _context180.sent;
              if (auth0Client) {
                _context180.next = 6;
                break;
              }
              throw new Error("Missing Auth0 Client");
            case 6:
              return _context180.abrupt("return", auth0Client.logout({ logoutParams: { returnTo: this.returnToURI } }).catch(function(err) {
                console.warn(err instanceof Error ? err.message : err);
                if (typeof location !== "undefined")
                  location.reload();
              }));
            case 7:
            case "end":
              return _context180.stop();
          }
      }, _callee179, this);
    }));
    function logOut() {
      return _logOut.apply(this, arguments);
    }
    return logOut;
  }() }, {
    key: "encodeToken",
    value: function() {
      var _encodeToken = _asyncToGenerator(_regeneratorRuntime().mark(function _callee180(data) {
        var accessToken;
        return _regeneratorRuntime().wrap(function _callee180$(_context181) {
          while (1)
            switch (_context181.prev = _context181.next) {
              case 0:
                _context181.next = 2;
                return this.getTokenSilently(data);
              case 2:
                accessToken = _context181.sent;
                return _context181.abrupt("return", accessToken.id_token);
              case 4:
              case "end":
                return _context181.stop();
            }
        }, _callee180, this);
      }));
      function encodeToken(_x259) {
        return _encodeToken.apply(this, arguments);
      }
      return encodeToken;
    }()
    // Getters for cached user data:
  }, { key: "getCachedUserDetails", value: function getCachedUserDetails() {
    return this.userDetails;
  } }, { key: "getCachedUserPublicKey", value: function getCachedUserPublicKey() {
    var _a;
    return ((_a = this.userDetails) == null ? void 0 : _a.owner) || null;
  } }, { key: "getCachedUserSub", value: function getCachedUserSub() {
    var _a;
    return ((_a = this.userDetails) == null ? void 0 : _a.sub) || null;
  } }, { key: "getCachedUserAddress", value: function getCachedUserAddress() {
    var _a;
    return ((_a = this.userDetails) == null ? void 0 : _a.walletAddress) || null;
  } }, { key: "getCachedUserAddressLabel", value: function getCachedUserAddressLabel() {
    var _a;
    return ((_a = this.userDetails) == null ? void 0 : _a.walletAddressLabel) || null;
  } }, {
    key: "getCachedUserEmail",
    value: function getCachedUserEmail() {
      var _a;
      return ((_a = this.userDetails) == null ? void 0 : _a.email) || null;
    }
    // DEVELOPMENT:
  }, { key: "overridePublicKey", value: function() {
    var _overridePublicKey = _asyncToGenerator(_regeneratorRuntime().mark(function _callee181(publicKeyPEM) {
      return _regeneratorRuntime().wrap(function _callee181$(_context182) {
        while (1)
          switch (_context182.prev = _context182.next) {
            case 0:
              this.overriddenPublicKey = uint8ArrayTob64Url(pemToUint8Array(publicKeyPEM));
            case 1:
            case "end":
              return _context182.stop();
          }
      }, _callee181, this);
    }));
    function overridePublicKey(_x260) {
      return _overridePublicKey.apply(this, arguments);
    }
    return overridePublicKey;
  }() }], [{ key: "isIdTokenValidUser", value: function isIdTokenValidUser(idToken) {
    return !!(idToken && idToken.sub && idToken.owner && idToken.walletAddress && idToken.authSystem === "KMS");
  } }]);
}();
function _createUser2(_x261, _x262, _x263) {
  return _createUser.apply(this, arguments);
}
function _createUser() {
  _createUser = _asyncToGenerator(_regeneratorRuntime().mark(function _callee230(api2, auth0, options) {
    var encodedData, idTokenWithData, createUserResponse;
    return _regeneratorRuntime().wrap(function _callee230$(_context232) {
      while (1)
        switch (_context232.prev = _context232.next) {
          case 0:
            _context232.next = 2;
            return auth0.encodeToken(_objectSpread({
              path: "/create-user"
              /* CREATE_USER */
            }, options));
          case 2:
            encodedData = _context232.sent;
            idTokenWithData = null;
            _context232.prev = 4;
            _context232.next = 7;
            return api2.post("/create-user", { encodedData });
          case 7:
            createUserResponse = _context232.sent;
            idTokenWithData = createUserResponse.data.idTokenWithData;
            _context232.next = 14;
            break;
          case 11:
            _context232.prev = 11;
            _context232.t0 = _context232["catch"](4);
            throw parseErrorResponse(_context232.t0);
          case 14:
            if (idTokenWithData) {
              _context232.next = 16;
              break;
            }
            throw new Error("Error creating user on server.");
          case 16:
            return _context232.abrupt("return", idTokenWithData);
          case 17:
          case "end":
            return _context232.stop();
        }
    }, _callee230, null, [[4, 11]]);
  }));
  return _createUser.apply(this, arguments);
}
function isLegacyBufferObject(legacyBufferData) {
  return !!legacyBufferData && _typeof(legacyBufferData) === "object" && legacyBufferData.type === "Buffer" && Array.isArray(legacyBufferData.data);
}
function normalizeBufferDataWithNull(data) {
  if (data === null || data === void 0)
    return null;
  if (typeof data === "string") {
    return b64ToUint8Array(data);
  }
  if (isLegacyBufferObject(data)) {
    return new Uint8Array(data.data);
  }
  return new Uint8Array(Object.values(data));
}
function _decrypt5(_x264, _x265, _x266) {
  return _decrypt4.apply(this, arguments);
}
function _decrypt4() {
  _decrypt4 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee231(api2, auth0, ciphertext) {
    var encodedData, decryptedData, decryptResponse;
    return _regeneratorRuntime().wrap(function _callee231$(_context233) {
      while (1)
        switch (_context233.prev = _context233.next) {
          case 0:
            _context233.next = 2;
            return auth0.encodeToken({ path: "/decrypt", ciphertext });
          case 2:
            encodedData = _context233.sent;
            decryptedData = null;
            _context233.prev = 4;
            _context233.next = 7;
            return api2.post("/decrypt", { encodedData });
          case 7:
            decryptResponse = _context233.sent;
            decryptedData = normalizeBufferDataWithNull(decryptResponse.data.decryptedData);
            _context233.next = 14;
            break;
          case 11:
            _context233.prev = 11;
            _context233.t0 = _context233["catch"](4);
            throw parseErrorResponse(_context233.t0);
          case 14:
            if (!(decryptedData === null)) {
              _context233.next = 16;
              break;
            }
            throw new Error("Error decrypting on server.");
          case 16:
            return _context233.abrupt("return", decryptedData);
          case 17:
          case "end":
            return _context233.stop();
        }
    }, _callee231, null, [[4, 11]]);
  }));
  return _decrypt4.apply(this, arguments);
}
function _encrypt5(_x267, _x268, _x269) {
  return _encrypt4.apply(this, arguments);
}
function _encrypt4() {
  _encrypt4 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee232(api2, auth0, plaintext) {
    var encodedData, encryptedData, encryptResponse;
    return _regeneratorRuntime().wrap(function _callee232$(_context234) {
      while (1)
        switch (_context234.prev = _context234.next) {
          case 0:
            _context234.next = 2;
            return auth0.encodeToken({ path: "/encrypt", plaintext });
          case 2:
            encodedData = _context234.sent;
            encryptedData = null;
            _context234.prev = 4;
            _context234.next = 7;
            return api2.post("/encrypt", { encodedData });
          case 7:
            encryptResponse = _context234.sent;
            encryptedData = normalizeBufferDataWithNull(encryptResponse.data.encryptedData);
            _context234.next = 14;
            break;
          case 11:
            _context234.prev = 11;
            _context234.t0 = _context234["catch"](4);
            throw parseErrorResponse(_context234.t0);
          case 14:
            if (!(encryptedData === null)) {
              _context234.next = 16;
              break;
            }
            throw new Error("Error encrypting on server.");
          case 16:
            return _context234.abrupt("return", encryptedData);
          case 17:
          case "end":
            return _context234.stop();
        }
    }, _callee232, null, [[4, 11]]);
  }));
  return _encrypt4.apply(this, arguments);
}
function _sign8(_x270, _x271, _x272) {
  return _sign7.apply(this, arguments);
}
function _sign7() {
  _sign7 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee233(api2, auth0, data) {
    var encodedData, signature2, signResponse;
    return _regeneratorRuntime().wrap(function _callee233$(_context235) {
      while (1)
        switch (_context235.prev = _context235.next) {
          case 0:
            _context235.next = 2;
            return auth0.encodeToken({ path: "/sign", data });
          case 2:
            encodedData = _context235.sent;
            signature2 = null;
            _context235.prev = 4;
            _context235.next = 7;
            return api2.post("/sign", { encodedData });
          case 7:
            signResponse = _context235.sent;
            signature2 = normalizeBufferDataWithNull(signResponse.data.signature);
            _context235.next = 14;
            break;
          case 11:
            _context235.prev = 11;
            _context235.t0 = _context235["catch"](4);
            throw parseErrorResponse(_context235.t0);
          case 14:
            if (!(signature2 === null)) {
              _context235.next = 16;
              break;
            }
            throw new Error("Error signing data on server.");
          case 16:
            return _context235.abrupt("return", signature2);
          case 17:
          case "end":
            return _context235.stop();
        }
    }, _callee233, null, [[4, 11]]);
  }));
  return _sign7.apply(this, arguments);
}
function _serverInfo2(_x273, _x274, _x275) {
  return _serverInfo.apply(this, arguments);
}
function _serverInfo() {
  _serverInfo = _asyncToGenerator(_regeneratorRuntime().mark(function _callee234(api2, auth0, options) {
    var encodedData, serverInfo2, serverInfoResponse;
    return _regeneratorRuntime().wrap(function _callee234$(_context236) {
      while (1)
        switch (_context236.prev = _context236.next) {
          case 0:
            if (!(options == null ? void 0 : options.includeToken)) {
              _context236.next = 6;
              break;
            }
            _context236.next = 3;
            return auth0.encodeToken();
          case 3:
            _context236.t0 = _context236.sent;
            _context236.next = 7;
            break;
          case 6:
            _context236.t0 = null;
          case 7:
            encodedData = _context236.t0;
            serverInfo2 = null;
            _context236.prev = 9;
            if (!encodedData) {
              _context236.next = 16;
              break;
            }
            _context236.next = 13;
            return api2.post("/", { encodedData });
          case 13:
            _context236.t1 = _context236.sent;
            _context236.next = 19;
            break;
          case 16:
            _context236.next = 18;
            return api2.get(
              "/"
              /* HOME */
            );
          case 18:
            _context236.t1 = _context236.sent;
          case 19:
            serverInfoResponse = _context236.t1;
            serverInfo2 = serverInfoResponse.data;
            _context236.next = 26;
            break;
          case 23:
            _context236.prev = 23;
            _context236.t2 = _context236["catch"](9);
            throw parseErrorResponse(_context236.t2);
          case 26:
            if (serverInfo2) {
              _context236.next = 28;
              break;
            }
            throw new Error("Error requesting the API status.");
          case 28:
            return _context236.abrupt("return", serverInfo2);
          case 29:
          case "end":
            return _context236.stop();
        }
    }, _callee234, null, [[9, 23]]);
  }));
  return _serverInfo.apply(this, arguments);
}
var OthentKMSClient = function() {
  function OthentKMSClient2(baseURL, auth0) {
    _classCallCheck2(this, OthentKMSClient2);
    this.api = axios3.create({ baseURL });
    this.auth0 = auth0;
  }
  return _createClass(OthentKMSClient2, [{ key: "serverInfo", value: function() {
    var _serverInfo3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee182(options) {
      return _regeneratorRuntime().wrap(function _callee182$(_context183) {
        while (1)
          switch (_context183.prev = _context183.next) {
            case 0:
              return _context183.abrupt("return", _serverInfo2(this.api, this.auth0, options));
            case 1:
            case "end":
              return _context183.stop();
          }
      }, _callee182, this);
    }));
    function serverInfo(_x276) {
      return _serverInfo3.apply(this, arguments);
    }
    return serverInfo;
  }() }, { key: "createUser", value: function() {
    var _createUser3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee183(options) {
      return _regeneratorRuntime().wrap(function _callee183$(_context184) {
        while (1)
          switch (_context184.prev = _context184.next) {
            case 0:
              return _context184.abrupt("return", _createUser2(this.api, this.auth0, options));
            case 1:
            case "end":
              return _context184.stop();
          }
      }, _callee183, this);
    }));
    function createUser(_x277) {
      return _createUser3.apply(this, arguments);
    }
    return createUser;
  }() }, { key: "decrypt", value: function() {
    var _decrypt6 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee184(ciphertext) {
      return _regeneratorRuntime().wrap(function _callee184$(_context185) {
        while (1)
          switch (_context185.prev = _context185.next) {
            case 0:
              return _context185.abrupt("return", _decrypt5(this.api, this.auth0, ciphertext));
            case 1:
            case "end":
              return _context185.stop();
          }
      }, _callee184, this);
    }));
    function decrypt(_x278) {
      return _decrypt6.apply(this, arguments);
    }
    return decrypt;
  }() }, { key: "encrypt", value: function() {
    var _encrypt6 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee185(plaintext) {
      return _regeneratorRuntime().wrap(function _callee185$(_context186) {
        while (1)
          switch (_context186.prev = _context186.next) {
            case 0:
              return _context186.abrupt("return", _encrypt5(this.api, this.auth0, plaintext));
            case 1:
            case "end":
              return _context186.stop();
          }
      }, _callee185, this);
    }));
    function encrypt(_x279) {
      return _encrypt6.apply(this, arguments);
    }
    return encrypt;
  }() }, { key: "sign", value: function() {
    var _sign9 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee186(data) {
      return _regeneratorRuntime().wrap(function _callee186$(_context187) {
        while (1)
          switch (_context187.prev = _context187.next) {
            case 0:
              return _context187.abrupt("return", _sign8(this.api, this.auth0, data));
            case 1:
            case "end":
              return _context187.stop();
          }
      }, _callee186, this);
    }));
    function sign(_x280) {
      return _sign9.apply(this, arguments);
    }
    return sign;
  }() }, { key: "getSignerSignFn", value: function getSignerSignFn() {
    var _this36 = this;
    return function() {
      var _ref94 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee187(data) {
        var signatureBuffer;
        return _regeneratorRuntime().wrap(function _callee187$(_context188) {
          while (1)
            switch (_context188.prev = _context188.next) {
              case 0:
                _context188.next = 2;
                return _this36.sign(data);
              case 2:
                signatureBuffer = _context188.sent;
                return _context188.abrupt("return", signatureBuffer);
              case 4:
              case "end":
                return _context188.stop();
            }
        }, _callee187);
      }));
      return function(_x281) {
        return _ref94.apply(this, arguments);
      };
    }();
  } }]);
}();
function padString(input) {
  var segmentLength = 4;
  var stringLength = input.length;
  var diff = stringLength % segmentLength;
  if (!diff) {
    return input;
  }
  var position = stringLength;
  var padLength = segmentLength - diff;
  var paddedStringLength = stringLength + padLength;
  var buffer2 = buffer$2.Buffer.alloc(paddedStringLength);
  buffer2.write(input);
  while (padLength--) {
    buffer2.write("=", position++);
  }
  return buffer2.toString();
}
function encode(input) {
  var encoding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "utf8";
  if (buffer$2.Buffer.isBuffer(input)) {
    return fromBase64(input.toString("base64"));
  }
  return fromBase64(buffer$2.Buffer.from(input, encoding).toString("base64"));
}
function decode(base64url2) {
  var encoding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "utf8";
  return buffer$2.Buffer.from(toBase64(base64url2), "base64").toString(encoding);
}
function toBase64(base64url2) {
  base64url2 = base64url2.toString();
  return padString(base64url2).replace(/\-/g, "+").replace(/_/g, "/");
}
function fromBase64(base642) {
  return base642.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function toBuffer(base64url2) {
  return buffer$2.Buffer.from(toBase64(base64url2), "base64");
}
var base64url = encode;
base64url.encode = encode;
base64url.decode = decode;
base64url.toBase64 = toBase64;
base64url.fromBase64 = fromBase64;
base64url.toBuffer = toBuffer;
function initArweave(apiConfig) {
  var ArweaveClass = ArweaveModule.hasOwnProperty("default") ? ArweaveModule.default : ArweaveModule;
  return ArweaveClass.init(apiConfig);
}
var _Othent = function() {
  function _Othent2() {
    var _this37 = this;
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DEFAULT_OTHENT_OPTIONS;
    _classCallCheck2(this, _Othent2);
    this.errorEventListenerHandler = new EventListenersHandler();
    this.tokens = /* @__PURE__ */ new Set();
    this.walletName = CLIENT_NAME;
    this.walletVersion = CLIENT_VERSION;
    this.config = DEFAULT_OTHENT_CONFIG;
    this.appInfo = DEFAULT_APP_INFO;
    this.gatewayConfig = DEFAULT_GATEWAY_CONFIG;
    if (!globalThis.Buffer) {
      globalThis.Buffer = buffer$2.Buffer;
      console.warn("`globalThis.Buffer` has been polyfilled for you. Note this could have side-effect and affect other libraries.");
    }
    var crypto2 = globalThis.crypto || null;
    if (!crypto2) {
      throw new Error("A Crypto module is needed for Othent to work. If your environment doesn't natively provide one, you should polyfill it.");
    }
    this.crypto = crypto2;
    var appInfo = options.appInfo, gatewayConfig = options.gatewayConfig, persistCookie = options.persistCookie, persistLocalStorage = options.persistLocalStorage, initialUserDetails = options.initialUserDetails, _options$auth0Cache = options.auth0Cache, auth0Cache = _options$auth0Cache === void 0 ? DEFAULT_OTHENT_CONFIG.auth0Cache : _options$auth0Cache, auth0RedirectURI = options.auth0RedirectURI, auth0ReturnToURI = options.auth0ReturnToURI, configOptions = _objectWithoutProperties(options, _excluded5);
    var defaultRedirectURI = typeof location === "undefined" ? null : location.origin;
    this.config = _objectSpread(_objectSpread({}, mergeOptions(configOptions, DEFAULT_OTHENT_CONFIG)), {}, { cookieKey: typeof persistCookie === "string" ? persistCookie : persistCookie ? DEFAULT_COOKIE_KEY : null, localStorageKey: typeof persistLocalStorage === "string" ? persistLocalStorage : persistLocalStorage ? DEFAULT_COOKIE_KEY : null, auth0Cache: _typeof(auth0Cache) === "object" ? "custom" : auth0Cache, auth0RedirectURI: auth0RedirectURI || defaultRedirectURI, auth0ReturnToURI: auth0ReturnToURI || defaultRedirectURI });
    this.setAppInfo(appInfo);
    this.setGatewayConfig(gatewayConfig);
    var config = this.config;
    var cookieKey = config.cookieKey, localStorageKey = config.localStorageKey;
    if (typeof cookieKey === "string" && !cookieKey.startsWith("othent")) {
      throw new Error('`persistCookie` / `cookieKey` must start with "othent".');
    }
    if (typeof localStorageKey === "string" && !localStorageKey.startsWith("othent")) {
      throw new Error('`persistLocalStorage` / `localStorageKey` must start with "othent".');
    }
    if (!config.auth0RedirectURI) {
      throw new Error("`auth0RedirectURI` is required.");
    }
    if (!config.auth0ReturnToURI) {
      throw new Error("`auth0ReturnToURI` is required.");
    }
    if (config.autoConnect === "eager" && config.auth0LogInMethod === "popup" && config.auth0Strategy === "refresh-tokens" && auth0Cache === "memory") {
      throw new Error('The browser cannot open the authentication modal automatically before an user interaction. Use `autoConnect = "lazy"` or change any of these other options: `auth0LogInMethod`, `auth0Strategy` or `auth0Cache`.');
    }
    this.auth0 = new OthentAuth0Client({ debug: config.debug, domain: config.auth0Domain, clientId: config.auth0ClientId, strategy: config.auth0Strategy, cache: auth0Cache, loginMethod: config.auth0LogInMethod, redirectURI: config.auth0RedirectURI, returnToURI: config.auth0ReturnToURI, refreshTokenExpirationMs: config.auth0RefreshTokenExpirationMs, appInfo: this.appInfo, initialUserDetails, cookieKey: config.cookieKey, localStorageKey: config.localStorageKey });
    if (config.autoConnect === "eager") {
      if (typeof location === "undefined") {
        this.connect();
      } else {
        var url = new URL(location.href);
        var searchParams = url.searchParams;
        if (!searchParams.has("code") && !searchParams.has("state")) {
          this.connect();
        }
      }
    }
    if (config.inject) {
      globalThis.arweaveWallet = this;
    }
    if (!config.throwErrors) {
      var walletMethods = ["connect", "disconnect", "getActiveAddress", "getActivePublicKey", "getAllAddresses", "getWalletNames", "getUserDetails", "getSyncActiveAddress", "getSyncActivePublicKey", "getSyncAllAddresses", "getSyncWalletNames", "getSyncUserDetails", "sign", "dispatch", "encrypt", "decrypt", "signature", "signDataItem", "signMessage", "verifyMessage", "privateHash", "getArweaveConfig", "getPermissions"];
      walletMethods.forEach(function(walletMethod) {
        var fn = _this37[walletMethod];
        if (typeof fn !== "function")
          return;
        fn = fn.bind(_this37);
        _this37[walletMethod] = function() {
          try {
            var result = fn.apply(void 0, arguments);
            if (isPromise(result)) {
              result = result.catch(function(err) {
                _this37.onError(err);
                return null;
              });
            }
            return result;
          } catch (err) {
            _this37.onError(err);
          }
          return null;
        };
      });
    }
    this.api = new OthentKMSClient(this.config.serverBaseURL, this.auth0);
  }
  return _createClass(_Othent2, [{
    key: "setAppInfo",
    value: function setAppInfo(appInfo) {
      var nextAppInfo = _objectSpread(_objectSpread({}, appInfo), {}, { env: appInfo.env || DEFAULT_APP_INFO.env });
      if (!nextAppInfo.name || !nextAppInfo.version || !nextAppInfo.env) {
        throw new Error("Incomplete `appInfo`: `name`, `version` and `env` are required.");
      }
      if (this.auth0)
        this.auth0.setAppInfo(nextAppInfo);
      return this.appInfo = nextAppInfo;
    }
    /**
    * @param appInfo Setter and validator for `gatewayConfig`.
    *
    * @returns `Othent.gatewayConfig`
    */
  }, {
    key: "setGatewayConfig",
    value: function setGatewayConfig(gatewayConfig) {
      var nextGatewayConfig = gatewayConfig || DEFAULT_GATEWAY_CONFIG;
      if (!nextGatewayConfig.host || !nextGatewayConfig.port || !nextGatewayConfig.protocol) {
        throw new Error("Incomplete `gatewayConfig`: `host`, `port` and `protocol` are required.");
      }
      return this.gatewayConfig = nextGatewayConfig;
    }
    /**
    * Start listening for `storage` events to sync user details across tabs. Only needed if `persistLocalStorage = true`.
    *
    * @returns A cleanup function that must be called whenever Othent needs to stop listening for `storage` events (e.g.
    * to be used in React's `useEffects`'s cleanup function).
    *
    * @see {@link https://docs.othent.io/js-sdk-api/start-tab-synching|startTabSynching() docs}
    */
  }, {
    key: "startTabSynching",
    value: function startTabSynching() {
      var _this38 = this;
      if (!this.config.localStorageKey) {
        console.warn("Calling `Othent.startTabSynching()` is a NOOP unless the `persistLocalStorage` option is used.");
      }
      this.auth0.initStorageSyncing();
      return function() {
        _this38.auth0.stopStorageSyncing();
      };
    }
    // ERROR EVENT / ERROR HANDLING:
  }, {
    key: "onError",
    value: function onError(error3) {
      if (!(error3 instanceof Error)) {
        console.warn("Unknown error type", error3);
        return;
      }
      if (this.errorEventListenerHandler.hasListeners) {
        this.errorEventListenerHandler.emit(error3);
      } else {
        console.warn("Unhandled unthrown error:\n", error3, '\nWhen using `throwErrors = false`, you must add at least one error event listener with `othent.addEventListener("error", () => { ... })`');
      }
    }
    /**
    * Add an event listener for the specific error type.
    *
    * @param type `"auth"` or `error`.
    * @param listener Function of type `AuthListener` or `ErrorListener`.
    *
    * @returns A cleanup function that will remove the error listener when called.
    *
    * @see {@link https://docs.othent.io/js-sdk-api/events|Events docs}
    */
  }, {
    key: "addEventListener",
    value: function addEventListener(type, listener) {
      var eventListenerHandler = null;
      if (type === "auth") {
        eventListenerHandler = this.auth0.getAuthEventListenerHandler();
      } else if (type === "error") {
        if (this.config.throwErrors)
          throw new Error("You can only listen for `error` events if `throwErrors = false`.");
        eventListenerHandler = this.errorEventListenerHandler;
      }
      if (!eventListenerHandler)
        throw new Error("Unknown event type");
      eventListenerHandler.add(listener);
      return function() {
        eventListenerHandler.delete(listener);
      };
    }
    /**
    * Remove an error listener of the specified error type.
    *
    * @param type `"auth"` or `error`.
    * @param listener Function of type `AuthListener` or `ErrorListener`.
    *
    * @see {@link https://docs.othent.io/js-sdk-api/events|Events docs}
    */
  }, {
    key: "removeEventListener",
    value: function removeEventListener(type, listener) {
      var eventListenerHandler = null;
      if (type === "auth") {
        eventListenerHandler = this.auth0.getAuthEventListenerHandler();
      } else if (type === "error") {
        eventListenerHandler = this.errorEventListenerHandler;
      }
      if (!eventListenerHandler)
        throw new Error("Unknown event type");
      eventListenerHandler.delete(listener);
    }
    // AUTH LOADING:
    /**
       * @returns `true` if the user is authenticated; `false` otherwise.
       *
       * @see {@link https://docs.othent.io/js-sdk-api/is-authenticated|isAuthenticated docs}
       */
  }, {
    key: "isAuthenticated",
    get: function get5() {
      return this.auth0.isAuthenticated;
    }
    /**
    * Automatically checks if the user is authenticated. If they are not, and...
    *
    * - `autoConnect === "eager"`: Prompts them to sign in/up again. It throws an error if authentication fails.
    * - `autoConnect === "lazy"`: Authenticates them automatically, either from an existing session or by prompting them
    *   to sign in/up again. It throws an error if authentication fails.
    * - `autoConnect === "off"`: It throws an error.
    *
    * @see {@link https://docs.othent.io/js-sdk-api/require-auth|requireAuth() docs}
    */
  }, {
    key: "requireAuth",
    value: function requireAuth() {
      return this.requireUserDataOrThrow().then(function() {
      });
    }
    /**
    * Automatically checks if the user is authenticated. If they are not, and...
    *
    * - `autoConnect === "eager"`: Prompts them to sign in/up again. It throws an error if authentication fails.
    * - `autoConnect === "lazy"`: Authenticates them automatically, either from an existing session or by prompting them
    *   to sign in/up again. It throws an error if authentication fails.
    * - `autoConnect === "off"`: It throws an error.
    *
    * @returns `Promise<{ sub, publicKey }>` to get these 2 properties required in most Othent functions.
    *
    * @see {@link https://docs.othent.io/js-sdk-api/require-auth|requireAuth() docs}
    */
  }, { key: "requireUserDataOrThrow", value: function() {
    var _requireUserDataOrThrow = _asyncToGenerator(_regeneratorRuntime().mark(function _callee188() {
      var _ref95, sub, owner;
      return _regeneratorRuntime().wrap(function _callee188$(_context189) {
        while (1)
          switch (_context189.prev = _context189.next) {
            case 0:
              if (!(this.config.autoConnect !== "off" && !this.auth0.isAuthenticated)) {
                _context189.next = 3;
                break;
              }
              _context189.next = 3;
              return this.connect(void 0, void 0, this.gatewayConfig);
            case 3:
              _ref95 = this.auth0.getCachedUserDetails() || {}, sub = _ref95.sub, owner = _ref95.owner;
              if (!(!sub || !owner)) {
                _context189.next = 6;
                break;
              }
              throw new Error("Missing cached user.");
            case 6:
              return _context189.abrupt("return", { sub, publicKey: owner });
            case 7:
            case "end":
              return _context189.stop();
          }
      }, _callee188, this);
    }));
    function requireUserDataOrThrow() {
      return _requireUserDataOrThrow.apply(this, arguments);
    }
    return requireUserDataOrThrow;
  }() }, {
    key: "completeConnectionOrCreateAuth0User",
    value: function() {
      var _completeConnectionOrCreateAuth0User = _asyncToGenerator(_regeneratorRuntime().mark(function _callee189(userDetails, hasIdToken) {
        var importOnly, idTokenWithData, userDetailsFromCreateUserResponse;
        return _regeneratorRuntime().wrap(function _callee189$(_context190) {
          while (1)
            switch (_context190.prev = _context190.next) {
              case 0:
                if (!(userDetails && hasIdToken)) {
                  _context190.next = 2;
                  break;
                }
                return _context190.abrupt("return", userDetails);
              case 2:
                importOnly = false;
                if (!(!(userDetails == null ? void 0 : userDetails.walletAddress) && hasIdToken)) {
                  _context190.next = 12;
                  break;
                }
                _context190.next = 6;
                return this.api.createUser({ importOnly });
              case 6:
                idTokenWithData = _context190.sent;
                _context190.next = 9;
                return this.auth0.updateUserDetails(idTokenWithData);
              case 9:
                userDetailsFromCreateUserResponse = _context190.sent;
                if (!userDetailsFromCreateUserResponse) {
                  _context190.next = 12;
                  break;
                }
                return _context190.abrupt("return", userDetailsFromCreateUserResponse);
              case 12:
                this.auth0.logOut();
                throw new Error("Unexpected authentication error");
              case 14:
              case "end":
                return _context190.stop();
            }
        }, _callee189, this);
      }));
      function completeConnectionOrCreateAuth0User(_x282, _x283) {
        return _completeConnectionOrCreateAuth0User.apply(this, arguments);
      }
      return completeConnectionOrCreateAuth0User;
    }()
    /**
    * If and only if you set the [`auth0LogInMethod = "redirect"`](./constructor.md#auth0loginmethod-auth0loginmethod) option,
    * users will be redirected to Auth0 to authenticate and then back to your application. When they land back in your
    * application, you must call `completeConnectionAfterRedirect()` to complete the authentication process.
    *
    * By default, `callbackUriWithParams = location.href`, if you environment supports it. Otherwise, you'll have to manually
    * pass an URI with the `code` and `state` params provided by Auth0, which handles the redirect callback.
    *
    * See [Auth0's `handleRedirectCallback`](https://auth0.github.io/auth0-spa-js/classes/Auth0Client.html#handleRedirectCallback).
    *
    * @param callbackUriWithParams
    *
    * @returns A Promise with the `UserDetails` or `null` if the log in modal was closed, could not even be opened or
    * authentication failed.
    *
    * @see {@link https://docs.othent.io/js-sdk-api/complete-connection-after-redirect|completeConnectionAfterRedirect() docs}
    */
  }, { key: "completeConnectionAfterRedirect", value: function() {
    var _completeConnectionAfterRedirect = _asyncToGenerator(_regeneratorRuntime().mark(function _callee190(callbackUriWithParams) {
      var urlString, urlObject, searchParams, idToken, userDetails, urlStringData;
      return _regeneratorRuntime().wrap(function _callee190$(_context191) {
        while (1)
          switch (_context191.prev = _context191.next) {
            case 0:
              if (this.config.auth0LogInMethod !== "redirect") {
                console.warn('Calling `Othent.completeConnectionAfterRedirect()` is a NOOP unless the `auth0LogInMethod` options is `"redirect"`.');
              }
              urlString = callbackUriWithParams || (typeof location === "undefined" ? "" : location.href);
              urlObject = new URL(urlString.replace(/.+\.auth0:\/\//, "https://"));
              searchParams = urlObject.searchParams;
              if (!(!searchParams.has("code") || !searchParams.has("state") || !urlString)) {
                _context191.next = 6;
                break;
              }
              return _context191.abrupt("return", null);
            case 6:
              idToken = null;
              userDetails = null;
              _context191.prev = 8;
              _context191.next = 11;
              return this.auth0.handleRedirectCallback(urlString);
            case 11:
              urlStringData = _context191.sent;
              idToken = urlStringData.idToken;
              userDetails = urlStringData.userDetails;
              _context191.next = 19;
              break;
            case 16:
              _context191.prev = 16;
              _context191.t0 = _context191["catch"](8);
              console.warn("The connection could not be completed. There was an error during the redirect flow:\n", _context191.t0);
            case 19:
              _context191.prev = 19;
              if (typeof location !== "undefined" && typeof history !== "undefined") {
                searchParams.delete("code");
                searchParams.delete("state");
                history.replaceState(null, "", urlObject);
              }
              return _context191.finish(19);
            case 22:
              return _context191.abrupt("return", this.completeConnectionOrCreateAuth0User(userDetails, !!idToken));
            case 23:
            case "end":
              return _context191.stop();
          }
      }, _callee190, this, [[8, 16, 19, 22]]);
    }));
    function completeConnectionAfterRedirect(_x284) {
      return _completeConnectionAfterRedirect.apply(this, arguments);
    }
    return completeConnectionAfterRedirect;
  }() }, { key: "connect", value: function() {
    var _connect = _asyncToGenerator(_regeneratorRuntime().mark(function _callee191(permissions, appInfo, gateway) {
      var id_token, userDetails, response, _response;
      return _regeneratorRuntime().wrap(function _callee191$(_context192) {
        while (1)
          switch (_context192.prev = _context192.next) {
            case 0:
              if (!(permissions && permissions.toSorted().join("-") !== _Othent2.ALL_PERMISSIONS.join("-"))) {
                _context192.next = 2;
                break;
              }
              throw new Error("Othent implicitly has access to all available permissions. You should pass `permissions = undefined` or include all of them.");
            case 2:
              if (appInfo)
                this.setAppInfo(appInfo);
              if (gateway)
                this.setGatewayConfig(gateway);
              id_token = "";
              userDetails = null;
              _context192.prev = 6;
              _context192.next = 9;
              return this.auth0.getTokenSilently();
            case 9:
              response = _context192.sent;
              id_token = response.id_token;
              userDetails = response.userDetails;
              _context192.next = 21;
              break;
            case 14:
              _context192.prev = 14;
              _context192.t0 = _context192["catch"](6);
              if (_context192.t0 instanceof Error) {
                _context192.next = 18;
                break;
              }
              throw _context192.t0;
            case 18:
              if (!(_context192.t0.message !== "Login required" && !(_context192.t0 instanceof f$1))) {
                _context192.next = 20;
                break;
              }
              throw _context192.t0;
            case 20:
              console.warn(_context192.t0.message);
            case 21:
              if (id_token) {
                _context192.next = 42;
                break;
              }
              _context192.prev = 22;
              _context192.next = 25;
              return this.auth0.logIn();
            case 25:
              _response = _context192.sent;
              id_token = _response.id_token;
              userDetails = _response.userDetails;
              _context192.next = 42;
              break;
            case 30:
              _context192.prev = 30;
              _context192.t1 = _context192["catch"](22);
              if (_context192.t1 instanceof Error) {
                _context192.next = 34;
                break;
              }
              throw _context192.t1;
            case 34:
              if (!(_context192.t1.message === "Redirecting...")) {
                _context192.next = 37;
                break;
              }
              _context192.next = 37;
              return new Promise(function() {
              });
            case 37:
              if (!(_context192.t1.message.startsWith("Unable to open a popup") || _context192.t1 instanceof p || _context192.t1 instanceof h)) {
                _context192.next = 41;
                break;
              }
              if (_context192.t1 instanceof h)
                _context192.t1.popup.close();
              console.warn(_context192.t1.message);
              return _context192.abrupt("return", null);
            case 41:
              throw _context192.t1;
            case 42:
              return _context192.abrupt("return", this.completeConnectionOrCreateAuth0User(userDetails, !!id_token));
            case 43:
            case "end":
              return _context192.stop();
          }
      }, _callee191, this, [[6, 14], [22, 30]]);
    }));
    function connect(_x285, _x286, _x287) {
      return _connect.apply(this, arguments);
    }
    return connect;
  }() }, { key: "disconnect", value: function() {
    var _disconnect = _asyncToGenerator(_regeneratorRuntime().mark(function _callee192() {
      return _regeneratorRuntime().wrap(function _callee192$(_context193) {
        while (1)
          switch (_context193.prev = _context193.next) {
            case 0:
              return _context193.abrupt("return", this.auth0.logOut());
            case 1:
            case "end":
              return _context193.stop();
          }
      }, _callee192, this);
    }));
    function disconnect() {
      return _disconnect.apply(this, arguments);
    }
    return disconnect;
  }() }, {
    key: "getActiveAddress",
    value: function getActiveAddress() {
      return Promise.resolve(this.getSyncActiveAddress());
    }
    /**
    * Returns the public key (`jwk.n` field) associated with the active (authenticated) user account.
    *
    * This function assumes (and requires) a user is authenticated.
    *
    * @returns A Promise with the owner (jwk.n field) of the users wallet.
    *
    * @see {@link https://docs.othent.io/js-sdk-api/get-active-public-key|getActivePublicKey() docs}
    */
  }, {
    key: "getActivePublicKey",
    value: function getActivePublicKey() {
      return Promise.resolve(this.getSyncActivePublicKey());
    }
    /**
    * Returns an array of Arweave wallet addresses associated with the active (authenticated) user account.
    *
    * However, note that Othent does not currently support creating/storing more than one wallet associated to the same
    * account, so this function will always return exactly one wallet address.
    *
    * This function assumes (and requires) a user is authenticated.
    *
    * @returns A Promise with an array of all wallet addresses of the users wallet.
    *
    * @see {@link https://docs.othent.io/js-sdk-api/get-all-addresses|getAllAddresses() docs}
    */
  }, {
    key: "getAllAddresses",
    value: function getAllAddresses() {
      return Promise.resolve(this.getSyncAllAddresses());
    }
    /**
    * Similarly to ArConnect, each wallet in Othent has a nickname. This is either:
    *
    * - The user's [ANS](https://ans.gg) name.
    * - A platform + email identifying label (e.g. `Google (email@gmail.com)`, `Twitter (email@outlook.com)`...).
    *
    * To provide better UX, you can retrieve these names and display them to the user, so that they can easily recognize
    * which wallet they're using.
    *
    * However, note that Othent does not currently support creating/storing more than one wallet associated to the same
    * account, so this function will always return exactly one wallet address.
    *
    * This function assumes (and requires) a user is authenticated.
    *
    * @returns A Promise containing an object that maps each wallet addresses to their nickname.
    *
    * @see {@link https://docs.othent.io/js-sdk-api/get-wallet-names|getWalletNames() docs}
    */
  }, {
    key: "getWalletNames",
    value: function getWalletNames() {
      return Promise.resolve(this.getSyncWalletNames());
    }
    /**
    * Returns an object with all the user details of the active (authenticated) user account.
    *
    * @returns A Promise containing all the user details of the active user, or `null` if the user is not authenticated.
    *
    * @see {@link https://docs.othent.io/js-sdk-api/get-user-details|getUserDetails() docs}
    */
  }, {
    key: "getUserDetails",
    value: function getUserDetails() {
      return Promise.resolve(this.getSyncUserDetails());
    }
    // GET DATA (SYNC):
    /**
       * Get the active wallet address of the users wallet. This function assumes (and requires) a user is authenticated.
       *
       * @returns The active wallet address of the users wallet.
       *
       * @see {@link https://docs.othent.io/js-sdk-api/get-sync-active-address|getSyncActiveAddress() docs}
       */
  }, {
    key: "getSyncActiveAddress",
    value: function getSyncActiveAddress() {
      return this.auth0.getCachedUserAddress() || "";
    }
    /**
    * Get the owner (jwk.n) field of the users wallet. This function assumes (and requires) a user is authenticated.
    *
    * @returns The owner (jwk.n) field of the users wallet.
    *
    * @see {@link https://docs.othent.io/js-sdk-api/get-sync-active-public-key|getSyncActivePublicKey() docs}
    */
  }, {
    key: "getSyncActivePublicKey",
    value: function getSyncActivePublicKey() {
      return this.auth0.getCachedUserPublicKey() || "";
    }
    /**
    * Get all addresses of the users wallet. This function assumes (and requires) a user is authenticated.
    *
    * @returns All wallet addresses of the users wallet.
    *
    * @see {@link https://docs.othent.io/js-sdk-api/get-sync-all-addresses|getSyncAllAddresses() docs}
    */
  }, {
    key: "getSyncAllAddresses",
    value: function getSyncAllAddresses() {
      var address = this.auth0.getCachedUserAddress();
      return address ? [address] : [];
    }
    /**
    * Get the wallets (users) email. This function assumes (and requires) a user is authenticated.
    *
    * @returns The wallets (users) email.
    *
    * @see {@link https://docs.othent.io/js-sdk-api/get-sync-wallet-names|getSyncWalletNames() docs}
    */
  }, {
    key: "getSyncWalletNames",
    value: function getSyncWalletNames() {
      var address = this.auth0.getCachedUserAddress();
      var addressLabel = this.auth0.getCachedUserAddressLabel();
      return Promise.resolve(address && addressLabel ? _defineProperty({}, address, addressLabel) : {});
    }
    /**
    * Get user details. This function assumes (and requires) a user is authenticated.
    *
    * @returns The user's details.
    *
    * @see {@link https://docs.othent.io/js-sdk-api/get-sync-user-details|getSyncUserDetails() docs}
    */
  }, { key: "getSyncUserDetails", value: function getSyncUserDetails() {
    return this.auth0.getCachedUserDetails();
  } }, {
    key: "addCommonTags",
    value: function addCommonTags() {
      var transactionOrTags = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var appInfo = this.appInfo;
      if (Array.isArray(transactionOrTags)) {
        var appInfoTags = [{ name: "App-Name", value: appInfo.name }, { name: "App-Version", value: appInfo.version }, { name: "App-Env", value: appInfo.env }];
        return [].concat(_toConsumableArray(transactionOrTags), _toConsumableArray(this.config.tags), appInfoTags, ANALYTICS_TAGS);
      }
      var _iterator11 = _createForOfIteratorHelper(this.config.tags), _step11;
      try {
        for (_iterator11.s(); !(_step11 = _iterator11.n()).done; ) {
          var _step11$value = _step11.value, _name2 = _step11$value.name, _value2 = _step11$value.value;
          transactionOrTags.addTag(_name2, _value2);
        }
      } catch (err) {
        _iterator11.e(err);
      } finally {
        _iterator11.f();
      }
      transactionOrTags.addTag("App-Name", appInfo.name);
      transactionOrTags.addTag("App-Version", appInfo.version);
      transactionOrTags.addTag("App-Env", appInfo.env);
      for (var _i77 = 0, _ANALYTICS_TAGS = ANALYTICS_TAGS; _i77 < _ANALYTICS_TAGS.length; _i77++) {
        var _ANALYTICS_TAGS$_i = _ANALYTICS_TAGS[_i77], _name = _ANALYTICS_TAGS$_i.name, value = _ANALYTICS_TAGS$_i.value;
        transactionOrTags.addTag(_name, value);
      }
    }
    /**
    * To submit a transaction to the Arweave Network, it first has to be signed using a private key. Othent creates a private
    * key / Arweave wallet for every account and stores it in Google KMS. The wallet associated with the active user account
    * is used to sign transactions using the `sign()` function.
    *
    * The `sign()` function is meant to replicate the behavior of the `transactions.sign()` function of
    * [`arweave-js`](https://github.com/arweaveTeam/arweave-js#sign-a-transaction), but instead of mutating the transaction
    * object, it returns a new and signed transaction instance.
    *
    * This function assumes (and requires) a user is authenticated and a valid arweave transaction.
    *
    * @param transaction The transaction to sign.
    *
    * @returns A Promise containing a new signed transaction.
    *
    * @see {@link https://docs.othent.io/js-sdk-api/sign|sign() docs}
    * @see {@link https://docs.arweave.org/developers/arweave-node-server/http-api#transaction-format|Transaction Format docs}
    */
  }, { key: "sign", value: function() {
    var _sign10 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee193(transaction2) {
      var _yield$this$requireUs, publicKey, arweave, transactionTags, tags2, transactionToSign, dataToSign, signatureBuffer, id;
      return _regeneratorRuntime().wrap(function _callee193$(_context194) {
        while (1)
          switch (_context194.prev = _context194.next) {
            case 0:
              _context194.next = 2;
              return this.requireUserDataOrThrow();
            case 2:
              _yield$this$requireUs = _context194.sent;
              publicKey = _yield$this$requireUs.publicKey;
              arweave = initArweave(this.gatewayConfig);
              transactionTags = transaction2.get("tags").map(function(tag) {
                return { name: tag.get("name", { decode: true, string: true }), value: tag.get("value", { decode: true, string: true }) };
              });
              tags2 = this.addCommonTags(transactionTags);
              _context194.next = 9;
              return arweave.createTransaction({
                format: transaction2.format,
                owner: publicKey,
                reward: transaction2.reward,
                // This value is added automatically when creating a transaction, so instead of propagating the one from the one
                // the user sends, we'll just leave it to the new `createTransaction` to fill this in:
                // last_tx: transaction.last_tx,
                // To transfer AR:
                target: transaction2.target,
                quantity: transaction2.quantity,
                // To send data:
                data: transaction2.data,
                data_root: transaction2.data_root,
                data_size: transaction2.data_size
              });
            case 9:
              transactionToSign = _context194.sent;
              tags2.forEach(function(tagData) {
                transactionToSign.addTag(tagData.name, tagData.value);
              });
              _context194.next = 13;
              return transactionToSign.getSignatureData();
            case 13:
              dataToSign = _context194.sent;
              _context194.next = 16;
              return this.api.sign(dataToSign);
            case 16:
              signatureBuffer = _context194.sent;
              _context194.next = 19;
              return hash(signatureBuffer);
            case 19:
              id = _context194.sent;
              transactionToSign.setSignature({ id: uint8ArrayTob64Url(id), owner: publicKey, signature: uint8ArrayTob64Url(signatureBuffer), tags: transactionToSign.tags, reward: transactionToSign.reward });
              return _context194.abrupt("return", transactionToSign);
            case 22:
            case "end":
              return _context194.stop();
          }
      }, _callee193, this);
    }));
    function sign(_x288) {
      return _sign10.apply(this, arguments);
    }
    return sign;
  }() }, { key: "dispatch", value: function() {
    var _dispatch = _asyncToGenerator(_regeneratorRuntime().mark(function _callee194(transaction2, options) {
      var _a, transactionTags, signedDataItemBuffer, url, res, signedTransaction, arweave, uploader;
      return _regeneratorRuntime().wrap(function _callee194$(_context195) {
        while (1)
          switch (_context195.prev = _context195.next) {
            case 0:
              transactionTags = transaction2.get("tags").map(function(tag) {
                return { name: tag.get("name", { decode: true, string: true }), value: tag.get("value", { decode: true, string: true }) };
              });
              _context195.next = 3;
              return this.signDataItem({
                // Not used for now as `transaction.last_tx` is not 32 bytes, as required by `DataItem`:
                // anchor: transaction.last_tx,
                target: transaction2.target,
                data: transaction2.data,
                tags: transactionTags
              });
            case 3:
              signedDataItemBuffer = _context195.sent;
              url = "".concat((options == null ? void 0 : options.node) || DEFAULT_DISPATCH_NODE, "/tx");
              _context195.prev = 5;
              _context195.next = 8;
              return axios3.post(url, signedDataItemBuffer, { headers: { "Content-Type": "application/octet-stream" }, maxBodyLength: Infinity, maxContentLength: Infinity, responseType: "json" });
            case 8:
              res = _context195.sent;
              if (!(res.status >= 400)) {
                _context195.next = 11;
                break;
              }
              throw new Error("".concat(res.status, " - ").concat(JSON.stringify(res.data)));
            case 11:
              return _context195.abrupt("return", _objectSpread(_objectSpread({}, res.data), {}, { type: "BUNDLED" }));
            case 14:
              _context195.prev = 14;
              _context195.t0 = _context195["catch"](5);
              console.warn("Error dispatching transaction to ".concat(url, " =\n"), _context195.t0);
              _context195.next = 19;
              return this.sign(transaction2);
            case 19:
              signedTransaction = _context195.sent;
              arweave = (_a = options == null ? void 0 : options.arweave) != null ? _a : initArweave(this.gatewayConfig);
              _context195.next = 23;
              return arweave.transactions.getUploader(signedTransaction);
            case 23:
              uploader = _context195.sent;
            case 24:
              if (uploader.isComplete) {
                _context195.next = 29;
                break;
              }
              _context195.next = 27;
              return uploader.uploadChunk();
            case 27:
              _context195.next = 24;
              break;
            case 29:
              return _context195.abrupt("return", { id: signedTransaction.id, signature: signedTransaction.signature, owner: signedTransaction.owner, type: "BASE" });
            case 30:
            case "end":
              return _context195.stop();
          }
      }, _callee194, this, [[5, 14]]);
    }));
    function dispatch(_x289, _x290) {
      return _dispatch.apply(this, arguments);
    }
    return dispatch;
  }() }, {
    key: "encrypt",
    value: function() {
      var _encrypt7 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee195(plaintext) {
        var ciphertextBuffer;
        return _regeneratorRuntime().wrap(function _callee195$(_context196) {
          while (1)
            switch (_context196.prev = _context196.next) {
              case 0:
                _context196.next = 2;
                return this.requireUserDataOrThrow();
              case 2:
                _context196.next = 4;
                return this.api.encrypt(plaintext);
              case 4:
                ciphertextBuffer = _context196.sent;
                return _context196.abrupt("return", ciphertextBuffer);
              case 6:
              case "end":
                return _context196.stop();
            }
        }, _callee195, this);
      }));
      function encrypt(_x291) {
        return _encrypt7.apply(this, arguments);
      }
      return encrypt;
    }()
    /**
    * Decrypt data with the users JWK.
    *
    * This function assumes (and requires) a user is authenticated.
    *
    * @param ciphertext The data to decrypt.
    *
    * @returns The decrypted data.
    *
    * @see {@link https://docs.othent.io/js-sdk-api/decrypt|decrypt() docs}
    */
  }, { key: "decrypt", value: function() {
    var _decrypt7 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee196(ciphertext) {
      var plaintextBuffer;
      return _regeneratorRuntime().wrap(function _callee196$(_context197) {
        while (1)
          switch (_context197.prev = _context197.next) {
            case 0:
              _context197.next = 2;
              return this.requireUserDataOrThrow();
            case 2:
              _context197.next = 4;
              return this.api.decrypt(ciphertext);
            case 4:
              plaintextBuffer = _context197.sent;
              return _context197.abrupt("return", plaintextBuffer);
            case 6:
            case "end":
              return _context197.stop();
          }
      }, _callee196, this);
    }));
    function decrypt(_x292) {
      return _decrypt7.apply(this, arguments);
    }
    return decrypt;
  }() }, {
    key: "signature",
    value: function() {
      var _signature = _asyncToGenerator(_regeneratorRuntime().mark(function _callee197(data) {
        var signatureBuffer;
        return _regeneratorRuntime().wrap(function _callee197$(_context198) {
          while (1)
            switch (_context198.prev = _context198.next) {
              case 0:
                _context198.next = 2;
                return this.requireUserDataOrThrow();
              case 2:
                _context198.next = 4;
                return this.api.sign(data);
              case 4:
                signatureBuffer = _context198.sent;
                return _context198.abrupt("return", signatureBuffer);
              case 6:
              case "end":
                return _context198.stop();
            }
        }, _callee197, this);
      }));
      function signature2(_x293) {
        return _signature.apply(this, arguments);
      }
      return signature2;
    }()
    /**
    * The signDataItem() function allows you to create and sign a data item object, compatible with arbundles. These data
    * items can then be submitted to an ANS-104 compatible bundler.
    *
    * @param dataItem The data to sign.
    *
    * @returns The signed data item.
    *
    * @see {@link https://docs.othent.io/js-sdk-api/sign-data-item|signDataItem() docs}
    */
  }, { key: "signDataItem", value: function() {
    var _signDataItem = _asyncToGenerator(_regeneratorRuntime().mark(function _callee198(dataItem) {
      var _yield$this$requireUs2, publicKey, data, tags2, options, signer, opts, dataItemInstance;
      return _regeneratorRuntime().wrap(function _callee198$(_context199) {
        while (1)
          switch (_context199.prev = _context199.next) {
            case 0:
              _context199.next = 2;
              return this.requireUserDataOrThrow();
            case 2:
              _yield$this$requireUs2 = _context199.sent;
              publicKey = _yield$this$requireUs2.publicKey;
              data = dataItem.data, tags2 = dataItem.tags, options = _objectWithoutProperties(dataItem, _excluded6);
              signer = {
                publicKey: toBuffer(publicKey),
                signatureType: 1,
                signatureLength: 512,
                ownerLength: 512,
                sign: this.api.getSignerSignFn()
                // Note we don't provide `verify` as it's not used anyway:
                // verify: () => true,
              };
              opts = _objectSpread(_objectSpread({}, options), {}, { tags: this.addCommonTags(tags2) });
              dataItemInstance = ge(data, signer, opts);
              _context199.next = 10;
              return dataItemInstance.sign(signer);
            case 10:
              return _context199.abrupt("return", dataItemInstance.getRaw().buffer);
            case 11:
            case "end":
              return _context199.stop();
          }
      }, _callee198, this);
    }));
    function signDataItem(_x294) {
      return _signDataItem.apply(this, arguments);
    }
    return signDataItem;
  }() }, { key: "signMessage", value: function() {
    var _signMessage = _asyncToGenerator(_regeneratorRuntime().mark(function _callee199(data, options) {
      var hashAlgorithm, hashArrayBuffer, signatureBuffer;
      return _regeneratorRuntime().wrap(function _callee199$(_context200) {
        while (1)
          switch (_context200.prev = _context200.next) {
            case 0:
              _context200.next = 2;
              return this.requireUserDataOrThrow();
            case 2:
              hashAlgorithm = (options == null ? void 0 : options.hashAlgorithm) || "SHA-256";
              _context200.next = 5;
              return this.crypto.subtle.digest(hashAlgorithm, binaryDataTypeOrStringToBinaryDataType(data));
            case 5:
              hashArrayBuffer = _context200.sent;
              _context200.next = 8;
              return this.api.sign(hashArrayBuffer);
            case 8:
              signatureBuffer = _context200.sent;
              return _context200.abrupt("return", signatureBuffer);
            case 10:
            case "end":
              return _context200.stop();
          }
      }, _callee199, this);
    }));
    function signMessage(_x295, _x296) {
      return _signMessage.apply(this, arguments);
    }
    return signMessage;
  }() }, { key: "verifyMessage", value: function() {
    var _verifyMessage = _asyncToGenerator(_regeneratorRuntime().mark(function _callee200(data, signature2, publicKey) {
      var options, requiredUserData, hashAlgorithm, hashArrayBuffer, publicJWK, cryptoKey, result, _args118 = arguments;
      return _regeneratorRuntime().wrap(function _callee200$(_context201) {
        while (1)
          switch (_context201.prev = _context201.next) {
            case 0:
              options = _args118.length > 3 && _args118[3] !== void 0 ? _args118[3] : { hashAlgorithm: "SHA-256" };
              if (publicKey) {
                _context201.next = 6;
                break;
              }
              _context201.next = 4;
              return this.requireUserDataOrThrow();
            case 4:
              requiredUserData = _context201.sent;
              publicKey || (publicKey = requiredUserData.publicKey);
            case 6:
              hashAlgorithm = (options == null ? void 0 : options.hashAlgorithm) || "SHA-256";
              _context201.next = 9;
              return this.crypto.subtle.digest(hashAlgorithm, binaryDataTypeOrStringToBinaryDataType(data));
            case 9:
              hashArrayBuffer = _context201.sent;
              publicJWK = { e: "AQAB", ext: true, kty: "RSA", n: publicKey };
              _context201.next = 13;
              return this.crypto.subtle.importKey("jwk", publicJWK, { name: "RSA-PSS", hash: options.hashAlgorithm }, false, ["verify"]);
            case 13:
              cryptoKey = _context201.sent;
              _context201.next = 16;
              return this.crypto.subtle.verify({ name: "RSA-PSS", saltLength: 32 }, cryptoKey, binaryDataTypeOrStringToBinaryDataType(signature2), hashArrayBuffer);
            case 16:
              result = _context201.sent;
              return _context201.abrupt("return", result);
            case 18:
            case "end":
              return _context201.stop();
          }
      }, _callee200, this);
    }));
    function verifyMessage(_x297, _x298, _x299) {
      return _verifyMessage.apply(this, arguments);
    }
    return verifyMessage;
  }() }, { key: "privateHash", value: function() {
    var _privateHash = _asyncToGenerator(_regeneratorRuntime().mark(function _callee201(data, options) {
      return _regeneratorRuntime().wrap(function _callee201$(_context202) {
        while (1)
          switch (_context202.prev = _context202.next) {
            case 0:
              return _context202.abrupt("return", hash(binaryDataTypeOrStringToBinaryDataType(data), options == null ? void 0 : options.hashAlgorithm));
            case 1:
            case "end":
              return _context202.stop();
          }
      }, _callee201);
    }));
    function privateHash(_x300, _x301) {
      return _privateHash.apply(this, arguments);
    }
    return privateHash;
  }() }, {
    key: "getArweaveConfig",
    value: function getArweaveConfig() {
      return Promise.resolve(this.gatewayConfig);
    }
    /**
    * Get the permissions Othent can use in the current site.
    *
    * @returns Promise of Othent's `PermissionType[]`.
    *
    * @see {@link https://docs.othent.io/js-sdk-api/get-permissions|getPermissions() docs}
    */
  }, {
    key: "getPermissions",
    value: function getPermissions() {
      return Promise.resolve(_Othent2.ALL_PERMISSIONS);
    }
    /**
    * Mocked implementation to add tokens.
    * Othent doesn't currently support this feature and only tracks added tokens temporarily in memory.
    */
  }, {
    key: "addToken",
    value: function addToken(id, type, gateway) {
      console.warn("Othent doesn't currently support this feature and only tracks added tokens temporarily in memory.");
      this.tokens.add(id);
      return Promise.resolve();
    }
    /**
    * Mocked implementation to check if a token has been added.
    * Othent doesn't currently support this feature and only tracks added tokens temporarily in memory.
    */
  }, {
    key: "isTokenAdded",
    value: function isTokenAdded(id) {
      console.warn("Othent doesn't currently support this feature and only tracks added tokens temporarily in memory.");
      return Promise.resolve(this.tokens.has(id));
    }
    // DEVELOPMENT:
  }, { key: "__overridePublicKey", value: function __overridePublicKey(publicKeyPEM) {
    this.auth0.overridePublicKey(publicKeyPEM);
  } }, { key: "__getServerInfo", value: function __getServerInfo(options) {
    return this.api.serverInfo(options);
  } }]);
}();
_Othent.walletName = CLIENT_NAME;
_Othent.walletVersion = CLIENT_VERSION;
_Othent.ALL_PERMISSIONS = ["ACCESS_ADDRESS", "ACCESS_ALL_ADDRESSES", "ACCESS_ARWEAVE_CONFIG", "ACCESS_PUBLIC_KEY", "DECRYPT", "DISPATCH", "ENCRYPT", "SIGN_TRANSACTION", "SIGNATURE"];
var Othent = _Othent;
var OthentStrategy = function() {
  function OthentStrategy2() {
    _classCallCheck2(this, OthentStrategy2);
    _defineProperty(this, "id", "othent");
    _defineProperty(this, "name", "Othent");
    _defineProperty(this, "description", "Othent JS SDK to manage Arweave wallets backed by Auth0 and Google Key Management Service.");
    _defineProperty(this, "theme", "35, 117, 239");
    _defineProperty(this, "logo", "33nBIUNlGK4MnWtJZQy9EzkVJaAd7WoydIKfkJoMvDs");
    _defineProperty(this, "url", "https://othent.io");
    _defineProperty(this, "othent", null);
    _defineProperty(this, "othentOptions", null);
    _defineProperty(this, "addressListeners", []);
  }
  return _createClass(OthentStrategy2, [{ key: "__overrideOthentOptions", value: function __overrideOthentOptions(othentOptions) {
    this.othentOptions = othentOptions;
  } }, {
    key: "othentInstance",
    value: function othentInstance() {
      var _this39 = this;
      if (this.othent)
        return this.othent;
      try {
        var _this$othentOptions;
        var appInfo = { name: typeof location === "undefined" ? "UNKNOWN" : location.hostname, version: "ArweaveWalletKit", env: "" };
        this.othent = new Othent(_objectSpread({ appInfo, persistLocalStorage: true }, this.othentOptions));
        this.othent.addEventListener("auth", function(userDetails) {
          var _iterator12 = _createForOfIteratorHelper(_this39.addressListeners), _step12;
          try {
            for (_iterator12.s(); !(_step12 = _iterator12.n()).done; ) {
              var listener = _step12.value;
              listener((userDetails === null || userDetails === void 0 ? void 0 : userDetails.walletAddress) || void 0);
            }
          } catch (err) {
            _iterator12.e(err);
          } finally {
            _iterator12.f();
          }
        });
        if ((_this$othentOptions = this.othentOptions) !== null && _this$othentOptions !== void 0 && _this$othentOptions.persistLocalStorage) {
          this.othent.startTabSynching();
        }
      } catch (err) {
        throw new Error("[Arweave Wallet Kit] ".concat(err instanceof Error && err.message || err));
      }
      return this.othent;
    }
    /**
    * Advanced function to override the default API ID
    * Othent uses.
    */
  }, { key: "isAvailable", value: function() {
    var _isAvailable = _asyncToGenerator(_regeneratorRuntime().mark(function _callee202() {
      return _regeneratorRuntime().wrap(function _callee202$(_context203) {
        while (1)
          switch (_context203.prev = _context203.next) {
            case 0:
              _context203.prev = 0;
              return _context203.abrupt("return", !!this.othentInstance());
            case 4:
              _context203.prev = 4;
              _context203.t0 = _context203["catch"](0);
              return _context203.abrupt("return", false);
            case 7:
            case "end":
              return _context203.stop();
          }
      }, _callee202, this, [[0, 4]]);
    }));
    function isAvailable() {
      return _isAvailable.apply(this, arguments);
    }
    return isAvailable;
  }() }, { key: "connect", value: function() {
    var _connect2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee203(permissions, appInfo, gateway) {
      var othent;
      return _regeneratorRuntime().wrap(function _callee203$(_context204) {
        while (1)
          switch (_context204.prev = _context204.next) {
            case 0:
              othent = this.othentInstance();
              if (permissions) {
                console.warn("[Arweave Wallet Kit] Othent implicitly requires all permissions. Your `permissions` parameter will be ignored.");
              }
              return _context204.abrupt("return", othent.connect(void 0, appInfo ? _objectSpread(_objectSpread({}, othent.appInfo), appInfo) : void 0, gateway).then(function() {
                return void 0;
              }));
            case 3:
            case "end":
              return _context204.stop();
          }
      }, _callee203, this);
    }));
    function connect(_x302, _x303, _x304) {
      return _connect2.apply(this, arguments);
    }
    return connect;
  }() }, { key: "disconnect", value: function() {
    var _disconnect2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee204() {
      return _regeneratorRuntime().wrap(function _callee204$(_context205) {
        while (1)
          switch (_context205.prev = _context205.next) {
            case 0:
              return _context205.abrupt("return", this.othentInstance().disconnect());
            case 1:
            case "end":
              return _context205.stop();
          }
      }, _callee204, this);
    }));
    function disconnect() {
      return _disconnect2.apply(this, arguments);
    }
    return disconnect;
  }() }, { key: "decrypt", value: function decrypt(data, options) {
    if (options) {
      console.warn("[Arweave Wallet Kit] Othent does not support `decrypt()` options");
    }
    return this.othentInstance().decrypt(data);
  } }, { key: "dispatch", value: function() {
    var _dispatch2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee205(transaction2) {
      return _regeneratorRuntime().wrap(function _callee205$(_context206) {
        while (1)
          switch (_context206.prev = _context206.next) {
            case 0:
              return _context206.abrupt("return", this.othentInstance().dispatch(transaction2));
            case 1:
            case "end":
              return _context206.stop();
          }
      }, _callee205, this);
    }));
    function dispatch(_x305) {
      return _dispatch2.apply(this, arguments);
    }
    return dispatch;
  }() }, { key: "signDataItem", value: function signDataItem(p2) {
    return this.othentInstance().signDataItem(p2);
  } }, { key: "encrypt", value: function encrypt(data, options) {
    if (options) {
      console.warn("[Arweave Wallet Kit] Othent does not support `encrypt()` options");
    }
    return this.othentInstance().encrypt(data);
  } }, { key: "getPermissions", value: function() {
    var _getPermissions = _asyncToGenerator(_regeneratorRuntime().mark(function _callee206() {
      var othent;
      return _regeneratorRuntime().wrap(function _callee206$(_context207) {
        while (1)
          switch (_context207.prev = _context207.next) {
            case 0:
              othent = this.othentInstance();
              return _context207.abrupt("return", othent.getSyncUserDetails() ? othent.getPermissions() : Promise.resolve([]));
            case 2:
            case "end":
              return _context207.stop();
          }
      }, _callee206, this);
    }));
    function getPermissions() {
      return _getPermissions.apply(this, arguments);
    }
    return getPermissions;
  }() }, { key: "getActiveAddress", value: function() {
    var _getActiveAddress = _asyncToGenerator(_regeneratorRuntime().mark(function _callee207() {
      return _regeneratorRuntime().wrap(function _callee207$(_context208) {
        while (1)
          switch (_context208.prev = _context208.next) {
            case 0:
              return _context208.abrupt("return", this.othentInstance().getActiveAddress());
            case 1:
            case "end":
              return _context208.stop();
          }
      }, _callee207, this);
    }));
    function getActiveAddress() {
      return _getActiveAddress.apply(this, arguments);
    }
    return getActiveAddress;
  }() }, { key: "getAllAddresses", value: function() {
    var _getAllAddresses = _asyncToGenerator(_regeneratorRuntime().mark(function _callee208() {
      return _regeneratorRuntime().wrap(function _callee208$(_context209) {
        while (1)
          switch (_context209.prev = _context209.next) {
            case 0:
              return _context209.abrupt("return", this.othentInstance().getAllAddresses());
            case 1:
            case "end":
              return _context209.stop();
          }
      }, _callee208, this);
    }));
    function getAllAddresses() {
      return _getAllAddresses.apply(this, arguments);
    }
    return getAllAddresses;
  }() }, { key: "addToken", value: function() {
    var _addToken = _asyncToGenerator(_regeneratorRuntime().mark(function _callee209(id) {
      return _regeneratorRuntime().wrap(function _callee209$(_context210) {
        while (1)
          switch (_context210.prev = _context210.next) {
            case 0:
              throw new Error("Not implemented: " + id);
            case 1:
            case "end":
              return _context210.stop();
          }
      }, _callee209);
    }));
    function addToken(_x306) {
      return _addToken.apply(this, arguments);
    }
    return addToken;
  }() }, { key: "getArweaveConfig", value: function getArweaveConfig() {
    return this.othentInstance().getArweaveConfig();
  } }, { key: "getActivePublicKey", value: function() {
    var _getActivePublicKey = _asyncToGenerator(_regeneratorRuntime().mark(function _callee210() {
      return _regeneratorRuntime().wrap(function _callee210$(_context211) {
        while (1)
          switch (_context211.prev = _context211.next) {
            case 0:
              return _context211.abrupt("return", this.othentInstance().getActivePublicKey());
            case 1:
            case "end":
              return _context211.stop();
          }
      }, _callee210, this);
    }));
    function getActivePublicKey() {
      return _getActivePublicKey.apply(this, arguments);
    }
    return getActivePublicKey;
  }() }, { key: "getWalletNames", value: function() {
    var _getWalletNames = _asyncToGenerator(_regeneratorRuntime().mark(function _callee211() {
      return _regeneratorRuntime().wrap(function _callee211$(_context212) {
        while (1)
          switch (_context212.prev = _context212.next) {
            case 0:
              return _context212.abrupt("return", this.othentInstance().getWalletNames());
            case 1:
            case "end":
              return _context212.stop();
          }
      }, _callee211, this);
    }));
    function getWalletNames() {
      return _getWalletNames.apply(this, arguments);
    }
    return getWalletNames;
  }() }, { key: "sign", value: function() {
    var _sign11 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee212(transaction2, options) {
      return _regeneratorRuntime().wrap(function _callee212$(_context213) {
        while (1)
          switch (_context213.prev = _context213.next) {
            case 0:
              if (options) {
                console.warn("[Arweave Wallet Kit] Othent does not support transaction signature options");
              }
              return _context213.abrupt("return", this.othentInstance().sign(transaction2));
            case 2:
            case "end":
              return _context213.stop();
          }
      }, _callee212, this);
    }));
    function sign(_x307, _x308) {
      return _sign11.apply(this, arguments);
    }
    return sign;
  }() }, { key: "userDetails", value: function() {
    var _userDetails = _asyncToGenerator(_regeneratorRuntime().mark(function _callee213() {
      return _regeneratorRuntime().wrap(function _callee213$(_context214) {
        while (1)
          switch (_context214.prev = _context214.next) {
            case 0:
              return _context214.abrupt("return", this.othentInstance().getUserDetails());
            case 1:
            case "end":
              return _context214.stop();
          }
      }, _callee213, this);
    }));
    function userDetails() {
      return _userDetails.apply(this, arguments);
    }
    return userDetails;
  }() }, { key: "addAddressEvent", value: function addAddressEvent(listener) {
    this.addressListeners.push(listener);
    return listener;
  } }, { key: "removeAddressEvent", value: function removeAddressEvent(listener) {
    this.addressListeners.splice(this.addressListeners.indexOf(listener), 1);
  } }, { key: "signature", value: function signature2(data, options) {
    if (options) {
      console.warn("[Arweave Wallet Kit] Othent does not support `signature()` options");
    }
    return this.othentInstance().signature(data);
  } }]);
}();
export {
  OthentStrategy as default
};
/*! Bundled license information:

@arweave-wallet-kit/othent-strategy/dist/index.es.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE *)

@arweave-wallet-kit/othent-strategy/dist/index.es.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
  (*!
  * shallow-clone <https://github.com/jonschlinkert/shallow-clone>
  *
  * Copyright (c) 2015-present, Jon Schlinkert.
  * Released under the MIT License.
  *)
  (*!
  * isobject <https://github.com/jonschlinkert/isobject>
  *
  * Copyright (c) 2014-2017, Jon Schlinkert.
  * Released under the MIT License.
  *)
  (*!
  * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
  *
  * Copyright (c) 2014-2017, Jon Schlinkert.
  * Released under the MIT License.
  *)
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*!
  * The buffer module from node.js, for the browser.
  *
  * @author   Feross Aboukhadijeh <https://feross.org>
  * @license  MIT
  *)
  (*! Bundled license information:
  
  ieee754/index.js:
    (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  
  buffer/index.js:
    (*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     *)
  *)
*/
//# sourceMappingURL=@arweave-wallet-kit_othent-strategy.js.map
